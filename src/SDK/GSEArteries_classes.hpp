#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GSEArteries

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GSEArteries_structs.hpp"
#include "Arteries_structs.hpp"
#include "Arteries_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class GSEArteries.GSEArteriesSplineComponent
// 0x0030 (0x0690 - 0x0660)
class UGSEArteriesSplineComponent final : public USplineComponent
{
public:
	uint8                                         Pad_658[0x18];                                     // 0x0658(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSplineClosed;                                     // 0x0670(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_671[0x7];                                      // 0x0671(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BindedBoxExtent;                                   // 0x0678(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindSplineToBoxExtent(const struct FVector& InBoxExtent);
	bool IsGSArteriesSplineClosed();
	bool MakeGSArteriesSplineClosedAsRect(float CloseDistance);
	void SetGSArteriesSplineMinUnitLength(float Length);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEArteriesSplineComponent">();
	}
	static class UGSEArteriesSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEArteriesSplineComponent>();
	}
};
static_assert(alignof(UGSEArteriesSplineComponent) == 0x000010, "Wrong alignment on UGSEArteriesSplineComponent");
static_assert(sizeof(UGSEArteriesSplineComponent) == 0x000690, "Wrong size on UGSEArteriesSplineComponent");
static_assert(offsetof(UGSEArteriesSplineComponent, bSplineClosed) == 0x000670, "Member 'UGSEArteriesSplineComponent::bSplineClosed' has a wrong offset!");
static_assert(offsetof(UGSEArteriesSplineComponent, BindedBoxExtent) == 0x000678, "Member 'UGSEArteriesSplineComponent::BindedBoxExtent' has a wrong offset!");

// Class GSEArteries.GSEArteriesActor
// 0x0018 (0x0330 - 0x0318)
class AGSEArteriesActor final : public AArteriesActor
{
public:
	bool                                          bEnableCollision;                                  // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            MobilityMode;                                      // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSArteriesIteractType                        InteractType;                                      // 0x031A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31B[0x5];                                      // 0x031B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGSEArteriesSplineComponent*            GSEArteriesSplineComp;                             // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGSEArteriesBoxComponent*               GSEArteriesBoxComp;                                // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CloseSplineAndBuild(float CloseDistance);
	void SetSplineUnitLength(float Length);
	void UpdateHISMCollision();
	void UpdateInteractComp();
	void UpdateMobility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEArteriesActor">();
	}
	static class AGSEArteriesActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGSEArteriesActor>();
	}
};
static_assert(alignof(AGSEArteriesActor) == 0x000008, "Wrong alignment on AGSEArteriesActor");
static_assert(sizeof(AGSEArteriesActor) == 0x000330, "Wrong size on AGSEArteriesActor");
static_assert(offsetof(AGSEArteriesActor, bEnableCollision) == 0x000318, "Member 'AGSEArteriesActor::bEnableCollision' has a wrong offset!");
static_assert(offsetof(AGSEArteriesActor, MobilityMode) == 0x000319, "Member 'AGSEArteriesActor::MobilityMode' has a wrong offset!");
static_assert(offsetof(AGSEArteriesActor, InteractType) == 0x00031A, "Member 'AGSEArteriesActor::InteractType' has a wrong offset!");
static_assert(offsetof(AGSEArteriesActor, GSEArteriesSplineComp) == 0x000320, "Member 'AGSEArteriesActor::GSEArteriesSplineComp' has a wrong offset!");
static_assert(offsetof(AGSEArteriesActor, GSEArteriesBoxComp) == 0x000328, "Member 'AGSEArteriesActor::GSEArteriesBoxComp' has a wrong offset!");

// Class GSEArteries.GSEArteriesBoxComponent
// 0x0030 (0x05C0 - 0x0590)
class UGSEArteriesBoxComponent final : public UBoxComponent
{
public:
	uint8                                         Pad_590[0x30];                                     // 0x0590(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FVector> GetSurfacePointsClockWise(bool bBottomSurface);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEArteriesBoxComponent">();
	}
	static class UGSEArteriesBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEArteriesBoxComponent>();
	}
};
static_assert(alignof(UGSEArteriesBoxComponent) == 0x000010, "Wrong alignment on UGSEArteriesBoxComponent");
static_assert(sizeof(UGSEArteriesBoxComponent) == 0x0005C0, "Wrong size on UGSEArteriesBoxComponent");

// Class GSEArteries.GSEArteriesFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSEArteriesFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class UArteriesObject* AddLineAlongSpline(class USplineComponent* SplineComp, float Length);
	static class UArteriesObject* AddNoiseToPoints(class UArteriesObject* Target, const class FString& InGroup, const struct FTransform& TransformNoiseLow, const struct FTransform& TransformNoiseHigh, float StepYaw, float StepPitch, float StepRoll, float NoiseRatio);
	static class UArteriesObject* AddPerpendicularLinesAlongLine(class UArteriesObject* BackBones, const class FString& InGroup, float Length);
	static class UArteriesObject* AddRoofToSimpleRect(class UArteriesObject* Target, const class FString& InGroup);
	static class UArteriesObject* AdvancedCopyToCornerCatenatePointsBySoftPath(class UArteriesObject* Target, const class FString& InGroup, const TArray<struct FSoftObjectPath>& Sources, const struct FTransform& LocalTransform, float UnitLength, bool bCatOutCorner, bool bAlongCurveOutNormalOnly);
	static class UArteriesObject* AdvancedCopyToCornerPointsBySoftPath(class UArteriesObject* Target, const class FString& InGroup, const TArray<struct FSoftObjectPath>& Sources, const struct FTransform& LocalTransform, bool bAsInnerCorner, bool bAlongCurveOutNormalOnly);
	static class UArteriesObject* AdvancedCopyToEndPointsBySoftPath(class UArteriesObject* Target, const class FString& InGroup, const TArray<struct FSoftObjectPath>& Sources, const struct FTransform& LocalTransform, bool bIgnoreDelatZ);
	static class UArteriesObject* AdvancedCopyToPoints(class UArteriesObject* Target, const class FString& Groups, const TArray<class UObject*>& Sources, const struct FTransform& LocalTransform);
	static class UArteriesObject* AdvancedCopyToPointsBySoftPath(class UArteriesObject* Target, const class FString& Groups, const TArray<struct FSoftObjectPath>& Sources, const struct FTransform& LocalTransform, bool bIgnoreCorner, bool bIgnoreCornerAdjacent);
	static class UArteriesObject* AdvancedCopyToPointsByTrSoftPath(class UArteriesObject* Target, const class FString& Groups, const TArray<struct FBaseTransformedSoftObject>& Sources, const struct FTransform& LocalTransform, const struct FTransform& TransformNoiseLow, const struct FTransform& TransformNoiseHigh, float EachPathWidth, bool bIgnoreCorner, bool bIgnoreCornerAdjacent, bool bGenerateMultiPath, int32 GenPathCount);
	static class UArteriesObject* AdvancedSmartCopyToPointsByMeshExtents(class UArteriesObject* Target, const class FString& Groups, const TArray<class UStaticMesh*>& MeshSources, const struct FTransform& LocalTransform, const struct FTransform& TransformNoiseLow, const struct FTransform& TransformNoiseHigh, EGSATERIES_SAMPLE_AXIS SampleAxis, float StepYaw, float StepPitch, float StepRoll, float LineNoiseChance, float ResampleScale);
	static class UArteriesObject* AdvancedSmartCopyToPointsBySoftObjectExtents(class UArteriesObject* Target, const class FString& Groups, const TArray<struct FSoftObjectPath>& Sources, const TArray<struct FSoftObjectPath>& NoiseSources, const struct FTransform& LocalTransform, const struct FTransform& TransformNoiseLow, const struct FTransform& TransformNoiseHigh, EGSATERIES_SAMPLE_AXIS SampleAxis, float StepYaw, float StepPitch, float StepRoll, float LineTwistChance, float UnitNoiseChane, float ResampleScale, int32 IterationCount, bool CurvelyAdjusting);
	static class UArteriesObject* AdvancedSmartStackToPointsBySoftPath(class AArteriesActor* OwnerActor, class UArteriesObject* Target, int32 ExpectedObjectsNum, const class FString& Groups, const TMap<struct FSoftObjectPath, struct FGSArteriesStackRule>& SoftPathToRuleMap, const struct FTransform& LocalTransform, const struct FTransform& TransformNoiseLow, const struct FTransform& TransformNoiseHigh, const TArray<struct FVector>& InCustomCornerLocs, float StepYaw, float StepPitch, float StepRoll);
	static class UArteriesObject* AggregatePoints(class UArteriesObject* Target, const class FString& Groups, int32 DesiredGroupNum);
	static class UArteriesObject* BreakPrimitivesIntoPoints(class UArteriesObject* Target, const class FString& InGroup, bool bKeepRotation, bool bResetUpDirection);
	static class UArteriesObject* CreateGSArteriesPoint(const struct FVector& InPosition);
	static class UArteriesObject* CreateNoiseGroup(class UArteriesObject* Target, const class FString& InGroup, const class FString& OutGeneralGroup, const class FString& OutNoiseGroup, float NoiseRatio);
	static class UArteriesObject* CreateSamplingSurface(class UArteriesObject* BackBones, const class FString& InPrimGroup, float Length, const struct FVector& InDirection);
	static class UArteriesObject* CreateSlopeSideSamplingSurface(class UArteriesObject* BackBones, const class FString& InPrimGroup, float OffsetLength);
	static class UArteriesObject* FindCornerPoints(class UArteriesObject* Target, const class FString& InGroup, bool WithAdjacentPoints);
	static class UArteriesObject* FindDoorFeaturePoints(class AArteriesActor* OwnerActor, class UArteriesObject* Target, int32 DoorNum, float UnitLength, float DoorUnitLength, const class FString& DoorGroup, const class FString& DoorCatnateGroup, const class FString& RestGroup, float DoorCatUnitLength, EGSATERIES_SIDE_SELECT_FEATURE ESelectSide, EGSATERIES_SIDE_DISTRIBUTION_FEATURE EDistribute);
	static class UArteriesObject* FindFlatFeaturePoints(class UArteriesObject* Target, const class FString& InGroup, bool bFindSlopePoints, float Tolerence);
	static class UArteriesObject* FindLeafPoints(class UArteriesObject* Target, const class FString& InGroup);
	static class UArteriesObject* FindWindowFeaturePoints(class UArteriesObject* Target, int32 WindowNum, float WindowUnitLength);
	static struct FRandomStream GenRandSeedStream();
	static int32 GetNumberOfPoints(class UArteriesObject* Target);
	static class UArteriesObject* MakeHoles(class UArteriesObject* Target, const class FString& HoleGroups, const class FString& OutHoleGroups, int32 MaxHoleIteration, int32 MaxHoleNum, float HoleIterationChance);
	static class UArteriesObject* MergeAndCleanInstancedMeshToStaticSurface(class AArteriesActor* OwnerActor, class UArteriesObject* Target, bool bHitLandscapeOnly, float RayCastDistance, float Tolerence);
	static class UArteriesObject* MergePointsToGrid(class UArteriesObject* Target, const class FString& InGroup, float GridSize, const struct FVector& Offset);
	static class UArteriesObject* MergePointsToLandscape(class AArteriesActor* OwnerActor, class UArteriesObject* Target, const class FString& InGroup, const struct FVector& RayCastOffset, float RayDistance);
	static class UArteriesObject* MergePointsToPrimitive(class UArteriesObject* Target, const class FString& InGroup, const struct FVector& Offset, bool bMakeClose);
	static class UArteriesObject* MergePointsToStaticSurface(class AArteriesActor* OwnerActor, class UArteriesObject* Target, const class FString& InGroup, const struct FVector& RayCastOffset, float RayDistance);
	static class UArteriesObject* RayCastDown(class AArteriesActor* OwnerActor, class UArteriesObject* BackBones, const class FString& InGroup, const struct FVector& RayCastOffset, float RayCastDistance, float EndOffsetLength, bool bHitLandscapeOnly);
	static class UArteriesObject* ResampleAsMidPoints(class UArteriesObject* Target);
	static class UArteriesObject* ResampleEachPrimsByLengths(class UArteriesObject* Target, const TArray<float>& SegmentLengthSets, bool ByEdge, int32 NumSegments, EArteriesTangentOutputType OutputType);
	static class UArteriesObject* ResizePrimitive2D(class UArteriesObject* Target, const class FString& InGroup, float Distance, bool bInwards);
	static class UArteriesObject* ScalizeGridPrimitive(class UArteriesObject* Target, float UnitLength);
	static class UArteriesObject* SmartResampleBySourceExtent(class UArteriesObject* Target, const TArray<struct FSoftObjectPath>& InSources, const EGSATERIES_SAMPLE_AXIS InAxis, float MinResampleLength, float MaxResampleLength, float ResampleScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEArteriesFuncLib">();
	}
	static class UGSEArteriesFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEArteriesFuncLib>();
	}
};
static_assert(alignof(UGSEArteriesFuncLib) == 0x000008, "Wrong alignment on UGSEArteriesFuncLib");
static_assert(sizeof(UGSEArteriesFuncLib) == 0x000028, "Wrong size on UGSEArteriesFuncLib");

// Class GSEArteries.GSEArteriesLandscapeComponent
// 0x0000 (0x00B0 - 0x00B0)
class UGSEArteriesLandscapeComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEArteriesLandscapeComponent">();
	}
	static class UGSEArteriesLandscapeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEArteriesLandscapeComponent>();
	}
};
static_assert(alignof(UGSEArteriesLandscapeComponent) == 0x000008, "Wrong alignment on UGSEArteriesLandscapeComponent");
static_assert(sizeof(UGSEArteriesLandscapeComponent) == 0x0000B0, "Wrong size on UGSEArteriesLandscapeComponent");

}

