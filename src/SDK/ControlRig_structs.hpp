#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ControlRig

#include "Basic.hpp"

#include "AnimationCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "RigVM_structs.hpp"
#include "Engine_structs.hpp"
#include "MovieScene_structs.hpp"
#include "MovieSceneTracks_structs.hpp"


namespace SDK
{

// Enum ControlRig.EControlRigComponentSpace
// NumValues: 0x0006
enum class EControlRigComponentSpace : uint8
{
	WorldSpace                               = 0,
	ActorSpace                               = 1,
	ComponentSpace                           = 2,
	RigSpace                                 = 3,
	LocalSpace                               = 4,
	Max                                      = 5,
};

// Enum ControlRig.EControlRigComponentMapDirection
// NumValues: 0x0003
enum class EControlRigComponentMapDirection : uint8
{
	Input                                    = 0,
	Output                                   = 1,
	EControlRigComponentMapDirection_MAX     = 2,
};

// Enum ControlRig.ETransformSpaceMode
// NumValues: 0x0005
enum class ETransformSpaceMode : uint8
{
	LocalSpace                               = 0,
	GlobalSpace                              = 1,
	BaseSpace                                = 2,
	BaseJoint                                = 3,
	Max                                      = 4,
};

// Enum ControlRig.EControlRigClampSpatialMode
// NumValues: 0x0004
enum class EControlRigClampSpatialMode : uint8
{
	Plane                                    = 0,
	Cylinder                                 = 1,
	Sphere                                   = 2,
	EControlRigClampSpatialMode_MAX          = 3,
};

// Enum ControlRig.ETransformGetterType
// NumValues: 0x0003
enum class ETransformGetterType : uint8
{
	Initial                                  = 0,
	Current                                  = 1,
	Max                                      = 2,
};

// Enum ControlRig.EBoneGetterSetterMode
// NumValues: 0x0003
enum class EBoneGetterSetterMode : uint8
{
	LocalSpace                               = 0,
	GlobalSpace                              = 1,
	Max                                      = 2,
};

// Enum ControlRig.ERigExecutionType
// NumValues: 0x0003
enum class ERigExecutionType : uint8
{
	Runtime                                  = 0,
	Editing                                  = 1,
	Max                                      = 2,
};

// Enum ControlRig.EControlRigDrawSettings
// NumValues: 0x0005
enum class EControlRigDrawSettings : uint8
{
	Points                                   = 0,
	Lines                                    = 1,
	LineStrip                                = 2,
	DynamicMesh                              = 3,
	EControlRigDrawSettings_MAX              = 4,
};

// Enum ControlRig.EControlRigDrawHierarchyMode
// NumValues: 0x0002
enum class EControlRigDrawHierarchyMode : uint8
{
	Axes                                     = 0,
	Max                                      = 1,
};

// Enum ControlRig.EControlRigAnimEasingType
// NumValues: 0x0020
enum class EControlRigAnimEasingType : uint8
{
	Linear                                   = 0,
	QuadraticEaseIn                          = 1,
	QuadraticEaseOut                         = 2,
	QuadraticEaseInOut                       = 3,
	CubicEaseIn                              = 4,
	CubicEaseOut                             = 5,
	CubicEaseInOut                           = 6,
	QuarticEaseIn                            = 7,
	QuarticEaseOut                           = 8,
	QuarticEaseInOut                         = 9,
	QuinticEaseIn                            = 10,
	QuinticEaseOut                           = 11,
	QuinticEaseInOut                         = 12,
	SineEaseIn                               = 13,
	SineEaseOut                              = 14,
	SineEaseInOut                            = 15,
	CircularEaseIn                           = 16,
	CircularEaseOut                          = 17,
	CircularEaseInOut                        = 18,
	ExponentialEaseIn                        = 19,
	ExponentialEaseOut                       = 20,
	ExponentialEaseInOut                     = 21,
	ElasticEaseIn                            = 22,
	ElasticEaseOut                           = 23,
	ElasticEaseInOut                         = 24,
	BackEaseIn                               = 25,
	BackEaseOut                              = 26,
	BackEaseInOut                            = 27,
	BounceEaseIn                             = 28,
	BounceEaseOut                            = 29,
	BounceEaseInOut                          = 30,
	EControlRigAnimEasingType_MAX            = 31,
};

// Enum ControlRig.ECRSimPointIntegrateType
// NumValues: 0x0003
enum class ECRSimPointIntegrateType : uint8
{
	Verlet                                   = 0,
	SemiExplicitEuler                        = 1,
	ECRSimPointIntegrateType_MAX             = 2,
};

// Enum ControlRig.ECRSimConstraintType
// NumValues: 0x0005
enum class ECRSimConstraintType : uint8
{
	Distance                                 = 0,
	DistanceFromA                            = 1,
	DistanceFromB                            = 2,
	Plane                                    = 3,
	ECRSimConstraintType_MAX                 = 4,
};

// Enum ControlRig.ECRSimPointForceType
// NumValues: 0x0002
enum class ECRSimPointForceType : uint8
{
	Direction                                = 0,
	ECRSimPointForceType_MAX                 = 1,
};

// Enum ControlRig.ECRSimSoftCollisionType
// NumValues: 0x0004
enum class ECRSimSoftCollisionType : uint8
{
	Plane                                    = 0,
	Sphere                                   = 1,
	Cone                                     = 2,
	ECRSimSoftCollisionType_MAX              = 3,
};

// Enum ControlRig.EControlRigFKRigExecuteMode
// NumValues: 0x0003
enum class EControlRigFKRigExecuteMode : uint8
{
	Replace                                  = 0,
	Additive                                 = 1,
	Max                                      = 2,
};

// Enum ControlRig.EMovieSceneControlRigSpaceType
// NumValues: 0x0004
enum class EMovieSceneControlRigSpaceType : uint8
{
	Parent                                   = 0,
	World                                    = 1,
	ControlRig                               = 2,
	EMovieSceneControlRigSpaceType_MAX       = 3,
};

// Enum ControlRig.ERigTransformStackEntryType
// NumValues: 0x0005
enum class ERigTransformStackEntryType : uint8
{
	TransformPose                            = 0,
	ControlOffset                            = 1,
	ControlShape                             = 2,
	CurveValue                               = 3,
	ERigTransformStackEntryType_MAX          = 4,
};

// Enum ControlRig.ERigElementType
// NumValues: 0x000C
enum class ERigElementType : uint8
{
	None                                     = 0,
	Bone                                     = 1,
	Null                                     = 2,
	Space                                    = 2,
	Control                                  = 4,
	Curve                                    = 8,
	RigidBody                                = 16,
	Reference                                = 32,
	Last                                     = 64,
	All                                      = 63,
	ToResetAfterSetupEvent                   = 13,
	ERigElementType_MAX                      = 65,
};

// Enum ControlRig.ERigBoneType
// NumValues: 0x0003
enum class ERigBoneType : uint8
{
	Imported                                 = 0,
	User                                     = 1,
	ERigBoneType_MAX                         = 2,
};

// Enum ControlRig.ERigHierarchyNotification
// NumValues: 0x000C
enum class ERigHierarchyNotification : uint8
{
	ElementAdded                             = 0,
	ElementRemoved                           = 1,
	ElementRenamed                           = 2,
	ElementSelected                          = 3,
	ElementDeselected                        = 4,
	ParentChanged                            = 5,
	HierarchyReset                           = 6,
	ControlSettingChanged                    = 7,
	ControlVisibilityChanged                 = 8,
	ControlShapeTransformChanged             = 9,
	ParentWeightsChanged                     = 10,
	Max                                      = 11,
};

// Enum ControlRig.ERigEvent
// NumValues: 0x0003
enum class ERigEvent : uint8
{
	None                                     = 0,
	RequestAutoKey                           = 1,
	Max                                      = 2,
};

// Enum ControlRig.EControlRigSetKey
// NumValues: 0x0004
enum class EControlRigSetKey : uint8
{
	DoNotCare                                = 0,
	Always                                   = 1,
	Never                                    = 2,
	EControlRigSetKey_MAX                    = 3,
};

// Enum ControlRig.ERigControlType
// NumValues: 0x000B
enum class ERigControlType : uint8
{
	Bool                                     = 0,
	Float                                    = 1,
	Integer                                  = 2,
	Vector2D                                 = 3,
	Position                                 = 4,
	Scale                                    = 5,
	Rotator                                  = 6,
	Transform                                = 7,
	TransformNoScale                         = 8,
	EulerTransform                           = 9,
	ERigControlType_MAX                      = 10,
};

// Enum ControlRig.ERigControlValueType
// NumValues: 0x0005
enum class ERigControlValueType : uint8
{
	Initial                                  = 0,
	Current                                  = 1,
	Minimum                                  = 2,
	Maximum                                  = 3,
	ERigControlValueType_MAX                 = 4,
};

// Enum ControlRig.ERigControlAxis
// NumValues: 0x0004
enum class ERigControlAxis : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	ERigControlAxis_MAX                      = 3,
};

// Enum ControlRig.ERigTransformType
// NumValues: 0x0006
enum class ERigTransformType : uint8
{
	InitialLocal                             = 0,
	CurrentLocal                             = 1,
	InitialGlobal                            = 2,
	CurrentGlobal                            = 3,
	NumTransformTypes                        = 4,
	ERigTransformType_MAX                    = 5,
};

// Enum ControlRig.ERigSpaceType
// NumValues: 0x0005
enum class ERigSpaceType : uint8
{
	Global                                   = 0,
	Bone                                     = 1,
	Control                                  = 2,
	Space                                    = 3,
	ERigSpaceType_MAX                        = 4,
};

// Enum ControlRig.EControlRigState
// NumValues: 0x0004
enum class EControlRigState : uint8
{
	Init                                     = 0,
	Update                                   = 1,
	Invalid                                  = 2,
	EControlRigState_MAX                     = 3,
};

// Enum ControlRig.EAimMode
// NumValues: 0x0003
enum class EAimMode : uint8
{
	AimAtTarget                              = 0,
	OrientToTarget                           = 1,
	MAX                                      = 2,
};

// Enum ControlRig.EApplyTransformMode
// NumValues: 0x0003
enum class EApplyTransformMode : uint8
{
	Override                                 = 0,
	Additive                                 = 1,
	Max                                      = 2,
};

// Enum ControlRig.ERigUnitDebugPointMode
// NumValues: 0x0003
enum class ERigUnitDebugPointMode : uint8
{
	Point                                    = 0,
	Vector                                   = 1,
	Max                                      = 2,
};

// Enum ControlRig.ERigUnitDebugTransformMode
// NumValues: 0x0004
enum class ERigUnitDebugTransformMode : uint8
{
	Point                                    = 0,
	Axes                                     = 1,
	Box                                      = 2,
	Max                                      = 3,
};

// Enum ControlRig.ERigSwitchParentMode
// NumValues: 0x0004
enum class ERigSwitchParentMode : uint8
{
	World                                    = 0,
	DefaultParent                            = 1,
	ParentItem                               = 2,
	ERigSwitchParentMode_MAX                 = 3,
};

// Enum ControlRig.EControlRigCurveAlignment
// NumValues: 0x0003
enum class EControlRigCurveAlignment : uint8
{
	Front                                    = 0,
	Stretched                                = 1,
	EControlRigCurveAlignment_MAX            = 2,
};

// Enum ControlRig.EControlRigVectorKind
// NumValues: 0x0003
enum class EControlRigVectorKind : uint8
{
	Direction                                = 0,
	Location                                 = 1,
	EControlRigVectorKind_MAX                = 2,
};

// Enum ControlRig.ERBFKernelType
// NumValues: 0x0006
enum class ERBFKernelType : uint8
{
	Gaussian                                 = 0,
	Exponential                              = 1,
	Linear                                   = 2,
	Cubic                                    = 3,
	Quintic                                  = 4,
	ERBFKernelType_MAX                       = 5,
};

// Enum ControlRig.ERBFQuatDistanceType
// NumValues: 0x0005
enum class ERBFQuatDistanceType : uint8
{
	Euclidean                                = 0,
	ArcLength                                = 1,
	SwingAngle                               = 2,
	TwistAngle                               = 3,
	ERBFQuatDistanceType_MAX                 = 4,
};

// Enum ControlRig.ERBFVectorDistanceType
// NumValues: 0x0004
enum class ERBFVectorDistanceType : uint8
{
	Euclidean                                = 0,
	Manhattan                                = 1,
	ArcLength                                = 2,
	ERBFVectorDistanceType_MAX               = 3,
};

// Enum ControlRig.EControlRigModifyBoneMode
// NumValues: 0x0005
enum class EControlRigModifyBoneMode : uint8
{
	OverrideLocal                            = 0,
	OverrideGlobal                           = 1,
	AdditiveLocal                            = 2,
	AdditiveGlobal                           = 3,
	Max                                      = 4,
};

// Enum ControlRig.EConstraintInterpType
// NumValues: 0x0003
enum class EConstraintInterpType : uint8
{
	Average                                  = 0,
	Shortest                                 = 1,
	Max                                      = 2,
};

// Enum ControlRig.ERigUnitVisualDebugPointMode
// NumValues: 0x0003
enum class ERigUnitVisualDebugPointMode : uint8
{
	Point                                    = 0,
	Vector                                   = 1,
	Max                                      = 2,
};

// ScriptStruct ControlRig.RigUnit
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit : public FRigVMStruct
{
};
static_assert(alignof(FRigUnit) == 0x000008, "Wrong alignment on FRigUnit");
static_assert(sizeof(FRigUnit) == 0x000008, "Wrong size on FRigUnit");

// ScriptStruct ControlRig.RigUnit_MathBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_MathBase) == 0x000008, "Wrong alignment on FRigUnit_MathBase");
static_assert(sizeof(FRigUnit_MathBase) == 0x000008, "Wrong size on FRigUnit_MathBase");

// ScriptStruct ControlRig.RigUnit_MathTransformBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathTransformBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathTransformBase) == 0x000008, "Wrong alignment on FRigUnit_MathTransformBase");
static_assert(sizeof(FRigUnit_MathTransformBase) == 0x000008, "Wrong size on FRigUnit_MathTransformBase");

// ScriptStruct ControlRig.RigUnit_MathTransformUnaryOp
// 0x00C8 (0x00D0 - 0x0008)
struct FRigUnit_MathTransformUnaryOp : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformUnaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathTransformUnaryOp");
static_assert(sizeof(FRigUnit_MathTransformUnaryOp) == 0x0000D0, "Wrong size on FRigUnit_MathTransformUnaryOp");
static_assert(offsetof(FRigUnit_MathTransformUnaryOp, Value) == 0x000010, "Member 'FRigUnit_MathTransformUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformUnaryOp, Result) == 0x000070, "Member 'FRigUnit_MathTransformUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchyRef
// 0x0001 (0x0001 - 0x0000)
struct FRigHierarchyRef final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigHierarchyRef) == 0x000001, "Wrong alignment on FRigHierarchyRef");
static_assert(sizeof(FRigHierarchyRef) == 0x000001, "Wrong size on FRigHierarchyRef");

// ScriptStruct ControlRig.RigUnit_DebugBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_DebugBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_DebugBase) == 0x000008, "Wrong alignment on FRigUnit_DebugBase");
static_assert(sizeof(FRigUnit_DebugBase) == 0x000008, "Wrong size on FRigUnit_DebugBase");

// ScriptStruct ControlRig.RigUnit_VisualDebugTransform
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_VisualDebugTransform final : public FRigUnit_DebugBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneSpace;                                         // 0x007C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_VisualDebugTransform) == 0x000010, "Wrong alignment on FRigUnit_VisualDebugTransform");
static_assert(sizeof(FRigUnit_VisualDebugTransform) == 0x000090, "Wrong size on FRigUnit_VisualDebugTransform");
static_assert(offsetof(FRigUnit_VisualDebugTransform, Value) == 0x000010, "Member 'FRigUnit_VisualDebugTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugTransform, bEnabled) == 0x000070, "Member 'FRigUnit_VisualDebugTransform::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugTransform, Thickness) == 0x000074, "Member 'FRigUnit_VisualDebugTransform::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugTransform, Scale) == 0x000078, "Member 'FRigUnit_VisualDebugTransform::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugTransform, BoneSpace) == 0x00007C, "Member 'FRigUnit_VisualDebugTransform::BoneSpace' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigComponentMappedElement
// 0x00D0 (0x00D0 - 0x0000)
struct FControlRigComponentMappedElement final
{
public:
	struct FComponentReference                    ComponentReference;                                // 0x0000(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         TransformIndex;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TransformName;                                     // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ElementName;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigComponentMapDirection              Direction;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0050(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigComponentSpace                     Space;                                             // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ElementIndex;                                      // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubIndex;                                          // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigComponentMappedElement) == 0x000010, "Wrong alignment on FControlRigComponentMappedElement");
static_assert(sizeof(FControlRigComponentMappedElement) == 0x0000D0, "Wrong size on FControlRigComponentMappedElement");
static_assert(offsetof(FControlRigComponentMappedElement, ComponentReference) == 0x000000, "Member 'FControlRigComponentMappedElement::ComponentReference' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, TransformIndex) == 0x000028, "Member 'FControlRigComponentMappedElement::TransformIndex' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, TransformName) == 0x00002C, "Member 'FControlRigComponentMappedElement::TransformName' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, ElementType) == 0x000034, "Member 'FControlRigComponentMappedElement::ElementType' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, ElementName) == 0x000038, "Member 'FControlRigComponentMappedElement::ElementName' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, Direction) == 0x000040, "Member 'FControlRigComponentMappedElement::Direction' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, Offset) == 0x000050, "Member 'FControlRigComponentMappedElement::Offset' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, Weight) == 0x0000B0, "Member 'FControlRigComponentMappedElement::Weight' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, Space) == 0x0000B4, "Member 'FControlRigComponentMappedElement::Space' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, SceneComponent) == 0x0000B8, "Member 'FControlRigComponentMappedElement::SceneComponent' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, ElementIndex) == 0x0000C0, "Member 'FControlRigComponentMappedElement::ElementIndex' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedElement, SubIndex) == 0x0000C4, "Member 'FControlRigComponentMappedElement::SubIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryVectorOp
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_BinaryVectorOp : public FRigUnit
{
public:
	struct FVector                                Argument0;                                         // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Argument1;                                         // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BinaryVectorOp) == 0x000008, "Wrong alignment on FRigUnit_BinaryVectorOp");
static_assert(sizeof(FRigUnit_BinaryVectorOp) == 0x000050, "Wrong size on FRigUnit_BinaryVectorOp");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Argument0) == 0x000008, "Member 'FRigUnit_BinaryVectorOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Argument1) == 0x000020, "Member 'FRigUnit_BinaryVectorOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Result) == 0x000038, "Member 'FRigUnit_BinaryVectorOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Subtract_VectorVector
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_Subtract_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Subtract_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Subtract_VectorVector");
static_assert(sizeof(FRigUnit_Subtract_VectorVector) == 0x000050, "Wrong size on FRigUnit_Subtract_VectorVector");

// ScriptStruct ControlRig.RigElement
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRigElement
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigElement) == 0x000008, "Wrong alignment on FRigElement");
static_assert(sizeof(FRigElement) == 0x000018, "Wrong size on FRigElement");
static_assert(offsetof(FRigElement, Name) == 0x000008, "Member 'FRigElement::Name' has a wrong offset!");
static_assert(offsetof(FRigElement, Index) == 0x000010, "Member 'FRigElement::Index' has a wrong offset!");

// ScriptStruct ControlRig.RigCurve
// 0x0008 (0x0020 - 0x0018)
struct FRigCurve final : public FRigElement
{
public:
	float                                         Value;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigCurve) == 0x000008, "Wrong alignment on FRigCurve");
static_assert(sizeof(FRigCurve) == 0x000020, "Wrong size on FRigCurve");
static_assert(offsetof(FRigCurve, Value) == 0x000018, "Member 'FRigCurve::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigElementKey
// 0x000C (0x000C - 0x0000)
struct FRigElementKey final
{
public:
	ERigElementType                               Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigElementKey) == 0x000004, "Wrong alignment on FRigElementKey");
static_assert(sizeof(FRigElementKey) == 0x00000C, "Wrong size on FRigElementKey");
static_assert(offsetof(FRigElementKey, Type) == 0x000000, "Member 'FRigElementKey::Type' has a wrong offset!");
static_assert(offsetof(FRigElementKey, Name) == 0x000004, "Member 'FRigElementKey::Name' has a wrong offset!");

// ScriptStruct ControlRig.CachedRigElement
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCachedRigElement final
{
public:
	struct FRigElementKey                         Key;                                               // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        Index;                                             // 0x000C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContainerVersion;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedRigElement) == 0x000008, "Wrong alignment on FCachedRigElement");
static_assert(sizeof(FCachedRigElement) == 0x000020, "Wrong size on FCachedRigElement");
static_assert(offsetof(FCachedRigElement, Key) == 0x000000, "Member 'FCachedRigElement::Key' has a wrong offset!");
static_assert(offsetof(FCachedRigElement, Index) == 0x00000C, "Member 'FCachedRigElement::Index' has a wrong offset!");
static_assert(offsetof(FCachedRigElement, ContainerVersion) == 0x000010, "Member 'FCachedRigElement::ContainerVersion' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigExecuteContext
// 0x0000 (0x00C0 - 0x00C0)
struct FControlRigExecuteContext final : public FRigVMExecuteContext
{
};
static_assert(alignof(FControlRigExecuteContext) == 0x000010, "Wrong alignment on FControlRigExecuteContext");
static_assert(sizeof(FControlRigExecuteContext) == 0x0000C0, "Wrong size on FControlRigExecuteContext");

// ScriptStruct ControlRig.RigUnitMutable
// 0x00C8 (0x00D0 - 0x0008)
struct FRigUnitMutable : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              ExecuteContext;                                    // 0x0010(0x00C0)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnitMutable) == 0x000010, "Wrong alignment on FRigUnitMutable");
static_assert(sizeof(FRigUnitMutable) == 0x0000D0, "Wrong size on FRigUnitMutable");
static_assert(offsetof(FRigUnitMutable, ExecuteContext) == 0x000010, "Member 'FRigUnitMutable::ExecuteContext' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetRelativeBoneTransform
// 0x00C0 (0x0190 - 0x00D0)
struct FRigUnit_SetRelativeBoneTransform final : public FRigUnitMutable
{
public:
	class FName                                   bone;                                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0144(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedBone;                                        // 0x0148(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedSpaceIndex;                                  // 0x0168(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetRelativeBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_SetRelativeBoneTransform");
static_assert(sizeof(FRigUnit_SetRelativeBoneTransform) == 0x000190, "Wrong size on FRigUnit_SetRelativeBoneTransform");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, bone) == 0x0000D0, "Member 'FRigUnit_SetRelativeBoneTransform::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, Space) == 0x0000D8, "Member 'FRigUnit_SetRelativeBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, Transform) == 0x0000E0, "Member 'FRigUnit_SetRelativeBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, Weight) == 0x000140, "Member 'FRigUnit_SetRelativeBoneTransform::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, bPropagateToChildren) == 0x000144, "Member 'FRigUnit_SetRelativeBoneTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, CachedBone) == 0x000148, "Member 'FRigUnit_SetRelativeBoneTransform::CachedBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, CachedSpaceIndex) == 0x000168, "Member 'FRigUnit_SetRelativeBoneTransform::CachedSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.ConstraintNodeData
// 0x0140 (0x0140 - 0x0000)
struct FConstraintNodeData final
{
public:
	struct FTransform                             RelativeParent;                                    // 0x0000(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FConstraintOffset                      ConstraintOffset;                                  // 0x0060(0x00C0)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LinkedNode;                                        // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransformConstraint>           Constraints;                                       // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConstraintNodeData) == 0x000010, "Wrong alignment on FConstraintNodeData");
static_assert(sizeof(FConstraintNodeData) == 0x000140, "Wrong size on FConstraintNodeData");
static_assert(offsetof(FConstraintNodeData, RelativeParent) == 0x000000, "Member 'FConstraintNodeData::RelativeParent' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, ConstraintOffset) == 0x000060, "Member 'FConstraintNodeData::ConstraintOffset' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, LinkedNode) == 0x000120, "Member 'FConstraintNodeData::LinkedNode' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, Constraints) == 0x000128, "Member 'FConstraintNodeData::Constraints' has a wrong offset!");

// ScriptStruct ControlRig.AnimationHierarchy
// 0x0010 (0x0088 - 0x0078)
struct FAnimationHierarchy final : public FNodeHierarchyWithUserData
{
public:
	TArray<struct FConstraintNodeData>            UserData;                                          // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationHierarchy) == 0x000008, "Wrong alignment on FAnimationHierarchy");
static_assert(sizeof(FAnimationHierarchy) == 0x000088, "Wrong size on FAnimationHierarchy");
static_assert(offsetof(FAnimationHierarchy, UserData) == 0x000078, "Member 'FAnimationHierarchy::UserData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlVector2D_Entry
// 0x0018 (0x0018 - 0x0000)
struct FRigUnit_SetMultiControlVector2D_Entry final
{
public:
	class FName                                   Control;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vector;                                            // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetMultiControlVector2D_Entry) == 0x000008, "Wrong alignment on FRigUnit_SetMultiControlVector2D_Entry");
static_assert(sizeof(FRigUnit_SetMultiControlVector2D_Entry) == 0x000018, "Wrong size on FRigUnit_SetMultiControlVector2D_Entry");
static_assert(offsetof(FRigUnit_SetMultiControlVector2D_Entry, Control) == 0x000000, "Member 'FRigUnit_SetMultiControlVector2D_Entry::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlVector2D_Entry, Vector) == 0x000008, "Member 'FRigUnit_SetMultiControlVector2D_Entry::Vector' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlVector2D
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_SetMultiControlVector2D final : public FRigUnitMutable
{
public:
	TArray<struct FRigUnit_SetMultiControlVector2D_Entry> Entries;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedRigElement>              CachedControlIndices;                              // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetMultiControlVector2D) == 0x000010, "Wrong alignment on FRigUnit_SetMultiControlVector2D");
static_assert(sizeof(FRigUnit_SetMultiControlVector2D) == 0x000100, "Wrong size on FRigUnit_SetMultiControlVector2D");
static_assert(offsetof(FRigUnit_SetMultiControlVector2D, Entries) == 0x0000D0, "Member 'FRigUnit_SetMultiControlVector2D::Entries' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlVector2D, Weight) == 0x0000E0, "Member 'FRigUnit_SetMultiControlVector2D::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlVector2D, CachedControlIndices) == 0x0000E8, "Member 'FRigUnit_SetMultiControlVector2D::CachedControlIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigControlModifiedContext
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FRigControlModifiedContext final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigControlModifiedContext) == 0x000004, "Wrong alignment on FRigControlModifiedContext");
static_assert(sizeof(FRigControlModifiedContext) == 0x000014, "Wrong size on FRigControlModifiedContext");

// ScriptStruct ControlRig.RigUnit_MathVectorBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathVectorBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathVectorBase) == 0x000008, "Wrong alignment on FRigUnit_MathVectorBase");
static_assert(sizeof(FRigUnit_MathVectorBase) == 0x000008, "Wrong size on FRigUnit_MathVectorBase");

// ScriptStruct ControlRig.RigUnit_MathVectorIsNearlyZero
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_MathVectorIsNearlyZero final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorIsNearlyZero) == 0x000008, "Wrong alignment on FRigUnit_MathVectorIsNearlyZero");
static_assert(sizeof(FRigUnit_MathVectorIsNearlyZero) == 0x000028, "Wrong size on FRigUnit_MathVectorIsNearlyZero");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyZero, Value) == 0x000008, "Member 'FRigUnit_MathVectorIsNearlyZero::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyZero, Tolerance) == 0x000020, "Member 'FRigUnit_MathVectorIsNearlyZero::Tolerance' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyZero, Result) == 0x000024, "Member 'FRigUnit_MathVectorIsNearlyZero::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigTransformStackEntry
// 0x00F0 (0x00F0 - 0x0000)
struct FRigTransformStackEntry final
{
public:
	struct FRigElementKey                         Key;                                               // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigTransformStackEntryType                   EntryType;                                         // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigTransformType                             TransformType;                                     // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OldTransform;                                      // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             NewTransform;                                      // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAffectChildren;                                   // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Callstack;                                         // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigTransformStackEntry) == 0x000010, "Wrong alignment on FRigTransformStackEntry");
static_assert(sizeof(FRigTransformStackEntry) == 0x0000F0, "Wrong size on FRigTransformStackEntry");
static_assert(offsetof(FRigTransformStackEntry, Key) == 0x000000, "Member 'FRigTransformStackEntry::Key' has a wrong offset!");
static_assert(offsetof(FRigTransformStackEntry, EntryType) == 0x00000C, "Member 'FRigTransformStackEntry::EntryType' has a wrong offset!");
static_assert(offsetof(FRigTransformStackEntry, TransformType) == 0x00000D, "Member 'FRigTransformStackEntry::TransformType' has a wrong offset!");
static_assert(offsetof(FRigTransformStackEntry, OldTransform) == 0x000010, "Member 'FRigTransformStackEntry::OldTransform' has a wrong offset!");
static_assert(offsetof(FRigTransformStackEntry, NewTransform) == 0x000070, "Member 'FRigTransformStackEntry::NewTransform' has a wrong offset!");
static_assert(offsetof(FRigTransformStackEntry, bAffectChildren) == 0x0000D0, "Member 'FRigTransformStackEntry::bAffectChildren' has a wrong offset!");
static_assert(offsetof(FRigTransformStackEntry, Callstack) == 0x0000D8, "Member 'FRigTransformStackEntry::Callstack' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigIOSettings
// 0x0002 (0x0002 - 0x0000)
struct FControlRigIOSettings final
{
public:
	bool                                          bUpdatePose;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateCurves;                                     // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigIOSettings) == 0x000001, "Wrong alignment on FControlRigIOSettings");
static_assert(sizeof(FControlRigIOSettings) == 0x000002, "Wrong size on FControlRigIOSettings");
static_assert(offsetof(FControlRigIOSettings, bUpdatePose) == 0x000000, "Member 'FControlRigIOSettings::bUpdatePose' has a wrong offset!");
static_assert(offsetof(FControlRigIOSettings, bUpdateCurves) == 0x000001, "Member 'FControlRigIOSettings::bUpdateCurves' has a wrong offset!");

// ScriptStruct ControlRig.AnimNode_ControlRigBase
// 0x0200 (0x0258 - 0x0058)
struct FAnimNode_ControlRigBase : public FAnimNode_CustomProperty
{
public:
	struct FPoseLink                              Source;                                            // 0x0058(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bResetInputPoseToInitial;                          // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTransferInputPose;                                // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTransferInputCurves;                              // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTransferPoseInGlobalSpace;                        // 0x006B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneReference>                 InputBonesToTransfer;                              // 0x0070(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x1C0];                                     // 0x0080(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UNodeMappingContainer>   NodeMappingContainer;                              // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FControlRigIOSettings                  InputSettings;                                     // 0x0248(0x0002)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FControlRigIOSettings                  OutputSettings;                                    // 0x024A(0x0002)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bExecute;                                          // 0x024C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24D[0xB];                                      // 0x024D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ControlRigBase) == 0x000008, "Wrong alignment on FAnimNode_ControlRigBase");
static_assert(sizeof(FAnimNode_ControlRigBase) == 0x000258, "Wrong size on FAnimNode_ControlRigBase");
static_assert(offsetof(FAnimNode_ControlRigBase, Source) == 0x000058, "Member 'FAnimNode_ControlRigBase::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, bResetInputPoseToInitial) == 0x000068, "Member 'FAnimNode_ControlRigBase::bResetInputPoseToInitial' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, bTransferInputPose) == 0x000069, "Member 'FAnimNode_ControlRigBase::bTransferInputPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, bTransferInputCurves) == 0x00006A, "Member 'FAnimNode_ControlRigBase::bTransferInputCurves' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, bTransferPoseInGlobalSpace) == 0x00006B, "Member 'FAnimNode_ControlRigBase::bTransferPoseInGlobalSpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, InputBonesToTransfer) == 0x000070, "Member 'FAnimNode_ControlRigBase::InputBonesToTransfer' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, NodeMappingContainer) == 0x000240, "Member 'FAnimNode_ControlRigBase::NodeMappingContainer' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, InputSettings) == 0x000248, "Member 'FAnimNode_ControlRigBase::InputSettings' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, OutputSettings) == 0x00024A, "Member 'FAnimNode_ControlRigBase::OutputSettings' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, bExecute) == 0x00024C, "Member 'FAnimNode_ControlRigBase::bExecute' has a wrong offset!");

// ScriptStruct ControlRig.RigElementKeyCollection
// 0x0010 (0x0010 - 0x0000)
struct FRigElementKeyCollection final
{
public:
	TArray<struct FRigElementKey>                 Keys;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigElementKeyCollection) == 0x000008, "Wrong alignment on FRigElementKeyCollection");
static_assert(sizeof(FRigElementKeyCollection) == 0x000010, "Wrong size on FRigElementKeyCollection");
static_assert(offsetof(FRigElementKeyCollection, Keys) == 0x000000, "Member 'FRigElementKeyCollection::Keys' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_CollectionBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_CollectionBase) == 0x000008, "Wrong alignment on FRigUnit_CollectionBase");
static_assert(sizeof(FRigUnit_CollectionBase) == 0x000008, "Wrong size on FRigUnit_CollectionBase");

// ScriptStruct ControlRig.RigUnit_CollectionGetParentIndices
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_CollectionGetParentIndices final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               Collection;                                        // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ParentIndices;                                     // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionGetParentIndices) == 0x000008, "Wrong alignment on FRigUnit_CollectionGetParentIndices");
static_assert(sizeof(FRigUnit_CollectionGetParentIndices) == 0x000028, "Wrong size on FRigUnit_CollectionGetParentIndices");
static_assert(offsetof(FRigUnit_CollectionGetParentIndices, Collection) == 0x000008, "Member 'FRigUnit_CollectionGetParentIndices::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionGetParentIndices, ParentIndices) == 0x000018, "Member 'FRigUnit_CollectionGetParentIndices::ParentIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SimBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_SimBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_SimBase) == 0x000008, "Wrong alignment on FRigUnit_SimBase");
static_assert(sizeof(FRigUnit_SimBase) == 0x000008, "Wrong size on FRigUnit_SimBase");

// ScriptStruct ControlRig.RigUnit_AccumulateBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_AccumulateBase : public FRigUnit_SimBase
{
};
static_assert(alignof(FRigUnit_AccumulateBase) == 0x000008, "Wrong alignment on FRigUnit_AccumulateBase");
static_assert(sizeof(FRigUnit_AccumulateBase) == 0x000008, "Wrong size on FRigUnit_AccumulateBase");

// ScriptStruct ControlRig.RigUnit_AccumulateQuatLerp
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_AccumulateQuatLerp final : public FRigUnit_AccumulateBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  TargetValue;                                       // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  InitialValue;                                      // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0xB];                                       // 0x0055(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0060(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  AccumulatedValue;                                  // 0x0080(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateQuatLerp) == 0x000010, "Wrong alignment on FRigUnit_AccumulateQuatLerp");
static_assert(sizeof(FRigUnit_AccumulateQuatLerp) == 0x0000A0, "Wrong size on FRigUnit_AccumulateQuatLerp");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, TargetValue) == 0x000010, "Member 'FRigUnit_AccumulateQuatLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, InitialValue) == 0x000030, "Member 'FRigUnit_AccumulateQuatLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, Blend) == 0x000050, "Member 'FRigUnit_AccumulateQuatLerp::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, bIntegrateDeltaTime) == 0x000054, "Member 'FRigUnit_AccumulateQuatLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, Result) == 0x000060, "Member 'FRigUnit_AccumulateQuatLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, AccumulatedValue) == 0x000080, "Member 'FRigUnit_AccumulateQuatLerp::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_VisualDebugVector
// 0x0040 (0x0048 - 0x0008)
struct FRigUnit_VisualDebugVector final : public FRigUnit_DebugBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigUnitVisualDebugPointMode                  Mode;                                              // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0024(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneSpace;                                         // 0x003C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_VisualDebugVector) == 0x000008, "Wrong alignment on FRigUnit_VisualDebugVector");
static_assert(sizeof(FRigUnit_VisualDebugVector) == 0x000048, "Wrong size on FRigUnit_VisualDebugVector");
static_assert(offsetof(FRigUnit_VisualDebugVector, Value) == 0x000008, "Member 'FRigUnit_VisualDebugVector::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVector, bEnabled) == 0x000020, "Member 'FRigUnit_VisualDebugVector::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVector, Mode) == 0x000021, "Member 'FRigUnit_VisualDebugVector::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVector, Color) == 0x000024, "Member 'FRigUnit_VisualDebugVector::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVector, Thickness) == 0x000034, "Member 'FRigUnit_VisualDebugVector::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVector, Scale) == 0x000038, "Member 'FRigUnit_VisualDebugVector::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVector, BoneSpace) == 0x00003C, "Member 'FRigUnit_VisualDebugVector::BoneSpace' has a wrong offset!");

// ScriptStruct ControlRig.AnimNode_ControlRig
// 0x0200 (0x0458 - 0x0258)
struct FAnimNode_ControlRig final : public FAnimNode_ControlRigBase
{
public:
	TSubclassOf<class UControlRig>                ControlRigClass;                                   // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UControlRig*                            ControlRig;                                        // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Alpha;                                             // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAnimAlphaInputType                           AlphaInputType;                                    // 0x026C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bAlphaBoolEnabled : 1;                             // 0x026D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bSetRefPoseFromSkeleton : 1;                       // 0x026D(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_26E[0x2];                                      // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputScaleBias                        AlphaScaleBias;                                    // 0x0270(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FInputAlphaBoolBlend                   AlphaBoolBlend;                                    // 0x0278(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   AlphaCurveName;                                    // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FInputScaleBiasClamp                   AlphaScaleBiasClamp;                               // 0x02C8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<class FName, class FName>                InputMapping;                                      // 0x02F8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, class FName>                OutputMapping;                                     // 0x0348(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0xB0];                                     // 0x0398(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODThreshold;                                      // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44C[0xC];                                      // 0x044C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ControlRig) == 0x000008, "Wrong alignment on FAnimNode_ControlRig");
static_assert(sizeof(FAnimNode_ControlRig) == 0x000458, "Wrong size on FAnimNode_ControlRig");
static_assert(offsetof(FAnimNode_ControlRig, ControlRigClass) == 0x000258, "Member 'FAnimNode_ControlRig::ControlRigClass' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, ControlRig) == 0x000260, "Member 'FAnimNode_ControlRig::ControlRig' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, Alpha) == 0x000268, "Member 'FAnimNode_ControlRig::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, AlphaInputType) == 0x00026C, "Member 'FAnimNode_ControlRig::AlphaInputType' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, AlphaScaleBias) == 0x000270, "Member 'FAnimNode_ControlRig::AlphaScaleBias' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, AlphaBoolBlend) == 0x000278, "Member 'FAnimNode_ControlRig::AlphaBoolBlend' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, AlphaCurveName) == 0x0002C0, "Member 'FAnimNode_ControlRig::AlphaCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, AlphaScaleBiasClamp) == 0x0002C8, "Member 'FAnimNode_ControlRig::AlphaScaleBiasClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, InputMapping) == 0x0002F8, "Member 'FAnimNode_ControlRig::InputMapping' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, OutputMapping) == 0x000348, "Member 'FAnimNode_ControlRig::OutputMapping' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, LODThreshold) == 0x000448, "Member 'FAnimNode_ControlRig::LODThreshold' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Control
// 0x0178 (0x0180 - 0x0008)
struct FRigUnit_Control : public FRigUnit
{
public:
	struct FEulerTransform                        Transform;                                         // 0x0008(0x0048)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Base;                                              // 0x0050(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitTransform;                                     // 0x00B0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0110(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x0170(0x0009)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Control) == 0x000010, "Wrong alignment on FRigUnit_Control");
static_assert(sizeof(FRigUnit_Control) == 0x000180, "Wrong size on FRigUnit_Control");
static_assert(offsetof(FRigUnit_Control, Transform) == 0x000008, "Member 'FRigUnit_Control::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Base) == 0x000050, "Member 'FRigUnit_Control::Base' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, InitTransform) == 0x0000B0, "Member 'FRigUnit_Control::InitTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Result) == 0x000110, "Member 'FRigUnit_Control::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Filter) == 0x000170, "Member 'FRigUnit_Control::Filter' has a wrong offset!");

// ScriptStruct ControlRig.AnimNode_ControlRig_ExternalSource
// 0x0008 (0x0260 - 0x0258)
struct FAnimNode_ControlRig_ExternalSource final : public FAnimNode_ControlRigBase
{
public:
	TWeakObjectPtr<class UControlRig>             ControlRig;                                        // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimNode_ControlRig_ExternalSource) == 0x000008, "Wrong alignment on FAnimNode_ControlRig_ExternalSource");
static_assert(sizeof(FAnimNode_ControlRig_ExternalSource) == 0x000260, "Wrong size on FAnimNode_ControlRig_ExternalSource");
static_assert(offsetof(FAnimNode_ControlRig_ExternalSource, ControlRig) == 0x000258, "Member 'FAnimNode_ControlRig_ExternalSource::ControlRig' has a wrong offset!");

// ScriptStruct ControlRig.RigControlLimitEnabled
// 0x0002 (0x0002 - 0x0000)
struct FRigControlLimitEnabled final
{
public:
	bool                                          bMinimum;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaximum;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigControlLimitEnabled) == 0x000001, "Wrong alignment on FRigControlLimitEnabled");
static_assert(sizeof(FRigControlLimitEnabled) == 0x000002, "Wrong size on FRigControlLimitEnabled");
static_assert(offsetof(FRigControlLimitEnabled, bMinimum) == 0x000000, "Member 'FRigControlLimitEnabled::bMinimum' has a wrong offset!");
static_assert(offsetof(FRigControlLimitEnabled, bMaximum) == 0x000001, "Member 'FRigControlLimitEnabled::bMaximum' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_AnimBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_AnimBase) == 0x000008, "Wrong alignment on FRigUnit_AnimBase");
static_assert(sizeof(FRigUnit_AnimBase) == 0x000008, "Wrong size on FRigUnit_AnimBase");

// ScriptStruct ControlRig.ControlRigAnimInstanceProxy
// 0x00A0 (0x0930 - 0x0890)
struct FControlRigAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_890[0xA0];                                     // 0x0890(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigAnimInstanceProxy) == 0x000010, "Wrong alignment on FControlRigAnimInstanceProxy");
static_assert(sizeof(FControlRigAnimInstanceProxy) == 0x000930, "Wrong size on FControlRigAnimInstanceProxy");

// ScriptStruct ControlRig.ControlRigComponentMappedComponent
// 0x0018 (0x0018 - 0x0000)
struct FControlRigComponentMappedComponent final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ElementName;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigComponentMapDirection              Direction;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigComponentMappedComponent) == 0x000008, "Wrong alignment on FControlRigComponentMappedComponent");
static_assert(sizeof(FControlRigComponentMappedComponent) == 0x000018, "Wrong size on FControlRigComponentMappedComponent");
static_assert(offsetof(FControlRigComponentMappedComponent, Component) == 0x000000, "Member 'FControlRigComponentMappedComponent::Component' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedComponent, ElementName) == 0x000008, "Member 'FControlRigComponentMappedComponent::ElementName' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedComponent, ElementType) == 0x000010, "Member 'FControlRigComponentMappedComponent::ElementType' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedComponent, Direction) == 0x000011, "Member 'FControlRigComponentMappedComponent::Direction' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionBaseMutable
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_CollectionBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_CollectionBaseMutable) == 0x000010, "Wrong alignment on FRigUnit_CollectionBaseMutable");
static_assert(sizeof(FRigUnit_CollectionBaseMutable) == 0x0000D0, "Wrong size on FRigUnit_CollectionBaseMutable");

// ScriptStruct ControlRig.RigUnit_CollectionLoop
// 0x00F0 (0x01C0 - 0x00D0)
struct FRigUnit_CollectionLoop final : public FRigUnit_CollectionBaseMutable
{
public:
	struct FRigElementKeyCollection               Collection;                                        // 0x00D0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Item;                                              // 0x00E0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Continue;                                          // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              Completed;                                         // 0x0100(0x00C0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionLoop) == 0x000010, "Wrong alignment on FRigUnit_CollectionLoop");
static_assert(sizeof(FRigUnit_CollectionLoop) == 0x0001C0, "Wrong size on FRigUnit_CollectionLoop");
static_assert(offsetof(FRigUnit_CollectionLoop, Collection) == 0x0000D0, "Member 'FRigUnit_CollectionLoop::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionLoop, Item) == 0x0000E0, "Member 'FRigUnit_CollectionLoop::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionLoop, Index) == 0x0000EC, "Member 'FRigUnit_CollectionLoop::Index' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionLoop, Count) == 0x0000F0, "Member 'FRigUnit_CollectionLoop::Count' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionLoop, Ratio) == 0x0000F4, "Member 'FRigUnit_CollectionLoop::Ratio' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionLoop, Continue) == 0x0000F8, "Member 'FRigUnit_CollectionLoop::Continue' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionLoop, Completed) == 0x000100, "Member 'FRigUnit_CollectionLoop::Completed' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigComponentMappedBone
// 0x0010 (0x0010 - 0x0000)
struct FControlRigComponentMappedBone final
{
public:
	class FName                                   Source;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Target;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigComponentMappedBone) == 0x000004, "Wrong alignment on FControlRigComponentMappedBone");
static_assert(sizeof(FControlRigComponentMappedBone) == 0x000010, "Wrong size on FControlRigComponentMappedBone");
static_assert(offsetof(FControlRigComponentMappedBone, Source) == 0x000000, "Member 'FControlRigComponentMappedBone::Source' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedBone, Target) == 0x000008, "Member 'FControlRigComponentMappedBone::Target' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SphereTraceByObjectTypes
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_SphereTraceByObjectTypes final : public FRigUnit
{
public:
	struct FVector                                Start;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SphereTraceByObjectTypes) == 0x000008, "Wrong alignment on FRigUnit_SphereTraceByObjectTypes");
static_assert(sizeof(FRigUnit_SphereTraceByObjectTypes) == 0x000080, "Wrong size on FRigUnit_SphereTraceByObjectTypes");
static_assert(offsetof(FRigUnit_SphereTraceByObjectTypes, Start) == 0x000008, "Member 'FRigUnit_SphereTraceByObjectTypes::Start' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByObjectTypes, End) == 0x000020, "Member 'FRigUnit_SphereTraceByObjectTypes::End' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByObjectTypes, ObjectTypes) == 0x000038, "Member 'FRigUnit_SphereTraceByObjectTypes::ObjectTypes' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByObjectTypes, Radius) == 0x000048, "Member 'FRigUnit_SphereTraceByObjectTypes::Radius' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByObjectTypes, bHit) == 0x00004C, "Member 'FRigUnit_SphereTraceByObjectTypes::bHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByObjectTypes, HitLocation) == 0x000050, "Member 'FRigUnit_SphereTraceByObjectTypes::HitLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByObjectTypes, HitNormal) == 0x000068, "Member 'FRigUnit_SphereTraceByObjectTypes::HitNormal' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigComponentMappedCurve
// 0x0010 (0x0010 - 0x0000)
struct FControlRigComponentMappedCurve final
{
public:
	class FName                                   Source;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Target;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigComponentMappedCurve) == 0x000004, "Wrong alignment on FControlRigComponentMappedCurve");
static_assert(sizeof(FControlRigComponentMappedCurve) == 0x000010, "Wrong size on FControlRigComponentMappedCurve");
static_assert(offsetof(FControlRigComponentMappedCurve, Source) == 0x000000, "Member 'FControlRigComponentMappedCurve::Source' has a wrong offset!");
static_assert(offsetof(FControlRigComponentMappedCurve, Target) == 0x000008, "Member 'FControlRigComponentMappedCurve::Target' has a wrong offset!");

// ScriptStruct ControlRig.BlendTarget
// 0x0070 (0x0070 - 0x0000)
struct FBlendTarget final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlendTarget) == 0x000010, "Wrong alignment on FBlendTarget");
static_assert(sizeof(FBlendTarget) == 0x000070, "Wrong size on FBlendTarget");
static_assert(offsetof(FBlendTarget, Transform) == 0x000000, "Member 'FBlendTarget::Transform' has a wrong offset!");
static_assert(offsetof(FBlendTarget, Weight) == 0x000060, "Member 'FBlendTarget::Weight' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigDrawInstruction
// 0x00D0 (0x00D0 - 0x0000)
struct FControlRigDrawInstruction final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigDrawSettings                       PrimitiveType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Positions;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigDrawInstruction) == 0x000010, "Wrong alignment on FControlRigDrawInstruction");
static_assert(sizeof(FControlRigDrawInstruction) == 0x0000D0, "Wrong size on FControlRigDrawInstruction");
static_assert(offsetof(FControlRigDrawInstruction, Name) == 0x000000, "Member 'FControlRigDrawInstruction::Name' has a wrong offset!");
static_assert(offsetof(FControlRigDrawInstruction, PrimitiveType) == 0x000008, "Member 'FControlRigDrawInstruction::PrimitiveType' has a wrong offset!");
static_assert(offsetof(FControlRigDrawInstruction, Positions) == 0x000010, "Member 'FControlRigDrawInstruction::Positions' has a wrong offset!");
static_assert(offsetof(FControlRigDrawInstruction, Color) == 0x000020, "Member 'FControlRigDrawInstruction::Color' has a wrong offset!");
static_assert(offsetof(FControlRigDrawInstruction, Thickness) == 0x000030, "Member 'FControlRigDrawInstruction::Thickness' has a wrong offset!");
static_assert(offsetof(FControlRigDrawInstruction, Transform) == 0x000040, "Member 'FControlRigDrawInstruction::Transform' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigDrawContainer
// 0x0018 (0x0018 - 0x0000)
struct FControlRigDrawContainer
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FControlRigDrawInstruction>     Instructions;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigDrawContainer) == 0x000008, "Wrong alignment on FControlRigDrawContainer");
static_assert(sizeof(FControlRigDrawContainer) == 0x000018, "Wrong size on FControlRigDrawContainer");
static_assert(offsetof(FControlRigDrawContainer, Instructions) == 0x000008, "Member 'FControlRigDrawContainer::Instructions' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToRigSpace_Location
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_ToRigSpace_Location final : public FRigUnit
{
public:
	struct FVector                                Location;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Global;                                            // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToRigSpace_Location) == 0x000008, "Wrong alignment on FRigUnit_ToRigSpace_Location");
static_assert(sizeof(FRigUnit_ToRigSpace_Location) == 0x000038, "Wrong size on FRigUnit_ToRigSpace_Location");
static_assert(offsetof(FRigUnit_ToRigSpace_Location, Location) == 0x000008, "Member 'FRigUnit_ToRigSpace_Location::Location' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToRigSpace_Location, Global) == 0x000020, "Member 'FRigUnit_ToRigSpace_Location::Global' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimEasing
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_AnimEasing final : public FRigUnit_AnimBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     Type;                                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceMinimum;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMaximum;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMinimum;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaximum;                                     // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AnimEasing) == 0x000008, "Wrong alignment on FRigUnit_AnimEasing");
static_assert(sizeof(FRigUnit_AnimEasing) == 0x000028, "Wrong size on FRigUnit_AnimEasing");
static_assert(offsetof(FRigUnit_AnimEasing, Value) == 0x000008, "Member 'FRigUnit_AnimEasing::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, Type) == 0x00000C, "Member 'FRigUnit_AnimEasing::Type' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, SourceMinimum) == 0x000010, "Member 'FRigUnit_AnimEasing::SourceMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, SourceMaximum) == 0x000014, "Member 'FRigUnit_AnimEasing::SourceMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, TargetMinimum) == 0x000018, "Member 'FRigUnit_AnimEasing::TargetMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, TargetMaximum) == 0x00001C, "Member 'FRigUnit_AnimEasing::TargetMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, Result) == 0x000020, "Member 'FRigUnit_AnimEasing::Result' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigDrawInterface
// 0x0000 (0x0018 - 0x0018)
struct FControlRigDrawInterface final : public FControlRigDrawContainer
{
};
static_assert(alignof(FControlRigDrawInterface) == 0x000008, "Wrong alignment on FControlRigDrawInterface");
static_assert(sizeof(FControlRigDrawInterface) == 0x000018, "Wrong size on FControlRigDrawInterface");

// ScriptStruct ControlRig.ControlShapeActorCreationParam
// 0x01B0 (0x01B0 - 0x0000)
struct alignas(0x10) FControlShapeActorCreationParam final
{
public:
	uint8                                         Pad_0[0x1B0];                                      // 0x0000(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlShapeActorCreationParam) == 0x000010, "Wrong alignment on FControlShapeActorCreationParam");
static_assert(sizeof(FControlShapeActorCreationParam) == 0x0001B0, "Wrong size on FControlShapeActorCreationParam");

// ScriptStruct ControlRig.RigBone
// 0x0158 (0x0170 - 0x0018)
struct FRigBone final : public FRigElement
{
public:
	class FName                                   ParentName;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTransform;                                  // 0x0030(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             GlobalTransform;                                   // 0x0090(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x00F0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Dependents;                                        // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	ERigBoneType                                  Type;                                              // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigBone) == 0x000010, "Wrong alignment on FRigBone");
static_assert(sizeof(FRigBone) == 0x000170, "Wrong size on FRigBone");
static_assert(offsetof(FRigBone, ParentName) == 0x000018, "Member 'FRigBone::ParentName' has a wrong offset!");
static_assert(offsetof(FRigBone, ParentIndex) == 0x000020, "Member 'FRigBone::ParentIndex' has a wrong offset!");
static_assert(offsetof(FRigBone, InitialTransform) == 0x000030, "Member 'FRigBone::InitialTransform' has a wrong offset!");
static_assert(offsetof(FRigBone, GlobalTransform) == 0x000090, "Member 'FRigBone::GlobalTransform' has a wrong offset!");
static_assert(offsetof(FRigBone, LocalTransform) == 0x0000F0, "Member 'FRigBone::LocalTransform' has a wrong offset!");
static_assert(offsetof(FRigBone, Dependents) == 0x000150, "Member 'FRigBone::Dependents' has a wrong offset!");
static_assert(offsetof(FRigBone, Type) == 0x000160, "Member 'FRigBone::Type' has a wrong offset!");

// ScriptStruct ControlRig.RigBoneHierarchy
// 0x0010 (0x0010 - 0x0000)
struct FRigBoneHierarchy final
{
public:
	TArray<struct FRigBone>                       Bones;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigBoneHierarchy) == 0x000008, "Wrong alignment on FRigBoneHierarchy");
static_assert(sizeof(FRigBoneHierarchy) == 0x000010, "Wrong size on FRigBoneHierarchy");
static_assert(offsetof(FRigBoneHierarchy, Bones) == 0x000000, "Member 'FRigBoneHierarchy::Bones' has a wrong offset!");

// ScriptStruct ControlRig.RigSpace
// 0x00D8 (0x00F0 - 0x0018)
struct FRigSpace final : public FRigElement
{
public:
	ERigSpaceType                                 SpaceType;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParentName;                                        // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTransform;                                  // 0x0030(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x0090(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigSpace) == 0x000010, "Wrong alignment on FRigSpace");
static_assert(sizeof(FRigSpace) == 0x0000F0, "Wrong size on FRigSpace");
static_assert(offsetof(FRigSpace, SpaceType) == 0x000018, "Member 'FRigSpace::SpaceType' has a wrong offset!");
static_assert(offsetof(FRigSpace, ParentName) == 0x00001C, "Member 'FRigSpace::ParentName' has a wrong offset!");
static_assert(offsetof(FRigSpace, ParentIndex) == 0x000024, "Member 'FRigSpace::ParentIndex' has a wrong offset!");
static_assert(offsetof(FRigSpace, InitialTransform) == 0x000030, "Member 'FRigSpace::InitialTransform' has a wrong offset!");
static_assert(offsetof(FRigSpace, LocalTransform) == 0x000090, "Member 'FRigSpace::LocalTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigSpaceHierarchy
// 0x0010 (0x0010 - 0x0000)
struct FRigSpaceHierarchy final
{
public:
	TArray<struct FRigSpace>                      Spaces;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigSpaceHierarchy) == 0x000008, "Wrong alignment on FRigSpaceHierarchy");
static_assert(sizeof(FRigSpaceHierarchy) == 0x000010, "Wrong size on FRigSpaceHierarchy");
static_assert(offsetof(FRigSpaceHierarchy, Spaces) == 0x000000, "Member 'FRigSpaceHierarchy::Spaces' has a wrong offset!");

// ScriptStruct ControlRig.RigControlValueStorage
// 0x0084 (0x0084 - 0x0000)
struct FRigControlValueStorage final
{
public:
	float                                         Float00;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float01;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float02;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float03;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float10;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float11;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float12;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float13;                                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float20;                                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float21;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float22;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float23;                                           // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float30;                                           // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float31;                                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float32;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float33;                                           // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float00_2;                                         // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float01_2;                                         // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float02_2;                                         // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float03_2;                                         // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float10_2;                                         // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float11_2;                                         // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float12_2;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float13_2;                                         // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float20_2;                                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float21_2;                                         // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float22_2;                                         // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float23_2;                                         // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float30_2;                                         // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float31_2;                                         // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float32_2;                                         // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float33_2;                                         // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigControlValueStorage) == 0x000004, "Wrong alignment on FRigControlValueStorage");
static_assert(sizeof(FRigControlValueStorage) == 0x000084, "Wrong size on FRigControlValueStorage");
static_assert(offsetof(FRigControlValueStorage, Float00) == 0x000000, "Member 'FRigControlValueStorage::Float00' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float01) == 0x000004, "Member 'FRigControlValueStorage::Float01' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float02) == 0x000008, "Member 'FRigControlValueStorage::Float02' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float03) == 0x00000C, "Member 'FRigControlValueStorage::Float03' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float10) == 0x000010, "Member 'FRigControlValueStorage::Float10' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float11) == 0x000014, "Member 'FRigControlValueStorage::Float11' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float12) == 0x000018, "Member 'FRigControlValueStorage::Float12' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float13) == 0x00001C, "Member 'FRigControlValueStorage::Float13' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float20) == 0x000020, "Member 'FRigControlValueStorage::Float20' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float21) == 0x000024, "Member 'FRigControlValueStorage::Float21' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float22) == 0x000028, "Member 'FRigControlValueStorage::Float22' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float23) == 0x00002C, "Member 'FRigControlValueStorage::Float23' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float30) == 0x000030, "Member 'FRigControlValueStorage::Float30' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float31) == 0x000034, "Member 'FRigControlValueStorage::Float31' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float32) == 0x000038, "Member 'FRigControlValueStorage::Float32' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float33) == 0x00003C, "Member 'FRigControlValueStorage::Float33' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float00_2) == 0x000040, "Member 'FRigControlValueStorage::Float00_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float01_2) == 0x000044, "Member 'FRigControlValueStorage::Float01_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float02_2) == 0x000048, "Member 'FRigControlValueStorage::Float02_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float03_2) == 0x00004C, "Member 'FRigControlValueStorage::Float03_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float10_2) == 0x000050, "Member 'FRigControlValueStorage::Float10_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float11_2) == 0x000054, "Member 'FRigControlValueStorage::Float11_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float12_2) == 0x000058, "Member 'FRigControlValueStorage::Float12_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float13_2) == 0x00005C, "Member 'FRigControlValueStorage::Float13_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float20_2) == 0x000060, "Member 'FRigControlValueStorage::Float20_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float21_2) == 0x000064, "Member 'FRigControlValueStorage::Float21_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float22_2) == 0x000068, "Member 'FRigControlValueStorage::Float22_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float23_2) == 0x00006C, "Member 'FRigControlValueStorage::Float23_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float30_2) == 0x000070, "Member 'FRigControlValueStorage::Float30_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float31_2) == 0x000074, "Member 'FRigControlValueStorage::Float31_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float32_2) == 0x000078, "Member 'FRigControlValueStorage::Float32_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, Float33_2) == 0x00007C, "Member 'FRigControlValueStorage::Float33_2' has a wrong offset!");
static_assert(offsetof(FRigControlValueStorage, bValid) == 0x000080, "Member 'FRigControlValueStorage::bValid' has a wrong offset!");

// ScriptStruct ControlRig.RigControlValue
// 0x00F0 (0x00F0 - 0x0000)
struct FRigControlValue final
{
public:
	struct FRigControlValueStorage                FloatStorage;                                      // 0x0000(0x0084)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Storage;                                           // 0x0090(0x0060)(Deprecated, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigControlValue) == 0x000010, "Wrong alignment on FRigControlValue");
static_assert(sizeof(FRigControlValue) == 0x0000F0, "Wrong size on FRigControlValue");
static_assert(offsetof(FRigControlValue, FloatStorage) == 0x000000, "Member 'FRigControlValue::FloatStorage' has a wrong offset!");
static_assert(offsetof(FRigControlValue, Storage) == 0x000090, "Member 'FRigControlValue::Storage' has a wrong offset!");

// ScriptStruct ControlRig.RigControl
// 0x04F8 (0x0510 - 0x0018)
struct FRigControl final : public FRigElement
{
public:
	ERigControlType                               ControlType;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisplayName;                                       // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentName;                                        // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpaceName;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpaceIndex;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffsetTransform;                                   // 0x0040(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigControlValue                       InitialValue;                                      // 0x00A0(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigControlValue                       Value;                                             // 0x0190(0x00F0)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	ERigControlAxis                               PrimaryAxis;                                       // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurve;                                          // 0x0281(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimatable;                                       // 0x0282(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitTranslation;                                 // 0x0283(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitRotation;                                    // 0x0284(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitScale;                                       // 0x0285(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawLimits;                                       // 0x0286(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287[0x9];                                      // 0x0287(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigControlValue                       MinimumValue;                                      // 0x0290(0x00F0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigControlValue                       MaximumValue;                                      // 0x0380(0x00F0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bGizmoEnabled;                                     // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGizmoVisible;                                     // 0x0471(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_472[0x2];                                      // 0x0472(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GizmoName;                                         // 0x0474(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             GizmoTransform;                                    // 0x0480(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           GizmoColor;                                        // 0x04E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Dependents;                                        // 0x04F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bIsTransientControl;                               // 0x0500(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  ControlEnum;                                       // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigControl) == 0x000010, "Wrong alignment on FRigControl");
static_assert(sizeof(FRigControl) == 0x000510, "Wrong size on FRigControl");
static_assert(offsetof(FRigControl, ControlType) == 0x000018, "Member 'FRigControl::ControlType' has a wrong offset!");
static_assert(offsetof(FRigControl, DisplayName) == 0x00001C, "Member 'FRigControl::DisplayName' has a wrong offset!");
static_assert(offsetof(FRigControl, ParentName) == 0x000024, "Member 'FRigControl::ParentName' has a wrong offset!");
static_assert(offsetof(FRigControl, ParentIndex) == 0x00002C, "Member 'FRigControl::ParentIndex' has a wrong offset!");
static_assert(offsetof(FRigControl, SpaceName) == 0x000030, "Member 'FRigControl::SpaceName' has a wrong offset!");
static_assert(offsetof(FRigControl, SpaceIndex) == 0x000038, "Member 'FRigControl::SpaceIndex' has a wrong offset!");
static_assert(offsetof(FRigControl, OffsetTransform) == 0x000040, "Member 'FRigControl::OffsetTransform' has a wrong offset!");
static_assert(offsetof(FRigControl, InitialValue) == 0x0000A0, "Member 'FRigControl::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigControl, Value) == 0x000190, "Member 'FRigControl::Value' has a wrong offset!");
static_assert(offsetof(FRigControl, PrimaryAxis) == 0x000280, "Member 'FRigControl::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigControl, bIsCurve) == 0x000281, "Member 'FRigControl::bIsCurve' has a wrong offset!");
static_assert(offsetof(FRigControl, bAnimatable) == 0x000282, "Member 'FRigControl::bAnimatable' has a wrong offset!");
static_assert(offsetof(FRigControl, bLimitTranslation) == 0x000283, "Member 'FRigControl::bLimitTranslation' has a wrong offset!");
static_assert(offsetof(FRigControl, bLimitRotation) == 0x000284, "Member 'FRigControl::bLimitRotation' has a wrong offset!");
static_assert(offsetof(FRigControl, bLimitScale) == 0x000285, "Member 'FRigControl::bLimitScale' has a wrong offset!");
static_assert(offsetof(FRigControl, bDrawLimits) == 0x000286, "Member 'FRigControl::bDrawLimits' has a wrong offset!");
static_assert(offsetof(FRigControl, MinimumValue) == 0x000290, "Member 'FRigControl::MinimumValue' has a wrong offset!");
static_assert(offsetof(FRigControl, MaximumValue) == 0x000380, "Member 'FRigControl::MaximumValue' has a wrong offset!");
static_assert(offsetof(FRigControl, bGizmoEnabled) == 0x000470, "Member 'FRigControl::bGizmoEnabled' has a wrong offset!");
static_assert(offsetof(FRigControl, bGizmoVisible) == 0x000471, "Member 'FRigControl::bGizmoVisible' has a wrong offset!");
static_assert(offsetof(FRigControl, GizmoName) == 0x000474, "Member 'FRigControl::GizmoName' has a wrong offset!");
static_assert(offsetof(FRigControl, GizmoTransform) == 0x000480, "Member 'FRigControl::GizmoTransform' has a wrong offset!");
static_assert(offsetof(FRigControl, GizmoColor) == 0x0004E0, "Member 'FRigControl::GizmoColor' has a wrong offset!");
static_assert(offsetof(FRigControl, Dependents) == 0x0004F0, "Member 'FRigControl::Dependents' has a wrong offset!");
static_assert(offsetof(FRigControl, bIsTransientControl) == 0x000500, "Member 'FRigControl::bIsTransientControl' has a wrong offset!");
static_assert(offsetof(FRigControl, ControlEnum) == 0x000508, "Member 'FRigControl::ControlEnum' has a wrong offset!");

// ScriptStruct ControlRig.RigControlHierarchy
// 0x0010 (0x0010 - 0x0000)
struct FRigControlHierarchy final
{
public:
	TArray<struct FRigControl>                    Controls;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigControlHierarchy) == 0x000008, "Wrong alignment on FRigControlHierarchy");
static_assert(sizeof(FRigControlHierarchy) == 0x000010, "Wrong size on FRigControlHierarchy");
static_assert(offsetof(FRigControlHierarchy, Controls) == 0x000000, "Member 'FRigControlHierarchy::Controls' has a wrong offset!");

// ScriptStruct ControlRig.RigCurveContainer
// 0x0010 (0x0010 - 0x0000)
struct FRigCurveContainer final
{
public:
	TArray<struct FRigCurve>                      Curves;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigCurveContainer) == 0x000008, "Wrong alignment on FRigCurveContainer");
static_assert(sizeof(FRigCurveContainer) == 0x000010, "Wrong size on FRigCurveContainer");
static_assert(offsetof(FRigCurveContainer, Curves) == 0x000000, "Member 'FRigCurveContainer::Curves' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchyContainer
// 0x0040 (0x0040 - 0x0000)
struct FRigHierarchyContainer final
{
public:
	struct FRigBoneHierarchy                      BoneHierarchy;                                     // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	struct FRigSpaceHierarchy                     SpaceHierarchy;                                    // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	struct FRigControlHierarchy                   ControlHierarchy;                                  // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	struct FRigCurveContainer                     CurveContainer;                                    // 0x0030(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigHierarchyContainer) == 0x000008, "Wrong alignment on FRigHierarchyContainer");
static_assert(sizeof(FRigHierarchyContainer) == 0x000040, "Wrong size on FRigHierarchyContainer");
static_assert(offsetof(FRigHierarchyContainer, BoneHierarchy) == 0x000000, "Member 'FRigHierarchyContainer::BoneHierarchy' has a wrong offset!");
static_assert(offsetof(FRigHierarchyContainer, SpaceHierarchy) == 0x000010, "Member 'FRigHierarchyContainer::SpaceHierarchy' has a wrong offset!");
static_assert(offsetof(FRigHierarchyContainer, ControlHierarchy) == 0x000020, "Member 'FRigHierarchyContainer::ControlHierarchy' has a wrong offset!");
static_assert(offsetof(FRigHierarchyContainer, CurveContainer) == 0x000030, "Member 'FRigHierarchyContainer::CurveContainer' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigShapeDefinition
// 0x00A0 (0x00A0 - 0x0000)
struct FControlRigShapeDefinition final
{
public:
	class FName                                   ShapeName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0030(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigShapeDefinition) == 0x000010, "Wrong alignment on FControlRigShapeDefinition");
static_assert(sizeof(FControlRigShapeDefinition) == 0x0000A0, "Wrong size on FControlRigShapeDefinition");
static_assert(offsetof(FControlRigShapeDefinition, ShapeName) == 0x000000, "Member 'FControlRigShapeDefinition::ShapeName' has a wrong offset!");
static_assert(offsetof(FControlRigShapeDefinition, StaticMesh) == 0x000008, "Member 'FControlRigShapeDefinition::StaticMesh' has a wrong offset!");
static_assert(offsetof(FControlRigShapeDefinition, Transform) == 0x000030, "Member 'FControlRigShapeDefinition::Transform' has a wrong offset!");

// ScriptStruct ControlRig.AnimNode_ControlRigInputPose
// 0x0020 (0x0030 - 0x0010)
struct FAnimNode_ControlRigInputPose final : public FAnimNode_Base
{
public:
	struct FPoseLink                              InputPose;                                         // 0x0010(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ControlRigInputPose) == 0x000008, "Wrong alignment on FAnimNode_ControlRigInputPose");
static_assert(sizeof(FAnimNode_ControlRigInputPose) == 0x000030, "Wrong size on FAnimNode_ControlRigInputPose");
static_assert(offsetof(FAnimNode_ControlRigInputPose, InputPose) == 0x000010, "Member 'FAnimNode_ControlRigInputPose::InputPose' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigLayerInstanceProxy
// 0x00A0 (0x0930 - 0x0890)
struct FControlRigLayerInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_890[0xA0];                                     // 0x0890(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigLayerInstanceProxy) == 0x000010, "Wrong alignment on FControlRigLayerInstanceProxy");
static_assert(sizeof(FControlRigLayerInstanceProxy) == 0x000930, "Wrong size on FControlRigLayerInstanceProxy");

// ScriptStruct ControlRig.CRFourPointBezier
// 0x0060 (0x0060 - 0x0000)
struct FCRFourPointBezier final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                C;                                                 // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                D;                                                 // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCRFourPointBezier) == 0x000008, "Wrong alignment on FCRFourPointBezier");
static_assert(sizeof(FCRFourPointBezier) == 0x000060, "Wrong size on FCRFourPointBezier");
static_assert(offsetof(FCRFourPointBezier, A) == 0x000000, "Member 'FCRFourPointBezier::A' has a wrong offset!");
static_assert(offsetof(FCRFourPointBezier, B) == 0x000018, "Member 'FCRFourPointBezier::B' has a wrong offset!");
static_assert(offsetof(FCRFourPointBezier, C) == 0x000030, "Member 'FCRFourPointBezier::C' has a wrong offset!");
static_assert(offsetof(FCRFourPointBezier, D) == 0x000048, "Member 'FCRFourPointBezier::D' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BoneName
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_BoneName final : public FRigUnit
{
public:
	class FName                                   bone;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BoneName) == 0x000008, "Wrong alignment on FRigUnit_BoneName");
static_assert(sizeof(FRigUnit_BoneName) == 0x000010, "Wrong size on FRigUnit_BoneName");
static_assert(offsetof(FRigUnit_BoneName, bone) == 0x000008, "Member 'FRigUnit_BoneName::bone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathFloatBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathFloatBase) == 0x000008, "Wrong alignment on FRigUnit_MathFloatBase");
static_assert(sizeof(FRigUnit_MathFloatBase) == 0x000008, "Wrong size on FRigUnit_MathFloatBase");

// ScriptStruct ControlRig.RigUnit_MathFloatToInt
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathFloatToInt final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatToInt) == 0x000008, "Wrong alignment on FRigUnit_MathFloatToInt");
static_assert(sizeof(FRigUnit_MathFloatToInt) == 0x000010, "Wrong size on FRigUnit_MathFloatToInt");
static_assert(offsetof(FRigUnit_MathFloatToInt, Value) == 0x000008, "Member 'FRigUnit_MathFloatToInt::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatToInt, Result) == 0x00000C, "Member 'FRigUnit_MathFloatToInt::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigControlCopy
// 0x02A0 (0x02A0 - 0x0000)
struct FRigControlCopy final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigControlType                               ControlType;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigControlValue                       Value;                                             // 0x0020(0x00F0)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigElementKey                         ParentKey;                                         // 0x0110(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffsetTransform;                                   // 0x0120(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ParentTransform;                                   // 0x0180(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x01E0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             GlobalTransform;                                   // 0x0240(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigControlCopy) == 0x000010, "Wrong alignment on FRigControlCopy");
static_assert(sizeof(FRigControlCopy) == 0x0002A0, "Wrong size on FRigControlCopy");
static_assert(offsetof(FRigControlCopy, Name) == 0x000010, "Member 'FRigControlCopy::Name' has a wrong offset!");
static_assert(offsetof(FRigControlCopy, ControlType) == 0x000018, "Member 'FRigControlCopy::ControlType' has a wrong offset!");
static_assert(offsetof(FRigControlCopy, Value) == 0x000020, "Member 'FRigControlCopy::Value' has a wrong offset!");
static_assert(offsetof(FRigControlCopy, ParentKey) == 0x000110, "Member 'FRigControlCopy::ParentKey' has a wrong offset!");
static_assert(offsetof(FRigControlCopy, OffsetTransform) == 0x000120, "Member 'FRigControlCopy::OffsetTransform' has a wrong offset!");
static_assert(offsetof(FRigControlCopy, ParentTransform) == 0x000180, "Member 'FRigControlCopy::ParentTransform' has a wrong offset!");
static_assert(offsetof(FRigControlCopy, LocalTransform) == 0x0001E0, "Member 'FRigControlCopy::LocalTransform' has a wrong offset!");
static_assert(offsetof(FRigControlCopy, GlobalTransform) == 0x000240, "Member 'FRigControlCopy::GlobalTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BoneHarmonics_BoneTarget
// 0x000C (0x000C - 0x0000)
struct FRigUnit_BoneHarmonics_BoneTarget final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BoneHarmonics_BoneTarget) == 0x000004, "Wrong alignment on FRigUnit_BoneHarmonics_BoneTarget");
static_assert(sizeof(FRigUnit_BoneHarmonics_BoneTarget) == 0x00000C, "Wrong size on FRigUnit_BoneHarmonics_BoneTarget");
static_assert(offsetof(FRigUnit_BoneHarmonics_BoneTarget, bone) == 0x000000, "Member 'FRigUnit_BoneHarmonics_BoneTarget::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics_BoneTarget, Ratio) == 0x000008, "Member 'FRigUnit_BoneHarmonics_BoneTarget::Ratio' has a wrong offset!");

// ScriptStruct ControlRig.RigMirrorSettings
// 0x0028 (0x0028 - 0x0000)
struct FRigMirrorSettings final
{
public:
	EAxis                                         MirrorAxis;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         AxisToFlip;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SearchString;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReplaceString;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigMirrorSettings) == 0x000008, "Wrong alignment on FRigMirrorSettings");
static_assert(sizeof(FRigMirrorSettings) == 0x000028, "Wrong size on FRigMirrorSettings");
static_assert(offsetof(FRigMirrorSettings, MirrorAxis) == 0x000000, "Member 'FRigMirrorSettings::MirrorAxis' has a wrong offset!");
static_assert(offsetof(FRigMirrorSettings, AxisToFlip) == 0x000001, "Member 'FRigMirrorSettings::AxisToFlip' has a wrong offset!");
static_assert(offsetof(FRigMirrorSettings, SearchString) == 0x000008, "Member 'FRigMirrorSettings::SearchString' has a wrong offset!");
static_assert(offsetof(FRigMirrorSettings, ReplaceString) == 0x000018, "Member 'FRigMirrorSettings::ReplaceString' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimRichCurve
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_AnimRichCurve final : public FRigUnit_AnimBase
{
public:
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0008(0x0088)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AnimRichCurve) == 0x000008, "Wrong alignment on FRigUnit_AnimRichCurve");
static_assert(sizeof(FRigUnit_AnimRichCurve) == 0x000090, "Wrong size on FRigUnit_AnimRichCurve");
static_assert(offsetof(FRigUnit_AnimRichCurve, Curve) == 0x000008, "Member 'FRigUnit_AnimRichCurve::Curve' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigControlPose
// 0x0060 (0x0060 - 0x0000)
struct FControlRigControlPose final
{
public:
	TArray<struct FRigControlCopy>                CopyOfControls;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigControlPose) == 0x000008, "Wrong alignment on FControlRigControlPose");
static_assert(sizeof(FControlRigControlPose) == 0x000060, "Wrong size on FControlRigControlPose");
static_assert(offsetof(FControlRigControlPose, CopyOfControls) == 0x000000, "Member 'FControlRigControlPose::CopyOfControls' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatFloor
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatFloor final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatFloor) == 0x000008, "Wrong alignment on FRigUnit_MathFloatFloor");
static_assert(sizeof(FRigUnit_MathFloatFloor) == 0x000018, "Wrong size on FRigUnit_MathFloatFloor");
static_assert(offsetof(FRigUnit_MathFloatFloor, Value) == 0x000008, "Member 'FRigUnit_MathFloatFloor::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatFloor, Result) == 0x00000C, "Member 'FRigUnit_MathFloatFloor::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatFloor, Int) == 0x000010, "Member 'FRigUnit_MathFloatFloor::Int' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSequenceObjectReference
// 0x0008 (0x0008 - 0x0000)
struct FControlRigSequenceObjectReference final
{
public:
	TSubclassOf<class UControlRig>                ControlRigClass;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FControlRigSequenceObjectReference) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReference");
static_assert(sizeof(FControlRigSequenceObjectReference) == 0x000008, "Wrong size on FControlRigSequenceObjectReference");
static_assert(offsetof(FControlRigSequenceObjectReference, ControlRigClass) == 0x000000, "Member 'FControlRigSequenceObjectReference::ControlRigClass' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Harmonics_TargetItem
// 0x0010 (0x0010 - 0x0000)
struct FRigUnit_Harmonics_TargetItem final
{
public:
	struct FRigElementKey                         Item;                                              // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_Harmonics_TargetItem) == 0x000004, "Wrong alignment on FRigUnit_Harmonics_TargetItem");
static_assert(sizeof(FRigUnit_Harmonics_TargetItem) == 0x000010, "Wrong size on FRigUnit_Harmonics_TargetItem");
static_assert(offsetof(FRigUnit_Harmonics_TargetItem, Item) == 0x000000, "Member 'FRigUnit_Harmonics_TargetItem::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_Harmonics_TargetItem, Ratio) == 0x00000C, "Member 'FRigUnit_Harmonics_TargetItem::Ratio' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BoneHarmonics_WorkData
// 0x0028 (0x0028 - 0x0000)
struct FRigUnit_BoneHarmonics_WorkData final
{
public:
	TArray<struct FCachedRigElement>              CachedItems;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                WaveTime;                                          // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BoneHarmonics_WorkData) == 0x000008, "Wrong alignment on FRigUnit_BoneHarmonics_WorkData");
static_assert(sizeof(FRigUnit_BoneHarmonics_WorkData) == 0x000028, "Wrong size on FRigUnit_BoneHarmonics_WorkData");
static_assert(offsetof(FRigUnit_BoneHarmonics_WorkData, CachedItems) == 0x000000, "Member 'FRigUnit_BoneHarmonics_WorkData::CachedItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics_WorkData, WaveTime) == 0x000010, "Member 'FRigUnit_BoneHarmonics_WorkData::WaveTime' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HighlevelBaseMutable
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_HighlevelBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_HighlevelBaseMutable) == 0x000010, "Wrong alignment on FRigUnit_HighlevelBaseMutable");
static_assert(sizeof(FRigUnit_HighlevelBaseMutable) == 0x0000D0, "Wrong size on FRigUnit_HighlevelBaseMutable");

// ScriptStruct ControlRig.RigUnit_ItemHarmonics
// 0x00C0 (0x0190 - 0x00D0)
struct FRigUnit_ItemHarmonics final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigUnit_Harmonics_TargetItem>  Targets;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                WaveSpeed;                                         // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveFrequency;                                     // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveAmplitude;                                     // 0x0110(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveOffset;                                        // 0x0128(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveNoise;                                         // 0x0140(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     WaveEase;                                          // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaveMinimum;                                       // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveMaximum;                                       // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEulerRotationOrder                           RotationOrder;                                     // 0x0164(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_BoneHarmonics_WorkData        WorkData;                                          // 0x0168(0x0028)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ItemHarmonics) == 0x000010, "Wrong alignment on FRigUnit_ItemHarmonics");
static_assert(sizeof(FRigUnit_ItemHarmonics) == 0x000190, "Wrong size on FRigUnit_ItemHarmonics");
static_assert(offsetof(FRigUnit_ItemHarmonics, Targets) == 0x0000D0, "Member 'FRigUnit_ItemHarmonics::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WaveSpeed) == 0x0000E0, "Member 'FRigUnit_ItemHarmonics::WaveSpeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WaveFrequency) == 0x0000F8, "Member 'FRigUnit_ItemHarmonics::WaveFrequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WaveAmplitude) == 0x000110, "Member 'FRigUnit_ItemHarmonics::WaveAmplitude' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WaveOffset) == 0x000128, "Member 'FRigUnit_ItemHarmonics::WaveOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WaveNoise) == 0x000140, "Member 'FRigUnit_ItemHarmonics::WaveNoise' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WaveEase) == 0x000158, "Member 'FRigUnit_ItemHarmonics::WaveEase' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WaveMinimum) == 0x00015C, "Member 'FRigUnit_ItemHarmonics::WaveMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WaveMaximum) == 0x000160, "Member 'FRigUnit_ItemHarmonics::WaveMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, RotationOrder) == 0x000164, "Member 'FRigUnit_ItemHarmonics::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemHarmonics, WorkData) == 0x000168, "Member 'FRigUnit_ItemHarmonics::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSequenceObjectReferences
// 0x0010 (0x0010 - 0x0000)
struct FControlRigSequenceObjectReferences final
{
public:
	TArray<struct FControlRigSequenceObjectReference> Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigSequenceObjectReferences) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReferences");
static_assert(sizeof(FControlRigSequenceObjectReferences) == 0x000010, "Wrong size on FControlRigSequenceObjectReferences");
static_assert(offsetof(FControlRigSequenceObjectReferences, Array) == 0x000000, "Member 'FControlRigSequenceObjectReferences::Array' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSequenceObjectReferenceMap
// 0x0020 (0x0020 - 0x0000)
struct FControlRigSequenceObjectReferenceMap final
{
public:
	TArray<struct FGuid>                          BindingIds;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FControlRigSequenceObjectReferences> References;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FControlRigSequenceObjectReferenceMap) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReferenceMap");
static_assert(sizeof(FControlRigSequenceObjectReferenceMap) == 0x000020, "Wrong size on FControlRigSequenceObjectReferenceMap");
static_assert(offsetof(FControlRigSequenceObjectReferenceMap, BindingIds) == 0x000000, "Member 'FControlRigSequenceObjectReferenceMap::BindingIds' has a wrong offset!");
static_assert(offsetof(FControlRigSequenceObjectReferenceMap, References) == 0x000010, "Member 'FControlRigSequenceObjectReferenceMap::References' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CCDIK_RotationLimitPerItem
// 0x0010 (0x0010 - 0x0000)
struct FRigUnit_CCDIK_RotationLimitPerItem final
{
public:
	struct FRigElementKey                         Item;                                              // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limit;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CCDIK_RotationLimitPerItem) == 0x000004, "Wrong alignment on FRigUnit_CCDIK_RotationLimitPerItem");
static_assert(sizeof(FRigUnit_CCDIK_RotationLimitPerItem) == 0x000010, "Wrong size on FRigUnit_CCDIK_RotationLimitPerItem");
static_assert(offsetof(FRigUnit_CCDIK_RotationLimitPerItem, Item) == 0x000000, "Member 'FRigUnit_CCDIK_RotationLimitPerItem::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK_RotationLimitPerItem, Limit) == 0x00000C, "Member 'FRigUnit_CCDIK_RotationLimitPerItem::Limit' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CCDIK_WorkData
// 0x0060 (0x0060 - 0x0000)
struct FRigUnit_CCDIK_WorkData final
{
public:
	TArray<struct FCCDIKChainLink>                Chain;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              CachedItems;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 RotationLimitIndex;                                // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RotationLimitsPerItem;                             // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedEffector;                                    // 0x0040(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CCDIK_WorkData) == 0x000008, "Wrong alignment on FRigUnit_CCDIK_WorkData");
static_assert(sizeof(FRigUnit_CCDIK_WorkData) == 0x000060, "Wrong size on FRigUnit_CCDIK_WorkData");
static_assert(offsetof(FRigUnit_CCDIK_WorkData, Chain) == 0x000000, "Member 'FRigUnit_CCDIK_WorkData::Chain' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK_WorkData, CachedItems) == 0x000010, "Member 'FRigUnit_CCDIK_WorkData::CachedItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK_WorkData, RotationLimitIndex) == 0x000020, "Member 'FRigUnit_CCDIK_WorkData::RotationLimitIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK_WorkData, RotationLimitsPerItem) == 0x000030, "Member 'FRigUnit_CCDIK_WorkData::RotationLimitsPerItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK_WorkData, CachedEffector) == 0x000040, "Member 'FRigUnit_CCDIK_WorkData::CachedEffector' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CCDIKPerItem
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_CCDIKPerItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x00D0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EffectorTransform;                                 // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterations;                                     // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFromTail;                                    // 0x014C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseRotationLimit;                                 // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnit_CCDIK_RotationLimitPerItem> RotationLimits;                                    // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_CCDIK_WorkData                WorkData;                                          // 0x0170(0x0060)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CCDIKPerItem) == 0x000010, "Wrong alignment on FRigUnit_CCDIKPerItem");
static_assert(sizeof(FRigUnit_CCDIKPerItem) == 0x0001D0, "Wrong size on FRigUnit_CCDIKPerItem");
static_assert(offsetof(FRigUnit_CCDIKPerItem, Items) == 0x0000D0, "Member 'FRigUnit_CCDIKPerItem::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, EffectorTransform) == 0x0000E0, "Member 'FRigUnit_CCDIKPerItem::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, Precision) == 0x000140, "Member 'FRigUnit_CCDIKPerItem::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, Weight) == 0x000144, "Member 'FRigUnit_CCDIKPerItem::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, MaxIterations) == 0x000148, "Member 'FRigUnit_CCDIKPerItem::MaxIterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, bStartFromTail) == 0x00014C, "Member 'FRigUnit_CCDIKPerItem::bStartFromTail' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, BaseRotationLimit) == 0x000150, "Member 'FRigUnit_CCDIKPerItem::BaseRotationLimit' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, RotationLimits) == 0x000158, "Member 'FRigUnit_CCDIKPerItem::RotationLimits' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, bPropagateToChildren) == 0x000168, "Member 'FRigUnit_CCDIKPerItem::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKPerItem, WorkData) == 0x000170, "Member 'FRigUnit_CCDIKPerItem::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatLess
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatLess final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatLess) == 0x000008, "Wrong alignment on FRigUnit_MathFloatLess");
static_assert(sizeof(FRigUnit_MathFloatLess) == 0x000018, "Wrong size on FRigUnit_MathFloatLess");
static_assert(offsetof(FRigUnit_MathFloatLess, A) == 0x000008, "Member 'FRigUnit_MathFloatLess::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLess, B) == 0x00000C, "Member 'FRigUnit_MathFloatLess::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLess, Result) == 0x000010, "Member 'FRigUnit_MathFloatLess::Result' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSettingsPerPinBool
// 0x0050 (0x0050 - 0x0000)
struct FControlRigSettingsPerPinBool final
{
public:
	TMap<class FString, bool>                     Values;                                            // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigSettingsPerPinBool) == 0x000008, "Wrong alignment on FControlRigSettingsPerPinBool");
static_assert(sizeof(FControlRigSettingsPerPinBool) == 0x000050, "Wrong size on FControlRigSettingsPerPinBool");
static_assert(offsetof(FControlRigSettingsPerPinBool, Values) == 0x000000, "Member 'FControlRigSettingsPerPinBool::Values' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatUnaryOp
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathFloatUnaryOp : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatUnaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathFloatUnaryOp");
static_assert(sizeof(FRigUnit_MathFloatUnaryOp) == 0x000010, "Wrong size on FRigUnit_MathFloatUnaryOp");
static_assert(offsetof(FRigUnit_MathFloatUnaryOp, Value) == 0x000008, "Member 'FRigUnit_MathFloatUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatUnaryOp, Result) == 0x00000C, "Member 'FRigUnit_MathFloatUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatSign
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatSign final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatSign) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSign");
static_assert(sizeof(FRigUnit_MathFloatSign) == 0x000010, "Wrong size on FRigUnit_MathFloatSign");

// ScriptStruct ControlRig.ControlRigValidationContext
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FControlRigValidationContext final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigValidationContext) == 0x000008, "Wrong alignment on FControlRigValidationContext");
static_assert(sizeof(FControlRigValidationContext) == 0x000028, "Wrong size on FControlRigValidationContext");

// ScriptStruct ControlRig.RigUnit_ControlName
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_ControlName final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ControlName) == 0x000008, "Wrong alignment on FRigUnit_ControlName");
static_assert(sizeof(FRigUnit_ControlName) == 0x000010, "Wrong size on FRigUnit_ControlName");
static_assert(offsetof(FRigUnit_ControlName, Control) == 0x000008, "Member 'FRigUnit_ControlName::Control' has a wrong offset!");

// ScriptStruct ControlRig.CRSimContainer
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCRSimContainer
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeStep;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTime;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLeftForStep;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCRSimContainer) == 0x000008, "Wrong alignment on FCRSimContainer");
static_assert(sizeof(FCRSimContainer) == 0x000018, "Wrong size on FCRSimContainer");
static_assert(offsetof(FCRSimContainer, TimeStep) == 0x000008, "Member 'FCRSimContainer::TimeStep' has a wrong offset!");
static_assert(offsetof(FCRSimContainer, AccumulatedTime) == 0x00000C, "Member 'FCRSimContainer::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FCRSimContainer, TimeLeftForStep) == 0x000010, "Member 'FCRSimContainer::TimeLeftForStep' has a wrong offset!");

// ScriptStruct ControlRig.CRSimLinearSpring
// 0x0010 (0x0010 - 0x0000)
struct FCRSimLinearSpring final
{
public:
	int32                                         SubjectA;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubjectB;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Coefficient;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Equilibrium;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCRSimLinearSpring) == 0x000004, "Wrong alignment on FCRSimLinearSpring");
static_assert(sizeof(FCRSimLinearSpring) == 0x000010, "Wrong size on FCRSimLinearSpring");
static_assert(offsetof(FCRSimLinearSpring, SubjectA) == 0x000000, "Member 'FCRSimLinearSpring::SubjectA' has a wrong offset!");
static_assert(offsetof(FCRSimLinearSpring, SubjectB) == 0x000004, "Member 'FCRSimLinearSpring::SubjectB' has a wrong offset!");
static_assert(offsetof(FCRSimLinearSpring, Coefficient) == 0x000008, "Member 'FCRSimLinearSpring::Coefficient' has a wrong offset!");
static_assert(offsetof(FCRSimLinearSpring, Equilibrium) == 0x00000C, "Member 'FCRSimLinearSpring::Equilibrium' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatAbs
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatAbs final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAbs) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAbs");
static_assert(sizeof(FRigUnit_MathFloatAbs) == 0x000010, "Wrong size on FRigUnit_MathFloatAbs");

// ScriptStruct ControlRig.CRSimPoint
// 0x0040 (0x0040 - 0x0000)
struct FCRSimPoint final
{
public:
	float                                         Mass;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InheritMotion;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinearVelocity;                                    // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCRSimPoint) == 0x000008, "Wrong alignment on FCRSimPoint");
static_assert(sizeof(FCRSimPoint) == 0x000040, "Wrong size on FCRSimPoint");
static_assert(offsetof(FCRSimPoint, Mass) == 0x000000, "Member 'FCRSimPoint::Mass' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, Size) == 0x000004, "Member 'FCRSimPoint::Size' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, LinearDamping) == 0x000008, "Member 'FCRSimPoint::LinearDamping' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, InheritMotion) == 0x00000C, "Member 'FCRSimPoint::InheritMotion' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, Position) == 0x000010, "Member 'FCRSimPoint::Position' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, LinearVelocity) == 0x000028, "Member 'FCRSimPoint::LinearVelocity' has a wrong offset!");

// ScriptStruct ControlRig.CRSimPointConstraint
// 0x0040 (0x0040 - 0x0000)
struct FCRSimPointConstraint final
{
public:
	ECRSimConstraintType                          Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubjectA;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubjectB;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DataA;                                             // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DataB;                                             // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCRSimPointConstraint) == 0x000008, "Wrong alignment on FCRSimPointConstraint");
static_assert(sizeof(FCRSimPointConstraint) == 0x000040, "Wrong size on FCRSimPointConstraint");
static_assert(offsetof(FCRSimPointConstraint, Type) == 0x000000, "Member 'FCRSimPointConstraint::Type' has a wrong offset!");
static_assert(offsetof(FCRSimPointConstraint, SubjectA) == 0x000004, "Member 'FCRSimPointConstraint::SubjectA' has a wrong offset!");
static_assert(offsetof(FCRSimPointConstraint, SubjectB) == 0x000008, "Member 'FCRSimPointConstraint::SubjectB' has a wrong offset!");
static_assert(offsetof(FCRSimPointConstraint, DataA) == 0x000010, "Member 'FCRSimPointConstraint::DataA' has a wrong offset!");
static_assert(offsetof(FCRSimPointConstraint, DataB) == 0x000028, "Member 'FCRSimPointConstraint::DataB' has a wrong offset!");

// ScriptStruct ControlRig.RigComputedTransform
// 0x0070 (0x0070 - 0x0000)
struct FRigComputedTransform final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigComputedTransform) == 0x000010, "Wrong alignment on FRigComputedTransform");
static_assert(sizeof(FRigComputedTransform) == 0x000070, "Wrong size on FRigComputedTransform");
static_assert(offsetof(FRigComputedTransform, Transform) == 0x000000, "Member 'FRigComputedTransform::Transform' has a wrong offset!");

// ScriptStruct ControlRig.RigLocalAndGlobalTransform
// 0x00E0 (0x00E0 - 0x0000)
struct FRigLocalAndGlobalTransform final
{
public:
	struct FRigComputedTransform                  Local;                                             // 0x0000(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigComputedTransform                  Global;                                            // 0x0070(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigLocalAndGlobalTransform) == 0x000010, "Wrong alignment on FRigLocalAndGlobalTransform");
static_assert(sizeof(FRigLocalAndGlobalTransform) == 0x0000E0, "Wrong size on FRigLocalAndGlobalTransform");
static_assert(offsetof(FRigLocalAndGlobalTransform, Local) == 0x000000, "Member 'FRigLocalAndGlobalTransform::Local' has a wrong offset!");
static_assert(offsetof(FRigLocalAndGlobalTransform, Global) == 0x000070, "Member 'FRigLocalAndGlobalTransform::Global' has a wrong offset!");

// ScriptStruct ControlRig.RigCurrentAndInitialTransform
// 0x01C0 (0x01C0 - 0x0000)
struct FRigCurrentAndInitialTransform final
{
public:
	struct FRigLocalAndGlobalTransform            Current;                                           // 0x0000(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigLocalAndGlobalTransform            Initial;                                           // 0x00E0(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigCurrentAndInitialTransform) == 0x000010, "Wrong alignment on FRigCurrentAndInitialTransform");
static_assert(sizeof(FRigCurrentAndInitialTransform) == 0x0001C0, "Wrong size on FRigCurrentAndInitialTransform");
static_assert(offsetof(FRigCurrentAndInitialTransform, Current) == 0x000000, "Member 'FRigCurrentAndInitialTransform::Current' has a wrong offset!");
static_assert(offsetof(FRigCurrentAndInitialTransform, Initial) == 0x0000E0, "Member 'FRigCurrentAndInitialTransform::Initial' has a wrong offset!");

// ScriptStruct ControlRig.RigBaseElement
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FRigBaseElement
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         Key;                                               // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Index;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubIndex;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelected;                                         // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D[0x33];                                      // 0x001D(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigBaseElement) == 0x000008, "Wrong alignment on FRigBaseElement");
static_assert(sizeof(FRigBaseElement) == 0x000050, "Wrong size on FRigBaseElement");
static_assert(offsetof(FRigBaseElement, Key) == 0x000008, "Member 'FRigBaseElement::Key' has a wrong offset!");
static_assert(offsetof(FRigBaseElement, Index) == 0x000014, "Member 'FRigBaseElement::Index' has a wrong offset!");
static_assert(offsetof(FRigBaseElement, SubIndex) == 0x000018, "Member 'FRigBaseElement::SubIndex' has a wrong offset!");
static_assert(offsetof(FRigBaseElement, bSelected) == 0x00001C, "Member 'FRigBaseElement::bSelected' has a wrong offset!");

// ScriptStruct ControlRig.RigTransformElement
// 0x0200 (0x0250 - 0x0050)
struct FRigTransformElement : public FRigBaseElement
{
public:
	struct FRigCurrentAndInitialTransform         Pose;                                              // 0x0050(0x01C0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_210[0x40];                                     // 0x0210(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigTransformElement) == 0x000010, "Wrong alignment on FRigTransformElement");
static_assert(sizeof(FRigTransformElement) == 0x000250, "Wrong size on FRigTransformElement");
static_assert(offsetof(FRigTransformElement, Pose) == 0x000050, "Member 'FRigTransformElement::Pose' has a wrong offset!");

// ScriptStruct ControlRig.RigSingleParentElement
// 0x0010 (0x0260 - 0x0250)
#pragma pack(push, 0x1)
struct alignas(0x10) FRigSingleParentElement : public FRigTransformElement
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
#pragma pack(pop)
static_assert(alignof(FRigSingleParentElement) == 0x000010, "Wrong alignment on FRigSingleParentElement");
static_assert(sizeof(FRigSingleParentElement) == 0x000260, "Wrong size on FRigSingleParentElement");

// ScriptStruct ControlRig.RigReferenceElement
// 0x0010 (0x0270 - 0x0260)
struct FRigReferenceElement final : public FRigSingleParentElement
{
public:
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigReferenceElement) == 0x000010, "Wrong alignment on FRigReferenceElement");
static_assert(sizeof(FRigReferenceElement) == 0x000270, "Wrong size on FRigReferenceElement");

// ScriptStruct ControlRig.CRSimPointForce
// 0x0028 (0x0028 - 0x0000)
struct FCRSimPointForce final
{
public:
	ECRSimPointForceType                          ForceType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector;                                            // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Coefficient;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalize;                                        // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCRSimPointForce) == 0x000008, "Wrong alignment on FCRSimPointForce");
static_assert(sizeof(FCRSimPointForce) == 0x000028, "Wrong size on FCRSimPointForce");
static_assert(offsetof(FCRSimPointForce, ForceType) == 0x000000, "Member 'FCRSimPointForce::ForceType' has a wrong offset!");
static_assert(offsetof(FCRSimPointForce, Vector) == 0x000008, "Member 'FCRSimPointForce::Vector' has a wrong offset!");
static_assert(offsetof(FCRSimPointForce, Coefficient) == 0x000020, "Member 'FCRSimPointForce::Coefficient' has a wrong offset!");
static_assert(offsetof(FCRSimPointForce, bNormalize) == 0x000024, "Member 'FCRSimPointForce::bNormalize' has a wrong offset!");

// ScriptStruct ControlRig.CRSimSoftCollision
// 0x0080 (0x0080 - 0x0000)
struct FCRSimSoftCollision final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ECRSimSoftCollisionType                       ShapeType;                                         // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistance;                                   // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     FalloffType;                                       // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Coefficient;                                       // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverted;                                         // 0x0074(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0xB];                                       // 0x0075(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCRSimSoftCollision) == 0x000010, "Wrong alignment on FCRSimSoftCollision");
static_assert(sizeof(FCRSimSoftCollision) == 0x000080, "Wrong size on FCRSimSoftCollision");
static_assert(offsetof(FCRSimSoftCollision, Transform) == 0x000000, "Member 'FCRSimSoftCollision::Transform' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, ShapeType) == 0x000060, "Member 'FCRSimSoftCollision::ShapeType' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, MinimumDistance) == 0x000064, "Member 'FCRSimSoftCollision::MinimumDistance' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, MaximumDistance) == 0x000068, "Member 'FCRSimSoftCollision::MaximumDistance' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, FalloffType) == 0x00006C, "Member 'FCRSimSoftCollision::FalloffType' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, Coefficient) == 0x000070, "Member 'FCRSimSoftCollision::Coefficient' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, bInverted) == 0x000074, "Member 'FCRSimSoftCollision::bInverted' has a wrong offset!");

// ScriptStruct ControlRig.CRSimPointContainer
// 0x0060 (0x0078 - 0x0018)
struct FCRSimPointContainer final : public FCRSimContainer
{
public:
	TArray<struct FCRSimPoint>                    Points;                                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimLinearSpring>             Springs;                                           // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimPointForce>               Forces;                                            // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimSoftCollision>            CollisionVolumes;                                  // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimPointConstraint>          Constraints;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimPoint>                    PreviousStep;                                      // 0x0068(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCRSimPointContainer) == 0x000008, "Wrong alignment on FCRSimPointContainer");
static_assert(sizeof(FCRSimPointContainer) == 0x000078, "Wrong size on FCRSimPointContainer");
static_assert(offsetof(FCRSimPointContainer, Points) == 0x000018, "Member 'FCRSimPointContainer::Points' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, Springs) == 0x000028, "Member 'FCRSimPointContainer::Springs' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, Forces) == 0x000038, "Member 'FCRSimPointContainer::Forces' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, CollisionVolumes) == 0x000048, "Member 'FCRSimPointContainer::CollisionVolumes' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, Constraints) == 0x000058, "Member 'FCRSimPointContainer::Constraints' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, PreviousStep) == 0x000068, "Member 'FCRSimPointContainer::PreviousStep' has a wrong offset!");

// ScriptStruct ControlRig.RigPoseElement
// 0x00F0 (0x00F0 - 0x0000)
struct FRigPoseElement final
{
public:
	struct FCachedRigElement                      Index;                                             // 0x0000(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             GlobalTransform;                                   // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x0080(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurveValue;                                        // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0xC];                                       // 0x00E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigPoseElement) == 0x000010, "Wrong alignment on FRigPoseElement");
static_assert(sizeof(FRigPoseElement) == 0x0000F0, "Wrong size on FRigPoseElement");
static_assert(offsetof(FRigPoseElement, Index) == 0x000000, "Member 'FRigPoseElement::Index' has a wrong offset!");
static_assert(offsetof(FRigPoseElement, GlobalTransform) == 0x000020, "Member 'FRigPoseElement::GlobalTransform' has a wrong offset!");
static_assert(offsetof(FRigPoseElement, LocalTransform) == 0x000080, "Member 'FRigPoseElement::LocalTransform' has a wrong offset!");
static_assert(offsetof(FRigPoseElement, CurveValue) == 0x0000E0, "Member 'FRigPoseElement::CurveValue' has a wrong offset!");

// ScriptStruct ControlRig.RigPose
// 0x0070 (0x0070 - 0x0000)
struct FRigPose final
{
public:
	TArray<struct FRigPoseElement>                Elements;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         HierarchyTopologyVersion;                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoseHash;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x58];                                      // 0x0018(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigPose) == 0x000008, "Wrong alignment on FRigPose");
static_assert(sizeof(FRigPose) == 0x000070, "Wrong size on FRigPose");
static_assert(offsetof(FRigPose, Elements) == 0x000000, "Member 'FRigPose::Elements' has a wrong offset!");
static_assert(offsetof(FRigPose, HierarchyTopologyVersion) == 0x000010, "Member 'FRigPose::HierarchyTopologyVersion' has a wrong offset!");
static_assert(offsetof(FRigPose, PoseHash) == 0x000014, "Member 'FRigPose::PoseHash' has a wrong offset!");

// ScriptStruct ControlRig.MovieSceneControlRigInstanceData
// 0x0118 (0x0120 - 0x0008)
struct FMovieSceneControlRigInstanceData final : public FMovieSceneSequenceInstanceData
{
public:
	bool                                          bAdditive;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBoneFilter;                                  // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputBlendPose                        BoneFilter;                                        // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                Weight;                                            // 0x0020(0x00E8)(NativeAccessSpecifierPublic)
	struct FMovieSceneEvaluationOperand           Operand;                                           // 0x0108(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneControlRigInstanceData) == 0x000008, "Wrong alignment on FMovieSceneControlRigInstanceData");
static_assert(sizeof(FMovieSceneControlRigInstanceData) == 0x000120, "Wrong size on FMovieSceneControlRigInstanceData");
static_assert(offsetof(FMovieSceneControlRigInstanceData, bAdditive) == 0x000008, "Member 'FMovieSceneControlRigInstanceData::bAdditive' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, bApplyBoneFilter) == 0x000009, "Member 'FMovieSceneControlRigInstanceData::bApplyBoneFilter' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, BoneFilter) == 0x000010, "Member 'FMovieSceneControlRigInstanceData::BoneFilter' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, Weight) == 0x000020, "Member 'FMovieSceneControlRigInstanceData::Weight' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, Operand) == 0x000108, "Member 'FMovieSceneControlRigInstanceData::Operand' has a wrong offset!");

// ScriptStruct ControlRig.EnumParameterNameAndCurve
// 0x00E8 (0x00E8 - 0x0000)
struct FEnumParameterNameAndCurve final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneByteChannel                 ParameterCurve;                                    // 0x0008(0x00E0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnumParameterNameAndCurve) == 0x000008, "Wrong alignment on FEnumParameterNameAndCurve");
static_assert(sizeof(FEnumParameterNameAndCurve) == 0x0000E8, "Wrong size on FEnumParameterNameAndCurve");
static_assert(offsetof(FEnumParameterNameAndCurve, ParameterName) == 0x000000, "Member 'FEnumParameterNameAndCurve::ParameterName' has a wrong offset!");
static_assert(offsetof(FEnumParameterNameAndCurve, ParameterCurve) == 0x000008, "Member 'FEnumParameterNameAndCurve::ParameterCurve' has a wrong offset!");

// ScriptStruct ControlRig.IntegerParameterNameAndCurve
// 0x00E0 (0x00E0 - 0x0000)
struct FIntegerParameterNameAndCurve final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneIntegerChannel              ParameterCurve;                                    // 0x0008(0x00D8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntegerParameterNameAndCurve) == 0x000008, "Wrong alignment on FIntegerParameterNameAndCurve");
static_assert(sizeof(FIntegerParameterNameAndCurve) == 0x0000E0, "Wrong size on FIntegerParameterNameAndCurve");
static_assert(offsetof(FIntegerParameterNameAndCurve, ParameterName) == 0x000000, "Member 'FIntegerParameterNameAndCurve::ParameterName' has a wrong offset!");
static_assert(offsetof(FIntegerParameterNameAndCurve, ParameterCurve) == 0x000008, "Member 'FIntegerParameterNameAndCurve::ParameterCurve' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionReplaceItems
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_CollectionReplaceItems final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Old;                                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   New;                                               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveInvalidItems;                                // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDuplicates;                                  // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Collection;                                        // 0x0030(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedCollection;                                  // 0x0040(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedHierarchyHash;                               // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionReplaceItems) == 0x000008, "Wrong alignment on FRigUnit_CollectionReplaceItems");
static_assert(sizeof(FRigUnit_CollectionReplaceItems) == 0x000058, "Wrong size on FRigUnit_CollectionReplaceItems");
static_assert(offsetof(FRigUnit_CollectionReplaceItems, Items) == 0x000008, "Member 'FRigUnit_CollectionReplaceItems::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItems, Old) == 0x000018, "Member 'FRigUnit_CollectionReplaceItems::Old' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItems, New) == 0x000020, "Member 'FRigUnit_CollectionReplaceItems::New' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItems, RemoveInvalidItems) == 0x000028, "Member 'FRigUnit_CollectionReplaceItems::RemoveInvalidItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItems, bAllowDuplicates) == 0x000029, "Member 'FRigUnit_CollectionReplaceItems::bAllowDuplicates' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItems, Collection) == 0x000030, "Member 'FRigUnit_CollectionReplaceItems::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItems, CachedCollection) == 0x000040, "Member 'FRigUnit_CollectionReplaceItems::CachedCollection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItems, CachedHierarchyHash) == 0x000050, "Member 'FRigUnit_CollectionReplaceItems::CachedHierarchyHash' has a wrong offset!");

// ScriptStruct ControlRig.MovieSceneControlRigSpaceBaseKey
// 0x0010 (0x0010 - 0x0000)
struct FMovieSceneControlRigSpaceBaseKey final
{
public:
	EMovieSceneControlRigSpaceType                SpaceType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         ControlRigElement;                                 // 0x0004(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieSceneControlRigSpaceBaseKey) == 0x000004, "Wrong alignment on FMovieSceneControlRigSpaceBaseKey");
static_assert(sizeof(FMovieSceneControlRigSpaceBaseKey) == 0x000010, "Wrong size on FMovieSceneControlRigSpaceBaseKey");
static_assert(offsetof(FMovieSceneControlRigSpaceBaseKey, SpaceType) == 0x000000, "Member 'FMovieSceneControlRigSpaceBaseKey::SpaceType' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigSpaceBaseKey, ControlRigElement) == 0x000004, "Member 'FMovieSceneControlRigSpaceBaseKey::ControlRigElement' has a wrong offset!");

// ScriptStruct ControlRig.MovieSceneControlRigSpaceChannel
// 0x0098 (0x00E8 - 0x0050)
struct FMovieSceneControlRigSpaceChannel final : public FMovieSceneChannel
{
public:
	TArray<struct FFrameNumber>                   KeyTimes;                                          // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FMovieSceneControlRigSpaceBaseKey> KeyValues;                                         // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x78];                                      // 0x0070(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneControlRigSpaceChannel) == 0x000008, "Wrong alignment on FMovieSceneControlRigSpaceChannel");
static_assert(sizeof(FMovieSceneControlRigSpaceChannel) == 0x0000E8, "Wrong size on FMovieSceneControlRigSpaceChannel");
static_assert(offsetof(FMovieSceneControlRigSpaceChannel, KeyTimes) == 0x000050, "Member 'FMovieSceneControlRigSpaceChannel::KeyTimes' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigSpaceChannel, KeyValues) == 0x000060, "Member 'FMovieSceneControlRigSpaceChannel::KeyValues' has a wrong offset!");

// ScriptStruct ControlRig.SpaceControlNameAndChannel
// 0x00F0 (0x00F0 - 0x0000)
struct FSpaceControlNameAndChannel final
{
public:
	class FName                                   ControlName;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneControlRigSpaceChannel      SpaceCurve;                                        // 0x0008(0x00E8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpaceControlNameAndChannel) == 0x000008, "Wrong alignment on FSpaceControlNameAndChannel");
static_assert(sizeof(FSpaceControlNameAndChannel) == 0x0000F0, "Wrong size on FSpaceControlNameAndChannel");
static_assert(offsetof(FSpaceControlNameAndChannel, ControlName) == 0x000000, "Member 'FSpaceControlNameAndChannel::ControlName' has a wrong offset!");
static_assert(offsetof(FSpaceControlNameAndChannel, SpaceCurve) == 0x000008, "Member 'FSpaceControlNameAndChannel::SpaceCurve' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionChain
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_CollectionChain final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKey                         FirstItem;                                         // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         LastItem;                                          // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reverse;                                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Collection;                                        // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedCollection;                                  // 0x0038(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedHierarchyHash;                               // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionChain) == 0x000008, "Wrong alignment on FRigUnit_CollectionChain");
static_assert(sizeof(FRigUnit_CollectionChain) == 0x000050, "Wrong size on FRigUnit_CollectionChain");
static_assert(offsetof(FRigUnit_CollectionChain, FirstItem) == 0x000008, "Member 'FRigUnit_CollectionChain::FirstItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChain, LastItem) == 0x000014, "Member 'FRigUnit_CollectionChain::LastItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChain, Reverse) == 0x000020, "Member 'FRigUnit_CollectionChain::Reverse' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChain, Collection) == 0x000028, "Member 'FRigUnit_CollectionChain::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChain, CachedCollection) == 0x000038, "Member 'FRigUnit_CollectionChain::CachedCollection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChain, CachedHierarchyHash) == 0x000048, "Member 'FRigUnit_CollectionChain::CachedHierarchyHash' has a wrong offset!");

// ScriptStruct ControlRig.ChannelMapInfo
// 0x002C (0x002C - 0x0000)
struct FChannelMapInfo final
{
public:
	int32                                         ControlIndex;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalChannelIndex;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChannelIndex;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentControlIndex;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChannelTypeName;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesHaveSpace;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpaceChannelIndex;                                 // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaskIndex;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CategoryIndex;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChannelMapInfo) == 0x000004, "Wrong alignment on FChannelMapInfo");
static_assert(sizeof(FChannelMapInfo) == 0x00002C, "Wrong size on FChannelMapInfo");
static_assert(offsetof(FChannelMapInfo, ControlIndex) == 0x000000, "Member 'FChannelMapInfo::ControlIndex' has a wrong offset!");
static_assert(offsetof(FChannelMapInfo, TotalChannelIndex) == 0x000004, "Member 'FChannelMapInfo::TotalChannelIndex' has a wrong offset!");
static_assert(offsetof(FChannelMapInfo, ChannelIndex) == 0x000008, "Member 'FChannelMapInfo::ChannelIndex' has a wrong offset!");
static_assert(offsetof(FChannelMapInfo, ParentControlIndex) == 0x00000C, "Member 'FChannelMapInfo::ParentControlIndex' has a wrong offset!");
static_assert(offsetof(FChannelMapInfo, ChannelTypeName) == 0x000010, "Member 'FChannelMapInfo::ChannelTypeName' has a wrong offset!");
static_assert(offsetof(FChannelMapInfo, bDoesHaveSpace) == 0x000018, "Member 'FChannelMapInfo::bDoesHaveSpace' has a wrong offset!");
static_assert(offsetof(FChannelMapInfo, SpaceChannelIndex) == 0x00001C, "Member 'FChannelMapInfo::SpaceChannelIndex' has a wrong offset!");
static_assert(offsetof(FChannelMapInfo, MaskIndex) == 0x000020, "Member 'FChannelMapInfo::MaskIndex' has a wrong offset!");
static_assert(offsetof(FChannelMapInfo, CategoryIndex) == 0x000024, "Member 'FChannelMapInfo::CategoryIndex' has a wrong offset!");

// ScriptStruct ControlRig.MovieSceneControlRigParameterTemplate
// 0x0030 (0x00B0 - 0x0080)
struct FMovieSceneControlRigParameterTemplate final : public FMovieSceneParameterSectionTemplate
{
public:
	TArray<struct FEnumParameterNameAndCurve>     Enums;                                             // 0x0080(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FIntegerParameterNameAndCurve>  Integers;                                          // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSpaceControlNameAndChannel>    Spaces;                                            // 0x00A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMovieSceneControlRigParameterTemplate) == 0x000008, "Wrong alignment on FMovieSceneControlRigParameterTemplate");
static_assert(sizeof(FMovieSceneControlRigParameterTemplate) == 0x0000B0, "Wrong size on FMovieSceneControlRigParameterTemplate");
static_assert(offsetof(FMovieSceneControlRigParameterTemplate, Enums) == 0x000080, "Member 'FMovieSceneControlRigParameterTemplate::Enums' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigParameterTemplate, Integers) == 0x000090, "Member 'FMovieSceneControlRigParameterTemplate::Integers' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigParameterTemplate, Spaces) == 0x0000A0, "Member 'FMovieSceneControlRigParameterTemplate::Spaces' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionNameSearch
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_CollectionNameSearch final : public FRigUnit_CollectionBase
{
public:
	class FName                                   PartialName;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               TypeToSearch;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Collection;                                        // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedCollection;                                  // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedHierarchyHash;                               // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionNameSearch) == 0x000008, "Wrong alignment on FRigUnit_CollectionNameSearch");
static_assert(sizeof(FRigUnit_CollectionNameSearch) == 0x000040, "Wrong size on FRigUnit_CollectionNameSearch");
static_assert(offsetof(FRigUnit_CollectionNameSearch, PartialName) == 0x000008, "Member 'FRigUnit_CollectionNameSearch::PartialName' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionNameSearch, TypeToSearch) == 0x000010, "Member 'FRigUnit_CollectionNameSearch::TypeToSearch' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionNameSearch, Collection) == 0x000018, "Member 'FRigUnit_CollectionNameSearch::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionNameSearch, CachedCollection) == 0x000028, "Member 'FRigUnit_CollectionNameSearch::CachedCollection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionNameSearch, CachedHierarchyHash) == 0x000038, "Member 'FRigUnit_CollectionNameSearch::CachedHierarchyHash' has a wrong offset!");

// ScriptStruct ControlRig.MathRBFInterpolateVectorFloat_Target
// 0x0020 (0x0020 - 0x0000)
struct FMathRBFInterpolateVectorFloat_Target final
{
public:
	struct FVector                                Target;                                            // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMathRBFInterpolateVectorFloat_Target) == 0x000008, "Wrong alignment on FMathRBFInterpolateVectorFloat_Target");
static_assert(sizeof(FMathRBFInterpolateVectorFloat_Target) == 0x000020, "Wrong size on FMathRBFInterpolateVectorFloat_Target");
static_assert(offsetof(FMathRBFInterpolateVectorFloat_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateVectorFloat_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateVectorFloat_Target, Value) == 0x000018, "Member 'FMathRBFInterpolateVectorFloat_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigEventContext
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FRigEventContext final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigEventContext) == 0x000008, "Wrong alignment on FRigEventContext");
static_assert(sizeof(FRigEventContext) == 0x000028, "Wrong size on FRigEventContext");

// ScriptStruct ControlRig.RigUnit_HighlevelBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_HighlevelBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_HighlevelBase) == 0x000008, "Wrong alignment on FRigUnit_HighlevelBase");
static_assert(sizeof(FRigUnit_HighlevelBase) == 0x000008, "Wrong size on FRigUnit_HighlevelBase");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKSimpleTransforms
// 0x0198 (0x01A0 - 0x0008)
struct FRigUnit_TwoBoneIKSimpleTransforms final : public FRigUnit_HighlevelBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Root;                                              // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PoleVector;                                        // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Effector;                                          // 0x0090(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryAxisWeight;                               // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStretch;                                    // 0x0124(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StretchStartRatio;                                 // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StretchMaximumRatio;                               // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneALength;                                       // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneBLength;                                       // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Elbow;                                             // 0x0140(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwoBoneIKSimpleTransforms) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKSimpleTransforms");
static_assert(sizeof(FRigUnit_TwoBoneIKSimpleTransforms) == 0x0001A0, "Wrong size on FRigUnit_TwoBoneIKSimpleTransforms");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, Root) == 0x000010, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::Root' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, PoleVector) == 0x000070, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::PoleVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, Effector) == 0x000090, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::Effector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, PrimaryAxis) == 0x0000F0, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, SecondaryAxis) == 0x000108, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, SecondaryAxisWeight) == 0x000120, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::SecondaryAxisWeight' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, bEnableStretch) == 0x000124, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::bEnableStretch' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, StretchStartRatio) == 0x000128, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::StretchStartRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, StretchMaximumRatio) == 0x00012C, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::StretchMaximumRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, BoneALength) == 0x000130, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::BoneALength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, BoneBLength) == 0x000134, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::BoneBLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleTransforms, Elbow) == 0x000140, "Member 'FRigUnit_TwoBoneIKSimpleTransforms::Elbow' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionUnion
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_CollectionUnion final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               A;                                                 // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               B;                                                 // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDuplicates;                                  // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Collection;                                        // 0x0030(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionUnion) == 0x000008, "Wrong alignment on FRigUnit_CollectionUnion");
static_assert(sizeof(FRigUnit_CollectionUnion) == 0x000040, "Wrong size on FRigUnit_CollectionUnion");
static_assert(offsetof(FRigUnit_CollectionUnion, A) == 0x000008, "Member 'FRigUnit_CollectionUnion::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionUnion, B) == 0x000018, "Member 'FRigUnit_CollectionUnion::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionUnion, bAllowDuplicates) == 0x000028, "Member 'FRigUnit_CollectionUnion::bAllowDuplicates' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionUnion, Collection) == 0x000030, "Member 'FRigUnit_CollectionUnion::Collection' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorLerp
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_MathVectorLerp final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorLerp) == 0x000008, "Wrong alignment on FRigUnit_MathVectorLerp");
static_assert(sizeof(FRigUnit_MathVectorLerp) == 0x000058, "Wrong size on FRigUnit_MathVectorLerp");
static_assert(offsetof(FRigUnit_MathVectorLerp, A) == 0x000008, "Member 'FRigUnit_MathVectorLerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLerp, B) == 0x000020, "Member 'FRigUnit_MathVectorLerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLerp, T) == 0x000038, "Member 'FRigUnit_MathVectorLerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLerp, Result) == 0x000040, "Member 'FRigUnit_MathVectorLerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Control_StaticMesh
// 0x0060 (0x01E0 - 0x0180)
struct FRigUnit_Control_StaticMesh final : public FRigUnit_Control
{
public:
	struct FTransform                             MeshTransform;                                     // 0x0180(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_Control_StaticMesh) == 0x000010, "Wrong alignment on FRigUnit_Control_StaticMesh");
static_assert(sizeof(FRigUnit_Control_StaticMesh) == 0x0001E0, "Wrong size on FRigUnit_Control_StaticMesh");
static_assert(offsetof(FRigUnit_Control_StaticMesh, MeshTransform) == 0x000180, "Member 'FRigUnit_Control_StaticMesh::MeshTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionCount
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_CollectionCount final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               Collection;                                        // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionCount) == 0x000008, "Wrong alignment on FRigUnit_CollectionCount");
static_assert(sizeof(FRigUnit_CollectionCount) == 0x000020, "Wrong size on FRigUnit_CollectionCount");
static_assert(offsetof(FRigUnit_CollectionCount, Collection) == 0x000008, "Member 'FRigUnit_CollectionCount::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionCount, Count) == 0x000018, "Member 'FRigUnit_CollectionCount::Count' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorUnaryOp
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_MathVectorUnaryOp : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorUnaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathVectorUnaryOp");
static_assert(sizeof(FRigUnit_MathVectorUnaryOp) == 0x000038, "Wrong size on FRigUnit_MathVectorUnaryOp");
static_assert(offsetof(FRigUnit_MathVectorUnaryOp, Value) == 0x000008, "Member 'FRigUnit_MathVectorUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorUnaryOp, Result) == 0x000020, "Member 'FRigUnit_MathVectorUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorRad
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorRad final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorRad) == 0x000008, "Wrong alignment on FRigUnit_MathVectorRad");
static_assert(sizeof(FRigUnit_MathVectorRad) == 0x000038, "Wrong size on FRigUnit_MathVectorRad");

// ScriptStruct ControlRig.RigUnit_MathTransformInverse
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_MathTransformInverse final : public FRigUnit_MathTransformUnaryOp
{
};
static_assert(alignof(FRigUnit_MathTransformInverse) == 0x000010, "Wrong alignment on FRigUnit_MathTransformInverse");
static_assert(sizeof(FRigUnit_MathTransformInverse) == 0x0000D0, "Wrong size on FRigUnit_MathTransformInverse");

// ScriptStruct ControlRig.RigUnit_MathVectorBinaryOp
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathVectorBinaryOp : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorBinaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathVectorBinaryOp");
static_assert(sizeof(FRigUnit_MathVectorBinaryOp) == 0x000050, "Wrong size on FRigUnit_MathVectorBinaryOp");
static_assert(offsetof(FRigUnit_MathVectorBinaryOp, A) == 0x000008, "Member 'FRigUnit_MathVectorBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBinaryOp, B) == 0x000020, "Member 'FRigUnit_MathVectorBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBinaryOp, Result) == 0x000038, "Member 'FRigUnit_MathVectorBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorCross
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathVectorCross final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorCross) == 0x000008, "Wrong alignment on FRigUnit_MathVectorCross");
static_assert(sizeof(FRigUnit_MathVectorCross) == 0x000050, "Wrong size on FRigUnit_MathVectorCross");

// ScriptStruct ControlRig.MathRBFInterpolateVectorXform_Target
// 0x0080 (0x0080 - 0x0000)
struct FMathRBFInterpolateVectorXform_Target final
{
public:
	struct FVector                                Target;                                            // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathRBFInterpolateVectorXform_Target) == 0x000010, "Wrong alignment on FMathRBFInterpolateVectorXform_Target");
static_assert(sizeof(FMathRBFInterpolateVectorXform_Target) == 0x000080, "Wrong size on FMathRBFInterpolateVectorXform_Target");
static_assert(offsetof(FMathRBFInterpolateVectorXform_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateVectorXform_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateVectorXform_Target, Value) == 0x000020, "Member 'FMathRBFInterpolateVectorXform_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigElementWeight
// 0x000C (0x000C - 0x0000)
struct FRigElementWeight final
{
public:
	float                                         Location;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigElementWeight) == 0x000004, "Wrong alignment on FRigElementWeight");
static_assert(sizeof(FRigElementWeight) == 0x00000C, "Wrong size on FRigElementWeight");
static_assert(offsetof(FRigElementWeight, Location) == 0x000000, "Member 'FRigElementWeight::Location' has a wrong offset!");
static_assert(offsetof(FRigElementWeight, Rotation) == 0x000004, "Member 'FRigElementWeight::Rotation' has a wrong offset!");
static_assert(offsetof(FRigElementWeight, Scale) == 0x000008, "Member 'FRigElementWeight::Scale' has a wrong offset!");

// ScriptStruct ControlRig.RigElementParentConstraint
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FRigElementParentConstraint final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigElementParentConstraint) == 0x000010, "Wrong alignment on FRigElementParentConstraint");
static_assert(sizeof(FRigElementParentConstraint) == 0x000090, "Wrong size on FRigElementParentConstraint");

// ScriptStruct ControlRig.RigMultiParentElement
// 0x02C0 (0x0510 - 0x0250)
struct FRigMultiParentElement : public FRigTransformElement
{
public:
	struct FRigCurrentAndInitialTransform         Parent;                                            // 0x0250(0x01C0)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x100];                                    // 0x0410(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigMultiParentElement) == 0x000010, "Wrong alignment on FRigMultiParentElement");
static_assert(sizeof(FRigMultiParentElement) == 0x000510, "Wrong size on FRigMultiParentElement");
static_assert(offsetof(FRigMultiParentElement, Parent) == 0x000250, "Member 'FRigMultiParentElement::Parent' has a wrong offset!");

// ScriptStruct ControlRig.MathRBFInterpolateQuatXform_Target
// 0x0080 (0x0080 - 0x0000)
struct FMathRBFInterpolateQuatXform_Target final
{
public:
	struct FQuat                                  Target;                                            // 0x0000(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Value;                                             // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathRBFInterpolateQuatXform_Target) == 0x000010, "Wrong alignment on FMathRBFInterpolateQuatXform_Target");
static_assert(sizeof(FMathRBFInterpolateQuatXform_Target) == 0x000080, "Wrong size on FMathRBFInterpolateQuatXform_Target");
static_assert(offsetof(FMathRBFInterpolateQuatXform_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateQuatXform_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateQuatXform_Target, Value) == 0x000020, "Member 'FMathRBFInterpolateQuatXform_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigBoneElement
// 0x0000 (0x0260 - 0x0260)
struct FRigBoneElement final : public FRigSingleParentElement
{
public:
	ERigBoneType                                  BoneType;                                          // 0x0258(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigBoneElement) == 0x000010, "Wrong alignment on FRigBoneElement");
static_assert(sizeof(FRigBoneElement) == 0x000260, "Wrong size on FRigBoneElement");
static_assert(offsetof(FRigBoneElement, BoneType) == 0x000258, "Member 'FRigBoneElement::BoneType' has a wrong offset!");

// ScriptStruct ControlRig.RigNullElement
// 0x0000 (0x0510 - 0x0510)
struct FRigNullElement final : public FRigMultiParentElement
{
};
static_assert(alignof(FRigNullElement) == 0x000010, "Wrong alignment on FRigNullElement");
static_assert(sizeof(FRigNullElement) == 0x000510, "Wrong size on FRigNullElement");

// ScriptStruct ControlRig.RigControlElementCustomization
// 0x0020 (0x0020 - 0x0000)
struct FRigControlElementCustomization final
{
public:
	TArray<struct FRigElementKey>                 AvailableSpaces;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRigElementKey>                 RemovedSpaces;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigControlElementCustomization) == 0x000008, "Wrong alignment on FRigControlElementCustomization");
static_assert(sizeof(FRigControlElementCustomization) == 0x000020, "Wrong size on FRigControlElementCustomization");
static_assert(offsetof(FRigControlElementCustomization, AvailableSpaces) == 0x000000, "Member 'FRigControlElementCustomization::AvailableSpaces' has a wrong offset!");
static_assert(offsetof(FRigControlElementCustomization, RemovedSpaces) == 0x000010, "Member 'FRigControlElementCustomization::RemovedSpaces' has a wrong offset!");

// ScriptStruct ControlRig.RigControlSettings
// 0x0260 (0x0260 - 0x0000)
struct FRigControlSettings final
{
public:
	ERigControlType                               ControlType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisplayName;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigControlAxis                               PrimaryAxis;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurve;                                          // 0x000D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimatable;                                       // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigControlLimitEnabled>        LimitEnabled;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDrawLimits;                                       // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigControlValue                       MinimumValue;                                      // 0x0030(0x00F0)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigControlValue                       MaximumValue;                                      // 0x0120(0x00F0)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShapeEnabled;                                     // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShapeVisible;                                     // 0x0211(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_212[0x2];                                      // 0x0212(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ShapeName;                                         // 0x0214(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShapeColor;                                        // 0x021C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTransientControl;                               // 0x022C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  ControlEnum;                                       // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigControlElementCustomization        Customization;                                     // 0x0238(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigControlSettings) == 0x000010, "Wrong alignment on FRigControlSettings");
static_assert(sizeof(FRigControlSettings) == 0x000260, "Wrong size on FRigControlSettings");
static_assert(offsetof(FRigControlSettings, ControlType) == 0x000000, "Member 'FRigControlSettings::ControlType' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, DisplayName) == 0x000004, "Member 'FRigControlSettings::DisplayName' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, PrimaryAxis) == 0x00000C, "Member 'FRigControlSettings::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, bIsCurve) == 0x00000D, "Member 'FRigControlSettings::bIsCurve' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, bAnimatable) == 0x00000E, "Member 'FRigControlSettings::bAnimatable' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, LimitEnabled) == 0x000010, "Member 'FRigControlSettings::LimitEnabled' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, bDrawLimits) == 0x000020, "Member 'FRigControlSettings::bDrawLimits' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, MinimumValue) == 0x000030, "Member 'FRigControlSettings::MinimumValue' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, MaximumValue) == 0x000120, "Member 'FRigControlSettings::MaximumValue' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, bShapeEnabled) == 0x000210, "Member 'FRigControlSettings::bShapeEnabled' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, bShapeVisible) == 0x000211, "Member 'FRigControlSettings::bShapeVisible' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, ShapeName) == 0x000214, "Member 'FRigControlSettings::ShapeName' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, ShapeColor) == 0x00021C, "Member 'FRigControlSettings::ShapeColor' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, bIsTransientControl) == 0x00022C, "Member 'FRigControlSettings::bIsTransientControl' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, ControlEnum) == 0x000230, "Member 'FRigControlSettings::ControlEnum' has a wrong offset!");
static_assert(offsetof(FRigControlSettings, Customization) == 0x000238, "Member 'FRigControlSettings::Customization' has a wrong offset!");

// ScriptStruct ControlRig.MathRBFInterpolateVectorVector_Target
// 0x0030 (0x0030 - 0x0000)
struct FMathRBFInterpolateVectorVector_Target final
{
public:
	struct FVector                                Target;                                            // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathRBFInterpolateVectorVector_Target) == 0x000008, "Wrong alignment on FMathRBFInterpolateVectorVector_Target");
static_assert(sizeof(FMathRBFInterpolateVectorVector_Target) == 0x000030, "Wrong size on FMathRBFInterpolateVectorVector_Target");
static_assert(offsetof(FMathRBFInterpolateVectorVector_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateVectorVector_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateVectorVector_Target, Value) == 0x000018, "Member 'FMathRBFInterpolateVectorVector_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigControlElement
// 0x05E0 (0x0AF0 - 0x0510)
struct FRigControlElement final : public FRigMultiParentElement
{
public:
	struct FRigControlSettings                    Settings;                                          // 0x0510(0x0260)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRigCurrentAndInitialTransform         Offset;                                            // 0x0770(0x01C0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigCurrentAndInitialTransform         Shape;                                             // 0x0930(0x01C0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigControlElement) == 0x000010, "Wrong alignment on FRigControlElement");
static_assert(sizeof(FRigControlElement) == 0x000AF0, "Wrong size on FRigControlElement");
static_assert(offsetof(FRigControlElement, Settings) == 0x000510, "Member 'FRigControlElement::Settings' has a wrong offset!");
static_assert(offsetof(FRigControlElement, Offset) == 0x000770, "Member 'FRigControlElement::Offset' has a wrong offset!");
static_assert(offsetof(FRigControlElement, Shape) == 0x000930, "Member 'FRigControlElement::Shape' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformBinaryOp
// 0x0128 (0x0130 - 0x0008)
struct FRigUnit_MathTransformBinaryOp : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             A;                                                 // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformBinaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathTransformBinaryOp");
static_assert(sizeof(FRigUnit_MathTransformBinaryOp) == 0x000130, "Wrong size on FRigUnit_MathTransformBinaryOp");
static_assert(offsetof(FRigUnit_MathTransformBinaryOp, A) == 0x000010, "Member 'FRigUnit_MathTransformBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformBinaryOp, B) == 0x000070, "Member 'FRigUnit_MathTransformBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformBinaryOp, Result) == 0x0000D0, "Member 'FRigUnit_MathTransformBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformMul
// 0x0000 (0x0130 - 0x0130)
struct FRigUnit_MathTransformMul final : public FRigUnit_MathTransformBinaryOp
{
};
static_assert(alignof(FRigUnit_MathTransformMul) == 0x000010, "Wrong alignment on FRigUnit_MathTransformMul");
static_assert(sizeof(FRigUnit_MathTransformMul) == 0x000130, "Wrong size on FRigUnit_MathTransformMul");

// ScriptStruct ControlRig.RigCurveElement
// 0x0008 (0x0058 - 0x0050)
struct FRigCurveElement final : public FRigBaseElement
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigCurveElement) == 0x000008, "Wrong alignment on FRigCurveElement");
static_assert(sizeof(FRigCurveElement) == 0x000058, "Wrong size on FRigCurveElement");

// ScriptStruct ControlRig.RigRigidBodySettings
// 0x0004 (0x0004 - 0x0000)
struct FRigRigidBodySettings final
{
public:
	float                                         Mass;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigRigidBodySettings) == 0x000004, "Wrong alignment on FRigRigidBodySettings");
static_assert(sizeof(FRigRigidBodySettings) == 0x000004, "Wrong size on FRigRigidBodySettings");
static_assert(offsetof(FRigRigidBodySettings, Mass) == 0x000000, "Member 'FRigRigidBodySettings::Mass' has a wrong offset!");

// ScriptStruct ControlRig.RigRigidBodyElement
// 0x0000 (0x0260 - 0x0260)
struct FRigRigidBodyElement final : public FRigSingleParentElement
{
public:
	struct FRigRigidBodySettings                  Settings;                                          // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigRigidBodyElement) == 0x000010, "Wrong alignment on FRigRigidBodyElement");
static_assert(sizeof(FRigRigidBodyElement) == 0x000260, "Wrong size on FRigRigidBodyElement");
static_assert(offsetof(FRigRigidBodyElement, Settings) == 0x000258, "Member 'FRigRigidBodyElement::Settings' has a wrong offset!");

// ScriptStruct ControlRig.MathRBFInterpolateVectorQuat_Target
// 0x0040 (0x0040 - 0x0000)
struct FMathRBFInterpolateVectorQuat_Target final
{
public:
	struct FVector                                Target;                                            // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0020(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathRBFInterpolateVectorQuat_Target) == 0x000010, "Wrong alignment on FMathRBFInterpolateVectorQuat_Target");
static_assert(sizeof(FMathRBFInterpolateVectorQuat_Target) == 0x000040, "Wrong size on FMathRBFInterpolateVectorQuat_Target");
static_assert(offsetof(FMathRBFInterpolateVectorQuat_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateVectorQuat_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateVectorQuat_Target, Value) == 0x000020, "Member 'FMathRBFInterpolateVectorQuat_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchyCopyPasteContentPerElement
// 0x0200 (0x0200 - 0x0000)
struct FRigHierarchyCopyPasteContentPerElement final
{
public:
	struct FRigElementKey                         Key;                                               // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Content;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigElementKey>                 Parents;                                           // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRigElementWeight>              ParentWeights;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigCurrentAndInitialTransform         Pose;                                              // 0x0040(0x01C0)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigHierarchyCopyPasteContentPerElement) == 0x000010, "Wrong alignment on FRigHierarchyCopyPasteContentPerElement");
static_assert(sizeof(FRigHierarchyCopyPasteContentPerElement) == 0x000200, "Wrong size on FRigHierarchyCopyPasteContentPerElement");
static_assert(offsetof(FRigHierarchyCopyPasteContentPerElement, Key) == 0x000000, "Member 'FRigHierarchyCopyPasteContentPerElement::Key' has a wrong offset!");
static_assert(offsetof(FRigHierarchyCopyPasteContentPerElement, Content) == 0x000010, "Member 'FRigHierarchyCopyPasteContentPerElement::Content' has a wrong offset!");
static_assert(offsetof(FRigHierarchyCopyPasteContentPerElement, Parents) == 0x000020, "Member 'FRigHierarchyCopyPasteContentPerElement::Parents' has a wrong offset!");
static_assert(offsetof(FRigHierarchyCopyPasteContentPerElement, ParentWeights) == 0x000030, "Member 'FRigHierarchyCopyPasteContentPerElement::ParentWeights' has a wrong offset!");
static_assert(offsetof(FRigHierarchyCopyPasteContentPerElement, Pose) == 0x000040, "Member 'FRigHierarchyCopyPasteContentPerElement::Pose' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchyCopyPasteContent
// 0x0050 (0x0050 - 0x0000)
struct FRigHierarchyCopyPasteContent final
{
public:
	TArray<struct FRigHierarchyCopyPasteContentPerElement> Elements;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ERigElementType>                       Types;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Contents;                                          // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     LocalTransforms;                                   // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     GlobalTransforms;                                  // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigHierarchyCopyPasteContent) == 0x000008, "Wrong alignment on FRigHierarchyCopyPasteContent");
static_assert(sizeof(FRigHierarchyCopyPasteContent) == 0x000050, "Wrong size on FRigHierarchyCopyPasteContent");
static_assert(offsetof(FRigHierarchyCopyPasteContent, Elements) == 0x000000, "Member 'FRigHierarchyCopyPasteContent::Elements' has a wrong offset!");
static_assert(offsetof(FRigHierarchyCopyPasteContent, Types) == 0x000010, "Member 'FRigHierarchyCopyPasteContent::Types' has a wrong offset!");
static_assert(offsetof(FRigHierarchyCopyPasteContent, Contents) == 0x000020, "Member 'FRigHierarchyCopyPasteContent::Contents' has a wrong offset!");
static_assert(offsetof(FRigHierarchyCopyPasteContent, LocalTransforms) == 0x000030, "Member 'FRigHierarchyCopyPasteContent::LocalTransforms' has a wrong offset!");
static_assert(offsetof(FRigHierarchyCopyPasteContent, GlobalTransforms) == 0x000040, "Member 'FRigHierarchyCopyPasteContent::GlobalTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformTransformVector
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_MathTransformTransformVector final : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformTransformVector) == 0x000010, "Wrong alignment on FRigUnit_MathTransformTransformVector");
static_assert(sizeof(FRigUnit_MathTransformTransformVector) == 0x0000A0, "Wrong size on FRigUnit_MathTransformTransformVector");
static_assert(offsetof(FRigUnit_MathTransformTransformVector, Transform) == 0x000010, "Member 'FRigUnit_MathTransformTransformVector::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformTransformVector, Location) == 0x000070, "Member 'FRigUnit_MathTransformTransformVector::Location' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformTransformVector, Result) == 0x000088, "Member 'FRigUnit_MathTransformTransformVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigInfluenceEntry
// 0x0020 (0x0020 - 0x0000)
struct FRigInfluenceEntry final
{
public:
	struct FRigElementKey                         Source;                                            // 0x0000(0x000C)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 AffectedList;                                      // 0x0010(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FRigInfluenceEntry) == 0x000008, "Wrong alignment on FRigInfluenceEntry");
static_assert(sizeof(FRigInfluenceEntry) == 0x000020, "Wrong size on FRigInfluenceEntry");
static_assert(offsetof(FRigInfluenceEntry, Source) == 0x000000, "Member 'FRigInfluenceEntry::Source' has a wrong offset!");
static_assert(offsetof(FRigInfluenceEntry, AffectedList) == 0x000010, "Member 'FRigInfluenceEntry::AffectedList' has a wrong offset!");

// ScriptStruct ControlRig.RigInfluenceEntryModifier
// 0x0010 (0x0010 - 0x0000)
struct FRigInfluenceEntryModifier final
{
public:
	TArray<struct FRigElementKey>                 AffectedList;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigInfluenceEntryModifier) == 0x000008, "Wrong alignment on FRigInfluenceEntryModifier");
static_assert(sizeof(FRigInfluenceEntryModifier) == 0x000010, "Wrong size on FRigInfluenceEntryModifier");
static_assert(offsetof(FRigInfluenceEntryModifier, AffectedList) == 0x000000, "Member 'FRigInfluenceEntryModifier::AffectedList' has a wrong offset!");

// ScriptStruct ControlRig.RigInfluenceMap
// 0x0068 (0x0068 - 0x0000)
struct FRigInfluenceMap final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRigInfluenceEntry>             Entries;                                           // 0x0008(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FRigElementKey, int32>            KeyToIndex;                                        // 0x0018(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FRigInfluenceMap) == 0x000008, "Wrong alignment on FRigInfluenceMap");
static_assert(sizeof(FRigInfluenceMap) == 0x000068, "Wrong size on FRigInfluenceMap");
static_assert(offsetof(FRigInfluenceMap, EventName) == 0x000000, "Member 'FRigInfluenceMap::EventName' has a wrong offset!");
static_assert(offsetof(FRigInfluenceMap, Entries) == 0x000008, "Member 'FRigInfluenceMap::Entries' has a wrong offset!");
static_assert(offsetof(FRigInfluenceMap, KeyToIndex) == 0x000018, "Member 'FRigInfluenceMap::KeyToIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathIntBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathIntBase) == 0x000008, "Wrong alignment on FRigUnit_MathIntBase");
static_assert(sizeof(FRigUnit_MathIntBase) == 0x000008, "Wrong size on FRigUnit_MathIntBase");

// ScriptStruct ControlRig.RigUnit_MathIntLess
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathIntLess final : public FRigUnit_MathIntBase
{
public:
	int32                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathIntLess) == 0x000008, "Wrong alignment on FRigUnit_MathIntLess");
static_assert(sizeof(FRigUnit_MathIntLess) == 0x000018, "Wrong size on FRigUnit_MathIntLess");
static_assert(offsetof(FRigUnit_MathIntLess, A) == 0x000008, "Member 'FRigUnit_MathIntLess::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntLess, B) == 0x00000C, "Member 'FRigUnit_MathIntLess::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntLess, Result) == 0x000010, "Member 'FRigUnit_MathIntLess::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigInfluenceMapPerEvent
// 0x0060 (0x0060 - 0x0000)
struct FRigInfluenceMapPerEvent final
{
public:
	TArray<struct FRigInfluenceMap>               Maps;                                              // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      EventToIndex;                                      // 0x0010(0x0050)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FRigInfluenceMapPerEvent) == 0x000008, "Wrong alignment on FRigInfluenceMapPerEvent");
static_assert(sizeof(FRigInfluenceMapPerEvent) == 0x000060, "Wrong size on FRigInfluenceMapPerEvent");
static_assert(offsetof(FRigInfluenceMapPerEvent, Maps) == 0x000000, "Member 'FRigInfluenceMapPerEvent::Maps' has a wrong offset!");
static_assert(offsetof(FRigInfluenceMapPerEvent, EventToIndex) == 0x000010, "Member 'FRigInfluenceMapPerEvent::EventToIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathMatrixBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathMatrixBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathMatrixBase) == 0x000008, "Wrong alignment on FRigUnit_MathMatrixBase");
static_assert(sizeof(FRigUnit_MathMatrixBase) == 0x000008, "Wrong size on FRigUnit_MathMatrixBase");

// ScriptStruct ControlRig.RigUnit_MathMatrixUnaryOp
// 0x0108 (0x0110 - 0x0008)
struct FRigUnit_MathMatrixUnaryOp : public FRigUnit_MathMatrixBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                Value;                                             // 0x0010(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMatrix                                Result;                                            // 0x0090(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathMatrixUnaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathMatrixUnaryOp");
static_assert(sizeof(FRigUnit_MathMatrixUnaryOp) == 0x000110, "Wrong size on FRigUnit_MathMatrixUnaryOp");
static_assert(offsetof(FRigUnit_MathMatrixUnaryOp, Value) == 0x000010, "Member 'FRigUnit_MathMatrixUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixUnaryOp, Result) == 0x000090, "Member 'FRigUnit_MathMatrixUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorSub
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathVectorSub final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorSub) == 0x000008, "Wrong alignment on FRigUnit_MathVectorSub");
static_assert(sizeof(FRigUnit_MathVectorSub) == 0x000050, "Wrong size on FRigUnit_MathVectorSub");

// ScriptStruct ControlRig.RigUnit_AccumulateFloatAdd
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_AccumulateFloatAdd final : public FRigUnit_AccumulateBase
{
public:
	float                                         Increment;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialValue;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedValue;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateFloatAdd) == 0x000008, "Wrong alignment on FRigUnit_AccumulateFloatAdd");
static_assert(sizeof(FRigUnit_AccumulateFloatAdd) == 0x000020, "Wrong size on FRigUnit_AccumulateFloatAdd");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, Increment) == 0x000008, "Member 'FRigUnit_AccumulateFloatAdd::Increment' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, InitialValue) == 0x00000C, "Member 'FRigUnit_AccumulateFloatAdd::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, bIntegrateDeltaTime) == 0x000010, "Member 'FRigUnit_AccumulateFloatAdd::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, Result) == 0x000014, "Member 'FRigUnit_AccumulateFloatAdd::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, AccumulatedValue) == 0x000018, "Member 'FRigUnit_AccumulateFloatAdd::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateVectorAdd
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_AccumulateVectorAdd final : public FRigUnit_AccumulateBase
{
public:
	struct FVector                                Increment;                                         // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialValue;                                      // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedValue;                                  // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateVectorAdd) == 0x000008, "Wrong alignment on FRigUnit_AccumulateVectorAdd");
static_assert(sizeof(FRigUnit_AccumulateVectorAdd) == 0x000070, "Wrong size on FRigUnit_AccumulateVectorAdd");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, Increment) == 0x000008, "Member 'FRigUnit_AccumulateVectorAdd::Increment' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, InitialValue) == 0x000020, "Member 'FRigUnit_AccumulateVectorAdd::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, bIntegrateDeltaTime) == 0x000038, "Member 'FRigUnit_AccumulateVectorAdd::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, Result) == 0x000040, "Member 'FRigUnit_AccumulateVectorAdd::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, AccumulatedValue) == 0x000058, "Member 'FRigUnit_AccumulateVectorAdd::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathMatrixToVectors
// 0x00E8 (0x00F0 - 0x0008)
struct FRigUnit_MathMatrixToVectors final : public FRigUnit_MathMatrixBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                Value;                                             // 0x0010(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0090(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x00A8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x00C0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Z;                                                 // 0x00D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathMatrixToVectors) == 0x000010, "Wrong alignment on FRigUnit_MathMatrixToVectors");
static_assert(sizeof(FRigUnit_MathMatrixToVectors) == 0x0000F0, "Wrong size on FRigUnit_MathMatrixToVectors");
static_assert(offsetof(FRigUnit_MathMatrixToVectors, Value) == 0x000010, "Member 'FRigUnit_MathMatrixToVectors::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixToVectors, Origin) == 0x000090, "Member 'FRigUnit_MathMatrixToVectors::Origin' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixToVectors, X) == 0x0000A8, "Member 'FRigUnit_MathMatrixToVectors::X' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixToVectors, Y) == 0x0000C0, "Member 'FRigUnit_MathMatrixToVectors::Y' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixToVectors, Z) == 0x0000D8, "Member 'FRigUnit_MathMatrixToVectors::Z' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateFloatMul
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_AccumulateFloatMul final : public FRigUnit_AccumulateBase
{
public:
	float                                         Multiplier;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialValue;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedValue;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateFloatMul) == 0x000008, "Wrong alignment on FRigUnit_AccumulateFloatMul");
static_assert(sizeof(FRigUnit_AccumulateFloatMul) == 0x000020, "Wrong size on FRigUnit_AccumulateFloatMul");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, Multiplier) == 0x000008, "Member 'FRigUnit_AccumulateFloatMul::Multiplier' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, InitialValue) == 0x00000C, "Member 'FRigUnit_AccumulateFloatMul::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, bIntegrateDeltaTime) == 0x000010, "Member 'FRigUnit_AccumulateFloatMul::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, Result) == 0x000014, "Member 'FRigUnit_AccumulateFloatMul::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, AccumulatedValue) == 0x000018, "Member 'FRigUnit_AccumulateFloatMul::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorSelectBool
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_MathVectorSelectBool final : public FRigUnit_MathVectorBase
{
public:
	bool                                          Condition;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IfTrue;                                            // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IfFalse;                                           // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorSelectBool) == 0x000008, "Wrong alignment on FRigUnit_MathVectorSelectBool");
static_assert(sizeof(FRigUnit_MathVectorSelectBool) == 0x000058, "Wrong size on FRigUnit_MathVectorSelectBool");
static_assert(offsetof(FRigUnit_MathVectorSelectBool, Condition) == 0x000008, "Member 'FRigUnit_MathVectorSelectBool::Condition' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorSelectBool, IfTrue) == 0x000010, "Member 'FRigUnit_MathVectorSelectBool::IfTrue' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorSelectBool, IfFalse) == 0x000028, "Member 'FRigUnit_MathVectorSelectBool::IfFalse' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorSelectBool, Result) == 0x000040, "Member 'FRigUnit_MathVectorSelectBool::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateVectorMul
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_AccumulateVectorMul final : public FRigUnit_AccumulateBase
{
public:
	struct FVector                                Multiplier;                                        // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialValue;                                      // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedValue;                                  // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateVectorMul) == 0x000008, "Wrong alignment on FRigUnit_AccumulateVectorMul");
static_assert(sizeof(FRigUnit_AccumulateVectorMul) == 0x000070, "Wrong size on FRigUnit_AccumulateVectorMul");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, Multiplier) == 0x000008, "Member 'FRigUnit_AccumulateVectorMul::Multiplier' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, InitialValue) == 0x000020, "Member 'FRigUnit_AccumulateVectorMul::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, bIntegrateDeltaTime) == 0x000038, "Member 'FRigUnit_AccumulateVectorMul::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, Result) == 0x000040, "Member 'FRigUnit_AccumulateVectorMul::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, AccumulatedValue) == 0x000058, "Member 'FRigUnit_AccumulateVectorMul::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateQuatMul
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_AccumulateQuatMul final : public FRigUnit_AccumulateBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Multiplier;                                        // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  InitialValue;                                      // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bFlipOrder;                                        // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0xE];                                       // 0x0052(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0060(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  AccumulatedValue;                                  // 0x0080(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateQuatMul) == 0x000010, "Wrong alignment on FRigUnit_AccumulateQuatMul");
static_assert(sizeof(FRigUnit_AccumulateQuatMul) == 0x0000A0, "Wrong size on FRigUnit_AccumulateQuatMul");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, Multiplier) == 0x000010, "Member 'FRigUnit_AccumulateQuatMul::Multiplier' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, InitialValue) == 0x000030, "Member 'FRigUnit_AccumulateQuatMul::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, bFlipOrder) == 0x000050, "Member 'FRigUnit_AccumulateQuatMul::bFlipOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, bIntegrateDeltaTime) == 0x000051, "Member 'FRigUnit_AccumulateQuatMul::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, Result) == 0x000060, "Member 'FRigUnit_AccumulateQuatMul::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, AccumulatedValue) == 0x000080, "Member 'FRigUnit_AccumulateQuatMul::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateTransformMul
// 0x0198 (0x01A0 - 0x0008)
struct FRigUnit_AccumulateTransformMul final : public FRigUnit_AccumulateBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Multiplier;                                        // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitialValue;                                      // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bFlipOrder;                                        // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x00D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0xE];                                       // 0x00D2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             AccumulatedValue;                                  // 0x0140(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateTransformMul) == 0x000010, "Wrong alignment on FRigUnit_AccumulateTransformMul");
static_assert(sizeof(FRigUnit_AccumulateTransformMul) == 0x0001A0, "Wrong size on FRigUnit_AccumulateTransformMul");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, Multiplier) == 0x000010, "Member 'FRigUnit_AccumulateTransformMul::Multiplier' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, InitialValue) == 0x000070, "Member 'FRigUnit_AccumulateTransformMul::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, bFlipOrder) == 0x0000D0, "Member 'FRigUnit_AccumulateTransformMul::bFlipOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, bIntegrateDeltaTime) == 0x0000D1, "Member 'FRigUnit_AccumulateTransformMul::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, Result) == 0x0000E0, "Member 'FRigUnit_AccumulateTransformMul::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, AccumulatedValue) == 0x000140, "Member 'FRigUnit_AccumulateTransformMul::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathQuaternionBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathQuaternionBase) == 0x000008, "Wrong alignment on FRigUnit_MathQuaternionBase");
static_assert(sizeof(FRigUnit_MathQuaternionBase) == 0x000008, "Wrong size on FRigUnit_MathQuaternionBase");

// ScriptStruct ControlRig.RigUnit_AccumulateFloatLerp
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_AccumulateFloatLerp final : public FRigUnit_AccumulateBase
{
public:
	float                                         TargetValue;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialValue;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedValue;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateFloatLerp) == 0x000008, "Wrong alignment on FRigUnit_AccumulateFloatLerp");
static_assert(sizeof(FRigUnit_AccumulateFloatLerp) == 0x000020, "Wrong size on FRigUnit_AccumulateFloatLerp");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, TargetValue) == 0x000008, "Member 'FRigUnit_AccumulateFloatLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, InitialValue) == 0x00000C, "Member 'FRigUnit_AccumulateFloatLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, Blend) == 0x000010, "Member 'FRigUnit_AccumulateFloatLerp::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, bIntegrateDeltaTime) == 0x000014, "Member 'FRigUnit_AccumulateFloatLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, Result) == 0x000018, "Member 'FRigUnit_AccumulateFloatLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, AccumulatedValue) == 0x00001C, "Member 'FRigUnit_AccumulateFloatLerp::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorAbs
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorAbs final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorAbs) == 0x000008, "Wrong alignment on FRigUnit_MathVectorAbs");
static_assert(sizeof(FRigUnit_MathVectorAbs) == 0x000038, "Wrong size on FRigUnit_MathVectorAbs");

// ScriptStruct ControlRig.RigUnit_AccumulateVectorLerp
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_AccumulateVectorLerp final : public FRigUnit_AccumulateBase
{
public:
	struct FVector                                TargetValue;                                       // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialValue;                                      // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedValue;                                  // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateVectorLerp) == 0x000008, "Wrong alignment on FRigUnit_AccumulateVectorLerp");
static_assert(sizeof(FRigUnit_AccumulateVectorLerp) == 0x000070, "Wrong size on FRigUnit_AccumulateVectorLerp");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, TargetValue) == 0x000008, "Member 'FRigUnit_AccumulateVectorLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, InitialValue) == 0x000020, "Member 'FRigUnit_AccumulateVectorLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, Blend) == 0x000038, "Member 'FRigUnit_AccumulateVectorLerp::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, bIntegrateDeltaTime) == 0x00003C, "Member 'FRigUnit_AccumulateVectorLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, Result) == 0x000040, "Member 'FRigUnit_AccumulateVectorLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, AccumulatedValue) == 0x000058, "Member 'FRigUnit_AccumulateVectorLerp::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateTransformLerp
// 0x0198 (0x01A0 - 0x0008)
struct FRigUnit_AccumulateTransformLerp final : public FRigUnit_AccumulateBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TargetValue;                                       // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitialValue;                                      // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0xB];                                       // 0x00D5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             AccumulatedValue;                                  // 0x0140(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateTransformLerp) == 0x000010, "Wrong alignment on FRigUnit_AccumulateTransformLerp");
static_assert(sizeof(FRigUnit_AccumulateTransformLerp) == 0x0001A0, "Wrong size on FRigUnit_AccumulateTransformLerp");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, TargetValue) == 0x000010, "Member 'FRigUnit_AccumulateTransformLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, InitialValue) == 0x000070, "Member 'FRigUnit_AccumulateTransformLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, Blend) == 0x0000D0, "Member 'FRigUnit_AccumulateTransformLerp::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, bIntegrateDeltaTime) == 0x0000D4, "Member 'FRigUnit_AccumulateTransformLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, Result) == 0x0000E0, "Member 'FRigUnit_AccumulateTransformLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, AccumulatedValue) == 0x000140, "Member 'FRigUnit_AccumulateTransformLerp::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorFromFloat
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_MathVectorFromFloat final : public FRigUnit_MathVectorBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorFromFloat) == 0x000008, "Wrong alignment on FRigUnit_MathVectorFromFloat");
static_assert(sizeof(FRigUnit_MathVectorFromFloat) == 0x000028, "Wrong size on FRigUnit_MathVectorFromFloat");
static_assert(offsetof(FRigUnit_MathVectorFromFloat, Value) == 0x000008, "Member 'FRigUnit_MathVectorFromFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorFromFloat, Result) == 0x000010, "Member 'FRigUnit_MathVectorFromFloat::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateFloatRange
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_AccumulateFloatRange final : public FRigUnit_AccumulateBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedMinimum;                                // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedMaximum;                                // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateFloatRange) == 0x000008, "Wrong alignment on FRigUnit_AccumulateFloatRange");
static_assert(sizeof(FRigUnit_AccumulateFloatRange) == 0x000020, "Wrong size on FRigUnit_AccumulateFloatRange");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, Value) == 0x000008, "Member 'FRigUnit_AccumulateFloatRange::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, Minimum) == 0x00000C, "Member 'FRigUnit_AccumulateFloatRange::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, Maximum) == 0x000010, "Member 'FRigUnit_AccumulateFloatRange::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, AccumulatedMinimum) == 0x000014, "Member 'FRigUnit_AccumulateFloatRange::AccumulatedMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, AccumulatedMaximum) == 0x000018, "Member 'FRigUnit_AccumulateFloatRange::AccumulatedMaximum' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorUnit
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorUnit final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorUnit) == 0x000008, "Wrong alignment on FRigUnit_MathVectorUnit");
static_assert(sizeof(FRigUnit_MathVectorUnit) == 0x000038, "Wrong size on FRigUnit_MathVectorUnit");

// ScriptStruct ControlRig.RigUnit_AccumulateVectorRange
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_AccumulateVectorRange final : public FRigUnit_AccumulateBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Minimum;                                           // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Maximum;                                           // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedMinimum;                                // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedMaximum;                                // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateVectorRange) == 0x000008, "Wrong alignment on FRigUnit_AccumulateVectorRange");
static_assert(sizeof(FRigUnit_AccumulateVectorRange) == 0x000080, "Wrong size on FRigUnit_AccumulateVectorRange");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, Value) == 0x000008, "Member 'FRigUnit_AccumulateVectorRange::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, Minimum) == 0x000020, "Member 'FRigUnit_AccumulateVectorRange::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, Maximum) == 0x000038, "Member 'FRigUnit_AccumulateVectorRange::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, AccumulatedMinimum) == 0x000050, "Member 'FRigUnit_AccumulateVectorRange::AccumulatedMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, AccumulatedMaximum) == 0x000068, "Member 'FRigUnit_AccumulateVectorRange::AccumulatedMaximum' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AddBoneTransform
// 0x00A0 (0x0170 - 0x00D0)
struct FRigUnit_AddBoneTransform final : public FRigUnitMutable
{
public:
	class FName                                   bone;                                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostMultiply;                                     // 0x0144(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0145(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_146[0x2];                                      // 0x0146(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedBone;                                        // 0x0148(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AddBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_AddBoneTransform");
static_assert(sizeof(FRigUnit_AddBoneTransform) == 0x000170, "Wrong size on FRigUnit_AddBoneTransform");
static_assert(offsetof(FRigUnit_AddBoneTransform, bone) == 0x0000D0, "Member 'FRigUnit_AddBoneTransform::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, Transform) == 0x0000E0, "Member 'FRigUnit_AddBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, Weight) == 0x000140, "Member 'FRigUnit_AddBoneTransform::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, bPostMultiply) == 0x000144, "Member 'FRigUnit_AddBoneTransform::bPostMultiply' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, bPropagateToChildren) == 0x000145, "Member 'FRigUnit_AddBoneTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, CachedBone) == 0x000148, "Member 'FRigUnit_AddBoneTransform::CachedBone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimBone_Target
// 0x0048 (0x0048 - 0x0000)
struct FRigUnit_AimBone_Target final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Axis;                                              // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigVectorKind                         Kind;                                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Space;                                             // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AimBone_Target) == 0x000008, "Wrong alignment on FRigUnit_AimBone_Target");
static_assert(sizeof(FRigUnit_AimBone_Target) == 0x000048, "Wrong size on FRigUnit_AimBone_Target");
static_assert(offsetof(FRigUnit_AimBone_Target, Weight) == 0x000000, "Member 'FRigUnit_AimBone_Target::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_Target, Axis) == 0x000008, "Member 'FRigUnit_AimBone_Target::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_Target, Target) == 0x000020, "Member 'FRigUnit_AimBone_Target::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_Target, Kind) == 0x000038, "Member 'FRigUnit_AimBone_Target::Kind' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_Target, Space) == 0x00003C, "Member 'FRigUnit_AimBone_Target::Space' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorScale
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorScale final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Factor;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorScale) == 0x000008, "Wrong alignment on FRigUnit_MathVectorScale");
static_assert(sizeof(FRigUnit_MathVectorScale) == 0x000040, "Wrong size on FRigUnit_MathVectorScale");
static_assert(offsetof(FRigUnit_MathVectorScale, Value) == 0x000008, "Member 'FRigUnit_MathVectorScale::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorScale, Factor) == 0x000020, "Member 'FRigUnit_MathVectorScale::Factor' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorScale, Result) == 0x000028, "Member 'FRigUnit_MathVectorScale::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimItem_Target
// 0x0048 (0x0048 - 0x0000)
struct FRigUnit_AimItem_Target final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Axis;                                              // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigVectorKind                         Kind;                                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         Space;                                             // 0x003C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimItem_Target) == 0x000008, "Wrong alignment on FRigUnit_AimItem_Target");
static_assert(sizeof(FRigUnit_AimItem_Target) == 0x000048, "Wrong size on FRigUnit_AimItem_Target");
static_assert(offsetof(FRigUnit_AimItem_Target, Weight) == 0x000000, "Member 'FRigUnit_AimItem_Target::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem_Target, Axis) == 0x000008, "Member 'FRigUnit_AimItem_Target::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem_Target, Target) == 0x000020, "Member 'FRigUnit_AimItem_Target::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem_Target, Kind) == 0x000038, "Member 'FRigUnit_AimItem_Target::Kind' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem_Target, Space) == 0x00003C, "Member 'FRigUnit_AimItem_Target::Space' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorEquals
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorEquals final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorEquals) == 0x000008, "Wrong alignment on FRigUnit_MathVectorEquals");
static_assert(sizeof(FRigUnit_MathVectorEquals) == 0x000040, "Wrong size on FRigUnit_MathVectorEquals");
static_assert(offsetof(FRigUnit_MathVectorEquals, A) == 0x000008, "Member 'FRigUnit_MathVectorEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorEquals, B) == 0x000020, "Member 'FRigUnit_MathVectorEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorEquals, Result) == 0x000038, "Member 'FRigUnit_MathVectorEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimBone_DebugSettings
// 0x0070 (0x0070 - 0x0000)
struct FRigUnit_AimBone_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0010(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimBone_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_AimBone_DebugSettings");
static_assert(sizeof(FRigUnit_AimBone_DebugSettings) == 0x000070, "Wrong size on FRigUnit_AimBone_DebugSettings");
static_assert(offsetof(FRigUnit_AimBone_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_AimBone_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_AimBone_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_DebugSettings, WorldOffset) == 0x000010, "Member 'FRigUnit_AimBone_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimBoneMath
// 0x0218 (0x0220 - 0x0008)
struct FRigUnit_AimBoneMath final : public FRigUnit_HighlevelBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InputTransform;                                    // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_AimItem_Target                Primary;                                           // 0x0070(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_AimItem_Target                Secondary;                                         // 0x00B8(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0xC];                                      // 0x0104(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0110(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_AimBone_DebugSettings         DebugSettings;                                     // 0x0170(0x0070)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      PrimaryCachedSpace;                                // 0x01E0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      SecondaryCachedSpace;                              // 0x0200(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimBoneMath) == 0x000010, "Wrong alignment on FRigUnit_AimBoneMath");
static_assert(sizeof(FRigUnit_AimBoneMath) == 0x000220, "Wrong size on FRigUnit_AimBoneMath");
static_assert(offsetof(FRigUnit_AimBoneMath, InputTransform) == 0x000010, "Member 'FRigUnit_AimBoneMath::InputTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBoneMath, Primary) == 0x000070, "Member 'FRigUnit_AimBoneMath::Primary' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBoneMath, Secondary) == 0x0000B8, "Member 'FRigUnit_AimBoneMath::Secondary' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBoneMath, Weight) == 0x000100, "Member 'FRigUnit_AimBoneMath::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBoneMath, Result) == 0x000110, "Member 'FRigUnit_AimBoneMath::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBoneMath, DebugSettings) == 0x000170, "Member 'FRigUnit_AimBoneMath::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBoneMath, PrimaryCachedSpace) == 0x0001E0, "Member 'FRigUnit_AimBoneMath::PrimaryCachedSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBoneMath, SecondaryCachedSpace) == 0x000200, "Member 'FRigUnit_AimBoneMath::SecondaryCachedSpace' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMax
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathVectorMax final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorMax) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMax");
static_assert(sizeof(FRigUnit_MathVectorMax) == 0x000050, "Wrong size on FRigUnit_MathVectorMax");

// ScriptStruct ControlRig.MathRBFInterpolateVectorColor_Target
// 0x0028 (0x0028 - 0x0000)
struct FMathRBFInterpolateVectorColor_Target final
{
public:
	struct FVector                                Target;                                            // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathRBFInterpolateVectorColor_Target) == 0x000008, "Wrong alignment on FMathRBFInterpolateVectorColor_Target");
static_assert(sizeof(FMathRBFInterpolateVectorColor_Target) == 0x000028, "Wrong size on FMathRBFInterpolateVectorColor_Target");
static_assert(offsetof(FMathRBFInterpolateVectorColor_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateVectorColor_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateVectorColor_Target, Value) == 0x000018, "Member 'FMathRBFInterpolateVectorColor_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimBone
// 0x0170 (0x0240 - 0x00D0)
struct FRigUnit_AimBone final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   bone;                                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_AimBone_Target                Primary;                                           // 0x00D8(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_AimBone_Target                Secondary;                                         // 0x0120(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x016C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_AimBone_DebugSettings         DebugSettings;                                     // 0x0170(0x0070)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedBoneIndex;                                   // 0x01E0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      PrimaryCachedSpace;                                // 0x0200(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      SecondaryCachedSpace;                              // 0x0220(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimBone) == 0x000010, "Wrong alignment on FRigUnit_AimBone");
static_assert(sizeof(FRigUnit_AimBone) == 0x000240, "Wrong size on FRigUnit_AimBone");
static_assert(offsetof(FRigUnit_AimBone, bone) == 0x0000D0, "Member 'FRigUnit_AimBone::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, Primary) == 0x0000D8, "Member 'FRigUnit_AimBone::Primary' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, Secondary) == 0x000120, "Member 'FRigUnit_AimBone::Secondary' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, Weight) == 0x000168, "Member 'FRigUnit_AimBone::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, bPropagateToChildren) == 0x00016C, "Member 'FRigUnit_AimBone::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, DebugSettings) == 0x000170, "Member 'FRigUnit_AimBone::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, CachedBoneIndex) == 0x0001E0, "Member 'FRigUnit_AimBone::CachedBoneIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, PrimaryCachedSpace) == 0x000200, "Member 'FRigUnit_AimBone::PrimaryCachedSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, SecondaryCachedSpace) == 0x000220, "Member 'FRigUnit_AimBone::SecondaryCachedSpace' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimItem
// 0x0180 (0x0250 - 0x00D0)
struct FRigUnit_AimItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_AimItem_Target                Primary;                                           // 0x00E0(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_AimItem_Target                Secondary;                                         // 0x0128(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0170(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0xC];                                      // 0x0174(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_AimBone_DebugSettings         DebugSettings;                                     // 0x0180(0x0070)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedItem;                                        // 0x01F0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      PrimaryCachedSpace;                                // 0x0210(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      SecondaryCachedSpace;                              // 0x0230(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimItem) == 0x000010, "Wrong alignment on FRigUnit_AimItem");
static_assert(sizeof(FRigUnit_AimItem) == 0x000250, "Wrong size on FRigUnit_AimItem");
static_assert(offsetof(FRigUnit_AimItem, Item) == 0x0000D0, "Member 'FRigUnit_AimItem::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem, Primary) == 0x0000E0, "Member 'FRigUnit_AimItem::Primary' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem, Secondary) == 0x000128, "Member 'FRigUnit_AimItem::Secondary' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem, Weight) == 0x000170, "Member 'FRigUnit_AimItem::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem, DebugSettings) == 0x000180, "Member 'FRigUnit_AimItem::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem, CachedItem) == 0x0001F0, "Member 'FRigUnit_AimItem::CachedItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem, PrimaryCachedSpace) == 0x000210, "Member 'FRigUnit_AimItem::PrimaryCachedSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimItem, SecondaryCachedSpace) == 0x000230, "Member 'FRigUnit_AimItem::SecondaryCachedSpace' has a wrong offset!");

// ScriptStruct ControlRig.AimTarget
// 0x0090 (0x0090 - 0x0000)
struct FAimTarget final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AlignVector;                                       // 0x0070(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimTarget) == 0x000010, "Wrong alignment on FAimTarget");
static_assert(sizeof(FAimTarget) == 0x000090, "Wrong size on FAimTarget");
static_assert(offsetof(FAimTarget, Weight) == 0x000000, "Member 'FAimTarget::Weight' has a wrong offset!");
static_assert(offsetof(FAimTarget, Transform) == 0x000010, "Member 'FAimTarget::Transform' has a wrong offset!");
static_assert(offsetof(FAimTarget, AlignVector) == 0x000070, "Member 'FAimTarget::AlignVector' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorCeil
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorCeil final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorCeil) == 0x000008, "Wrong alignment on FRigUnit_MathVectorCeil");
static_assert(sizeof(FRigUnit_MathVectorCeil) == 0x000038, "Wrong size on FRigUnit_MathVectorCeil");

// ScriptStruct ControlRig.RigUnit_AimConstraint_WorkData
// 0x0010 (0x0010 - 0x0000)
struct FRigUnit_AimConstraint_WorkData final
{
public:
	TArray<struct FConstraintData>                ConstraintData;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimConstraint_WorkData) == 0x000008, "Wrong alignment on FRigUnit_AimConstraint_WorkData");
static_assert(sizeof(FRigUnit_AimConstraint_WorkData) == 0x000010, "Wrong size on FRigUnit_AimConstraint_WorkData");
static_assert(offsetof(FRigUnit_AimConstraint_WorkData, ConstraintData) == 0x000000, "Member 'FRigUnit_AimConstraint_WorkData::ConstraintData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_RandomFloat
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_RandomFloat final : public FRigUnit_MathBase
{
public:
	int32                                         Seed;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastResult;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSeed;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseSeed;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLeft;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_RandomFloat) == 0x000008, "Wrong alignment on FRigUnit_RandomFloat");
static_assert(sizeof(FRigUnit_RandomFloat) == 0x000030, "Wrong size on FRigUnit_RandomFloat");
static_assert(offsetof(FRigUnit_RandomFloat, Seed) == 0x000008, "Member 'FRigUnit_RandomFloat::Seed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, Minimum) == 0x00000C, "Member 'FRigUnit_RandomFloat::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, Maximum) == 0x000010, "Member 'FRigUnit_RandomFloat::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, Duration) == 0x000014, "Member 'FRigUnit_RandomFloat::Duration' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, Result) == 0x000018, "Member 'FRigUnit_RandomFloat::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, LastResult) == 0x00001C, "Member 'FRigUnit_RandomFloat::LastResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, LastSeed) == 0x000020, "Member 'FRigUnit_RandomFloat::LastSeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, BaseSeed) == 0x000024, "Member 'FRigUnit_RandomFloat::BaseSeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, TimeLeft) == 0x000028, "Member 'FRigUnit_RandomFloat::TimeLeft' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimConstraint
// 0x0070 (0x0140 - 0x00D0)
struct FRigUnit_AimConstraint final : public FRigUnitMutable
{
public:
	class FName                                   Joint;                                             // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimMode                                      AimMode;                                           // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAimMode                                      UpMode;                                            // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimVector;                                         // 0x00E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpVector;                                          // 0x00F8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAimTarget>                     AimTargets;                                        // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAimTarget>                     UpTargets;                                         // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigUnit_AimConstraint_WorkData        WorkData;                                          // 0x0130(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimConstraint) == 0x000010, "Wrong alignment on FRigUnit_AimConstraint");
static_assert(sizeof(FRigUnit_AimConstraint) == 0x000140, "Wrong size on FRigUnit_AimConstraint");
static_assert(offsetof(FRigUnit_AimConstraint, Joint) == 0x0000D0, "Member 'FRigUnit_AimConstraint::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimMode) == 0x0000D8, "Member 'FRigUnit_AimConstraint::AimMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpMode) == 0x0000D9, "Member 'FRigUnit_AimConstraint::UpMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimVector) == 0x0000E0, "Member 'FRigUnit_AimConstraint::AimVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpVector) == 0x0000F8, "Member 'FRigUnit_AimConstraint::UpVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimTargets) == 0x000110, "Member 'FRigUnit_AimConstraint::AimTargets' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpTargets) == 0x000120, "Member 'FRigUnit_AimConstraint::UpTargets' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, WorkData) == 0x000130, "Member 'FRigUnit_AimConstraint::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AlphaInterp
// 0x0070 (0x0078 - 0x0008)
struct FRigUnit_AlphaInterp final : public FRigUnit_SimBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMapRange;                                         // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputRange                            InRange;                                           // 0x0018(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FInputRange                            OutRange;                                          // 0x0020(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bClampResult;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampMin;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpResult;                                     // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpSpeedIncreasing;                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedDecreasing;                             // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBiasClamp                   ScaleBiasClamp;                                    // 0x0044(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AlphaInterp) == 0x000008, "Wrong alignment on FRigUnit_AlphaInterp");
static_assert(sizeof(FRigUnit_AlphaInterp) == 0x000078, "Wrong size on FRigUnit_AlphaInterp");
static_assert(offsetof(FRigUnit_AlphaInterp, Value) == 0x000008, "Member 'FRigUnit_AlphaInterp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, Scale) == 0x00000C, "Member 'FRigUnit_AlphaInterp::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, Bias) == 0x000010, "Member 'FRigUnit_AlphaInterp::Bias' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, bMapRange) == 0x000014, "Member 'FRigUnit_AlphaInterp::bMapRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, InRange) == 0x000018, "Member 'FRigUnit_AlphaInterp::InRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, OutRange) == 0x000020, "Member 'FRigUnit_AlphaInterp::OutRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, bClampResult) == 0x000028, "Member 'FRigUnit_AlphaInterp::bClampResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, ClampMin) == 0x00002C, "Member 'FRigUnit_AlphaInterp::ClampMin' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, ClampMax) == 0x000030, "Member 'FRigUnit_AlphaInterp::ClampMax' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, bInterpResult) == 0x000034, "Member 'FRigUnit_AlphaInterp::bInterpResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, InterpSpeedIncreasing) == 0x000038, "Member 'FRigUnit_AlphaInterp::InterpSpeedIncreasing' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, InterpSpeedDecreasing) == 0x00003C, "Member 'FRigUnit_AlphaInterp::InterpSpeedDecreasing' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, Result) == 0x000040, "Member 'FRigUnit_AlphaInterp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterp, ScaleBiasClamp) == 0x000044, "Member 'FRigUnit_AlphaInterp::ScaleBiasClamp' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ModifyTransforms_PerItem
// 0x0070 (0x0070 - 0x0000)
struct FRigUnit_ModifyTransforms_PerItem final
{
public:
	struct FRigElementKey                         Item;                                              // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ModifyTransforms_PerItem) == 0x000010, "Wrong alignment on FRigUnit_ModifyTransforms_PerItem");
static_assert(sizeof(FRigUnit_ModifyTransforms_PerItem) == 0x000070, "Wrong size on FRigUnit_ModifyTransforms_PerItem");
static_assert(offsetof(FRigUnit_ModifyTransforms_PerItem, Item) == 0x000000, "Member 'FRigUnit_ModifyTransforms_PerItem::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyTransforms_PerItem, Transform) == 0x000010, "Member 'FRigUnit_ModifyTransforms_PerItem::Transform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AlphaInterpVector
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_AlphaInterpVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMapRange;                                         // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputRange                            InRange;                                           // 0x002C(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FInputRange                            OutRange;                                          // 0x0034(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bClampResult;                                      // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampMin;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpResult;                                     // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpSpeedIncreasing;                             // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedDecreasing;                             // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBiasClamp                   ScaleBiasClamp;                                    // 0x0070(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AlphaInterpVector) == 0x000008, "Wrong alignment on FRigUnit_AlphaInterpVector");
static_assert(sizeof(FRigUnit_AlphaInterpVector) == 0x0000A0, "Wrong size on FRigUnit_AlphaInterpVector");
static_assert(offsetof(FRigUnit_AlphaInterpVector, Value) == 0x000008, "Member 'FRigUnit_AlphaInterpVector::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, Scale) == 0x000020, "Member 'FRigUnit_AlphaInterpVector::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, Bias) == 0x000024, "Member 'FRigUnit_AlphaInterpVector::Bias' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, bMapRange) == 0x000028, "Member 'FRigUnit_AlphaInterpVector::bMapRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, InRange) == 0x00002C, "Member 'FRigUnit_AlphaInterpVector::InRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, OutRange) == 0x000034, "Member 'FRigUnit_AlphaInterpVector::OutRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, bClampResult) == 0x00003C, "Member 'FRigUnit_AlphaInterpVector::bClampResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, ClampMin) == 0x000040, "Member 'FRigUnit_AlphaInterpVector::ClampMin' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, ClampMax) == 0x000044, "Member 'FRigUnit_AlphaInterpVector::ClampMax' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, bInterpResult) == 0x000048, "Member 'FRigUnit_AlphaInterpVector::bInterpResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, InterpSpeedIncreasing) == 0x00004C, "Member 'FRigUnit_AlphaInterpVector::InterpSpeedIncreasing' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, InterpSpeedDecreasing) == 0x000050, "Member 'FRigUnit_AlphaInterpVector::InterpSpeedDecreasing' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, Result) == 0x000058, "Member 'FRigUnit_AlphaInterpVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AlphaInterpVector, ScaleBiasClamp) == 0x000070, "Member 'FRigUnit_AlphaInterpVector::ScaleBiasClamp' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetBoneInitialTransform
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_SetBoneInitialTransform final : public FRigUnitMutable
{
public:
	class FName                                   bone;                                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0140(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x01A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A2[0x6];                                      // 0x01A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedBone;                                        // 0x01A8(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetBoneInitialTransform) == 0x000010, "Wrong alignment on FRigUnit_SetBoneInitialTransform");
static_assert(sizeof(FRigUnit_SetBoneInitialTransform) == 0x0001D0, "Wrong size on FRigUnit_SetBoneInitialTransform");
static_assert(offsetof(FRigUnit_SetBoneInitialTransform, bone) == 0x0000D0, "Member 'FRigUnit_SetBoneInitialTransform::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneInitialTransform, Transform) == 0x0000E0, "Member 'FRigUnit_SetBoneInitialTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneInitialTransform, Result) == 0x000140, "Member 'FRigUnit_SetBoneInitialTransform::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneInitialTransform, Space) == 0x0001A0, "Member 'FRigUnit_SetBoneInitialTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneInitialTransform, bPropagateToChildren) == 0x0001A1, "Member 'FRigUnit_SetBoneInitialTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneInitialTransform, CachedBone) == 0x0001A8, "Member 'FRigUnit_SetBoneInitialTransform::CachedBone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimEasingType
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_AnimEasingType final : public FRigUnit_AnimBase
{
public:
	EControlRigAnimEasingType                     Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AnimEasingType) == 0x000008, "Wrong alignment on FRigUnit_AnimEasingType");
static_assert(sizeof(FRigUnit_AnimEasingType) == 0x000010, "Wrong size on FRigUnit_AnimEasingType");
static_assert(offsetof(FRigUnit_AnimEasingType, Type) == 0x000008, "Member 'FRigUnit_AnimEasingType::Type' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorAngle
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorAngle final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorAngle) == 0x000008, "Wrong alignment on FRigUnit_MathVectorAngle");
static_assert(sizeof(FRigUnit_MathVectorAngle) == 0x000040, "Wrong size on FRigUnit_MathVectorAngle");
static_assert(offsetof(FRigUnit_MathVectorAngle, A) == 0x000008, "Member 'FRigUnit_MathVectorAngle::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorAngle, B) == 0x000020, "Member 'FRigUnit_MathVectorAngle::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorAngle, Result) == 0x000038, "Member 'FRigUnit_MathVectorAngle::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimEvalRichCurve
// 0x00A8 (0x00B0 - 0x0008)
struct FRigUnit_AnimEvalRichCurve final : public FRigUnit_AnimBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0010(0x0088)(NativeAccessSpecifierPublic)
	float                                         SourceMinimum;                                     // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMaximum;                                     // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMinimum;                                     // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaximum;                                     // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AnimEvalRichCurve) == 0x000008, "Wrong alignment on FRigUnit_AnimEvalRichCurve");
static_assert(sizeof(FRigUnit_AnimEvalRichCurve) == 0x0000B0, "Wrong size on FRigUnit_AnimEvalRichCurve");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, Value) == 0x000008, "Member 'FRigUnit_AnimEvalRichCurve::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, Curve) == 0x000010, "Member 'FRigUnit_AnimEvalRichCurve::Curve' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, SourceMinimum) == 0x000098, "Member 'FRigUnit_AnimEvalRichCurve::SourceMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, SourceMaximum) == 0x00009C, "Member 'FRigUnit_AnimEvalRichCurve::SourceMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, TargetMinimum) == 0x0000A0, "Member 'FRigUnit_AnimEvalRichCurve::TargetMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, TargetMaximum) == 0x0000A4, "Member 'FRigUnit_AnimEvalRichCurve::TargetMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, Result) == 0x0000A8, "Member 'FRigUnit_AnimEvalRichCurve::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlColor
// 0x0040 (0x0110 - 0x00D0)
struct FRigUnit_SetControlColor final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x00D8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x00E8(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetControlColor) == 0x000010, "Wrong alignment on FRigUnit_SetControlColor");
static_assert(sizeof(FRigUnit_SetControlColor) == 0x000110, "Wrong size on FRigUnit_SetControlColor");
static_assert(offsetof(FRigUnit_SetControlColor, Control) == 0x0000D0, "Member 'FRigUnit_SetControlColor::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlColor, Color) == 0x0000D8, "Member 'FRigUnit_SetControlColor::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlColor, CachedControlIndex) == 0x0000E8, "Member 'FRigUnit_SetControlColor::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ApplyFK
// 0x00F0 (0x01C0 - 0x00D0)
struct FRigUnit_ApplyFK final : public FRigUnitMutable
{
public:
	class FName                                   Joint;                                             // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x0140(0x0009)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EApplyTransformMode                           ApplyTransformMode;                                // 0x0149(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           ApplyTransformSpace;                               // 0x014A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14B[0x5];                                      // 0x014B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0150(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseJoint;                                         // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ApplyFK) == 0x000010, "Wrong alignment on FRigUnit_ApplyFK");
static_assert(sizeof(FRigUnit_ApplyFK) == 0x0001C0, "Wrong size on FRigUnit_ApplyFK");
static_assert(offsetof(FRigUnit_ApplyFK, Joint) == 0x0000D0, "Member 'FRigUnit_ApplyFK::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, Transform) == 0x0000E0, "Member 'FRigUnit_ApplyFK::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, Filter) == 0x000140, "Member 'FRigUnit_ApplyFK::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, ApplyTransformMode) == 0x000149, "Member 'FRigUnit_ApplyFK::ApplyTransformMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, ApplyTransformSpace) == 0x00014A, "Member 'FRigUnit_ApplyFK::ApplyTransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, BaseTransform) == 0x000150, "Member 'FRigUnit_ApplyFK::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, BaseJoint) == 0x0001B0, "Member 'FRigUnit_ApplyFK::BaseJoint' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BeginExecution
// 0x00C8 (0x00D0 - 0x0008)
struct FRigUnit_BeginExecution final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              ExecuteContext;                                    // 0x0010(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BeginExecution) == 0x000010, "Wrong alignment on FRigUnit_BeginExecution");
static_assert(sizeof(FRigUnit_BeginExecution) == 0x0000D0, "Wrong size on FRigUnit_BeginExecution");
static_assert(offsetof(FRigUnit_BeginExecution, ExecuteContext) == 0x000010, "Member 'FRigUnit_BeginExecution::ExecuteContext' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlBool_Entry
// 0x000C (0x000C - 0x0000)
struct FRigUnit_SetMultiControlBool_Entry final
{
public:
	class FName                                   Control;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetMultiControlBool_Entry) == 0x000004, "Wrong alignment on FRigUnit_SetMultiControlBool_Entry");
static_assert(sizeof(FRigUnit_SetMultiControlBool_Entry) == 0x00000C, "Wrong size on FRigUnit_SetMultiControlBool_Entry");
static_assert(offsetof(FRigUnit_SetMultiControlBool_Entry, Control) == 0x000000, "Member 'FRigUnit_SetMultiControlBool_Entry::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlBool_Entry, BoolValue) == 0x000008, "Member 'FRigUnit_SetMultiControlBool_Entry::BoolValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlBool
// 0x0020 (0x00F0 - 0x00D0)
struct FRigUnit_SetMultiControlBool final : public FRigUnitMutable
{
public:
	TArray<struct FRigUnit_SetMultiControlBool_Entry> Entries;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              CachedControlIndices;                              // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetMultiControlBool) == 0x000010, "Wrong alignment on FRigUnit_SetMultiControlBool");
static_assert(sizeof(FRigUnit_SetMultiControlBool) == 0x0000F0, "Wrong size on FRigUnit_SetMultiControlBool");
static_assert(offsetof(FRigUnit_SetMultiControlBool, Entries) == 0x0000D0, "Member 'FRigUnit_SetMultiControlBool::Entries' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlBool, CachedControlIndices) == 0x0000E0, "Member 'FRigUnit_SetMultiControlBool::CachedControlIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BlendTransform
// 0x00D8 (0x00E0 - 0x0008)
struct FRigUnit_BlendTransform final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Source;                                            // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBlendTarget>                   Targets;                                           // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0080(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BlendTransform) == 0x000010, "Wrong alignment on FRigUnit_BlendTransform");
static_assert(sizeof(FRigUnit_BlendTransform) == 0x0000E0, "Wrong size on FRigUnit_BlendTransform");
static_assert(offsetof(FRigUnit_BlendTransform, Source) == 0x000010, "Member 'FRigUnit_BlendTransform::Source' has a wrong offset!");
static_assert(offsetof(FRigUnit_BlendTransform, Targets) == 0x000070, "Member 'FRigUnit_BlendTransform::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_BlendTransform, Result) == 0x000080, "Member 'FRigUnit_BlendTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ModifyBoneTransforms_PerBone
// 0x0070 (0x0070 - 0x0000)
struct FRigUnit_ModifyBoneTransforms_PerBone final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ModifyBoneTransforms_PerBone) == 0x000010, "Wrong alignment on FRigUnit_ModifyBoneTransforms_PerBone");
static_assert(sizeof(FRigUnit_ModifyBoneTransforms_PerBone) == 0x000070, "Wrong size on FRigUnit_ModifyBoneTransforms_PerBone");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms_PerBone, bone) == 0x000000, "Member 'FRigUnit_ModifyBoneTransforms_PerBone::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms_PerBone, Transform) == 0x000010, "Member 'FRigUnit_ModifyBoneTransforms_PerBone::Transform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BoneHarmonics
// 0x00C0 (0x0190 - 0x00D0)
struct FRigUnit_BoneHarmonics final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigUnit_BoneHarmonics_BoneTarget> Bones;                                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                WaveSpeed;                                         // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveFrequency;                                     // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveAmplitude;                                     // 0x0110(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveOffset;                                        // 0x0128(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveNoise;                                         // 0x0140(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     WaveEase;                                          // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaveMinimum;                                       // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveMaximum;                                       // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEulerRotationOrder                           RotationOrder;                                     // 0x0164(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0165(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_166[0x2];                                      // 0x0166(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_BoneHarmonics_WorkData        WorkData;                                          // 0x0168(0x0028)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BoneHarmonics) == 0x000010, "Wrong alignment on FRigUnit_BoneHarmonics");
static_assert(sizeof(FRigUnit_BoneHarmonics) == 0x000190, "Wrong size on FRigUnit_BoneHarmonics");
static_assert(offsetof(FRigUnit_BoneHarmonics, Bones) == 0x0000D0, "Member 'FRigUnit_BoneHarmonics::Bones' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveSpeed) == 0x0000E0, "Member 'FRigUnit_BoneHarmonics::WaveSpeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveFrequency) == 0x0000F8, "Member 'FRigUnit_BoneHarmonics::WaveFrequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveAmplitude) == 0x000110, "Member 'FRigUnit_BoneHarmonics::WaveAmplitude' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveOffset) == 0x000128, "Member 'FRigUnit_BoneHarmonics::WaveOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveNoise) == 0x000140, "Member 'FRigUnit_BoneHarmonics::WaveNoise' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveEase) == 0x000158, "Member 'FRigUnit_BoneHarmonics::WaveEase' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveMinimum) == 0x00015C, "Member 'FRigUnit_BoneHarmonics::WaveMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveMaximum) == 0x000160, "Member 'FRigUnit_BoneHarmonics::WaveMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, RotationOrder) == 0x000164, "Member 'FRigUnit_BoneHarmonics::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, bPropagateToChildren) == 0x000165, "Member 'FRigUnit_BoneHarmonics::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WorkData) == 0x000168, "Member 'FRigUnit_BoneHarmonics::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorClampLength
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorClampLength final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumLength;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumLength;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorClampLength) == 0x000008, "Wrong alignment on FRigUnit_MathVectorClampLength");
static_assert(sizeof(FRigUnit_MathVectorClampLength) == 0x000040, "Wrong size on FRigUnit_MathVectorClampLength");
static_assert(offsetof(FRigUnit_MathVectorClampLength, Value) == 0x000008, "Member 'FRigUnit_MathVectorClampLength::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampLength, MinimumLength) == 0x000020, "Member 'FRigUnit_MathVectorClampLength::MinimumLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampLength, MaximumLength) == 0x000024, "Member 'FRigUnit_MathVectorClampLength::MaximumLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampLength, Result) == 0x000028, "Member 'FRigUnit_MathVectorClampLength::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Item
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_Item final : public FRigUnit
{
public:
	struct FRigElementKey                         Item;                                              // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Item) == 0x000008, "Wrong alignment on FRigUnit_Item");
static_assert(sizeof(FRigUnit_Item) == 0x000018, "Wrong size on FRigUnit_Item");
static_assert(offsetof(FRigUnit_Item, Item) == 0x000008, "Member 'FRigUnit_Item::Item' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpaceName
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_SpaceName final : public FRigUnit
{
public:
	class FName                                   Space;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpaceName) == 0x000008, "Wrong alignment on FRigUnit_SpaceName");
static_assert(sizeof(FRigUnit_SpaceName) == 0x000010, "Wrong size on FRigUnit_SpaceName");
static_assert(offsetof(FRigUnit_SpaceName, Space) == 0x000008, "Member 'FRigUnit_SpaceName::Space' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorOrthogonal
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorOrthogonal final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorOrthogonal) == 0x000008, "Wrong alignment on FRigUnit_MathVectorOrthogonal");
static_assert(sizeof(FRigUnit_MathVectorOrthogonal) == 0x000040, "Wrong size on FRigUnit_MathVectorOrthogonal");
static_assert(offsetof(FRigUnit_MathVectorOrthogonal, A) == 0x000008, "Member 'FRigUnit_MathVectorOrthogonal::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorOrthogonal, B) == 0x000020, "Member 'FRigUnit_MathVectorOrthogonal::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorOrthogonal, Result) == 0x000038, "Member 'FRigUnit_MathVectorOrthogonal::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CCDIK_RotationLimit
// 0x000C (0x000C - 0x0000)
struct FRigUnit_CCDIK_RotationLimit final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limit;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CCDIK_RotationLimit) == 0x000004, "Wrong alignment on FRigUnit_CCDIK_RotationLimit");
static_assert(sizeof(FRigUnit_CCDIK_RotationLimit) == 0x00000C, "Wrong size on FRigUnit_CCDIK_RotationLimit");
static_assert(offsetof(FRigUnit_CCDIK_RotationLimit, bone) == 0x000000, "Member 'FRigUnit_CCDIK_RotationLimit::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK_RotationLimit, Limit) == 0x000008, "Member 'FRigUnit_CCDIK_RotationLimit::Limit' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatRemap
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_MathFloatRemap final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMinimum;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMaximum;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMinimum;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaximum;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClamp;                                            // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatRemap) == 0x000008, "Wrong alignment on FRigUnit_MathFloatRemap");
static_assert(sizeof(FRigUnit_MathFloatRemap) == 0x000028, "Wrong size on FRigUnit_MathFloatRemap");
static_assert(offsetof(FRigUnit_MathFloatRemap, Value) == 0x000008, "Member 'FRigUnit_MathFloatRemap::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, SourceMinimum) == 0x00000C, "Member 'FRigUnit_MathFloatRemap::SourceMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, SourceMaximum) == 0x000010, "Member 'FRigUnit_MathFloatRemap::SourceMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, TargetMinimum) == 0x000014, "Member 'FRigUnit_MathFloatRemap::TargetMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, TargetMaximum) == 0x000018, "Member 'FRigUnit_MathFloatRemap::TargetMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, bClamp) == 0x00001C, "Member 'FRigUnit_MathFloatRemap::bClamp' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, Result) == 0x000020, "Member 'FRigUnit_MathFloatRemap::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntersectPlane
// 0x0080 (0x0088 - 0x0008)
struct FRigUnit_MathIntersectPlane final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Start;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlanePoint;                                        // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathIntersectPlane) == 0x000008, "Wrong alignment on FRigUnit_MathIntersectPlane");
static_assert(sizeof(FRigUnit_MathIntersectPlane) == 0x000088, "Wrong size on FRigUnit_MathIntersectPlane");
static_assert(offsetof(FRigUnit_MathIntersectPlane, Start) == 0x000008, "Member 'FRigUnit_MathIntersectPlane::Start' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntersectPlane, Direction) == 0x000020, "Member 'FRigUnit_MathIntersectPlane::Direction' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntersectPlane, PlanePoint) == 0x000038, "Member 'FRigUnit_MathIntersectPlane::PlanePoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntersectPlane, PlaneNormal) == 0x000050, "Member 'FRigUnit_MathIntersectPlane::PlaneNormal' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntersectPlane, Result) == 0x000068, "Member 'FRigUnit_MathIntersectPlane::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntersectPlane, Distance) == 0x000080, "Member 'FRigUnit_MathIntersectPlane::Distance' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CCDIK
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_CCDIK final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectorBone;                                      // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EffectorTransform;                                 // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterations;                                     // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFromTail;                                    // 0x014C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseRotationLimit;                                 // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnit_CCDIK_RotationLimit>   RotationLimits;                                    // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_CCDIK_WorkData                WorkData;                                          // 0x0170(0x0060)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CCDIK) == 0x000010, "Wrong alignment on FRigUnit_CCDIK");
static_assert(sizeof(FRigUnit_CCDIK) == 0x0001D0, "Wrong size on FRigUnit_CCDIK");
static_assert(offsetof(FRigUnit_CCDIK, StartBone) == 0x0000D0, "Member 'FRigUnit_CCDIK::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, EffectorBone) == 0x0000D8, "Member 'FRigUnit_CCDIK::EffectorBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, EffectorTransform) == 0x0000E0, "Member 'FRigUnit_CCDIK::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, Precision) == 0x000140, "Member 'FRigUnit_CCDIK::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, Weight) == 0x000144, "Member 'FRigUnit_CCDIK::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, MaxIterations) == 0x000148, "Member 'FRigUnit_CCDIK::MaxIterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, bStartFromTail) == 0x00014C, "Member 'FRigUnit_CCDIK::bStartFromTail' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, BaseRotationLimit) == 0x000150, "Member 'FRigUnit_CCDIK::BaseRotationLimit' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, RotationLimits) == 0x000158, "Member 'FRigUnit_CCDIK::RotationLimits' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, bPropagateToChildren) == 0x000168, "Member 'FRigUnit_CCDIK::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, WorkData) == 0x000170, "Member 'FRigUnit_CCDIK::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CCDIKItemArray
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_CCDIKItemArray final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             EffectorTransform;                                 // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterations;                                     // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFromTail;                                    // 0x014C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseRotationLimit;                                 // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnit_CCDIK_RotationLimitPerItem> RotationLimits;                                    // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_CCDIK_WorkData                WorkData;                                          // 0x0170(0x0060)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CCDIKItemArray) == 0x000010, "Wrong alignment on FRigUnit_CCDIKItemArray");
static_assert(sizeof(FRigUnit_CCDIKItemArray) == 0x0001D0, "Wrong size on FRigUnit_CCDIKItemArray");
static_assert(offsetof(FRigUnit_CCDIKItemArray, Items) == 0x0000D0, "Member 'FRigUnit_CCDIKItemArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, EffectorTransform) == 0x0000E0, "Member 'FRigUnit_CCDIKItemArray::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, Precision) == 0x000140, "Member 'FRigUnit_CCDIKItemArray::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, Weight) == 0x000144, "Member 'FRigUnit_CCDIKItemArray::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, MaxIterations) == 0x000148, "Member 'FRigUnit_CCDIKItemArray::MaxIterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, bStartFromTail) == 0x00014C, "Member 'FRigUnit_CCDIKItemArray::bStartFromTail' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, BaseRotationLimit) == 0x000150, "Member 'FRigUnit_CCDIKItemArray::BaseRotationLimit' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, RotationLimits) == 0x000158, "Member 'FRigUnit_CCDIKItemArray::RotationLimits' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, bPropagateToChildren) == 0x000168, "Member 'FRigUnit_CCDIKItemArray::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIKItemArray, WorkData) == 0x000170, "Member 'FRigUnit_CCDIKItemArray::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ModifyTransforms_WorkData
// 0x0010 (0x0010 - 0x0000)
struct FRigUnit_ModifyTransforms_WorkData
{
public:
	TArray<struct FCachedRigElement>              CachedItems;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ModifyTransforms_WorkData) == 0x000008, "Wrong alignment on FRigUnit_ModifyTransforms_WorkData");
static_assert(sizeof(FRigUnit_ModifyTransforms_WorkData) == 0x000010, "Wrong size on FRigUnit_ModifyTransforms_WorkData");
static_assert(offsetof(FRigUnit_ModifyTransforms_WorkData, CachedItems) == 0x000000, "Member 'FRigUnit_ModifyTransforms_WorkData::CachedItems' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ModifyBoneTransforms_WorkData
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_ModifyBoneTransforms_WorkData final : public FRigUnit_ModifyTransforms_WorkData
{
};
static_assert(alignof(FRigUnit_ModifyBoneTransforms_WorkData) == 0x000008, "Wrong alignment on FRigUnit_ModifyBoneTransforms_WorkData");
static_assert(sizeof(FRigUnit_ModifyBoneTransforms_WorkData) == 0x000010, "Wrong size on FRigUnit_ModifyBoneTransforms_WorkData");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics_Reach
// 0x0048 (0x0048 - 0x0000)
struct FRigUnit_ChainHarmonics_Reach final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReachTarget;                                       // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReachAxis;                                         // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachMinimum;                                      // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachMaximum;                                      // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     ReachEase;                                         // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ChainHarmonics_Reach) == 0x000008, "Wrong alignment on FRigUnit_ChainHarmonics_Reach");
static_assert(sizeof(FRigUnit_ChainHarmonics_Reach) == 0x000048, "Wrong size on FRigUnit_ChainHarmonics_Reach");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, bEnabled) == 0x000000, "Member 'FRigUnit_ChainHarmonics_Reach::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachTarget) == 0x000008, "Member 'FRigUnit_ChainHarmonics_Reach::ReachTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachAxis) == 0x000020, "Member 'FRigUnit_ChainHarmonics_Reach::ReachAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachMinimum) == 0x000038, "Member 'FRigUnit_ChainHarmonics_Reach::ReachMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachMaximum) == 0x00003C, "Member 'FRigUnit_ChainHarmonics_Reach::ReachMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachEase) == 0x000040, "Member 'FRigUnit_ChainHarmonics_Reach::ReachEase' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics_Wave
// 0x0078 (0x0078 - 0x0000)
struct FRigUnit_ChainHarmonics_Wave final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WaveFrequency;                                     // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveAmplitude;                                     // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveOffset;                                        // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveNoise;                                         // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveMinimum;                                       // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveMaximum;                                       // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     WaveEase;                                          // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ChainHarmonics_Wave) == 0x000008, "Wrong alignment on FRigUnit_ChainHarmonics_Wave");
static_assert(sizeof(FRigUnit_ChainHarmonics_Wave) == 0x000078, "Wrong size on FRigUnit_ChainHarmonics_Wave");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, bEnabled) == 0x000000, "Member 'FRigUnit_ChainHarmonics_Wave::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveFrequency) == 0x000008, "Member 'FRigUnit_ChainHarmonics_Wave::WaveFrequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveAmplitude) == 0x000020, "Member 'FRigUnit_ChainHarmonics_Wave::WaveAmplitude' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveOffset) == 0x000038, "Member 'FRigUnit_ChainHarmonics_Wave::WaveOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveNoise) == 0x000050, "Member 'FRigUnit_ChainHarmonics_Wave::WaveNoise' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveMinimum) == 0x000068, "Member 'FRigUnit_ChainHarmonics_Wave::WaveMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveMaximum) == 0x00006C, "Member 'FRigUnit_ChainHarmonics_Wave::WaveMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveEase) == 0x000070, "Member 'FRigUnit_ChainHarmonics_Wave::WaveEase' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics_Pendulum
// 0x0058 (0x0058 - 0x0000)
struct FRigUnit_ChainHarmonics_Pendulum final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PendulumStiffness;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PendulumGravity;                                   // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendulumBlend;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendulumDrag;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendulumMinimum;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendulumMaximum;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     PendulumEase;                                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UnwindAxis;                                        // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnwindMinimum;                                     // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnwindMaximum;                                     // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ChainHarmonics_Pendulum) == 0x000008, "Wrong alignment on FRigUnit_ChainHarmonics_Pendulum");
static_assert(sizeof(FRigUnit_ChainHarmonics_Pendulum) == 0x000058, "Wrong size on FRigUnit_ChainHarmonics_Pendulum");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, bEnabled) == 0x000000, "Member 'FRigUnit_ChainHarmonics_Pendulum::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumStiffness) == 0x000004, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumStiffness' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumGravity) == 0x000008, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumGravity' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumBlend) == 0x000020, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumBlend' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumDrag) == 0x000024, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumDrag' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumMinimum) == 0x000028, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumMaximum) == 0x00002C, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumEase) == 0x000030, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumEase' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, UnwindAxis) == 0x000038, "Member 'FRigUnit_ChainHarmonics_Pendulum::UnwindAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, UnwindMinimum) == 0x000050, "Member 'FRigUnit_ChainHarmonics_Pendulum::UnwindMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, UnwindMaximum) == 0x000054, "Member 'FRigUnit_ChainHarmonics_Pendulum::UnwindMaximum' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics_WorkData
// 0x0098 (0x0098 - 0x0000)
struct FRigUnit_ChainHarmonics_WorkData final
{
public:
	struct FVector                                Time;                                              // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              Items;                                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Ratio;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        LocalTip;                                          // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PendulumTip;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PendulumPosition;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PendulumVelocity;                                  // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        HierarchyLine;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        VelocityLines;                                     // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ChainHarmonics_WorkData) == 0x000008, "Wrong alignment on FRigUnit_ChainHarmonics_WorkData");
static_assert(sizeof(FRigUnit_ChainHarmonics_WorkData) == 0x000098, "Wrong size on FRigUnit_ChainHarmonics_WorkData");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, Time) == 0x000000, "Member 'FRigUnit_ChainHarmonics_WorkData::Time' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, Items) == 0x000018, "Member 'FRigUnit_ChainHarmonics_WorkData::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, Ratio) == 0x000028, "Member 'FRigUnit_ChainHarmonics_WorkData::Ratio' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, LocalTip) == 0x000038, "Member 'FRigUnit_ChainHarmonics_WorkData::LocalTip' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, PendulumTip) == 0x000048, "Member 'FRigUnit_ChainHarmonics_WorkData::PendulumTip' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, PendulumPosition) == 0x000058, "Member 'FRigUnit_ChainHarmonics_WorkData::PendulumPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, PendulumVelocity) == 0x000068, "Member 'FRigUnit_ChainHarmonics_WorkData::PendulumVelocity' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, HierarchyLine) == 0x000078, "Member 'FRigUnit_ChainHarmonics_WorkData::HierarchyLine' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_WorkData, VelocityLines) == 0x000088, "Member 'FRigUnit_ChainHarmonics_WorkData::VelocityLines' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformFromEulerTransform
// 0x00A8 (0x00B0 - 0x0008)
struct FRigUnit_MathTransformFromEulerTransform final : public FRigUnit_MathTransformBase
{
public:
	struct FEulerTransform                        EulerTransform;                                    // 0x0008(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0050(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformFromEulerTransform) == 0x000010, "Wrong alignment on FRigUnit_MathTransformFromEulerTransform");
static_assert(sizeof(FRigUnit_MathTransformFromEulerTransform) == 0x0000B0, "Wrong size on FRigUnit_MathTransformFromEulerTransform");
static_assert(offsetof(FRigUnit_MathTransformFromEulerTransform, EulerTransform) == 0x000008, "Member 'FRigUnit_MathTransformFromEulerTransform::EulerTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromEulerTransform, Result) == 0x000050, "Member 'FRigUnit_MathTransformFromEulerTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics
// 0x02D0 (0x03A0 - 0x00D0)
struct FRigUnit_ChainHarmonics final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   ChainRoot;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Speed;                                             // 0x00D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Reach          Reach;                                             // 0x00F0(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Wave           Wave;                                              // 0x0138(0x0078)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     WaveCurve;                                         // 0x01B0(0x0088)(NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Pendulum       Pendulum;                                          // 0x0238(0x0058)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0290(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0xF];                                      // 0x0291(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DrawWorldOffset;                                   // 0x02A0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_WorkData       WorkData;                                          // 0x0300(0x0098)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ChainHarmonics) == 0x000010, "Wrong alignment on FRigUnit_ChainHarmonics");
static_assert(sizeof(FRigUnit_ChainHarmonics) == 0x0003A0, "Wrong size on FRigUnit_ChainHarmonics");
static_assert(offsetof(FRigUnit_ChainHarmonics, ChainRoot) == 0x0000D0, "Member 'FRigUnit_ChainHarmonics::ChainRoot' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Speed) == 0x0000D8, "Member 'FRigUnit_ChainHarmonics::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Reach) == 0x0000F0, "Member 'FRigUnit_ChainHarmonics::Reach' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Wave) == 0x000138, "Member 'FRigUnit_ChainHarmonics::Wave' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, WaveCurve) == 0x0001B0, "Member 'FRigUnit_ChainHarmonics::WaveCurve' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Pendulum) == 0x000238, "Member 'FRigUnit_ChainHarmonics::Pendulum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, bDrawDebug) == 0x000290, "Member 'FRigUnit_ChainHarmonics::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, DrawWorldOffset) == 0x0002A0, "Member 'FRigUnit_ChainHarmonics::DrawWorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, WorkData) == 0x000300, "Member 'FRigUnit_ChainHarmonics::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonicsPerItem
// 0x02D0 (0x03A0 - 0x00D0)
struct FRigUnit_ChainHarmonicsPerItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         ChainRoot;                                         // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Speed;                                             // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Reach          Reach;                                             // 0x00F8(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Wave           Wave;                                              // 0x0140(0x0078)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     WaveCurve;                                         // 0x01B8(0x0088)(NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Pendulum       Pendulum;                                          // 0x0240(0x0058)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0298(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DrawWorldOffset;                                   // 0x02A0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_WorkData       WorkData;                                          // 0x0300(0x0098)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ChainHarmonicsPerItem) == 0x000010, "Wrong alignment on FRigUnit_ChainHarmonicsPerItem");
static_assert(sizeof(FRigUnit_ChainHarmonicsPerItem) == 0x0003A0, "Wrong size on FRigUnit_ChainHarmonicsPerItem");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, ChainRoot) == 0x0000D0, "Member 'FRigUnit_ChainHarmonicsPerItem::ChainRoot' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, Speed) == 0x0000E0, "Member 'FRigUnit_ChainHarmonicsPerItem::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, Reach) == 0x0000F8, "Member 'FRigUnit_ChainHarmonicsPerItem::Reach' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, Wave) == 0x000140, "Member 'FRigUnit_ChainHarmonicsPerItem::Wave' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, WaveCurve) == 0x0001B8, "Member 'FRigUnit_ChainHarmonicsPerItem::WaveCurve' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, Pendulum) == 0x000240, "Member 'FRigUnit_ChainHarmonicsPerItem::Pendulum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, bDrawDebug) == 0x000298, "Member 'FRigUnit_ChainHarmonicsPerItem::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, DrawWorldOffset) == 0x0002A0, "Member 'FRigUnit_ChainHarmonicsPerItem::DrawWorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonicsPerItem, WorkData) == 0x000300, "Member 'FRigUnit_ChainHarmonicsPerItem::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformMakeAbsolute
// 0x0128 (0x0130 - 0x0008)
struct FRigUnit_MathTransformMakeAbsolute final : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Local;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Parent;                                            // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Global;                                            // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformMakeAbsolute) == 0x000010, "Wrong alignment on FRigUnit_MathTransformMakeAbsolute");
static_assert(sizeof(FRigUnit_MathTransformMakeAbsolute) == 0x000130, "Wrong size on FRigUnit_MathTransformMakeAbsolute");
static_assert(offsetof(FRigUnit_MathTransformMakeAbsolute, Local) == 0x000010, "Member 'FRigUnit_MathTransformMakeAbsolute::Local' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformMakeAbsolute, Parent) == 0x000070, "Member 'FRigUnit_MathTransformMakeAbsolute::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformMakeAbsolute, Global) == 0x0000D0, "Member 'FRigUnit_MathTransformMakeAbsolute::Global' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionChainArray
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_CollectionChainArray final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKey                         FirstItem;                                         // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         LastItem;                                          // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reverse;                                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 Items;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedCollection;                                  // 0x0038(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedHierarchyHash;                               // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionChainArray) == 0x000008, "Wrong alignment on FRigUnit_CollectionChainArray");
static_assert(sizeof(FRigUnit_CollectionChainArray) == 0x000050, "Wrong size on FRigUnit_CollectionChainArray");
static_assert(offsetof(FRigUnit_CollectionChainArray, FirstItem) == 0x000008, "Member 'FRigUnit_CollectionChainArray::FirstItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChainArray, LastItem) == 0x000014, "Member 'FRigUnit_CollectionChainArray::LastItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChainArray, Reverse) == 0x000020, "Member 'FRigUnit_CollectionChainArray::Reverse' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChainArray, Items) == 0x000028, "Member 'FRigUnit_CollectionChainArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChainArray, CachedCollection) == 0x000038, "Member 'FRigUnit_CollectionChainArray::CachedCollection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChainArray, CachedHierarchyHash) == 0x000048, "Member 'FRigUnit_CollectionChainArray::CachedHierarchyHash' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionNameSearchArray
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_CollectionNameSearchArray final : public FRigUnit_CollectionBase
{
public:
	class FName                                   PartialName;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               TypeToSearch;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 Items;                                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedCollection;                                  // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedHierarchyHash;                               // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionNameSearchArray) == 0x000008, "Wrong alignment on FRigUnit_CollectionNameSearchArray");
static_assert(sizeof(FRigUnit_CollectionNameSearchArray) == 0x000040, "Wrong size on FRigUnit_CollectionNameSearchArray");
static_assert(offsetof(FRigUnit_CollectionNameSearchArray, PartialName) == 0x000008, "Member 'FRigUnit_CollectionNameSearchArray::PartialName' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionNameSearchArray, TypeToSearch) == 0x000010, "Member 'FRigUnit_CollectionNameSearchArray::TypeToSearch' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionNameSearchArray, Items) == 0x000018, "Member 'FRigUnit_CollectionNameSearchArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionNameSearchArray, CachedCollection) == 0x000028, "Member 'FRigUnit_CollectionNameSearchArray::CachedCollection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionNameSearchArray, CachedHierarchyHash) == 0x000038, "Member 'FRigUnit_CollectionNameSearchArray::CachedHierarchyHash' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformSelectBool
// 0x0128 (0x0130 - 0x0008)
struct FRigUnit_MathTransformSelectBool final : public FRigUnit_MathTransformBase
{
public:
	bool                                          Condition;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IfTrue;                                            // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             IfFalse;                                           // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformSelectBool) == 0x000010, "Wrong alignment on FRigUnit_MathTransformSelectBool");
static_assert(sizeof(FRigUnit_MathTransformSelectBool) == 0x000130, "Wrong size on FRigUnit_MathTransformSelectBool");
static_assert(offsetof(FRigUnit_MathTransformSelectBool, Condition) == 0x000008, "Member 'FRigUnit_MathTransformSelectBool::Condition' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformSelectBool, IfTrue) == 0x000010, "Member 'FRigUnit_MathTransformSelectBool::IfTrue' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformSelectBool, IfFalse) == 0x000070, "Member 'FRigUnit_MathTransformSelectBool::IfFalse' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformSelectBool, Result) == 0x0000D0, "Member 'FRigUnit_MathTransformSelectBool::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionChildren
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_CollectionChildren final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKey                         Parent;                                            // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeParent;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursive;                                        // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               TypeToSearch;                                      // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Collection;                                        // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedCollection;                                  // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedHierarchyHash;                               // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionChildren) == 0x000008, "Wrong alignment on FRigUnit_CollectionChildren");
static_assert(sizeof(FRigUnit_CollectionChildren) == 0x000040, "Wrong size on FRigUnit_CollectionChildren");
static_assert(offsetof(FRigUnit_CollectionChildren, Parent) == 0x000008, "Member 'FRigUnit_CollectionChildren::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildren, bIncludeParent) == 0x000014, "Member 'FRigUnit_CollectionChildren::bIncludeParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildren, bRecursive) == 0x000015, "Member 'FRigUnit_CollectionChildren::bRecursive' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildren, TypeToSearch) == 0x000016, "Member 'FRigUnit_CollectionChildren::TypeToSearch' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildren, Collection) == 0x000018, "Member 'FRigUnit_CollectionChildren::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildren, CachedCollection) == 0x000028, "Member 'FRigUnit_CollectionChildren::CachedCollection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildren, CachedHierarchyHash) == 0x000038, "Member 'FRigUnit_CollectionChildren::CachedHierarchyHash' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionChildrenArray
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_CollectionChildrenArray final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKey                         Parent;                                            // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeParent;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursive;                                        // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               TypeToSearch;                                      // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 Items;                                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedCollection;                                  // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedHierarchyHash;                               // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionChildrenArray) == 0x000008, "Wrong alignment on FRigUnit_CollectionChildrenArray");
static_assert(sizeof(FRigUnit_CollectionChildrenArray) == 0x000040, "Wrong size on FRigUnit_CollectionChildrenArray");
static_assert(offsetof(FRigUnit_CollectionChildrenArray, Parent) == 0x000008, "Member 'FRigUnit_CollectionChildrenArray::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildrenArray, bIncludeParent) == 0x000014, "Member 'FRigUnit_CollectionChildrenArray::bIncludeParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildrenArray, bRecursive) == 0x000015, "Member 'FRigUnit_CollectionChildrenArray::bRecursive' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildrenArray, TypeToSearch) == 0x000016, "Member 'FRigUnit_CollectionChildrenArray::TypeToSearch' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildrenArray, Items) == 0x000018, "Member 'FRigUnit_CollectionChildrenArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildrenArray, CachedCollection) == 0x000028, "Member 'FRigUnit_CollectionChildrenArray::CachedCollection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionChildrenArray, CachedHierarchyHash) == 0x000038, "Member 'FRigUnit_CollectionChildrenArray::CachedHierarchyHash' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionReplaceItemsArray
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_CollectionReplaceItemsArray final : public FRigUnit_CollectionBase
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Old;                                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   New;                                               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveInvalidItems;                                // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDuplicates;                                  // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 Result;                                            // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedCollection;                                  // 0x0040(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedHierarchyHash;                               // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CollectionReplaceItemsArray) == 0x000008, "Wrong alignment on FRigUnit_CollectionReplaceItemsArray");
static_assert(sizeof(FRigUnit_CollectionReplaceItemsArray) == 0x000058, "Wrong size on FRigUnit_CollectionReplaceItemsArray");
static_assert(offsetof(FRigUnit_CollectionReplaceItemsArray, Items) == 0x000008, "Member 'FRigUnit_CollectionReplaceItemsArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItemsArray, Old) == 0x000018, "Member 'FRigUnit_CollectionReplaceItemsArray::Old' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItemsArray, New) == 0x000020, "Member 'FRigUnit_CollectionReplaceItemsArray::New' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItemsArray, RemoveInvalidItems) == 0x000028, "Member 'FRigUnit_CollectionReplaceItemsArray::RemoveInvalidItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItemsArray, bAllowDuplicates) == 0x000029, "Member 'FRigUnit_CollectionReplaceItemsArray::bAllowDuplicates' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItemsArray, Result) == 0x000030, "Member 'FRigUnit_CollectionReplaceItemsArray::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItemsArray, CachedCollection) == 0x000040, "Member 'FRigUnit_CollectionReplaceItemsArray::CachedCollection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReplaceItemsArray, CachedHierarchyHash) == 0x000050, "Member 'FRigUnit_CollectionReplaceItemsArray::CachedHierarchyHash' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformClampSpatially
// 0x0158 (0x0160 - 0x0008)
struct FRigUnit_MathTransformClampSpatially final : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAxis                                         Axis;                                              // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigClampSpatialMode                   Type;                                              // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Minimum;                                           // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Space;                                             // 0x0080(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DebugColor;                                        // 0x00E4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugThickness;                                    // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0100(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformClampSpatially) == 0x000010, "Wrong alignment on FRigUnit_MathTransformClampSpatially");
static_assert(sizeof(FRigUnit_MathTransformClampSpatially) == 0x000160, "Wrong size on FRigUnit_MathTransformClampSpatially");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, Value) == 0x000010, "Member 'FRigUnit_MathTransformClampSpatially::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, Axis) == 0x000070, "Member 'FRigUnit_MathTransformClampSpatially::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, Type) == 0x000071, "Member 'FRigUnit_MathTransformClampSpatially::Type' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, Minimum) == 0x000074, "Member 'FRigUnit_MathTransformClampSpatially::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, Maximum) == 0x000078, "Member 'FRigUnit_MathTransformClampSpatially::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, Space) == 0x000080, "Member 'FRigUnit_MathTransformClampSpatially::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, bDrawDebug) == 0x0000E0, "Member 'FRigUnit_MathTransformClampSpatially::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, DebugColor) == 0x0000E4, "Member 'FRigUnit_MathTransformClampSpatially::DebugColor' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, DebugThickness) == 0x0000F4, "Member 'FRigUnit_MathTransformClampSpatially::DebugThickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformClampSpatially, Result) == 0x000100, "Member 'FRigUnit_MathTransformClampSpatially::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionItems
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_CollectionItems final : public FRigUnit_CollectionBase
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAllowDuplicates;                                  // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Collection;                                        // 0x0020(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionItems) == 0x000008, "Wrong alignment on FRigUnit_CollectionItems");
static_assert(sizeof(FRigUnit_CollectionItems) == 0x000030, "Wrong size on FRigUnit_CollectionItems");
static_assert(offsetof(FRigUnit_CollectionItems, Items) == 0x000008, "Member 'FRigUnit_CollectionItems::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionItems, bAllowDuplicates) == 0x000018, "Member 'FRigUnit_CollectionItems::bAllowDuplicates' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionItems, Collection) == 0x000020, "Member 'FRigUnit_CollectionItems::Collection' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionGetItems
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_CollectionGetItems final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               Collection;                                        // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigElementKey>                 Items;                                             // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionGetItems) == 0x000008, "Wrong alignment on FRigUnit_CollectionGetItems");
static_assert(sizeof(FRigUnit_CollectionGetItems) == 0x000028, "Wrong size on FRigUnit_CollectionGetItems");
static_assert(offsetof(FRigUnit_CollectionGetItems, Collection) == 0x000008, "Member 'FRigUnit_CollectionGetItems::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionGetItems, Items) == 0x000018, "Member 'FRigUnit_CollectionGetItems::Items' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PointSimulation_BoneTarget
// 0x0014 (0x0014 - 0x0000)
struct FRigUnit_PointSimulation_BoneTarget final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslationPoint;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryAimPoint;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryAimPoint;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PointSimulation_BoneTarget) == 0x000004, "Wrong alignment on FRigUnit_PointSimulation_BoneTarget");
static_assert(sizeof(FRigUnit_PointSimulation_BoneTarget) == 0x000014, "Wrong size on FRigUnit_PointSimulation_BoneTarget");
static_assert(offsetof(FRigUnit_PointSimulation_BoneTarget, bone) == 0x000000, "Member 'FRigUnit_PointSimulation_BoneTarget::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_BoneTarget, TranslationPoint) == 0x000008, "Member 'FRigUnit_PointSimulation_BoneTarget::TranslationPoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_BoneTarget, PrimaryAimPoint) == 0x00000C, "Member 'FRigUnit_PointSimulation_BoneTarget::PrimaryAimPoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_BoneTarget, SecondaryAimPoint) == 0x000010, "Member 'FRigUnit_PointSimulation_BoneTarget::SecondaryAimPoint' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionGetParentIndicesItemArray
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_CollectionGetParentIndicesItemArray final : public FRigUnit_CollectionBase
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ParentIndices;                                     // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionGetParentIndicesItemArray) == 0x000008, "Wrong alignment on FRigUnit_CollectionGetParentIndicesItemArray");
static_assert(sizeof(FRigUnit_CollectionGetParentIndicesItemArray) == 0x000028, "Wrong size on FRigUnit_CollectionGetParentIndicesItemArray");
static_assert(offsetof(FRigUnit_CollectionGetParentIndicesItemArray, Items) == 0x000008, "Member 'FRigUnit_CollectionGetParentIndicesItemArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionGetParentIndicesItemArray, ParentIndices) == 0x000018, "Member 'FRigUnit_CollectionGetParentIndicesItemArray::ParentIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionIntersection
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_CollectionIntersection final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               A;                                                 // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               B;                                                 // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               Collection;                                        // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionIntersection) == 0x000008, "Wrong alignment on FRigUnit_CollectionIntersection");
static_assert(sizeof(FRigUnit_CollectionIntersection) == 0x000038, "Wrong size on FRigUnit_CollectionIntersection");
static_assert(offsetof(FRigUnit_CollectionIntersection, A) == 0x000008, "Member 'FRigUnit_CollectionIntersection::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionIntersection, B) == 0x000018, "Member 'FRigUnit_CollectionIntersection::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionIntersection, Collection) == 0x000028, "Member 'FRigUnit_CollectionIntersection::Collection' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionDifference
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_CollectionDifference final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               A;                                                 // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               B;                                                 // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               Collection;                                        // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionDifference) == 0x000008, "Wrong alignment on FRigUnit_CollectionDifference");
static_assert(sizeof(FRigUnit_CollectionDifference) == 0x000038, "Wrong size on FRigUnit_CollectionDifference");
static_assert(offsetof(FRigUnit_CollectionDifference, A) == 0x000008, "Member 'FRigUnit_CollectionDifference::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionDifference, B) == 0x000018, "Member 'FRigUnit_CollectionDifference::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionDifference, Collection) == 0x000028, "Member 'FRigUnit_CollectionDifference::Collection' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PrepareForExecution
// 0x00C8 (0x00D0 - 0x0008)
struct FRigUnit_PrepareForExecution final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              ExecuteContext;                                    // 0x0010(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PrepareForExecution) == 0x000010, "Wrong alignment on FRigUnit_PrepareForExecution");
static_assert(sizeof(FRigUnit_PrepareForExecution) == 0x0000D0, "Wrong size on FRigUnit_PrepareForExecution");
static_assert(offsetof(FRigUnit_PrepareForExecution, ExecuteContext) == 0x000010, "Member 'FRigUnit_PrepareForExecution::ExecuteContext' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionReverse
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_CollectionReverse final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               Collection;                                        // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               Reversed;                                          // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionReverse) == 0x000008, "Wrong alignment on FRigUnit_CollectionReverse");
static_assert(sizeof(FRigUnit_CollectionReverse) == 0x000028, "Wrong size on FRigUnit_CollectionReverse");
static_assert(offsetof(FRigUnit_CollectionReverse, Collection) == 0x000008, "Member 'FRigUnit_CollectionReverse::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionReverse, Reversed) == 0x000018, "Member 'FRigUnit_CollectionReverse::Reversed' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionItemAtIndex
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_CollectionItemAtIndex final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               Collection;                                        // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Item;                                              // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionItemAtIndex) == 0x000008, "Wrong alignment on FRigUnit_CollectionItemAtIndex");
static_assert(sizeof(FRigUnit_CollectionItemAtIndex) == 0x000028, "Wrong size on FRigUnit_CollectionItemAtIndex");
static_assert(offsetof(FRigUnit_CollectionItemAtIndex, Collection) == 0x000008, "Member 'FRigUnit_CollectionItemAtIndex::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionItemAtIndex, Index) == 0x000018, "Member 'FRigUnit_CollectionItemAtIndex::Index' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionItemAtIndex, Item) == 0x00001C, "Member 'FRigUnit_CollectionItemAtIndex::Item' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PropagateTransform
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_PropagateTransform final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecomputeGlobal;                                  // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToChildren;                                  // 0x00DD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursive;                                        // 0x00DE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF[0x1];                                       // 0x00DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedIndex;                                       // 0x00E0(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PropagateTransform) == 0x000010, "Wrong alignment on FRigUnit_PropagateTransform");
static_assert(sizeof(FRigUnit_PropagateTransform) == 0x000100, "Wrong size on FRigUnit_PropagateTransform");
static_assert(offsetof(FRigUnit_PropagateTransform, Item) == 0x0000D0, "Member 'FRigUnit_PropagateTransform::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_PropagateTransform, bRecomputeGlobal) == 0x0000DC, "Member 'FRigUnit_PropagateTransform::bRecomputeGlobal' has a wrong offset!");
static_assert(offsetof(FRigUnit_PropagateTransform, bApplyToChildren) == 0x0000DD, "Member 'FRigUnit_PropagateTransform::bApplyToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_PropagateTransform, bRecursive) == 0x0000DE, "Member 'FRigUnit_PropagateTransform::bRecursive' has a wrong offset!");
static_assert(offsetof(FRigUnit_PropagateTransform, CachedIndex) == 0x0000E0, "Member 'FRigUnit_PropagateTransform::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CollectionAddItem
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_CollectionAddItem final : public FRigUnit_CollectionBase
{
public:
	struct FRigElementKeyCollection               Collection;                                        // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Item;                                              // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Result;                                            // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CollectionAddItem) == 0x000008, "Wrong alignment on FRigUnit_CollectionAddItem");
static_assert(sizeof(FRigUnit_CollectionAddItem) == 0x000038, "Wrong size on FRigUnit_CollectionAddItem");
static_assert(offsetof(FRigUnit_CollectionAddItem, Collection) == 0x000008, "Member 'FRigUnit_CollectionAddItem::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionAddItem, Item) == 0x000018, "Member 'FRigUnit_CollectionAddItem::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_CollectionAddItem, Result) == 0x000028, "Member 'FRigUnit_CollectionAddItem::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_UnaryQuaternionOp
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_UnaryQuaternionOp : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Argument;                                          // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_UnaryQuaternionOp) == 0x000010, "Wrong alignment on FRigUnit_UnaryQuaternionOp");
static_assert(sizeof(FRigUnit_UnaryQuaternionOp) == 0x000050, "Wrong size on FRigUnit_UnaryQuaternionOp");
static_assert(offsetof(FRigUnit_UnaryQuaternionOp, Argument) == 0x000010, "Member 'FRigUnit_UnaryQuaternionOp::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_UnaryQuaternionOp, Result) == 0x000030, "Member 'FRigUnit_UnaryQuaternionOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_InverseQuaterion
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_InverseQuaterion final : public FRigUnit_UnaryQuaternionOp
{
};
static_assert(alignof(FRigUnit_InverseQuaterion) == 0x000010, "Wrong alignment on FRigUnit_InverseQuaterion");
static_assert(sizeof(FRigUnit_InverseQuaterion) == 0x000050, "Wrong size on FRigUnit_InverseQuaterion");

// ScriptStruct ControlRig.RigUnit_ConvertTransform
// 0x00B8 (0x00C0 - 0x0008)
struct FRigUnit_ConvertTransform final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Input;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEulerTransform                        Result;                                            // 0x0070(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertTransform) == 0x000010, "Wrong alignment on FRigUnit_ConvertTransform");
static_assert(sizeof(FRigUnit_ConvertTransform) == 0x0000C0, "Wrong size on FRigUnit_ConvertTransform");
static_assert(offsetof(FRigUnit_ConvertTransform, Input) == 0x000010, "Member 'FRigUnit_ConvertTransform::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertTransform, Result) == 0x000070, "Member 'FRigUnit_ConvertTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertEulerTransform
// 0x00A8 (0x00B0 - 0x0008)
struct FRigUnit_ConvertEulerTransform final : public FRigUnit
{
public:
	struct FEulerTransform                        Input;                                             // 0x0008(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0050(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertEulerTransform) == 0x000010, "Wrong alignment on FRigUnit_ConvertEulerTransform");
static_assert(sizeof(FRigUnit_ConvertEulerTransform) == 0x0000B0, "Wrong size on FRigUnit_ConvertEulerTransform");
static_assert(offsetof(FRigUnit_ConvertEulerTransform, Input) == 0x000008, "Member 'FRigUnit_ConvertEulerTransform::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertEulerTransform, Result) == 0x000050, "Member 'FRigUnit_ConvertEulerTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertRotation
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_ConvertRotation : public FRigUnit
{
public:
	struct FRotator                               Input;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0020(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertRotation) == 0x000010, "Wrong alignment on FRigUnit_ConvertRotation");
static_assert(sizeof(FRigUnit_ConvertRotation) == 0x000040, "Wrong size on FRigUnit_ConvertRotation");
static_assert(offsetof(FRigUnit_ConvertRotation, Input) == 0x000008, "Member 'FRigUnit_ConvertRotation::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertRotation, Result) == 0x000020, "Member 'FRigUnit_ConvertRotation::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertVectorRotation
// 0x0000 (0x0040 - 0x0040)
struct FRigUnit_ConvertVectorRotation final : public FRigUnit_ConvertRotation
{
};
static_assert(alignof(FRigUnit_ConvertVectorRotation) == 0x000010, "Wrong alignment on FRigUnit_ConvertVectorRotation");
static_assert(sizeof(FRigUnit_ConvertVectorRotation) == 0x000040, "Wrong size on FRigUnit_ConvertVectorRotation");

// ScriptStruct ControlRig.RigUnit_ConvertQuaternion
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_ConvertQuaternion final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Input;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Result;                                            // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertQuaternion) == 0x000010, "Wrong alignment on FRigUnit_ConvertQuaternion");
static_assert(sizeof(FRigUnit_ConvertQuaternion) == 0x000050, "Wrong size on FRigUnit_ConvertQuaternion");
static_assert(offsetof(FRigUnit_ConvertQuaternion, Input) == 0x000010, "Member 'FRigUnit_ConvertQuaternion::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertQuaternion, Result) == 0x000030, "Member 'FRigUnit_ConvertQuaternion::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathBoolBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathBoolBase) == 0x000008, "Wrong alignment on FRigUnit_MathBoolBase");
static_assert(sizeof(FRigUnit_MathBoolBase) == 0x000008, "Wrong size on FRigUnit_MathBoolBase");

// ScriptStruct ControlRig.RigUnit_MathBoolToggled
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathBoolToggled final : public FRigUnit_MathBoolBase
{
public:
	bool                                          Value;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Toggled;                                           // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Initialized;                                       // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LastValue;                                         // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolToggled) == 0x000008, "Wrong alignment on FRigUnit_MathBoolToggled");
static_assert(sizeof(FRigUnit_MathBoolToggled) == 0x000010, "Wrong size on FRigUnit_MathBoolToggled");
static_assert(offsetof(FRigUnit_MathBoolToggled, Value) == 0x000008, "Member 'FRigUnit_MathBoolToggled::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolToggled, Toggled) == 0x000009, "Member 'FRigUnit_MathBoolToggled::Toggled' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolToggled, Initialized) == 0x00000A, "Member 'FRigUnit_MathBoolToggled::Initialized' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolToggled, LastValue) == 0x00000B, "Member 'FRigUnit_MathBoolToggled::LastValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertVectorToRotation
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_ConvertVectorToRotation final : public FRigUnit
{
public:
	struct FVector                                Input;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Result;                                            // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertVectorToRotation) == 0x000008, "Wrong alignment on FRigUnit_ConvertVectorToRotation");
static_assert(sizeof(FRigUnit_ConvertVectorToRotation) == 0x000038, "Wrong size on FRigUnit_ConvertVectorToRotation");
static_assert(offsetof(FRigUnit_ConvertVectorToRotation, Input) == 0x000008, "Member 'FRigUnit_ConvertVectorToRotation::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertVectorToRotation, Result) == 0x000020, "Member 'FRigUnit_ConvertVectorToRotation::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertVectorToQuaternion
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_ConvertVectorToQuaternion final : public FRigUnit
{
public:
	struct FVector                                Input;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0020(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertVectorToQuaternion) == 0x000010, "Wrong alignment on FRigUnit_ConvertVectorToQuaternion");
static_assert(sizeof(FRigUnit_ConvertVectorToQuaternion) == 0x000040, "Wrong size on FRigUnit_ConvertVectorToQuaternion");
static_assert(offsetof(FRigUnit_ConvertVectorToQuaternion, Input) == 0x000008, "Member 'FRigUnit_ConvertVectorToQuaternion::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertVectorToQuaternion, Result) == 0x000020, "Member 'FRigUnit_ConvertVectorToQuaternion::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertRotationToVector
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_ConvertRotationToVector final : public FRigUnit
{
public:
	struct FRotator                               Input;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertRotationToVector) == 0x000008, "Wrong alignment on FRigUnit_ConvertRotationToVector");
static_assert(sizeof(FRigUnit_ConvertRotationToVector) == 0x000038, "Wrong size on FRigUnit_ConvertRotationToVector");
static_assert(offsetof(FRigUnit_ConvertRotationToVector, Input) == 0x000008, "Member 'FRigUnit_ConvertRotationToVector::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertRotationToVector, Result) == 0x000020, "Member 'FRigUnit_ConvertRotationToVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatConstant
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathFloatConstant : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatConstant) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstant");
static_assert(sizeof(FRigUnit_MathFloatConstant) == 0x000010, "Wrong size on FRigUnit_MathFloatConstant");
static_assert(offsetof(FRigUnit_MathFloatConstant, Value) == 0x000008, "Member 'FRigUnit_MathFloatConstant::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatConstTwoPi
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatConstTwoPi final : public FRigUnit_MathFloatConstant
{
};
static_assert(alignof(FRigUnit_MathFloatConstTwoPi) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstTwoPi");
static_assert(sizeof(FRigUnit_MathFloatConstTwoPi) == 0x000010, "Wrong size on FRigUnit_MathFloatConstTwoPi");

// ScriptStruct ControlRig.RigUnit_ConvertQuaternionToVector
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_ConvertQuaternionToVector final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Input;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertQuaternionToVector) == 0x000010, "Wrong alignment on FRigUnit_ConvertQuaternionToVector");
static_assert(sizeof(FRigUnit_ConvertQuaternionToVector) == 0x000050, "Wrong size on FRigUnit_ConvertQuaternionToVector");
static_assert(offsetof(FRigUnit_ConvertQuaternionToVector, Input) == 0x000010, "Member 'FRigUnit_ConvertQuaternionToVector::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertQuaternionToVector, Result) == 0x000030, "Member 'FRigUnit_ConvertQuaternionToVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatLawOfCosine
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_MathFloatLawOfCosine final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         C;                                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaAngle;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BetaAngle;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GammaAngle;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatLawOfCosine) == 0x000008, "Wrong alignment on FRigUnit_MathFloatLawOfCosine");
static_assert(sizeof(FRigUnit_MathFloatLawOfCosine) == 0x000028, "Wrong size on FRigUnit_MathFloatLawOfCosine");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, A) == 0x000008, "Member 'FRigUnit_MathFloatLawOfCosine::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, B) == 0x00000C, "Member 'FRigUnit_MathFloatLawOfCosine::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, C) == 0x000010, "Member 'FRigUnit_MathFloatLawOfCosine::C' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, AlphaAngle) == 0x000014, "Member 'FRigUnit_MathFloatLawOfCosine::AlphaAngle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, BetaAngle) == 0x000018, "Member 'FRigUnit_MathFloatLawOfCosine::BetaAngle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, GammaAngle) == 0x00001C, "Member 'FRigUnit_MathFloatLawOfCosine::GammaAngle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, bValid) == 0x000020, "Member 'FRigUnit_MathFloatLawOfCosine::bValid' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToSwingAndTwist
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_ToSwingAndTwist final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Input;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TwistAxis;                                         // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Swing;                                             // 0x0050(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Twist;                                             // 0x0070(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToSwingAndTwist) == 0x000010, "Wrong alignment on FRigUnit_ToSwingAndTwist");
static_assert(sizeof(FRigUnit_ToSwingAndTwist) == 0x000090, "Wrong size on FRigUnit_ToSwingAndTwist");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Input) == 0x000010, "Member 'FRigUnit_ToSwingAndTwist::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, TwistAxis) == 0x000030, "Member 'FRigUnit_ToSwingAndTwist::TwistAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Swing) == 0x000050, "Member 'FRigUnit_ToSwingAndTwist::Swing' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Twist) == 0x000070, "Member 'FRigUnit_ToSwingAndTwist::Twist' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugBaseMutable
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_DebugBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_DebugBaseMutable) == 0x000010, "Wrong alignment on FRigUnit_DebugBaseMutable");
static_assert(sizeof(FRigUnit_DebugBaseMutable) == 0x0000D0, "Wrong size on FRigUnit_DebugBaseMutable");

// ScriptStruct ControlRig.RigUnit_MathFloatBinaryOp
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatBinaryOp : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatBinaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathFloatBinaryOp");
static_assert(sizeof(FRigUnit_MathFloatBinaryOp) == 0x000018, "Wrong size on FRigUnit_MathFloatBinaryOp");
static_assert(offsetof(FRigUnit_MathFloatBinaryOp, A) == 0x000008, "Member 'FRigUnit_MathFloatBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatBinaryOp, B) == 0x00000C, "Member 'FRigUnit_MathFloatBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatBinaryOp, Result) == 0x000010, "Member 'FRigUnit_MathFloatBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatMul
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathFloatMul final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatMul) == 0x000008, "Wrong alignment on FRigUnit_MathFloatMul");
static_assert(sizeof(FRigUnit_MathFloatMul) == 0x000018, "Wrong size on FRigUnit_MathFloatMul");

// ScriptStruct ControlRig.RigUnit_DebugBezier
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_DebugBezier final : public FRigUnit_DebugBaseMutable
{
public:
	struct FCRFourPointBezier                     Bezier;                                            // 0x00D0(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinimumU;                                          // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumU;                                          // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0138(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Detail;                                            // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugBezier) == 0x000010, "Wrong alignment on FRigUnit_DebugBezier");
static_assert(sizeof(FRigUnit_DebugBezier) == 0x0001D0, "Wrong size on FRigUnit_DebugBezier");
static_assert(offsetof(FRigUnit_DebugBezier, Bezier) == 0x0000D0, "Member 'FRigUnit_DebugBezier::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, MinimumU) == 0x000130, "Member 'FRigUnit_DebugBezier::MinimumU' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, MaximumU) == 0x000134, "Member 'FRigUnit_DebugBezier::MaximumU' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, Color) == 0x000138, "Member 'FRigUnit_DebugBezier::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, Thickness) == 0x000148, "Member 'FRigUnit_DebugBezier::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, Detail) == 0x00014C, "Member 'FRigUnit_DebugBezier::Detail' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, Space) == 0x000150, "Member 'FRigUnit_DebugBezier::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, WorldOffset) == 0x000160, "Member 'FRigUnit_DebugBezier::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, bEnabled) == 0x0001C0, "Member 'FRigUnit_DebugBezier::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugBezierItemSpace
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_DebugBezierItemSpace final : public FRigUnit_DebugBaseMutable
{
public:
	struct FCRFourPointBezier                     Bezier;                                            // 0x00D0(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinimumU;                                          // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumU;                                          // 0x0134(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0138(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Detail;                                            // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x0150(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugBezierItemSpace) == 0x000010, "Wrong alignment on FRigUnit_DebugBezierItemSpace");
static_assert(sizeof(FRigUnit_DebugBezierItemSpace) == 0x0001D0, "Wrong size on FRigUnit_DebugBezierItemSpace");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, Bezier) == 0x0000D0, "Member 'FRigUnit_DebugBezierItemSpace::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, MinimumU) == 0x000130, "Member 'FRigUnit_DebugBezierItemSpace::MinimumU' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, MaximumU) == 0x000134, "Member 'FRigUnit_DebugBezierItemSpace::MaximumU' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, Color) == 0x000138, "Member 'FRigUnit_DebugBezierItemSpace::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, Thickness) == 0x000148, "Member 'FRigUnit_DebugBezierItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, Detail) == 0x00014C, "Member 'FRigUnit_DebugBezierItemSpace::Detail' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, Space) == 0x000150, "Member 'FRigUnit_DebugBezierItemSpace::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, WorldOffset) == 0x000160, "Member 'FRigUnit_DebugBezierItemSpace::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezierItemSpace, bEnabled) == 0x0001C0, "Member 'FRigUnit_DebugBezierItemSpace::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugHierarchy
// 0x0090 (0x0160 - 0x00D0)
struct FRigUnit_DebugHierarchy final : public FRigUnit_DebugBaseMutable
{
public:
	float                                         Scale;                                             // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x00D4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0xF];                                      // 0x0151(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugHierarchy) == 0x000010, "Wrong alignment on FRigUnit_DebugHierarchy");
static_assert(sizeof(FRigUnit_DebugHierarchy) == 0x000160, "Wrong size on FRigUnit_DebugHierarchy");
static_assert(offsetof(FRigUnit_DebugHierarchy, Scale) == 0x0000D0, "Member 'FRigUnit_DebugHierarchy::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, Color) == 0x0000D4, "Member 'FRigUnit_DebugHierarchy::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, Thickness) == 0x0000E4, "Member 'FRigUnit_DebugHierarchy::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, WorldOffset) == 0x0000F0, "Member 'FRigUnit_DebugHierarchy::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, bEnabled) == 0x000150, "Member 'FRigUnit_DebugHierarchy::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugPose
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_DebugPose final : public FRigUnit_DebugBaseMutable
{
public:
	struct FRigPose                               Pose;                                              // 0x00D0(0x0070)(NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0144(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugPose) == 0x000010, "Wrong alignment on FRigUnit_DebugPose");
static_assert(sizeof(FRigUnit_DebugPose) == 0x0001D0, "Wrong size on FRigUnit_DebugPose");
static_assert(offsetof(FRigUnit_DebugPose, Pose) == 0x0000D0, "Member 'FRigUnit_DebugPose::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPose, Scale) == 0x000140, "Member 'FRigUnit_DebugPose::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPose, Color) == 0x000144, "Member 'FRigUnit_DebugPose::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPose, Thickness) == 0x000154, "Member 'FRigUnit_DebugPose::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPose, WorldOffset) == 0x000160, "Member 'FRigUnit_DebugPose::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPose, bEnabled) == 0x0001C0, "Member 'FRigUnit_DebugPose::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatMax
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathFloatMax final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatMax) == 0x000008, "Wrong alignment on FRigUnit_MathFloatMax");
static_assert(sizeof(FRigUnit_MathFloatMax) == 0x000018, "Wrong size on FRigUnit_MathFloatMax");

// ScriptStruct ControlRig.RigUnit_DebugLine
// 0x00C0 (0x0190 - 0x00D0)
struct FRigUnit_DebugLine final : public FRigUnit_DebugBaseMutable
{
public:
	struct FVector                                A;                                                 // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x00E8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0100(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0114(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0120(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugLine) == 0x000010, "Wrong alignment on FRigUnit_DebugLine");
static_assert(sizeof(FRigUnit_DebugLine) == 0x000190, "Wrong size on FRigUnit_DebugLine");
static_assert(offsetof(FRigUnit_DebugLine, A) == 0x0000D0, "Member 'FRigUnit_DebugLine::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, B) == 0x0000E8, "Member 'FRigUnit_DebugLine::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, Color) == 0x000100, "Member 'FRigUnit_DebugLine::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, Thickness) == 0x000110, "Member 'FRigUnit_DebugLine::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, Space) == 0x000114, "Member 'FRigUnit_DebugLine::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, WorldOffset) == 0x000120, "Member 'FRigUnit_DebugLine::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, bEnabled) == 0x000180, "Member 'FRigUnit_DebugLine::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolBinaryOp
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathBoolBinaryOp : public FRigUnit_MathBoolBase
{
public:
	bool                                          A;                                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolBinaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathBoolBinaryOp");
static_assert(sizeof(FRigUnit_MathBoolBinaryOp) == 0x000010, "Wrong size on FRigUnit_MathBoolBinaryOp");
static_assert(offsetof(FRigUnit_MathBoolBinaryOp, A) == 0x000008, "Member 'FRigUnit_MathBoolBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolBinaryOp, B) == 0x000009, "Member 'FRigUnit_MathBoolBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolBinaryOp, Result) == 0x00000A, "Member 'FRigUnit_MathBoolBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolNand
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathBoolNand final : public FRigUnit_MathBoolBinaryOp
{
};
static_assert(alignof(FRigUnit_MathBoolNand) == 0x000008, "Wrong alignment on FRigUnit_MathBoolNand");
static_assert(sizeof(FRigUnit_MathBoolNand) == 0x000010, "Wrong size on FRigUnit_MathBoolNand");

// ScriptStruct ControlRig.RigUnit_DebugLineItemSpace
// 0x00C0 (0x0190 - 0x00D0)
struct FRigUnit_DebugLineItemSpace final : public FRigUnit_DebugBaseMutable
{
public:
	struct FVector                                A;                                                 // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x00E8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0100(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x0114(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0120(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugLineItemSpace) == 0x000010, "Wrong alignment on FRigUnit_DebugLineItemSpace");
static_assert(sizeof(FRigUnit_DebugLineItemSpace) == 0x000190, "Wrong size on FRigUnit_DebugLineItemSpace");
static_assert(offsetof(FRigUnit_DebugLineItemSpace, A) == 0x0000D0, "Member 'FRigUnit_DebugLineItemSpace::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineItemSpace, B) == 0x0000E8, "Member 'FRigUnit_DebugLineItemSpace::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineItemSpace, Color) == 0x000100, "Member 'FRigUnit_DebugLineItemSpace::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineItemSpace, Thickness) == 0x000110, "Member 'FRigUnit_DebugLineItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineItemSpace, Space) == 0x000114, "Member 'FRigUnit_DebugLineItemSpace::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineItemSpace, WorldOffset) == 0x000120, "Member 'FRigUnit_DebugLineItemSpace::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineItemSpace, bEnabled) == 0x000180, "Member 'FRigUnit_DebugLineItemSpace::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugLineStrip
// 0x00A0 (0x0170 - 0x00D0)
struct FRigUnit_DebugLineStrip final : public FRigUnit_DebugBaseMutable
{
public:
	TArray<struct FVector>                        Points;                                            // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x00E0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x00F4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0100(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0160(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugLineStrip) == 0x000010, "Wrong alignment on FRigUnit_DebugLineStrip");
static_assert(sizeof(FRigUnit_DebugLineStrip) == 0x000170, "Wrong size on FRigUnit_DebugLineStrip");
static_assert(offsetof(FRigUnit_DebugLineStrip, Points) == 0x0000D0, "Member 'FRigUnit_DebugLineStrip::Points' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, Color) == 0x0000E0, "Member 'FRigUnit_DebugLineStrip::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, Thickness) == 0x0000F0, "Member 'FRigUnit_DebugLineStrip::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, Space) == 0x0000F4, "Member 'FRigUnit_DebugLineStrip::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, WorldOffset) == 0x000100, "Member 'FRigUnit_DebugLineStrip::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, bEnabled) == 0x000160, "Member 'FRigUnit_DebugLineStrip::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugLineStripItemSpace
// 0x00A0 (0x0170 - 0x00D0)
struct FRigUnit_DebugLineStripItemSpace final : public FRigUnit_DebugBaseMutable
{
public:
	TArray<struct FVector>                        Points;                                            // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x00E0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x00F4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0100(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0160(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugLineStripItemSpace) == 0x000010, "Wrong alignment on FRigUnit_DebugLineStripItemSpace");
static_assert(sizeof(FRigUnit_DebugLineStripItemSpace) == 0x000170, "Wrong size on FRigUnit_DebugLineStripItemSpace");
static_assert(offsetof(FRigUnit_DebugLineStripItemSpace, Points) == 0x0000D0, "Member 'FRigUnit_DebugLineStripItemSpace::Points' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStripItemSpace, Color) == 0x0000E0, "Member 'FRigUnit_DebugLineStripItemSpace::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStripItemSpace, Thickness) == 0x0000F0, "Member 'FRigUnit_DebugLineStripItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStripItemSpace, Space) == 0x0000F4, "Member 'FRigUnit_DebugLineStripItemSpace::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStripItemSpace, WorldOffset) == 0x000100, "Member 'FRigUnit_DebugLineStripItemSpace::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStripItemSpace, bEnabled) == 0x000160, "Member 'FRigUnit_DebugLineStripItemSpace::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionFromRotator
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathQuaternionFromRotator final : public FRigUnit_MathQuaternionBase
{
public:
	struct FRotator                               Rotator;                                           // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0020(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionFromRotator) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionFromRotator");
static_assert(sizeof(FRigUnit_MathQuaternionFromRotator) == 0x000040, "Wrong size on FRigUnit_MathQuaternionFromRotator");
static_assert(offsetof(FRigUnit_MathQuaternionFromRotator, Rotator) == 0x000008, "Member 'FRigUnit_MathQuaternionFromRotator::Rotator' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromRotator, Result) == 0x000020, "Member 'FRigUnit_MathQuaternionFromRotator::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugPoint
// 0x00B8 (0x00C0 - 0x0008)
struct FRigUnit_DebugPoint final : public FRigUnit_DebugBase
{
public:
	struct FVector                                Vector;                                            // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigUnitDebugPointMode                        Mode;                                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0024(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x003C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0050(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugPoint) == 0x000010, "Wrong alignment on FRigUnit_DebugPoint");
static_assert(sizeof(FRigUnit_DebugPoint) == 0x0000C0, "Wrong size on FRigUnit_DebugPoint");
static_assert(offsetof(FRigUnit_DebugPoint, Vector) == 0x000008, "Member 'FRigUnit_DebugPoint::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Mode) == 0x000020, "Member 'FRigUnit_DebugPoint::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Color) == 0x000024, "Member 'FRigUnit_DebugPoint::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Scale) == 0x000034, "Member 'FRigUnit_DebugPoint::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Thickness) == 0x000038, "Member 'FRigUnit_DebugPoint::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Space) == 0x00003C, "Member 'FRigUnit_DebugPoint::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, WorldOffset) == 0x000050, "Member 'FRigUnit_DebugPoint::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, bEnabled) == 0x0000B0, "Member 'FRigUnit_DebugPoint::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatAdd
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathFloatAdd final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAdd) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAdd");
static_assert(sizeof(FRigUnit_MathFloatAdd) == 0x000018, "Wrong size on FRigUnit_MathFloatAdd");

// ScriptStruct ControlRig.RigUnit_DebugPointMutable
// 0x00B0 (0x0180 - 0x00D0)
struct FRigUnit_DebugPointMutable final : public FRigUnit_DebugBaseMutable
{
public:
	struct FVector                                Vector;                                            // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigUnitDebugPointMode                        Mode;                                              // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x00EC(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0104(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0110(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0xF];                                      // 0x0171(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugPointMutable) == 0x000010, "Wrong alignment on FRigUnit_DebugPointMutable");
static_assert(sizeof(FRigUnit_DebugPointMutable) == 0x000180, "Wrong size on FRigUnit_DebugPointMutable");
static_assert(offsetof(FRigUnit_DebugPointMutable, Vector) == 0x0000D0, "Member 'FRigUnit_DebugPointMutable::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Mode) == 0x0000E8, "Member 'FRigUnit_DebugPointMutable::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Color) == 0x0000EC, "Member 'FRigUnit_DebugPointMutable::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Scale) == 0x0000FC, "Member 'FRigUnit_DebugPointMutable::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Thickness) == 0x000100, "Member 'FRigUnit_DebugPointMutable::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Space) == 0x000104, "Member 'FRigUnit_DebugPointMutable::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, WorldOffset) == 0x000110, "Member 'FRigUnit_DebugPointMutable::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, bEnabled) == 0x000170, "Member 'FRigUnit_DebugPointMutable::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugRectangle
// 0x00F0 (0x01C0 - 0x00D0)
struct FRigUnit_DebugRectangle final : public FRigUnit_DebugBaseMutable
{
public:
	struct FTransform                             Transform;                                         // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0130(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0150(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0xF];                                      // 0x01B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugRectangle) == 0x000010, "Wrong alignment on FRigUnit_DebugRectangle");
static_assert(sizeof(FRigUnit_DebugRectangle) == 0x0001C0, "Wrong size on FRigUnit_DebugRectangle");
static_assert(offsetof(FRigUnit_DebugRectangle, Transform) == 0x0000D0, "Member 'FRigUnit_DebugRectangle::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, Color) == 0x000130, "Member 'FRigUnit_DebugRectangle::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, Scale) == 0x000140, "Member 'FRigUnit_DebugRectangle::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, Thickness) == 0x000144, "Member 'FRigUnit_DebugRectangle::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, Space) == 0x000148, "Member 'FRigUnit_DebugRectangle::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, WorldOffset) == 0x000150, "Member 'FRigUnit_DebugRectangle::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, bEnabled) == 0x0001B0, "Member 'FRigUnit_DebugRectangle::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugRectangleItemSpace
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_DebugRectangleItemSpace final : public FRigUnit_DebugBaseMutable
{
public:
	struct FTransform                             Transform;                                         // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0130(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x0148(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0xC];                                      // 0x0154(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugRectangleItemSpace) == 0x000010, "Wrong alignment on FRigUnit_DebugRectangleItemSpace");
static_assert(sizeof(FRigUnit_DebugRectangleItemSpace) == 0x0001D0, "Wrong size on FRigUnit_DebugRectangleItemSpace");
static_assert(offsetof(FRigUnit_DebugRectangleItemSpace, Transform) == 0x0000D0, "Member 'FRigUnit_DebugRectangleItemSpace::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangleItemSpace, Color) == 0x000130, "Member 'FRigUnit_DebugRectangleItemSpace::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangleItemSpace, Scale) == 0x000140, "Member 'FRigUnit_DebugRectangleItemSpace::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangleItemSpace, Thickness) == 0x000144, "Member 'FRigUnit_DebugRectangleItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangleItemSpace, Space) == 0x000148, "Member 'FRigUnit_DebugRectangleItemSpace::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangleItemSpace, WorldOffset) == 0x000160, "Member 'FRigUnit_DebugRectangleItemSpace::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangleItemSpace, bEnabled) == 0x0001C0, "Member 'FRigUnit_DebugRectangleItemSpace::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionToEuler
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathQuaternionToEuler final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EEulerRotationOrder                           RotationOrder;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionToEuler) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionToEuler");
static_assert(sizeof(FRigUnit_MathQuaternionToEuler) == 0x000050, "Wrong size on FRigUnit_MathQuaternionToEuler");
static_assert(offsetof(FRigUnit_MathQuaternionToEuler, Value) == 0x000010, "Member 'FRigUnit_MathQuaternionToEuler::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToEuler, RotationOrder) == 0x000030, "Member 'FRigUnit_MathQuaternionToEuler::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToEuler, Result) == 0x000038, "Member 'FRigUnit_MathQuaternionToEuler::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugArc
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_DebugArc final : public FRigUnit_DebugBaseMutable
{
public:
	struct FTransform                             Transform;                                         // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0130(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDegrees;                                    // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDegrees;                                    // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Detail;                                            // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0154(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugArc) == 0x000010, "Wrong alignment on FRigUnit_DebugArc");
static_assert(sizeof(FRigUnit_DebugArc) == 0x0001D0, "Wrong size on FRigUnit_DebugArc");
static_assert(offsetof(FRigUnit_DebugArc, Transform) == 0x0000D0, "Member 'FRigUnit_DebugArc::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Color) == 0x000130, "Member 'FRigUnit_DebugArc::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Radius) == 0x000140, "Member 'FRigUnit_DebugArc::Radius' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, MinimumDegrees) == 0x000144, "Member 'FRigUnit_DebugArc::MinimumDegrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, MaximumDegrees) == 0x000148, "Member 'FRigUnit_DebugArc::MaximumDegrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Thickness) == 0x00014C, "Member 'FRigUnit_DebugArc::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Detail) == 0x000150, "Member 'FRigUnit_DebugArc::Detail' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Space) == 0x000154, "Member 'FRigUnit_DebugArc::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, WorldOffset) == 0x000160, "Member 'FRigUnit_DebugArc::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, bEnabled) == 0x0001C0, "Member 'FRigUnit_DebugArc::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathColorBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathColorBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathColorBase) == 0x000008, "Wrong alignment on FRigUnit_MathColorBase");
static_assert(sizeof(FRigUnit_MathColorBase) == 0x000008, "Wrong size on FRigUnit_MathColorBase");

// ScriptStruct ControlRig.RigUnit_MathColorBinaryOp
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_MathColorBinaryOp : public FRigUnit_MathColorBase
{
public:
	struct FLinearColor                           A;                                                 // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           B;                                                 // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Result;                                            // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathColorBinaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathColorBinaryOp");
static_assert(sizeof(FRigUnit_MathColorBinaryOp) == 0x000038, "Wrong size on FRigUnit_MathColorBinaryOp");
static_assert(offsetof(FRigUnit_MathColorBinaryOp, A) == 0x000008, "Member 'FRigUnit_MathColorBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathColorBinaryOp, B) == 0x000018, "Member 'FRigUnit_MathColorBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathColorBinaryOp, Result) == 0x000028, "Member 'FRigUnit_MathColorBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathColorAdd
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathColorAdd final : public FRigUnit_MathColorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathColorAdd) == 0x000008, "Wrong alignment on FRigUnit_MathColorAdd");
static_assert(sizeof(FRigUnit_MathColorAdd) == 0x000038, "Wrong size on FRigUnit_MathColorAdd");

// ScriptStruct ControlRig.RigUnit_DebugArcItemSpace
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_DebugArcItemSpace final : public FRigUnit_DebugBaseMutable
{
public:
	struct FTransform                             Transform;                                         // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0130(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDegrees;                                    // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDegrees;                                    // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Detail;                                            // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x0154(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugArcItemSpace) == 0x000010, "Wrong alignment on FRigUnit_DebugArcItemSpace");
static_assert(sizeof(FRigUnit_DebugArcItemSpace) == 0x0001D0, "Wrong size on FRigUnit_DebugArcItemSpace");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, Transform) == 0x0000D0, "Member 'FRigUnit_DebugArcItemSpace::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, Color) == 0x000130, "Member 'FRigUnit_DebugArcItemSpace::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, Radius) == 0x000140, "Member 'FRigUnit_DebugArcItemSpace::Radius' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, MinimumDegrees) == 0x000144, "Member 'FRigUnit_DebugArcItemSpace::MinimumDegrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, MaximumDegrees) == 0x000148, "Member 'FRigUnit_DebugArcItemSpace::MaximumDegrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, Thickness) == 0x00014C, "Member 'FRigUnit_DebugArcItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, Detail) == 0x000150, "Member 'FRigUnit_DebugArcItemSpace::Detail' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, Space) == 0x000154, "Member 'FRigUnit_DebugArcItemSpace::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, WorldOffset) == 0x000160, "Member 'FRigUnit_DebugArcItemSpace::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArcItemSpace, bEnabled) == 0x0001C0, "Member 'FRigUnit_DebugArcItemSpace::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugTransform
// 0x0108 (0x0110 - 0x0008)
struct FRigUnit_DebugTransform final : public FRigUnit_DebugBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ERigUnitDebugTransformMode                    Mode;                                              // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0074(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x008C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x00A0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0100(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0xF];                                      // 0x0101(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugTransform) == 0x000010, "Wrong alignment on FRigUnit_DebugTransform");
static_assert(sizeof(FRigUnit_DebugTransform) == 0x000110, "Wrong size on FRigUnit_DebugTransform");
static_assert(offsetof(FRigUnit_DebugTransform, Transform) == 0x000010, "Member 'FRigUnit_DebugTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Mode) == 0x000070, "Member 'FRigUnit_DebugTransform::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Color) == 0x000074, "Member 'FRigUnit_DebugTransform::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Thickness) == 0x000084, "Member 'FRigUnit_DebugTransform::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Scale) == 0x000088, "Member 'FRigUnit_DebugTransform::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Space) == 0x00008C, "Member 'FRigUnit_DebugTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, WorldOffset) == 0x0000A0, "Member 'FRigUnit_DebugTransform::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, bEnabled) == 0x000100, "Member 'FRigUnit_DebugTransform::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugTransformMutable
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_DebugTransformMutable final : public FRigUnit_DebugBaseMutable
{
public:
	struct FTransform                             Transform;                                         // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ERigUnitDebugTransformMode                    Mode;                                              // 0x0130(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0134(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x014C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0xC];                                      // 0x0154(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugTransformMutable) == 0x000010, "Wrong alignment on FRigUnit_DebugTransformMutable");
static_assert(sizeof(FRigUnit_DebugTransformMutable) == 0x0001D0, "Wrong size on FRigUnit_DebugTransformMutable");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Transform) == 0x0000D0, "Member 'FRigUnit_DebugTransformMutable::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Mode) == 0x000130, "Member 'FRigUnit_DebugTransformMutable::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Color) == 0x000134, "Member 'FRigUnit_DebugTransformMutable::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Thickness) == 0x000144, "Member 'FRigUnit_DebugTransformMutable::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Scale) == 0x000148, "Member 'FRigUnit_DebugTransformMutable::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Space) == 0x00014C, "Member 'FRigUnit_DebugTransformMutable::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, WorldOffset) == 0x000160, "Member 'FRigUnit_DebugTransformMutable::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, bEnabled) == 0x0001C0, "Member 'FRigUnit_DebugTransformMutable::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionSlerp
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_MathQuaternionSlerp final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  A;                                                 // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0060(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionSlerp) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionSlerp");
static_assert(sizeof(FRigUnit_MathQuaternionSlerp) == 0x000080, "Wrong size on FRigUnit_MathQuaternionSlerp");
static_assert(offsetof(FRigUnit_MathQuaternionSlerp, A) == 0x000010, "Member 'FRigUnit_MathQuaternionSlerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSlerp, B) == 0x000030, "Member 'FRigUnit_MathQuaternionSlerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSlerp, T) == 0x000050, "Member 'FRigUnit_MathQuaternionSlerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSlerp, Result) == 0x000060, "Member 'FRigUnit_MathQuaternionSlerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugTransformMutableItemSpace
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_DebugTransformMutableItemSpace final : public FRigUnit_DebugBaseMutable
{
public:
	struct FTransform                             Transform;                                         // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ERigUnitDebugTransformMode                    Mode;                                              // 0x0130(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0134(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x014C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0xF];                                      // 0x01C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugTransformMutableItemSpace) == 0x000010, "Wrong alignment on FRigUnit_DebugTransformMutableItemSpace");
static_assert(sizeof(FRigUnit_DebugTransformMutableItemSpace) == 0x0001D0, "Wrong size on FRigUnit_DebugTransformMutableItemSpace");
static_assert(offsetof(FRigUnit_DebugTransformMutableItemSpace, Transform) == 0x0000D0, "Member 'FRigUnit_DebugTransformMutableItemSpace::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutableItemSpace, Mode) == 0x000130, "Member 'FRigUnit_DebugTransformMutableItemSpace::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutableItemSpace, Color) == 0x000134, "Member 'FRigUnit_DebugTransformMutableItemSpace::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutableItemSpace, Thickness) == 0x000144, "Member 'FRigUnit_DebugTransformMutableItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutableItemSpace, Scale) == 0x000148, "Member 'FRigUnit_DebugTransformMutableItemSpace::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutableItemSpace, Space) == 0x00014C, "Member 'FRigUnit_DebugTransformMutableItemSpace::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutableItemSpace, WorldOffset) == 0x000160, "Member 'FRigUnit_DebugTransformMutableItemSpace::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutableItemSpace, bEnabled) == 0x0001C0, "Member 'FRigUnit_DebugTransformMutableItemSpace::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatSqrt
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatSqrt final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatSqrt) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSqrt");
static_assert(sizeof(FRigUnit_MathFloatSqrt) == 0x000010, "Wrong size on FRigUnit_MathFloatSqrt");

// ScriptStruct ControlRig.RigUnit_DebugTransformArrayMutable_WorkData
// 0x0010 (0x0010 - 0x0000)
struct FRigUnit_DebugTransformArrayMutable_WorkData final
{
public:
	TArray<struct FTransform>                     DrawTransforms;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DebugTransformArrayMutable_WorkData) == 0x000008, "Wrong alignment on FRigUnit_DebugTransformArrayMutable_WorkData");
static_assert(sizeof(FRigUnit_DebugTransformArrayMutable_WorkData) == 0x000010, "Wrong size on FRigUnit_DebugTransformArrayMutable_WorkData");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable_WorkData, DrawTransforms) == 0x000000, "Member 'FRigUnit_DebugTransformArrayMutable_WorkData::DrawTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugTransformArrayMutable
// 0x00C0 (0x0190 - 0x00D0)
struct FRigUnit_DebugTransformArrayMutable final : public FRigUnit_DebugBaseMutable
{
public:
	TArray<struct FTransform>                     Transforms;                                        // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ERigUnitDebugTransformMode                    Mode;                                              // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x00E4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x00FC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0xC];                                      // 0x0104(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0110(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_DebugTransformArrayMutable_WorkData WorkData;                                          // 0x0178(0x0010)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugTransformArrayMutable) == 0x000010, "Wrong alignment on FRigUnit_DebugTransformArrayMutable");
static_assert(sizeof(FRigUnit_DebugTransformArrayMutable) == 0x000190, "Wrong size on FRigUnit_DebugTransformArrayMutable");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Transforms) == 0x0000D0, "Member 'FRigUnit_DebugTransformArrayMutable::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Mode) == 0x0000E0, "Member 'FRigUnit_DebugTransformArrayMutable::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Color) == 0x0000E4, "Member 'FRigUnit_DebugTransformArrayMutable::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Thickness) == 0x0000F4, "Member 'FRigUnit_DebugTransformArrayMutable::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Scale) == 0x0000F8, "Member 'FRigUnit_DebugTransformArrayMutable::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Space) == 0x0000FC, "Member 'FRigUnit_DebugTransformArrayMutable::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, WorldOffset) == 0x000110, "Member 'FRigUnit_DebugTransformArrayMutable::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, bEnabled) == 0x000170, "Member 'FRigUnit_DebugTransformArrayMutable::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, WorkData) == 0x000178, "Member 'FRigUnit_DebugTransformArrayMutable::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugTransformArrayMutableItemSpace
// 0x00C0 (0x0190 - 0x00D0)
struct FRigUnit_DebugTransformArrayMutableItemSpace final : public FRigUnit_DebugBaseMutable
{
public:
	TArray<struct FTransform>                     Transforms;                                        // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ParentIndices;                                     // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ERigUnitDebugTransformMode                    Mode;                                              // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x00F4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x010C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0120(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugTransformArrayMutableItemSpace) == 0x000010, "Wrong alignment on FRigUnit_DebugTransformArrayMutableItemSpace");
static_assert(sizeof(FRigUnit_DebugTransformArrayMutableItemSpace) == 0x000190, "Wrong size on FRigUnit_DebugTransformArrayMutableItemSpace");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, Transforms) == 0x0000D0, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, ParentIndices) == 0x0000E0, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::ParentIndices' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, Mode) == 0x0000F0, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, Color) == 0x0000F4, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, Thickness) == 0x000104, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, Scale) == 0x000108, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, Space) == 0x00010C, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, WorldOffset) == 0x000120, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutableItemSpace, bEnabled) == 0x000180, "Member 'FRigUnit_DebugTransformArrayMutableItemSpace::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionDot
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_MathQuaternionDot final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  A;                                                 // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionDot) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionDot");
static_assert(sizeof(FRigUnit_MathQuaternionDot) == 0x000060, "Wrong size on FRigUnit_MathQuaternionDot");
static_assert(offsetof(FRigUnit_MathQuaternionDot, A) == 0x000010, "Member 'FRigUnit_MathQuaternionDot::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionDot, B) == 0x000030, "Member 'FRigUnit_MathQuaternionDot::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionDot, Result) == 0x000050, "Member 'FRigUnit_MathQuaternionDot::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DeltaFromPreviousFloat
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_DeltaFromPreviousFloat final : public FRigUnit_SimBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delta;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousValue;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cache;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DeltaFromPreviousFloat) == 0x000008, "Wrong alignment on FRigUnit_DeltaFromPreviousFloat");
static_assert(sizeof(FRigUnit_DeltaFromPreviousFloat) == 0x000018, "Wrong size on FRigUnit_DeltaFromPreviousFloat");
static_assert(offsetof(FRigUnit_DeltaFromPreviousFloat, Value) == 0x000008, "Member 'FRigUnit_DeltaFromPreviousFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousFloat, Delta) == 0x00000C, "Member 'FRigUnit_DeltaFromPreviousFloat::Delta' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousFloat, PreviousValue) == 0x000010, "Member 'FRigUnit_DeltaFromPreviousFloat::PreviousValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousFloat, Cache) == 0x000014, "Member 'FRigUnit_DeltaFromPreviousFloat::Cache' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatConstPi
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatConstPi final : public FRigUnit_MathFloatConstant
{
};
static_assert(alignof(FRigUnit_MathFloatConstPi) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstPi");
static_assert(sizeof(FRigUnit_MathFloatConstPi) == 0x000010, "Wrong size on FRigUnit_MathFloatConstPi");

// ScriptStruct ControlRig.RigUnit_DeltaFromPreviousVector
// 0x0060 (0x0068 - 0x0008)
struct FRigUnit_DeltaFromPreviousVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Delta;                                             // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousValue;                                     // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Cache;                                             // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DeltaFromPreviousVector) == 0x000008, "Wrong alignment on FRigUnit_DeltaFromPreviousVector");
static_assert(sizeof(FRigUnit_DeltaFromPreviousVector) == 0x000068, "Wrong size on FRigUnit_DeltaFromPreviousVector");
static_assert(offsetof(FRigUnit_DeltaFromPreviousVector, Value) == 0x000008, "Member 'FRigUnit_DeltaFromPreviousVector::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousVector, Delta) == 0x000020, "Member 'FRigUnit_DeltaFromPreviousVector::Delta' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousVector, PreviousValue) == 0x000038, "Member 'FRigUnit_DeltaFromPreviousVector::PreviousValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousVector, Cache) == 0x000050, "Member 'FRigUnit_DeltaFromPreviousVector::Cache' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DeltaFromPreviousQuat
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_DeltaFromPreviousQuat final : public FRigUnit_SimBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Delta;                                             // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  PreviousValue;                                     // 0x0050(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Cache;                                             // 0x0070(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DeltaFromPreviousQuat) == 0x000010, "Wrong alignment on FRigUnit_DeltaFromPreviousQuat");
static_assert(sizeof(FRigUnit_DeltaFromPreviousQuat) == 0x000090, "Wrong size on FRigUnit_DeltaFromPreviousQuat");
static_assert(offsetof(FRigUnit_DeltaFromPreviousQuat, Value) == 0x000010, "Member 'FRigUnit_DeltaFromPreviousQuat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousQuat, Delta) == 0x000030, "Member 'FRigUnit_DeltaFromPreviousQuat::Delta' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousQuat, PreviousValue) == 0x000050, "Member 'FRigUnit_DeltaFromPreviousQuat::PreviousValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousQuat, Cache) == 0x000070, "Member 'FRigUnit_DeltaFromPreviousQuat::Cache' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DeltaFromPreviousTransform
// 0x0188 (0x0190 - 0x0008)
struct FRigUnit_DeltaFromPreviousTransform final : public FRigUnit_SimBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Delta;                                             // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PreviousValue;                                     // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Cache;                                             // 0x0130(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DeltaFromPreviousTransform) == 0x000010, "Wrong alignment on FRigUnit_DeltaFromPreviousTransform");
static_assert(sizeof(FRigUnit_DeltaFromPreviousTransform) == 0x000190, "Wrong size on FRigUnit_DeltaFromPreviousTransform");
static_assert(offsetof(FRigUnit_DeltaFromPreviousTransform, Value) == 0x000010, "Member 'FRigUnit_DeltaFromPreviousTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousTransform, Delta) == 0x000070, "Member 'FRigUnit_DeltaFromPreviousTransform::Delta' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousTransform, PreviousValue) == 0x0000D0, "Member 'FRigUnit_DeltaFromPreviousTransform::PreviousValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousTransform, Cache) == 0x000130, "Member 'FRigUnit_DeltaFromPreviousTransform::Cache' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatIsNearlyEqual
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatIsNearlyEqual final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatIsNearlyEqual) == 0x000008, "Wrong alignment on FRigUnit_MathFloatIsNearlyEqual");
static_assert(sizeof(FRigUnit_MathFloatIsNearlyEqual) == 0x000018, "Wrong size on FRigUnit_MathFloatIsNearlyEqual");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyEqual, A) == 0x000008, "Member 'FRigUnit_MathFloatIsNearlyEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyEqual, B) == 0x00000C, "Member 'FRigUnit_MathFloatIsNearlyEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyEqual, Tolerance) == 0x000010, "Member 'FRigUnit_MathFloatIsNearlyEqual::Tolerance' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyEqual, Result) == 0x000014, "Member 'FRigUnit_MathFloatIsNearlyEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DistributeRotation_Rotation
// 0x0030 (0x0030 - 0x0000)
struct FRigUnit_DistributeRotation_Rotation final
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DistributeRotation_Rotation) == 0x000010, "Wrong alignment on FRigUnit_DistributeRotation_Rotation");
static_assert(sizeof(FRigUnit_DistributeRotation_Rotation) == 0x000030, "Wrong size on FRigUnit_DistributeRotation_Rotation");
static_assert(offsetof(FRigUnit_DistributeRotation_Rotation, Rotation) == 0x000000, "Member 'FRigUnit_DistributeRotation_Rotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation_Rotation, Ratio) == 0x000020, "Member 'FRigUnit_DistributeRotation_Rotation::Ratio' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MultiFABRIK_WorkData
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FRigUnit_MultiFABRIK_WorkData final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MultiFABRIK_WorkData) == 0x000008, "Wrong alignment on FRigUnit_MultiFABRIK_WorkData");
static_assert(sizeof(FRigUnit_MultiFABRIK_WorkData) == 0x000068, "Wrong size on FRigUnit_MultiFABRIK_WorkData");

// ScriptStruct ControlRig.RigUnit_MathFloatClamp
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatClamp final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatClamp) == 0x000008, "Wrong alignment on FRigUnit_MathFloatClamp");
static_assert(sizeof(FRigUnit_MathFloatClamp) == 0x000018, "Wrong size on FRigUnit_MathFloatClamp");
static_assert(offsetof(FRigUnit_MathFloatClamp, Value) == 0x000008, "Member 'FRigUnit_MathFloatClamp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatClamp, Minimum) == 0x00000C, "Member 'FRigUnit_MathFloatClamp::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatClamp, Maximum) == 0x000010, "Member 'FRigUnit_MathFloatClamp::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatClamp, Result) == 0x000014, "Member 'FRigUnit_MathFloatClamp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DistributeRotation_WorkData
// 0x0050 (0x0050 - 0x0000)
struct FRigUnit_DistributeRotation_WorkData final
{
public:
	TArray<struct FCachedRigElement>              CachedItems;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ItemRotationA;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ItemRotationB;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ItemRotationT;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ItemLocalTransforms;                               // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DistributeRotation_WorkData) == 0x000008, "Wrong alignment on FRigUnit_DistributeRotation_WorkData");
static_assert(sizeof(FRigUnit_DistributeRotation_WorkData) == 0x000050, "Wrong size on FRigUnit_DistributeRotation_WorkData");
static_assert(offsetof(FRigUnit_DistributeRotation_WorkData, CachedItems) == 0x000000, "Member 'FRigUnit_DistributeRotation_WorkData::CachedItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation_WorkData, ItemRotationA) == 0x000010, "Member 'FRigUnit_DistributeRotation_WorkData::ItemRotationA' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation_WorkData, ItemRotationB) == 0x000020, "Member 'FRigUnit_DistributeRotation_WorkData::ItemRotationB' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation_WorkData, ItemRotationT) == 0x000030, "Member 'FRigUnit_DistributeRotation_WorkData::ItemRotationT' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation_WorkData, ItemLocalTransforms) == 0x000040, "Member 'FRigUnit_DistributeRotation_WorkData::ItemLocalTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DistributeRotation
// 0x0080 (0x0150 - 0x00D0)
struct FRigUnit_DistributeRotation final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBone;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_DistributeRotation_Rotation> Rotations;                                         // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     RotationEaseType;                                  // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_DistributeRotation_WorkData   WorkData;                                          // 0x0100(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DistributeRotation) == 0x000010, "Wrong alignment on FRigUnit_DistributeRotation");
static_assert(sizeof(FRigUnit_DistributeRotation) == 0x000150, "Wrong size on FRigUnit_DistributeRotation");
static_assert(offsetof(FRigUnit_DistributeRotation, StartBone) == 0x0000D0, "Member 'FRigUnit_DistributeRotation::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, EndBone) == 0x0000D8, "Member 'FRigUnit_DistributeRotation::EndBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, Rotations) == 0x0000E0, "Member 'FRigUnit_DistributeRotation::Rotations' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, RotationEaseType) == 0x0000F0, "Member 'FRigUnit_DistributeRotation::RotationEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, Weight) == 0x0000F4, "Member 'FRigUnit_DistributeRotation::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, bPropagateToChildren) == 0x0000F8, "Member 'FRigUnit_DistributeRotation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, WorkData) == 0x000100, "Member 'FRigUnit_DistributeRotation::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DistributeRotationForCollection
// 0x0080 (0x0150 - 0x00D0)
struct FRigUnit_DistributeRotationForCollection final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x00D0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_DistributeRotation_Rotation> Rotations;                                         // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     RotationEaseType;                                  // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_DistributeRotation_WorkData   WorkData;                                          // 0x00F8(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DistributeRotationForCollection) == 0x000010, "Wrong alignment on FRigUnit_DistributeRotationForCollection");
static_assert(sizeof(FRigUnit_DistributeRotationForCollection) == 0x000150, "Wrong size on FRigUnit_DistributeRotationForCollection");
static_assert(offsetof(FRigUnit_DistributeRotationForCollection, Items) == 0x0000D0, "Member 'FRigUnit_DistributeRotationForCollection::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotationForCollection, Rotations) == 0x0000E0, "Member 'FRigUnit_DistributeRotationForCollection::Rotations' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotationForCollection, RotationEaseType) == 0x0000F0, "Member 'FRigUnit_DistributeRotationForCollection::RotationEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotationForCollection, Weight) == 0x0000F4, "Member 'FRigUnit_DistributeRotationForCollection::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotationForCollection, WorkData) == 0x0000F8, "Member 'FRigUnit_DistributeRotationForCollection::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatSin
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatSin final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatSin) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSin");
static_assert(sizeof(FRigUnit_MathFloatSin) == 0x000010, "Wrong size on FRigUnit_MathFloatSin");

// ScriptStruct ControlRig.RigUnit_NameBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_NameBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_NameBase) == 0x000008, "Wrong alignment on FRigUnit_NameBase");
static_assert(sizeof(FRigUnit_NameBase) == 0x000008, "Wrong size on FRigUnit_NameBase");

// ScriptStruct ControlRig.RigUnit_NameConcat
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_NameConcat final : public FRigUnit_NameBase
{
public:
	class FName                                   A;                                                 // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   B;                                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Result;                                            // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_NameConcat) == 0x000008, "Wrong alignment on FRigUnit_NameConcat");
static_assert(sizeof(FRigUnit_NameConcat) == 0x000020, "Wrong size on FRigUnit_NameConcat");
static_assert(offsetof(FRigUnit_NameConcat, A) == 0x000008, "Member 'FRigUnit_NameConcat::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameConcat, B) == 0x000010, "Member 'FRigUnit_NameConcat::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameConcat, Result) == 0x000018, "Member 'FRigUnit_NameConcat::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DistributeRotationForItemArray
// 0x0080 (0x0150 - 0x00D0)
struct FRigUnit_DistributeRotationForItemArray final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_DistributeRotation_Rotation> Rotations;                                         // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     RotationEaseType;                                  // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_DistributeRotation_WorkData   WorkData;                                          // 0x00F8(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DistributeRotationForItemArray) == 0x000010, "Wrong alignment on FRigUnit_DistributeRotationForItemArray");
static_assert(sizeof(FRigUnit_DistributeRotationForItemArray) == 0x000150, "Wrong size on FRigUnit_DistributeRotationForItemArray");
static_assert(offsetof(FRigUnit_DistributeRotationForItemArray, Items) == 0x0000D0, "Member 'FRigUnit_DistributeRotationForItemArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotationForItemArray, Rotations) == 0x0000E0, "Member 'FRigUnit_DistributeRotationForItemArray::Rotations' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotationForItemArray, RotationEaseType) == 0x0000F0, "Member 'FRigUnit_DistributeRotationForItemArray::RotationEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotationForItemArray, Weight) == 0x0000F4, "Member 'FRigUnit_DistributeRotationForItemArray::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotationForItemArray, WorkData) == 0x0000F8, "Member 'FRigUnit_DistributeRotationForItemArray::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DrawContainerGetInstruction
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_DrawContainerGetInstruction final : public FRigUnit
{
public:
	class FName                                   InstructionName;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DrawContainerGetInstruction) == 0x000010, "Wrong alignment on FRigUnit_DrawContainerGetInstruction");
static_assert(sizeof(FRigUnit_DrawContainerGetInstruction) == 0x000080, "Wrong size on FRigUnit_DrawContainerGetInstruction");
static_assert(offsetof(FRigUnit_DrawContainerGetInstruction, InstructionName) == 0x000008, "Member 'FRigUnit_DrawContainerGetInstruction::InstructionName' has a wrong offset!");
static_assert(offsetof(FRigUnit_DrawContainerGetInstruction, Color) == 0x000010, "Member 'FRigUnit_DrawContainerGetInstruction::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DrawContainerGetInstruction, Transform) == 0x000020, "Member 'FRigUnit_DrawContainerGetInstruction::Transform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DrawContainerSetColor
// 0x0020 (0x00F0 - 0x00D0)
struct FRigUnit_DrawContainerSetColor final : public FRigUnitMutable
{
public:
	class FName                                   InstructionName;                                   // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x00D8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DrawContainerSetColor) == 0x000010, "Wrong alignment on FRigUnit_DrawContainerSetColor");
static_assert(sizeof(FRigUnit_DrawContainerSetColor) == 0x0000F0, "Wrong size on FRigUnit_DrawContainerSetColor");
static_assert(offsetof(FRigUnit_DrawContainerSetColor, InstructionName) == 0x0000D0, "Member 'FRigUnit_DrawContainerSetColor::InstructionName' has a wrong offset!");
static_assert(offsetof(FRigUnit_DrawContainerSetColor, Color) == 0x0000D8, "Member 'FRigUnit_DrawContainerSetColor::Color' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DrawContainerSetThickness
// 0x0010 (0x00E0 - 0x00D0)
struct FRigUnit_DrawContainerSetThickness final : public FRigUnitMutable
{
public:
	class FName                                   InstructionName;                                   // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DrawContainerSetThickness) == 0x000010, "Wrong alignment on FRigUnit_DrawContainerSetThickness");
static_assert(sizeof(FRigUnit_DrawContainerSetThickness) == 0x0000E0, "Wrong size on FRigUnit_DrawContainerSetThickness");
static_assert(offsetof(FRigUnit_DrawContainerSetThickness, InstructionName) == 0x0000D0, "Member 'FRigUnit_DrawContainerSetThickness::InstructionName' has a wrong offset!");
static_assert(offsetof(FRigUnit_DrawContainerSetThickness, Thickness) == 0x0000D8, "Member 'FRigUnit_DrawContainerSetThickness::Thickness' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatAcos
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatAcos final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAcos) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAcos");
static_assert(sizeof(FRigUnit_MathFloatAcos) == 0x000010, "Wrong size on FRigUnit_MathFloatAcos");

// ScriptStruct ControlRig.RigUnit_StartsWith
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_StartsWith final : public FRigUnit_NameBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Start;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_StartsWith) == 0x000008, "Wrong alignment on FRigUnit_StartsWith");
static_assert(sizeof(FRigUnit_StartsWith) == 0x000020, "Wrong size on FRigUnit_StartsWith");
static_assert(offsetof(FRigUnit_StartsWith, Name) == 0x000008, "Member 'FRigUnit_StartsWith::Name' has a wrong offset!");
static_assert(offsetof(FRigUnit_StartsWith, Start) == 0x000010, "Member 'FRigUnit_StartsWith::Start' has a wrong offset!");
static_assert(offsetof(FRigUnit_StartsWith, Result) == 0x000018, "Member 'FRigUnit_StartsWith::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DrawContainerSetTransform
// 0x0070 (0x0140 - 0x00D0)
struct FRigUnit_DrawContainerSetTransform final : public FRigUnitMutable
{
public:
	class FName                                   InstructionName;                                   // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DrawContainerSetTransform) == 0x000010, "Wrong alignment on FRigUnit_DrawContainerSetTransform");
static_assert(sizeof(FRigUnit_DrawContainerSetTransform) == 0x000140, "Wrong size on FRigUnit_DrawContainerSetTransform");
static_assert(offsetof(FRigUnit_DrawContainerSetTransform, InstructionName) == 0x0000D0, "Member 'FRigUnit_DrawContainerSetTransform::InstructionName' has a wrong offset!");
static_assert(offsetof(FRigUnit_DrawContainerSetTransform, Transform) == 0x0000E0, "Member 'FRigUnit_DrawContainerSetTransform::Transform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatLessEqual
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatLessEqual final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatLessEqual) == 0x000008, "Wrong alignment on FRigUnit_MathFloatLessEqual");
static_assert(sizeof(FRigUnit_MathFloatLessEqual) == 0x000018, "Wrong size on FRigUnit_MathFloatLessEqual");
static_assert(offsetof(FRigUnit_MathFloatLessEqual, A) == 0x000008, "Member 'FRigUnit_MathFloatLessEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLessEqual, B) == 0x00000C, "Member 'FRigUnit_MathFloatLessEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLessEqual, Result) == 0x000010, "Member 'FRigUnit_MathFloatLessEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DynamicHierarchyBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_DynamicHierarchyBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_DynamicHierarchyBase) == 0x000008, "Wrong alignment on FRigUnit_DynamicHierarchyBase");
static_assert(sizeof(FRigUnit_DynamicHierarchyBase) == 0x000008, "Wrong size on FRigUnit_DynamicHierarchyBase");

// ScriptStruct ControlRig.RigUnit_DynamicHierarchyBaseMutable
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_DynamicHierarchyBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_DynamicHierarchyBaseMutable) == 0x000010, "Wrong alignment on FRigUnit_DynamicHierarchyBaseMutable");
static_assert(sizeof(FRigUnit_DynamicHierarchyBaseMutable) == 0x0000D0, "Wrong size on FRigUnit_DynamicHierarchyBaseMutable");

// ScriptStruct ControlRig.RigUnit_AddParent
// 0x0020 (0x00F0 - 0x00D0)
struct FRigUnit_AddParent final : public FRigUnit_DynamicHierarchyBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Parent;                                            // 0x00DC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AddParent) == 0x000010, "Wrong alignment on FRigUnit_AddParent");
static_assert(sizeof(FRigUnit_AddParent) == 0x0000F0, "Wrong size on FRigUnit_AddParent");
static_assert(offsetof(FRigUnit_AddParent, Child) == 0x0000D0, "Member 'FRigUnit_AddParent::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddParent, Parent) == 0x0000DC, "Member 'FRigUnit_AddParent::Parent' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_OffsetTransformForItem
// 0x00A0 (0x0170 - 0x00D0)
struct FRigUnit_OffsetTransformForItem final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffsetTransform;                                   // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0144(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedIndex;                                       // 0x0148(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_OffsetTransformForItem) == 0x000010, "Wrong alignment on FRigUnit_OffsetTransformForItem");
static_assert(sizeof(FRigUnit_OffsetTransformForItem) == 0x000170, "Wrong size on FRigUnit_OffsetTransformForItem");
static_assert(offsetof(FRigUnit_OffsetTransformForItem, Item) == 0x0000D0, "Member 'FRigUnit_OffsetTransformForItem::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_OffsetTransformForItem, OffsetTransform) == 0x0000E0, "Member 'FRigUnit_OffsetTransformForItem::OffsetTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_OffsetTransformForItem, Weight) == 0x000140, "Member 'FRigUnit_OffsetTransformForItem::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_OffsetTransformForItem, bPropagateToChildren) == 0x000144, "Member 'FRigUnit_OffsetTransformForItem::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_OffsetTransformForItem, CachedIndex) == 0x000148, "Member 'FRigUnit_OffsetTransformForItem::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SwitchParent
// 0x0020 (0x00F0 - 0x00D0)
struct FRigUnit_SwitchParent final : public FRigUnit_DynamicHierarchyBaseMutable
{
public:
	ERigSwitchParentMode                          Mode;                                              // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         Child;                                             // 0x00D4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Parent;                                            // 0x00E0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainGlobal;                                   // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SwitchParent) == 0x000010, "Wrong alignment on FRigUnit_SwitchParent");
static_assert(sizeof(FRigUnit_SwitchParent) == 0x0000F0, "Wrong size on FRigUnit_SwitchParent");
static_assert(offsetof(FRigUnit_SwitchParent, Mode) == 0x0000D0, "Member 'FRigUnit_SwitchParent::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_SwitchParent, Child) == 0x0000D4, "Member 'FRigUnit_SwitchParent::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_SwitchParent, Parent) == 0x0000E0, "Member 'FRigUnit_SwitchParent::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_SwitchParent, bMaintainGlobal) == 0x0000EC, "Member 'FRigUnit_SwitchParent::bMaintainGlobal' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatCeil
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatCeil final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatCeil) == 0x000008, "Wrong alignment on FRigUnit_MathFloatCeil");
static_assert(sizeof(FRigUnit_MathFloatCeil) == 0x000018, "Wrong size on FRigUnit_MathFloatCeil");
static_assert(offsetof(FRigUnit_MathFloatCeil, Value) == 0x000008, "Member 'FRigUnit_MathFloatCeil::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatCeil, Result) == 0x00000C, "Member 'FRigUnit_MathFloatCeil::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatCeil, Int) == 0x000010, "Member 'FRigUnit_MathFloatCeil::Int' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetParentWeights
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_HierarchyGetParentWeights final : public FRigUnit_DynamicHierarchyBase
{
public:
	struct FRigElementKey                         Child;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementWeight>              Weights;                                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               Parents;                                           // 0x0028(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetParentWeights) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetParentWeights");
static_assert(sizeof(FRigUnit_HierarchyGetParentWeights) == 0x000038, "Wrong size on FRigUnit_HierarchyGetParentWeights");
static_assert(offsetof(FRigUnit_HierarchyGetParentWeights, Child) == 0x000008, "Member 'FRigUnit_HierarchyGetParentWeights::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentWeights, Weights) == 0x000018, "Member 'FRigUnit_HierarchyGetParentWeights::Weights' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentWeights, Parents) == 0x000028, "Member 'FRigUnit_HierarchyGetParentWeights::Parents' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetParentWeightsArray
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_HierarchyGetParentWeightsArray final : public FRigUnit_DynamicHierarchyBase
{
public:
	struct FRigElementKey                         Child;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementWeight>              Weights;                                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRigElementKey>                 Parents;                                           // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetParentWeightsArray) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetParentWeightsArray");
static_assert(sizeof(FRigUnit_HierarchyGetParentWeightsArray) == 0x000038, "Wrong size on FRigUnit_HierarchyGetParentWeightsArray");
static_assert(offsetof(FRigUnit_HierarchyGetParentWeightsArray, Child) == 0x000008, "Member 'FRigUnit_HierarchyGetParentWeightsArray::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentWeightsArray, Weights) == 0x000018, "Member 'FRigUnit_HierarchyGetParentWeightsArray::Weights' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentWeightsArray, Parents) == 0x000028, "Member 'FRigUnit_HierarchyGetParentWeightsArray::Parents' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchySetParentWeights
// 0x0020 (0x00F0 - 0x00D0)
struct FRigUnit_HierarchySetParentWeights final : public FRigUnit_DynamicHierarchyBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementWeight>              Weights;                                           // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchySetParentWeights) == 0x000010, "Wrong alignment on FRigUnit_HierarchySetParentWeights");
static_assert(sizeof(FRigUnit_HierarchySetParentWeights) == 0x0000F0, "Wrong size on FRigUnit_HierarchySetParentWeights");
static_assert(offsetof(FRigUnit_HierarchySetParentWeights, Child) == 0x0000D0, "Member 'FRigUnit_HierarchySetParentWeights::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetParentWeights, Weights) == 0x0000E0, "Member 'FRigUnit_HierarchySetParentWeights::Weights' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolUnaryOp
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathBoolUnaryOp : public FRigUnit_MathBoolBase
{
public:
	bool                                          Value;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolUnaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathBoolUnaryOp");
static_assert(sizeof(FRigUnit_MathBoolUnaryOp) == 0x000010, "Wrong size on FRigUnit_MathBoolUnaryOp");
static_assert(offsetof(FRigUnit_MathBoolUnaryOp, Value) == 0x000008, "Member 'FRigUnit_MathBoolUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolUnaryOp, Result) == 0x000009, "Member 'FRigUnit_MathBoolUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolNot
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathBoolNot final : public FRigUnit_MathBoolUnaryOp
{
};
static_assert(alignof(FRigUnit_MathBoolNot) == 0x000008, "Wrong alignment on FRigUnit_MathBoolNot");
static_assert(sizeof(FRigUnit_MathBoolNot) == 0x000010, "Wrong size on FRigUnit_MathBoolNot");

// ScriptStruct ControlRig.RigUnit_FABRIK_WorkData
// 0x0040 (0x0040 - 0x0000)
struct FRigUnit_FABRIK_WorkData final
{
public:
	TArray<struct FFABRIKChainLink>               Chain;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              CachedItems;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedEffector;                                    // 0x0020(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FABRIK_WorkData) == 0x000008, "Wrong alignment on FRigUnit_FABRIK_WorkData");
static_assert(sizeof(FRigUnit_FABRIK_WorkData) == 0x000040, "Wrong size on FRigUnit_FABRIK_WorkData");
static_assert(offsetof(FRigUnit_FABRIK_WorkData, Chain) == 0x000000, "Member 'FRigUnit_FABRIK_WorkData::Chain' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK_WorkData, CachedItems) == 0x000010, "Member 'FRigUnit_FABRIK_WorkData::CachedItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK_WorkData, CachedEffector) == 0x000020, "Member 'FRigUnit_FABRIK_WorkData::CachedEffector' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FABRIK
// 0x00D0 (0x01A0 - 0x00D0)
struct FRigUnit_FABRIK final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectorBone;                                      // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EffectorTransform;                                 // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxIterations;                                     // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_FABRIK_WorkData               WorkData;                                          // 0x0150(0x0040)(Transient, NativeAccessSpecifierPublic)
	bool                                          bSetEffectorTransform;                             // 0x0190(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0xF];                                      // 0x0191(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FABRIK) == 0x000010, "Wrong alignment on FRigUnit_FABRIK");
static_assert(sizeof(FRigUnit_FABRIK) == 0x0001A0, "Wrong size on FRigUnit_FABRIK");
static_assert(offsetof(FRigUnit_FABRIK, StartBone) == 0x0000D0, "Member 'FRigUnit_FABRIK::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, EffectorBone) == 0x0000D8, "Member 'FRigUnit_FABRIK::EffectorBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, EffectorTransform) == 0x0000E0, "Member 'FRigUnit_FABRIK::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, Precision) == 0x000140, "Member 'FRigUnit_FABRIK::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, Weight) == 0x000144, "Member 'FRigUnit_FABRIK::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, bPropagateToChildren) == 0x000148, "Member 'FRigUnit_FABRIK::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, MaxIterations) == 0x00014C, "Member 'FRigUnit_FABRIK::MaxIterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, WorkData) == 0x000150, "Member 'FRigUnit_FABRIK::WorkData' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, bSetEffectorTransform) == 0x000190, "Member 'FRigUnit_FABRIK::bSetEffectorTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FABRIKPerItem
// 0x00D0 (0x01A0 - 0x00D0)
struct FRigUnit_FABRIKPerItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x00D0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             EffectorTransform;                                 // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxIterations;                                     // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_FABRIK_WorkData               WorkData;                                          // 0x0150(0x0040)(Transient, NativeAccessSpecifierPublic)
	bool                                          bSetEffectorTransform;                             // 0x0190(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0xF];                                      // 0x0191(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FABRIKPerItem) == 0x000010, "Wrong alignment on FRigUnit_FABRIKPerItem");
static_assert(sizeof(FRigUnit_FABRIKPerItem) == 0x0001A0, "Wrong size on FRigUnit_FABRIKPerItem");
static_assert(offsetof(FRigUnit_FABRIKPerItem, Items) == 0x0000D0, "Member 'FRigUnit_FABRIKPerItem::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKPerItem, EffectorTransform) == 0x0000E0, "Member 'FRigUnit_FABRIKPerItem::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKPerItem, Precision) == 0x000140, "Member 'FRigUnit_FABRIKPerItem::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKPerItem, Weight) == 0x000144, "Member 'FRigUnit_FABRIKPerItem::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKPerItem, bPropagateToChildren) == 0x000148, "Member 'FRigUnit_FABRIKPerItem::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKPerItem, MaxIterations) == 0x00014C, "Member 'FRigUnit_FABRIKPerItem::MaxIterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKPerItem, WorkData) == 0x000150, "Member 'FRigUnit_FABRIKPerItem::WorkData' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKPerItem, bSetEffectorTransform) == 0x000190, "Member 'FRigUnit_FABRIKPerItem::bSetEffectorTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolEquals
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathBoolEquals final : public FRigUnit_MathBoolBase
{
public:
	bool                                          A;                                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolEquals) == 0x000008, "Wrong alignment on FRigUnit_MathBoolEquals");
static_assert(sizeof(FRigUnit_MathBoolEquals) == 0x000010, "Wrong size on FRigUnit_MathBoolEquals");
static_assert(offsetof(FRigUnit_MathBoolEquals, A) == 0x000008, "Member 'FRigUnit_MathBoolEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolEquals, B) == 0x000009, "Member 'FRigUnit_MathBoolEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolEquals, Result) == 0x00000A, "Member 'FRigUnit_MathBoolEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FABRIKItemArray
// 0x00D0 (0x01A0 - 0x00D0)
struct FRigUnit_FABRIKItemArray final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             EffectorTransform;                                 // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxIterations;                                     // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_FABRIK_WorkData               WorkData;                                          // 0x0150(0x0040)(Transient, NativeAccessSpecifierPublic)
	bool                                          bSetEffectorTransform;                             // 0x0190(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0xF];                                      // 0x0191(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FABRIKItemArray) == 0x000010, "Wrong alignment on FRigUnit_FABRIKItemArray");
static_assert(sizeof(FRigUnit_FABRIKItemArray) == 0x0001A0, "Wrong size on FRigUnit_FABRIKItemArray");
static_assert(offsetof(FRigUnit_FABRIKItemArray, Items) == 0x0000D0, "Member 'FRigUnit_FABRIKItemArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKItemArray, EffectorTransform) == 0x0000E0, "Member 'FRigUnit_FABRIKItemArray::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKItemArray, Precision) == 0x000140, "Member 'FRigUnit_FABRIKItemArray::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKItemArray, Weight) == 0x000144, "Member 'FRigUnit_FABRIKItemArray::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKItemArray, bPropagateToChildren) == 0x000148, "Member 'FRigUnit_FABRIKItemArray::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKItemArray, MaxIterations) == 0x00014C, "Member 'FRigUnit_FABRIKItemArray::MaxIterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKItemArray, WorkData) == 0x000150, "Member 'FRigUnit_FABRIKItemArray::WorkData' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIKItemArray, bSetEffectorTransform) == 0x000190, "Member 'FRigUnit_FABRIKItemArray::bSetEffectorTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatNotEquals
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatNotEquals final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatNotEquals) == 0x000008, "Wrong alignment on FRigUnit_MathFloatNotEquals");
static_assert(sizeof(FRigUnit_MathFloatNotEquals) == 0x000018, "Wrong size on FRigUnit_MathFloatNotEquals");
static_assert(offsetof(FRigUnit_MathFloatNotEquals, A) == 0x000008, "Member 'FRigUnit_MathFloatNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatNotEquals, B) == 0x00000C, "Member 'FRigUnit_MathFloatNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatNotEquals, Result) == 0x000010, "Member 'FRigUnit_MathFloatNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurve_Rotation
// 0x0030 (0x0030 - 0x0000)
struct FRigUnit_FitChainToCurve_Rotation final
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FitChainToCurve_Rotation) == 0x000010, "Wrong alignment on FRigUnit_FitChainToCurve_Rotation");
static_assert(sizeof(FRigUnit_FitChainToCurve_Rotation) == 0x000030, "Wrong size on FRigUnit_FitChainToCurve_Rotation");
static_assert(offsetof(FRigUnit_FitChainToCurve_Rotation, Rotation) == 0x000000, "Member 'FRigUnit_FitChainToCurve_Rotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_Rotation, Ratio) == 0x000020, "Member 'FRigUnit_FitChainToCurve_Rotation::Ratio' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurve_DebugSettings
// 0x0090 (0x0090 - 0x0000)
struct FRigUnit_FitChainToCurve_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CurveColor;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SegmentsColor;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0030(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FitChainToCurve_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_FitChainToCurve_DebugSettings");
static_assert(sizeof(FRigUnit_FitChainToCurve_DebugSettings) == 0x000090, "Wrong size on FRigUnit_FitChainToCurve_DebugSettings");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_FitChainToCurve_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_FitChainToCurve_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, CurveColor) == 0x000008, "Member 'FRigUnit_FitChainToCurve_DebugSettings::CurveColor' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, SegmentsColor) == 0x000018, "Member 'FRigUnit_FitChainToCurve_DebugSettings::SegmentsColor' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, WorldOffset) == 0x000030, "Member 'FRigUnit_FitChainToCurve_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurve_WorkData
// 0x0098 (0x0098 - 0x0000)
struct FRigUnit_FitChainToCurve_WorkData final
{
public:
	float                                         ChainLength;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ItemPositions;                                     // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ItemSegments;                                      // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        CurvePositions;                                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 CurveSegments;                                     // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              CachedItems;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ItemRotationA;                                     // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ItemRotationB;                                     // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ItemRotationT;                                     // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ItemLocalTransforms;                               // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FitChainToCurve_WorkData) == 0x000008, "Wrong alignment on FRigUnit_FitChainToCurve_WorkData");
static_assert(sizeof(FRigUnit_FitChainToCurve_WorkData) == 0x000098, "Wrong size on FRigUnit_FitChainToCurve_WorkData");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, ChainLength) == 0x000000, "Member 'FRigUnit_FitChainToCurve_WorkData::ChainLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, ItemPositions) == 0x000008, "Member 'FRigUnit_FitChainToCurve_WorkData::ItemPositions' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, ItemSegments) == 0x000018, "Member 'FRigUnit_FitChainToCurve_WorkData::ItemSegments' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, CurvePositions) == 0x000028, "Member 'FRigUnit_FitChainToCurve_WorkData::CurvePositions' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, CurveSegments) == 0x000038, "Member 'FRigUnit_FitChainToCurve_WorkData::CurveSegments' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, CachedItems) == 0x000048, "Member 'FRigUnit_FitChainToCurve_WorkData::CachedItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, ItemRotationA) == 0x000058, "Member 'FRigUnit_FitChainToCurve_WorkData::ItemRotationA' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, ItemRotationB) == 0x000068, "Member 'FRigUnit_FitChainToCurve_WorkData::ItemRotationB' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, ItemRotationT) == 0x000078, "Member 'FRigUnit_FitChainToCurve_WorkData::ItemRotationT' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_WorkData, ItemLocalTransforms) == 0x000088, "Member 'FRigUnit_FitChainToCurve_WorkData::ItemLocalTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurve
// 0x0220 (0x02F0 - 0x00D0)
struct FRigUnit_FitChainToCurve final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBone;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCRFourPointBezier                     Bezier;                                            // 0x00E0(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	EControlRigCurveAlignment                     Alignment;                                         // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Minimum;                                           // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SamplingPrecision;                                 // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x0150(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0168(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleVectorPosition;                                // 0x0180(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_FitChainToCurve_Rotation> Rotations;                                         // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     RotationEaseType;                                  // 0x01A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x01AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0xF];                                      // 0x01B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_FitChainToCurve_DebugSettings DebugSettings;                                     // 0x01C0(0x0090)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_FitChainToCurve_WorkData      WorkData;                                          // 0x0250(0x0098)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FitChainToCurve) == 0x000010, "Wrong alignment on FRigUnit_FitChainToCurve");
static_assert(sizeof(FRigUnit_FitChainToCurve) == 0x0002F0, "Wrong size on FRigUnit_FitChainToCurve");
static_assert(offsetof(FRigUnit_FitChainToCurve, StartBone) == 0x0000D0, "Member 'FRigUnit_FitChainToCurve::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, EndBone) == 0x0000D8, "Member 'FRigUnit_FitChainToCurve::EndBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Bezier) == 0x0000E0, "Member 'FRigUnit_FitChainToCurve::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Alignment) == 0x000140, "Member 'FRigUnit_FitChainToCurve::Alignment' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Minimum) == 0x000144, "Member 'FRigUnit_FitChainToCurve::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Maximum) == 0x000148, "Member 'FRigUnit_FitChainToCurve::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, SamplingPrecision) == 0x00014C, "Member 'FRigUnit_FitChainToCurve::SamplingPrecision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, PrimaryAxis) == 0x000150, "Member 'FRigUnit_FitChainToCurve::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, SecondaryAxis) == 0x000168, "Member 'FRigUnit_FitChainToCurve::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, PoleVectorPosition) == 0x000180, "Member 'FRigUnit_FitChainToCurve::PoleVectorPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Rotations) == 0x000198, "Member 'FRigUnit_FitChainToCurve::Rotations' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, RotationEaseType) == 0x0001A8, "Member 'FRigUnit_FitChainToCurve::RotationEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Weight) == 0x0001AC, "Member 'FRigUnit_FitChainToCurve::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, bPropagateToChildren) == 0x0001B0, "Member 'FRigUnit_FitChainToCurve::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, DebugSettings) == 0x0001C0, "Member 'FRigUnit_FitChainToCurve::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, WorkData) == 0x000250, "Member 'FRigUnit_FitChainToCurve::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntBinaryOp
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathIntBinaryOp : public FRigUnit_MathIntBase
{
public:
	int32                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathIntBinaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathIntBinaryOp");
static_assert(sizeof(FRigUnit_MathIntBinaryOp) == 0x000018, "Wrong size on FRigUnit_MathIntBinaryOp");
static_assert(offsetof(FRigUnit_MathIntBinaryOp, A) == 0x000008, "Member 'FRigUnit_MathIntBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntBinaryOp, B) == 0x00000C, "Member 'FRigUnit_MathIntBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntBinaryOp, Result) == 0x000010, "Member 'FRigUnit_MathIntBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurvePerItem
// 0x0220 (0x02F0 - 0x00D0)
struct FRigUnit_FitChainToCurvePerItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x00D0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCRFourPointBezier                     Bezier;                                            // 0x00E0(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	EControlRigCurveAlignment                     Alignment;                                         // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Minimum;                                           // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SamplingPrecision;                                 // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x0150(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0168(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleVectorPosition;                                // 0x0180(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_FitChainToCurve_Rotation> Rotations;                                         // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     RotationEaseType;                                  // 0x01A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x01AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0xF];                                      // 0x01B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_FitChainToCurve_DebugSettings DebugSettings;                                     // 0x01C0(0x0090)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_FitChainToCurve_WorkData      WorkData;                                          // 0x0250(0x0098)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FitChainToCurvePerItem) == 0x000010, "Wrong alignment on FRigUnit_FitChainToCurvePerItem");
static_assert(sizeof(FRigUnit_FitChainToCurvePerItem) == 0x0002F0, "Wrong size on FRigUnit_FitChainToCurvePerItem");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, Items) == 0x0000D0, "Member 'FRigUnit_FitChainToCurvePerItem::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, Bezier) == 0x0000E0, "Member 'FRigUnit_FitChainToCurvePerItem::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, Alignment) == 0x000140, "Member 'FRigUnit_FitChainToCurvePerItem::Alignment' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, Minimum) == 0x000144, "Member 'FRigUnit_FitChainToCurvePerItem::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, Maximum) == 0x000148, "Member 'FRigUnit_FitChainToCurvePerItem::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, SamplingPrecision) == 0x00014C, "Member 'FRigUnit_FitChainToCurvePerItem::SamplingPrecision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, PrimaryAxis) == 0x000150, "Member 'FRigUnit_FitChainToCurvePerItem::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, SecondaryAxis) == 0x000168, "Member 'FRigUnit_FitChainToCurvePerItem::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, PoleVectorPosition) == 0x000180, "Member 'FRigUnit_FitChainToCurvePerItem::PoleVectorPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, Rotations) == 0x000198, "Member 'FRigUnit_FitChainToCurvePerItem::Rotations' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, RotationEaseType) == 0x0001A8, "Member 'FRigUnit_FitChainToCurvePerItem::RotationEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, Weight) == 0x0001AC, "Member 'FRigUnit_FitChainToCurvePerItem::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, bPropagateToChildren) == 0x0001B0, "Member 'FRigUnit_FitChainToCurvePerItem::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, DebugSettings) == 0x0001C0, "Member 'FRigUnit_FitChainToCurvePerItem::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurvePerItem, WorkData) == 0x000250, "Member 'FRigUnit_FitChainToCurvePerItem::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurveItemArray
// 0x0220 (0x02F0 - 0x00D0)
struct FRigUnit_FitChainToCurveItemArray final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCRFourPointBezier                     Bezier;                                            // 0x00E0(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	EControlRigCurveAlignment                     Alignment;                                         // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x3];                                      // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Minimum;                                           // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SamplingPrecision;                                 // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x0150(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0168(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleVectorPosition;                                // 0x0180(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_FitChainToCurve_Rotation> Rotations;                                         // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     RotationEaseType;                                  // 0x01A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x01AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0xF];                                      // 0x01B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_FitChainToCurve_DebugSettings DebugSettings;                                     // 0x01C0(0x0090)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_FitChainToCurve_WorkData      WorkData;                                          // 0x0250(0x0098)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FitChainToCurveItemArray) == 0x000010, "Wrong alignment on FRigUnit_FitChainToCurveItemArray");
static_assert(sizeof(FRigUnit_FitChainToCurveItemArray) == 0x0002F0, "Wrong size on FRigUnit_FitChainToCurveItemArray");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, Items) == 0x0000D0, "Member 'FRigUnit_FitChainToCurveItemArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, Bezier) == 0x0000E0, "Member 'FRigUnit_FitChainToCurveItemArray::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, Alignment) == 0x000140, "Member 'FRigUnit_FitChainToCurveItemArray::Alignment' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, Minimum) == 0x000144, "Member 'FRigUnit_FitChainToCurveItemArray::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, Maximum) == 0x000148, "Member 'FRigUnit_FitChainToCurveItemArray::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, SamplingPrecision) == 0x00014C, "Member 'FRigUnit_FitChainToCurveItemArray::SamplingPrecision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, PrimaryAxis) == 0x000150, "Member 'FRigUnit_FitChainToCurveItemArray::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, SecondaryAxis) == 0x000168, "Member 'FRigUnit_FitChainToCurveItemArray::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, PoleVectorPosition) == 0x000180, "Member 'FRigUnit_FitChainToCurveItemArray::PoleVectorPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, Rotations) == 0x000198, "Member 'FRigUnit_FitChainToCurveItemArray::Rotations' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, RotationEaseType) == 0x0001A8, "Member 'FRigUnit_FitChainToCurveItemArray::RotationEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, Weight) == 0x0001AC, "Member 'FRigUnit_FitChainToCurveItemArray::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, bPropagateToChildren) == 0x0001B0, "Member 'FRigUnit_FitChainToCurveItemArray::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, DebugSettings) == 0x0001C0, "Member 'FRigUnit_FitChainToCurveItemArray::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurveItemArray, WorkData) == 0x000250, "Member 'FRigUnit_FitChainToCurveItemArray::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryFloatOp
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_BinaryFloatOp : public FRigUnit
{
public:
	float                                         Argument0;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Argument1;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_BinaryFloatOp) == 0x000008, "Wrong alignment on FRigUnit_BinaryFloatOp");
static_assert(sizeof(FRigUnit_BinaryFloatOp) == 0x000018, "Wrong size on FRigUnit_BinaryFloatOp");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Argument0) == 0x000008, "Member 'FRigUnit_BinaryFloatOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Argument1) == 0x00000C, "Member 'FRigUnit_BinaryFloatOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Result) == 0x000010, "Member 'FRigUnit_BinaryFloatOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathColorMul
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathColorMul final : public FRigUnit_MathColorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathColorMul) == 0x000008, "Wrong alignment on FRigUnit_MathColorMul");
static_assert(sizeof(FRigUnit_MathColorMul) == 0x000038, "Wrong size on FRigUnit_MathColorMul");

// ScriptStruct ControlRig.RigUnit_Multiply_FloatFloat
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_Multiply_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Multiply_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Multiply_FloatFloat");
static_assert(sizeof(FRigUnit_Multiply_FloatFloat) == 0x000018, "Wrong size on FRigUnit_Multiply_FloatFloat");

// ScriptStruct ControlRig.RigUnit_MathFloatDeg
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatDeg final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatDeg) == 0x000008, "Wrong alignment on FRigUnit_MathFloatDeg");
static_assert(sizeof(FRigUnit_MathFloatDeg) == 0x000010, "Wrong size on FRigUnit_MathFloatDeg");

// ScriptStruct ControlRig.RigUnit_Add_FloatFloat
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_Add_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Add_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Add_FloatFloat");
static_assert(sizeof(FRigUnit_Add_FloatFloat) == 0x000018, "Wrong size on FRigUnit_Add_FloatFloat");

// ScriptStruct ControlRig.RigUnit_Subtract_FloatFloat
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_Subtract_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Subtract_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Subtract_FloatFloat");
static_assert(sizeof(FRigUnit_Subtract_FloatFloat) == 0x000018, "Wrong size on FRigUnit_Subtract_FloatFloat");

// ScriptStruct ControlRig.RigUnit_Divide_FloatFloat
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_Divide_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Divide_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Divide_FloatFloat");
static_assert(sizeof(FRigUnit_Divide_FloatFloat) == 0x000018, "Wrong size on FRigUnit_Divide_FloatFloat");

// ScriptStruct ControlRig.RigUnit_MathIntGreaterEqual
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathIntGreaterEqual final : public FRigUnit_MathIntBase
{
public:
	int32                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathIntGreaterEqual) == 0x000008, "Wrong alignment on FRigUnit_MathIntGreaterEqual");
static_assert(sizeof(FRigUnit_MathIntGreaterEqual) == 0x000018, "Wrong size on FRigUnit_MathIntGreaterEqual");
static_assert(offsetof(FRigUnit_MathIntGreaterEqual, A) == 0x000008, "Member 'FRigUnit_MathIntGreaterEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntGreaterEqual, B) == 0x00000C, "Member 'FRigUnit_MathIntGreaterEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntGreaterEqual, Result) == 0x000010, "Member 'FRigUnit_MathIntGreaterEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Clamp_Float
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_Clamp_Float final : public FRigUnit
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_Clamp_Float) == 0x000008, "Wrong alignment on FRigUnit_Clamp_Float");
static_assert(sizeof(FRigUnit_Clamp_Float) == 0x000018, "Wrong size on FRigUnit_Clamp_Float");
static_assert(offsetof(FRigUnit_Clamp_Float, Value) == 0x000008, "Member 'FRigUnit_Clamp_Float::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Min) == 0x00000C, "Member 'FRigUnit_Clamp_Float::Min' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Max) == 0x000010, "Member 'FRigUnit_Clamp_Float::Max' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Result) == 0x000014, "Member 'FRigUnit_Clamp_Float::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntPow
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathIntPow final : public FRigUnit_MathIntBinaryOp
{
};
static_assert(alignof(FRigUnit_MathIntPow) == 0x000008, "Wrong alignment on FRigUnit_MathIntPow");
static_assert(sizeof(FRigUnit_MathIntPow) == 0x000018, "Wrong size on FRigUnit_MathIntPow");

// ScriptStruct ControlRig.RigUnit_MapRange_Float
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_MapRange_Float final : public FRigUnit
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinIn;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIn;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOut;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOut;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MapRange_Float) == 0x000008, "Wrong alignment on FRigUnit_MapRange_Float");
static_assert(sizeof(FRigUnit_MapRange_Float) == 0x000020, "Wrong size on FRigUnit_MapRange_Float");
static_assert(offsetof(FRigUnit_MapRange_Float, Value) == 0x000008, "Member 'FRigUnit_MapRange_Float::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, MinIn) == 0x00000C, "Member 'FRigUnit_MapRange_Float::MinIn' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, MaxIn) == 0x000010, "Member 'FRigUnit_MapRange_Float::MaxIn' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, MinOut) == 0x000014, "Member 'FRigUnit_MapRange_Float::MinOut' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, MaxOut) == 0x000018, "Member 'FRigUnit_MapRange_Float::MaxOut' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, Result) == 0x00001C, "Member 'FRigUnit_MapRange_Float::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ForLoopCount
// 0x00D0 (0x01A0 - 0x00D0)
struct FRigUnit_ForLoopCount final : public FRigUnitMutable
{
public:
	int32                                         Count;                                             // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Continue;                                          // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              Completed;                                         // 0x00E0(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ForLoopCount) == 0x000010, "Wrong alignment on FRigUnit_ForLoopCount");
static_assert(sizeof(FRigUnit_ForLoopCount) == 0x0001A0, "Wrong size on FRigUnit_ForLoopCount");
static_assert(offsetof(FRigUnit_ForLoopCount, Count) == 0x0000D0, "Member 'FRigUnit_ForLoopCount::Count' has a wrong offset!");
static_assert(offsetof(FRigUnit_ForLoopCount, Index) == 0x0000D4, "Member 'FRigUnit_ForLoopCount::Index' has a wrong offset!");
static_assert(offsetof(FRigUnit_ForLoopCount, Ratio) == 0x0000D8, "Member 'FRigUnit_ForLoopCount::Ratio' has a wrong offset!");
static_assert(offsetof(FRigUnit_ForLoopCount, Continue) == 0x0000DC, "Member 'FRigUnit_ForLoopCount::Continue' has a wrong offset!");
static_assert(offsetof(FRigUnit_ForLoopCount, Completed) == 0x0000E0, "Member 'FRigUnit_ForLoopCount::Completed' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetBoneTransform
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_GetBoneTransform final : public FRigUnit
{
public:
	class FName                                   bone;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedBone;                                        // 0x0080(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_GetBoneTransform");
static_assert(sizeof(FRigUnit_GetBoneTransform) == 0x0000A0, "Wrong size on FRigUnit_GetBoneTransform");
static_assert(offsetof(FRigUnit_GetBoneTransform, bone) == 0x000008, "Member 'FRigUnit_GetBoneTransform::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetBoneTransform, Space) == 0x000010, "Member 'FRigUnit_GetBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetBoneTransform, Transform) == 0x000020, "Member 'FRigUnit_GetBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetBoneTransform, CachedBone) == 0x000080, "Member 'FRigUnit_GetBoneTransform::CachedBone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathMatrixBinaryOp
// 0x0188 (0x0190 - 0x0008)
struct FRigUnit_MathMatrixBinaryOp : public FRigUnit_MathMatrixBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                A;                                                 // 0x0010(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMatrix                                B;                                                 // 0x0090(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMatrix                                Result;                                            // 0x0110(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathMatrixBinaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathMatrixBinaryOp");
static_assert(sizeof(FRigUnit_MathMatrixBinaryOp) == 0x000190, "Wrong size on FRigUnit_MathMatrixBinaryOp");
static_assert(offsetof(FRigUnit_MathMatrixBinaryOp, A) == 0x000010, "Member 'FRigUnit_MathMatrixBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixBinaryOp, B) == 0x000090, "Member 'FRigUnit_MathMatrixBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixBinaryOp, Result) == 0x000110, "Member 'FRigUnit_MathMatrixBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetControlInitialTransform
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_GetControlInitialTransform final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0080(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetControlInitialTransform) == 0x000010, "Wrong alignment on FRigUnit_GetControlInitialTransform");
static_assert(sizeof(FRigUnit_GetControlInitialTransform) == 0x0000A0, "Wrong size on FRigUnit_GetControlInitialTransform");
static_assert(offsetof(FRigUnit_GetControlInitialTransform, Control) == 0x000008, "Member 'FRigUnit_GetControlInitialTransform::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlInitialTransform, Space) == 0x000010, "Member 'FRigUnit_GetControlInitialTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlInitialTransform, Transform) == 0x000020, "Member 'FRigUnit_GetControlInitialTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlInitialTransform, CachedControlIndex) == 0x000080, "Member 'FRigUnit_GetControlInitialTransform::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.MathRBFInterpolateQuatVector_Target
// 0x0040 (0x0040 - 0x0000)
struct FMathRBFInterpolateQuatVector_Target final
{
public:
	struct FQuat                                  Target;                                            // 0x0000(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMathRBFInterpolateQuatVector_Target) == 0x000010, "Wrong alignment on FMathRBFInterpolateQuatVector_Target");
static_assert(sizeof(FMathRBFInterpolateQuatVector_Target) == 0x000040, "Wrong size on FMathRBFInterpolateQuatVector_Target");
static_assert(offsetof(FMathRBFInterpolateQuatVector_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateQuatVector_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateQuatVector_Target, Value) == 0x000020, "Member 'FMathRBFInterpolateQuatVector_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateQuatWorkData
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FRigUnit_MathRBFInterpolateQuatWorkData final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathRBFInterpolateQuatWorkData) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateQuatWorkData");
static_assert(sizeof(FRigUnit_MathRBFInterpolateQuatWorkData) == 0x000090, "Wrong size on FRigUnit_MathRBFInterpolateQuatWorkData");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MathRBFInterpolateBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathRBFInterpolateBase) == 0x000008, "Wrong alignment on FRigUnit_MathRBFInterpolateBase");
static_assert(sizeof(FRigUnit_MathRBFInterpolateBase) == 0x000008, "Wrong size on FRigUnit_MathRBFInterpolateBase");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateQuatBase
// 0x00E8 (0x00F0 - 0x0008)
struct FRigUnit_MathRBFInterpolateQuatBase : public FRigUnit_MathRBFInterpolateBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Input;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ERBFQuatDistanceType                          DistanceFunction;                                  // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERBFKernelType                                SmoothingFunction;                                 // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothingAngle;                                    // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalizeOutput;                                  // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TwistAxis;                                         // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_MathRBFInterpolateQuatWorkData WorkData;                                          // 0x0060(0x0090)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathRBFInterpolateQuatBase) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateQuatBase");
static_assert(sizeof(FRigUnit_MathRBFInterpolateQuatBase) == 0x0000F0, "Wrong size on FRigUnit_MathRBFInterpolateQuatBase");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatBase, Input) == 0x000010, "Member 'FRigUnit_MathRBFInterpolateQuatBase::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatBase, DistanceFunction) == 0x000030, "Member 'FRigUnit_MathRBFInterpolateQuatBase::DistanceFunction' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatBase, SmoothingFunction) == 0x000031, "Member 'FRigUnit_MathRBFInterpolateQuatBase::SmoothingFunction' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatBase, SmoothingAngle) == 0x000034, "Member 'FRigUnit_MathRBFInterpolateQuatBase::SmoothingAngle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatBase, bNormalizeOutput) == 0x000038, "Member 'FRigUnit_MathRBFInterpolateQuatBase::bNormalizeOutput' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatBase, TwistAxis) == 0x000040, "Member 'FRigUnit_MathRBFInterpolateQuatBase::TwistAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatBase, WorkData) == 0x000060, "Member 'FRigUnit_MathRBFInterpolateQuatBase::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateQuatVector
// 0x0030 (0x0120 - 0x00F0)
struct FRigUnit_MathRBFInterpolateQuatVector final : public FRigUnit_MathRBFInterpolateQuatBase
{
public:
	TArray<struct FMathRBFInterpolateQuatVector_Target> Targets;                                           // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Output;                                            // 0x0100(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathRBFInterpolateQuatVector) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateQuatVector");
static_assert(sizeof(FRigUnit_MathRBFInterpolateQuatVector) == 0x000120, "Wrong size on FRigUnit_MathRBFInterpolateQuatVector");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatVector, Targets) == 0x0000F0, "Member 'FRigUnit_MathRBFInterpolateQuatVector::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatVector, Output) == 0x000100, "Member 'FRigUnit_MathRBFInterpolateQuatVector::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetControlBool
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_GetControlBool final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0018(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetControlBool) == 0x000008, "Wrong alignment on FRigUnit_GetControlBool");
static_assert(sizeof(FRigUnit_GetControlBool) == 0x000038, "Wrong size on FRigUnit_GetControlBool");
static_assert(offsetof(FRigUnit_GetControlBool, Control) == 0x000008, "Member 'FRigUnit_GetControlBool::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlBool, BoolValue) == 0x000010, "Member 'FRigUnit_GetControlBool::BoolValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlBool, CachedControlIndex) == 0x000018, "Member 'FRigUnit_GetControlBool::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetControlFloat
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_GetControlFloat final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0020(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetControlFloat) == 0x000008, "Wrong alignment on FRigUnit_GetControlFloat");
static_assert(sizeof(FRigUnit_GetControlFloat) == 0x000040, "Wrong size on FRigUnit_GetControlFloat");
static_assert(offsetof(FRigUnit_GetControlFloat, Control) == 0x000008, "Member 'FRigUnit_GetControlFloat::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlFloat, FloatValue) == 0x000010, "Member 'FRigUnit_GetControlFloat::FloatValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlFloat, Minimum) == 0x000014, "Member 'FRigUnit_GetControlFloat::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlFloat, Maximum) == 0x000018, "Member 'FRigUnit_GetControlFloat::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlFloat, CachedControlIndex) == 0x000020, "Member 'FRigUnit_GetControlFloat::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetControlInteger
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_GetControlInteger final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntegerValue;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minimum;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Maximum;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0020(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetControlInteger) == 0x000008, "Wrong alignment on FRigUnit_GetControlInteger");
static_assert(sizeof(FRigUnit_GetControlInteger) == 0x000040, "Wrong size on FRigUnit_GetControlInteger");
static_assert(offsetof(FRigUnit_GetControlInteger, Control) == 0x000008, "Member 'FRigUnit_GetControlInteger::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlInteger, IntegerValue) == 0x000010, "Member 'FRigUnit_GetControlInteger::IntegerValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlInteger, Minimum) == 0x000014, "Member 'FRigUnit_GetControlInteger::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlInteger, Maximum) == 0x000018, "Member 'FRigUnit_GetControlInteger::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlInteger, CachedControlIndex) == 0x000020, "Member 'FRigUnit_GetControlInteger::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathMatrixFromVectors
// 0x00E8 (0x00F0 - 0x0008)
struct FRigUnit_MathMatrixFromVectors final : public FRigUnit_MathMatrixBase
{
public:
	struct FVector                                Origin;                                            // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Z;                                                 // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                Result;                                            // 0x0070(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathMatrixFromVectors) == 0x000010, "Wrong alignment on FRigUnit_MathMatrixFromVectors");
static_assert(sizeof(FRigUnit_MathMatrixFromVectors) == 0x0000F0, "Wrong size on FRigUnit_MathMatrixFromVectors");
static_assert(offsetof(FRigUnit_MathMatrixFromVectors, Origin) == 0x000008, "Member 'FRigUnit_MathMatrixFromVectors::Origin' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixFromVectors, X) == 0x000020, "Member 'FRigUnit_MathMatrixFromVectors::X' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixFromVectors, Y) == 0x000038, "Member 'FRigUnit_MathMatrixFromVectors::Y' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixFromVectors, Z) == 0x000050, "Member 'FRigUnit_MathMatrixFromVectors::Z' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixFromVectors, Result) == 0x000070, "Member 'FRigUnit_MathMatrixFromVectors::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetControlVector2D
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_GetControlVector2D final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Vector;                                            // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Minimum;                                           // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Maximum;                                           // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0040(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetControlVector2D) == 0x000008, "Wrong alignment on FRigUnit_GetControlVector2D");
static_assert(sizeof(FRigUnit_GetControlVector2D) == 0x000060, "Wrong size on FRigUnit_GetControlVector2D");
static_assert(offsetof(FRigUnit_GetControlVector2D, Control) == 0x000008, "Member 'FRigUnit_GetControlVector2D::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector2D, Vector) == 0x000010, "Member 'FRigUnit_GetControlVector2D::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector2D, Minimum) == 0x000020, "Member 'FRigUnit_GetControlVector2D::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector2D, Maximum) == 0x000030, "Member 'FRigUnit_GetControlVector2D::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector2D, CachedControlIndex) == 0x000040, "Member 'FRigUnit_GetControlVector2D::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntGreater
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathIntGreater final : public FRigUnit_MathIntBase
{
public:
	int32                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathIntGreater) == 0x000008, "Wrong alignment on FRigUnit_MathIntGreater");
static_assert(sizeof(FRigUnit_MathIntGreater) == 0x000018, "Wrong size on FRigUnit_MathIntGreater");
static_assert(offsetof(FRigUnit_MathIntGreater, A) == 0x000008, "Member 'FRigUnit_MathIntGreater::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntGreater, B) == 0x00000C, "Member 'FRigUnit_MathIntGreater::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntGreater, Result) == 0x000010, "Member 'FRigUnit_MathIntGreater::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetControlVector
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_GetControlVector final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector;                                            // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Minimum;                                           // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Maximum;                                           // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0060(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetControlVector) == 0x000008, "Wrong alignment on FRigUnit_GetControlVector");
static_assert(sizeof(FRigUnit_GetControlVector) == 0x000080, "Wrong size on FRigUnit_GetControlVector");
static_assert(offsetof(FRigUnit_GetControlVector, Control) == 0x000008, "Member 'FRigUnit_GetControlVector::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector, Space) == 0x000010, "Member 'FRigUnit_GetControlVector::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector, Vector) == 0x000018, "Member 'FRigUnit_GetControlVector::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector, Minimum) == 0x000030, "Member 'FRigUnit_GetControlVector::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector, Maximum) == 0x000048, "Member 'FRigUnit_GetControlVector::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlVector, CachedControlIndex) == 0x000060, "Member 'FRigUnit_GetControlVector::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetControlRotator
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_GetControlRotator final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotator;                                           // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Minimum;                                           // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Maximum;                                           // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0060(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetControlRotator) == 0x000008, "Wrong alignment on FRigUnit_GetControlRotator");
static_assert(sizeof(FRigUnit_GetControlRotator) == 0x000080, "Wrong size on FRigUnit_GetControlRotator");
static_assert(offsetof(FRigUnit_GetControlRotator, Control) == 0x000008, "Member 'FRigUnit_GetControlRotator::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlRotator, Space) == 0x000010, "Member 'FRigUnit_GetControlRotator::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlRotator, Rotator) == 0x000018, "Member 'FRigUnit_GetControlRotator::Rotator' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlRotator, Minimum) == 0x000030, "Member 'FRigUnit_GetControlRotator::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlRotator, Maximum) == 0x000048, "Member 'FRigUnit_GetControlRotator::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlRotator, CachedControlIndex) == 0x000060, "Member 'FRigUnit_GetControlRotator::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetControlTransform
// 0x0158 (0x0160 - 0x0008)
struct FRigUnit_GetControlTransform final : public FRigUnit
{
public:
	class FName                                   Control;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Minimum;                                           // 0x0080(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Maximum;                                           // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0140(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetControlTransform) == 0x000010, "Wrong alignment on FRigUnit_GetControlTransform");
static_assert(sizeof(FRigUnit_GetControlTransform) == 0x000160, "Wrong size on FRigUnit_GetControlTransform");
static_assert(offsetof(FRigUnit_GetControlTransform, Control) == 0x000008, "Member 'FRigUnit_GetControlTransform::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlTransform, Space) == 0x000010, "Member 'FRigUnit_GetControlTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlTransform, Transform) == 0x000020, "Member 'FRigUnit_GetControlTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlTransform, Minimum) == 0x000080, "Member 'FRigUnit_GetControlTransform::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlTransform, Maximum) == 0x0000E0, "Member 'FRigUnit_GetControlTransform::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetControlTransform, CachedControlIndex) == 0x000140, "Member 'FRigUnit_GetControlTransform::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionUnaryOp
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathQuaternionUnaryOp : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionUnaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionUnaryOp");
static_assert(sizeof(FRigUnit_MathQuaternionUnaryOp) == 0x000050, "Wrong size on FRigUnit_MathQuaternionUnaryOp");
static_assert(offsetof(FRigUnit_MathQuaternionUnaryOp, Value) == 0x000010, "Member 'FRigUnit_MathQuaternionUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionUnaryOp, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetCurveValue
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_GetCurveValue final : public FRigUnit
{
public:
	class FName                                   Curve;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedCurveIndex;                                  // 0x0018(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigUnit_GetCurveValue) == 0x000008, "Wrong alignment on FRigUnit_GetCurveValue");
static_assert(sizeof(FRigUnit_GetCurveValue) == 0x000038, "Wrong size on FRigUnit_GetCurveValue");
static_assert(offsetof(FRigUnit_GetCurveValue, Curve) == 0x000008, "Member 'FRigUnit_GetCurveValue::Curve' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetCurveValue, Value) == 0x000010, "Member 'FRigUnit_GetCurveValue::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetCurveValue, CachedCurveIndex) == 0x000018, "Member 'FRigUnit_GetCurveValue::CachedCurveIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntDiv
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathIntDiv final : public FRigUnit_MathIntBinaryOp
{
};
static_assert(alignof(FRigUnit_MathIntDiv) == 0x000008, "Wrong alignment on FRigUnit_MathIntDiv");
static_assert(sizeof(FRigUnit_MathIntDiv) == 0x000018, "Wrong size on FRigUnit_MathIntDiv");

// ScriptStruct ControlRig.RigUnit_GetDeltaTime
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_GetDeltaTime final : public FRigUnit_AnimBase
{
public:
	float                                         Result;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_GetDeltaTime) == 0x000008, "Wrong alignment on FRigUnit_GetDeltaTime");
static_assert(sizeof(FRigUnit_GetDeltaTime) == 0x000010, "Wrong size on FRigUnit_GetDeltaTime");
static_assert(offsetof(FRigUnit_GetDeltaTime, Result) == 0x000008, "Member 'FRigUnit_GetDeltaTime::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetInitialBoneTransform
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_GetInitialBoneTransform final : public FRigUnit
{
public:
	class FName                                   bone;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedBone;                                        // 0x0080(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetInitialBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_GetInitialBoneTransform");
static_assert(sizeof(FRigUnit_GetInitialBoneTransform) == 0x0000A0, "Wrong size on FRigUnit_GetInitialBoneTransform");
static_assert(offsetof(FRigUnit_GetInitialBoneTransform, bone) == 0x000008, "Member 'FRigUnit_GetInitialBoneTransform::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetInitialBoneTransform, Space) == 0x000010, "Member 'FRigUnit_GetInitialBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetInitialBoneTransform, Transform) == 0x000020, "Member 'FRigUnit_GetInitialBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetInitialBoneTransform, CachedBone) == 0x000080, "Member 'FRigUnit_GetInitialBoneTransform::CachedBone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetJointTransform
// 0x00E0 (0x01B0 - 0x00D0)
struct FRigUnit_GetJointTransform final : public FRigUnitMutable
{
public:
	class FName                                   Joint;                                             // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformGetterType                          Type;                                              // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           TransformSpace;                                    // 0x00D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseJoint;                                         // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Output;                                            // 0x0150(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetJointTransform) == 0x000010, "Wrong alignment on FRigUnit_GetJointTransform");
static_assert(sizeof(FRigUnit_GetJointTransform) == 0x0001B0, "Wrong size on FRigUnit_GetJointTransform");
static_assert(offsetof(FRigUnit_GetJointTransform, Joint) == 0x0000D0, "Member 'FRigUnit_GetJointTransform::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, Type) == 0x0000D8, "Member 'FRigUnit_GetJointTransform::Type' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, TransformSpace) == 0x0000D9, "Member 'FRigUnit_GetJointTransform::TransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, BaseTransform) == 0x0000E0, "Member 'FRigUnit_GetJointTransform::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, BaseJoint) == 0x000140, "Member 'FRigUnit_GetJointTransform::BaseJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, Output) == 0x000150, "Member 'FRigUnit_GetJointTransform::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorAdd
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathVectorAdd final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorAdd) == 0x000008, "Wrong alignment on FRigUnit_MathVectorAdd");
static_assert(sizeof(FRigUnit_MathVectorAdd) == 0x000050, "Wrong size on FRigUnit_MathVectorAdd");

// ScriptStruct ControlRig.RigUnit_GetRelativeBoneTransform
// 0x00B8 (0x00C0 - 0x0008)
struct FRigUnit_GetRelativeBoneTransform final : public FRigUnit
{
public:
	class FName                                   bone;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedBone;                                        // 0x0080(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedSpace;                                       // 0x00A0(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetRelativeBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_GetRelativeBoneTransform");
static_assert(sizeof(FRigUnit_GetRelativeBoneTransform) == 0x0000C0, "Wrong size on FRigUnit_GetRelativeBoneTransform");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, bone) == 0x000008, "Member 'FRigUnit_GetRelativeBoneTransform::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, Space) == 0x000010, "Member 'FRigUnit_GetRelativeBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, Transform) == 0x000020, "Member 'FRigUnit_GetRelativeBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, CachedBone) == 0x000080, "Member 'FRigUnit_GetRelativeBoneTransform::CachedBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, CachedSpace) == 0x0000A0, "Member 'FRigUnit_GetRelativeBoneTransform::CachedSpace' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathMatrixFromTransform
// 0x00E8 (0x00F0 - 0x0008)
struct FRigUnit_MathMatrixFromTransform final : public FRigUnit_MathMatrixBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMatrix                                Result;                                            // 0x0070(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathMatrixFromTransform) == 0x000010, "Wrong alignment on FRigUnit_MathMatrixFromTransform");
static_assert(sizeof(FRigUnit_MathMatrixFromTransform) == 0x0000F0, "Wrong size on FRigUnit_MathMatrixFromTransform");
static_assert(offsetof(FRigUnit_MathMatrixFromTransform, Transform) == 0x000010, "Member 'FRigUnit_MathMatrixFromTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixFromTransform, Result) == 0x000070, "Member 'FRigUnit_MathMatrixFromTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetRelativeTransformForItem
// 0x00C8 (0x00D0 - 0x0008)
struct FRigUnit_GetRelativeTransformForItem final : public FRigUnit
{
public:
	struct FRigElementKey                         Child;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChildInitial;                                     // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         Parent;                                            // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParentInitial;                                    // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0xB];                                       // 0x0025(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0030(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedChild;                                       // 0x0090(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedParent;                                      // 0x00B0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetRelativeTransformForItem) == 0x000010, "Wrong alignment on FRigUnit_GetRelativeTransformForItem");
static_assert(sizeof(FRigUnit_GetRelativeTransformForItem) == 0x0000D0, "Wrong size on FRigUnit_GetRelativeTransformForItem");
static_assert(offsetof(FRigUnit_GetRelativeTransformForItem, Child) == 0x000008, "Member 'FRigUnit_GetRelativeTransformForItem::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeTransformForItem, bChildInitial) == 0x000014, "Member 'FRigUnit_GetRelativeTransformForItem::bChildInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeTransformForItem, Parent) == 0x000018, "Member 'FRigUnit_GetRelativeTransformForItem::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeTransformForItem, bParentInitial) == 0x000024, "Member 'FRigUnit_GetRelativeTransformForItem::bParentInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeTransformForItem, RelativeTransform) == 0x000030, "Member 'FRigUnit_GetRelativeTransformForItem::RelativeTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeTransformForItem, CachedChild) == 0x000090, "Member 'FRigUnit_GetRelativeTransformForItem::CachedChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeTransformForItem, CachedParent) == 0x0000B0, "Member 'FRigUnit_GetRelativeTransformForItem::CachedParent' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetSpaceTransform
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_GetSpaceTransform final : public FRigUnit
{
public:
	class FName                                   Space;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         SpaceType;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedSpaceIndex;                                  // 0x0080(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetSpaceTransform) == 0x000010, "Wrong alignment on FRigUnit_GetSpaceTransform");
static_assert(sizeof(FRigUnit_GetSpaceTransform) == 0x0000A0, "Wrong size on FRigUnit_GetSpaceTransform");
static_assert(offsetof(FRigUnit_GetSpaceTransform, Space) == 0x000008, "Member 'FRigUnit_GetSpaceTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetSpaceTransform, SpaceType) == 0x000010, "Member 'FRigUnit_GetSpaceTransform::SpaceType' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetSpaceTransform, Transform) == 0x000020, "Member 'FRigUnit_GetSpaceTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetSpaceTransform, CachedSpaceIndex) == 0x000080, "Member 'FRigUnit_GetSpaceTransform::CachedSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetTransform
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_GetTransform final : public FRigUnit
{
public:
	struct FRigElementKey                         Item;                                              // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitial;                                          // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0xA];                                       // 0x0016(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedIndex;                                       // 0x0080(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetTransform) == 0x000010, "Wrong alignment on FRigUnit_GetTransform");
static_assert(sizeof(FRigUnit_GetTransform) == 0x0000A0, "Wrong size on FRigUnit_GetTransform");
static_assert(offsetof(FRigUnit_GetTransform, Item) == 0x000008, "Member 'FRigUnit_GetTransform::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransform, Space) == 0x000014, "Member 'FRigUnit_GetTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransform, bInitial) == 0x000015, "Member 'FRigUnit_GetTransform::bInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransform, Transform) == 0x000020, "Member 'FRigUnit_GetTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransform, CachedIndex) == 0x000080, "Member 'FRigUnit_GetTransform::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorDiv
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathVectorDiv final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorDiv) == 0x000008, "Wrong alignment on FRigUnit_MathVectorDiv");
static_assert(sizeof(FRigUnit_MathVectorDiv) == 0x000050, "Wrong size on FRigUnit_MathVectorDiv");

// ScriptStruct ControlRig.RigUnit_GetTransformArray
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_GetTransformArray final : public FRigUnit
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x0008(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitial;                                          // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Transforms;                                        // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              CachedIndex;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetTransformArray) == 0x000008, "Wrong alignment on FRigUnit_GetTransformArray");
static_assert(sizeof(FRigUnit_GetTransformArray) == 0x000040, "Wrong size on FRigUnit_GetTransformArray");
static_assert(offsetof(FRigUnit_GetTransformArray, Items) == 0x000008, "Member 'FRigUnit_GetTransformArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransformArray, Space) == 0x000018, "Member 'FRigUnit_GetTransformArray::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransformArray, bInitial) == 0x000019, "Member 'FRigUnit_GetTransformArray::bInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransformArray, Transforms) == 0x000020, "Member 'FRigUnit_GetTransformArray::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransformArray, CachedIndex) == 0x000030, "Member 'FRigUnit_GetTransformArray::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntUnaryOp
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathIntUnaryOp : public FRigUnit_MathIntBase
{
public:
	int32                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathIntUnaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathIntUnaryOp");
static_assert(sizeof(FRigUnit_MathIntUnaryOp) == 0x000010, "Wrong size on FRigUnit_MathIntUnaryOp");
static_assert(offsetof(FRigUnit_MathIntUnaryOp, Value) == 0x000008, "Member 'FRigUnit_MathIntUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntUnaryOp, Result) == 0x00000C, "Member 'FRigUnit_MathIntUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntSign
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathIntSign final : public FRigUnit_MathIntUnaryOp
{
};
static_assert(alignof(FRigUnit_MathIntSign) == 0x000008, "Wrong alignment on FRigUnit_MathIntSign");
static_assert(sizeof(FRigUnit_MathIntSign) == 0x000010, "Wrong size on FRigUnit_MathIntSign");

// ScriptStruct ControlRig.RigUnit_GetTransformItemArray
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_GetTransformItemArray final : public FRigUnit
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitial;                                          // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Transforms;                                        // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              CachedIndex;                                       // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetTransformItemArray) == 0x000008, "Wrong alignment on FRigUnit_GetTransformItemArray");
static_assert(sizeof(FRigUnit_GetTransformItemArray) == 0x000040, "Wrong size on FRigUnit_GetTransformItemArray");
static_assert(offsetof(FRigUnit_GetTransformItemArray, Items) == 0x000008, "Member 'FRigUnit_GetTransformItemArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransformItemArray, Space) == 0x000018, "Member 'FRigUnit_GetTransformItemArray::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransformItemArray, bInitial) == 0x000019, "Member 'FRigUnit_GetTransformItemArray::bInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransformItemArray, Transforms) == 0x000020, "Member 'FRigUnit_GetTransformItemArray::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetTransformItemArray, CachedIndex) == 0x000030, "Member 'FRigUnit_GetTransformItemArray::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetWorldTime
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_GetWorldTime final : public FRigUnit_AnimBase
{
public:
	float                                         Year;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Month;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Day;                                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeekDay;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hours;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minutes;                                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Seconds;                                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverallSeconds;                                    // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetWorldTime) == 0x000008, "Wrong alignment on FRigUnit_GetWorldTime");
static_assert(sizeof(FRigUnit_GetWorldTime) == 0x000028, "Wrong size on FRigUnit_GetWorldTime");
static_assert(offsetof(FRigUnit_GetWorldTime, Year) == 0x000008, "Member 'FRigUnit_GetWorldTime::Year' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Month) == 0x00000C, "Member 'FRigUnit_GetWorldTime::Month' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Day) == 0x000010, "Member 'FRigUnit_GetWorldTime::Day' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, WeekDay) == 0x000014, "Member 'FRigUnit_GetWorldTime::WeekDay' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Hours) == 0x000018, "Member 'FRigUnit_GetWorldTime::Hours' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Minutes) == 0x00001C, "Member 'FRigUnit_GetWorldTime::Minutes' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Seconds) == 0x000020, "Member 'FRigUnit_GetWorldTime::Seconds' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, OverallSeconds) == 0x000024, "Member 'FRigUnit_GetWorldTime::OverallSeconds' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_HierarchyBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_HierarchyBase) == 0x000008, "Wrong alignment on FRigUnit_HierarchyBase");
static_assert(sizeof(FRigUnit_HierarchyBase) == 0x000008, "Wrong size on FRigUnit_HierarchyBase");

// ScriptStruct ControlRig.RigUnit_MathVectorNegate
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorNegate final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorNegate) == 0x000008, "Wrong alignment on FRigUnit_MathVectorNegate");
static_assert(sizeof(FRigUnit_MathVectorNegate) == 0x000038, "Wrong size on FRigUnit_MathVectorNegate");

// ScriptStruct ControlRig.RigUnit_HierarchyBaseMutable
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_HierarchyBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_HierarchyBaseMutable) == 0x000010, "Wrong alignment on FRigUnit_HierarchyBaseMutable");
static_assert(sizeof(FRigUnit_HierarchyBaseMutable) == 0x0000D0, "Wrong size on FRigUnit_HierarchyBaseMutable");

// ScriptStruct ControlRig.RigUnit_MathQuaternionFromAxisAndAngle
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathQuaternionFromAxisAndAngle final : public FRigUnit_MathQuaternionBase
{
public:
	struct FVector                                Axis;                                              // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionFromAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionFromAxisAndAngle");
static_assert(sizeof(FRigUnit_MathQuaternionFromAxisAndAngle) == 0x000050, "Wrong size on FRigUnit_MathQuaternionFromAxisAndAngle");
static_assert(offsetof(FRigUnit_MathQuaternionFromAxisAndAngle, Axis) == 0x000008, "Member 'FRigUnit_MathQuaternionFromAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromAxisAndAngle, Angle) == 0x000020, "Member 'FRigUnit_MathQuaternionFromAxisAndAngle::Angle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromAxisAndAngle, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionFromAxisAndAngle::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetParent
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_HierarchyGetParent final : public FRigUnit_HierarchyBase
{
public:
	struct FRigElementKey                         Child;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Parent;                                            // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedChild;                                       // 0x0020(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedParent;                                      // 0x0040(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetParent) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetParent");
static_assert(sizeof(FRigUnit_HierarchyGetParent) == 0x000060, "Wrong size on FRigUnit_HierarchyGetParent");
static_assert(offsetof(FRigUnit_HierarchyGetParent, Child) == 0x000008, "Member 'FRigUnit_HierarchyGetParent::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParent, Parent) == 0x000014, "Member 'FRigUnit_HierarchyGetParent::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParent, CachedChild) == 0x000020, "Member 'FRigUnit_HierarchyGetParent::CachedChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParent, CachedParent) == 0x000040, "Member 'FRigUnit_HierarchyGetParent::CachedParent' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetParents
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_HierarchyGetParents final : public FRigUnit_HierarchyBase
{
public:
	struct FRigElementKey                         Child;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeChild;                                     // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverse;                                          // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Parents;                                           // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedChild;                                       // 0x0028(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedParents;                                     // 0x0048(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetParents) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetParents");
static_assert(sizeof(FRigUnit_HierarchyGetParents) == 0x000058, "Wrong size on FRigUnit_HierarchyGetParents");
static_assert(offsetof(FRigUnit_HierarchyGetParents, Child) == 0x000008, "Member 'FRigUnit_HierarchyGetParents::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParents, bIncludeChild) == 0x000014, "Member 'FRigUnit_HierarchyGetParents::bIncludeChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParents, bReverse) == 0x000015, "Member 'FRigUnit_HierarchyGetParents::bReverse' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParents, Parents) == 0x000018, "Member 'FRigUnit_HierarchyGetParents::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParents, CachedChild) == 0x000028, "Member 'FRigUnit_HierarchyGetParents::CachedChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParents, CachedParents) == 0x000048, "Member 'FRigUnit_HierarchyGetParents::CachedParents' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetParentsItemArray
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_HierarchyGetParentsItemArray final : public FRigUnit_HierarchyBase
{
public:
	struct FRigElementKey                         Child;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeChild;                                     // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverse;                                          // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 Parents;                                           // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedChild;                                       // 0x0028(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedParents;                                     // 0x0048(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetParentsItemArray) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetParentsItemArray");
static_assert(sizeof(FRigUnit_HierarchyGetParentsItemArray) == 0x000058, "Wrong size on FRigUnit_HierarchyGetParentsItemArray");
static_assert(offsetof(FRigUnit_HierarchyGetParentsItemArray, Child) == 0x000008, "Member 'FRigUnit_HierarchyGetParentsItemArray::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentsItemArray, bIncludeChild) == 0x000014, "Member 'FRigUnit_HierarchyGetParentsItemArray::bIncludeChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentsItemArray, bReverse) == 0x000015, "Member 'FRigUnit_HierarchyGetParentsItemArray::bReverse' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentsItemArray, Parents) == 0x000018, "Member 'FRigUnit_HierarchyGetParentsItemArray::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentsItemArray, CachedChild) == 0x000028, "Member 'FRigUnit_HierarchyGetParentsItemArray::CachedChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetParentsItemArray, CachedParents) == 0x000048, "Member 'FRigUnit_HierarchyGetParentsItemArray::CachedParents' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorRound
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorRound final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorRound) == 0x000008, "Wrong alignment on FRigUnit_MathVectorRound");
static_assert(sizeof(FRigUnit_MathVectorRound) == 0x000038, "Wrong size on FRigUnit_MathVectorRound");

// ScriptStruct ControlRig.RigUnit_HierarchyGetChildren
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_HierarchyGetChildren final : public FRigUnit_HierarchyBase
{
public:
	struct FRigElementKey                         Parent;                                            // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeParent;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursive;                                        // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Children;                                          // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedParent;                                      // 0x0028(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedChildren;                                    // 0x0048(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetChildren) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetChildren");
static_assert(sizeof(FRigUnit_HierarchyGetChildren) == 0x000058, "Wrong size on FRigUnit_HierarchyGetChildren");
static_assert(offsetof(FRigUnit_HierarchyGetChildren, Parent) == 0x000008, "Member 'FRigUnit_HierarchyGetChildren::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetChildren, bIncludeParent) == 0x000014, "Member 'FRigUnit_HierarchyGetChildren::bIncludeParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetChildren, bRecursive) == 0x000015, "Member 'FRigUnit_HierarchyGetChildren::bRecursive' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetChildren, Children) == 0x000018, "Member 'FRigUnit_HierarchyGetChildren::Children' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetChildren, CachedParent) == 0x000028, "Member 'FRigUnit_HierarchyGetChildren::CachedParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetChildren, CachedChildren) == 0x000048, "Member 'FRigUnit_HierarchyGetChildren::CachedChildren' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetSiblings
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_HierarchyGetSiblings final : public FRigUnit_HierarchyBase
{
public:
	struct FRigElementKey                         Item;                                              // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeItem;                                      // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Siblings;                                          // 0x0018(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedItem;                                        // 0x0028(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedSiblings;                                    // 0x0048(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetSiblings) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetSiblings");
static_assert(sizeof(FRigUnit_HierarchyGetSiblings) == 0x000058, "Wrong size on FRigUnit_HierarchyGetSiblings");
static_assert(offsetof(FRigUnit_HierarchyGetSiblings, Item) == 0x000008, "Member 'FRigUnit_HierarchyGetSiblings::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetSiblings, bIncludeItem) == 0x000014, "Member 'FRigUnit_HierarchyGetSiblings::bIncludeItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetSiblings, Siblings) == 0x000018, "Member 'FRigUnit_HierarchyGetSiblings::Siblings' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetSiblings, CachedItem) == 0x000028, "Member 'FRigUnit_HierarchyGetSiblings::CachedItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetSiblings, CachedSiblings) == 0x000048, "Member 'FRigUnit_HierarchyGetSiblings::CachedSiblings' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetSiblingsItemArray
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_HierarchyGetSiblingsItemArray final : public FRigUnit_HierarchyBase
{
public:
	struct FRigElementKey                         Item;                                              // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeItem;                                      // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 Siblings;                                          // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedItem;                                        // 0x0028(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               CachedSiblings;                                    // 0x0048(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetSiblingsItemArray) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetSiblingsItemArray");
static_assert(sizeof(FRigUnit_HierarchyGetSiblingsItemArray) == 0x000058, "Wrong size on FRigUnit_HierarchyGetSiblingsItemArray");
static_assert(offsetof(FRigUnit_HierarchyGetSiblingsItemArray, Item) == 0x000008, "Member 'FRigUnit_HierarchyGetSiblingsItemArray::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetSiblingsItemArray, bIncludeItem) == 0x000014, "Member 'FRigUnit_HierarchyGetSiblingsItemArray::bIncludeItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetSiblingsItemArray, Siblings) == 0x000018, "Member 'FRigUnit_HierarchyGetSiblingsItemArray::Siblings' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetSiblingsItemArray, CachedItem) == 0x000028, "Member 'FRigUnit_HierarchyGetSiblingsItemArray::CachedItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetSiblingsItemArray, CachedSiblings) == 0x000048, "Member 'FRigUnit_HierarchyGetSiblingsItemArray::CachedSiblings' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetPose
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_HierarchyGetPose final : public FRigUnit_HierarchyBase
{
public:
	bool                                          Initial;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               ItemsToGet;                                        // 0x0010(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigPose                               Pose;                                              // 0x0020(0x0070)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetPose) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetPose");
static_assert(sizeof(FRigUnit_HierarchyGetPose) == 0x000090, "Wrong size on FRigUnit_HierarchyGetPose");
static_assert(offsetof(FRigUnit_HierarchyGetPose, Initial) == 0x000008, "Member 'FRigUnit_HierarchyGetPose::Initial' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetPose, ElementType) == 0x000009, "Member 'FRigUnit_HierarchyGetPose::ElementType' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetPose, ItemsToGet) == 0x000010, "Member 'FRigUnit_HierarchyGetPose::ItemsToGet' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetPose, Pose) == 0x000020, "Member 'FRigUnit_HierarchyGetPose::Pose' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionSwingTwist
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_MathQuaternionSwingTwist final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Input;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TwistAxis;                                         // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Swing;                                             // 0x0050(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Twist;                                             // 0x0070(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionSwingTwist) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionSwingTwist");
static_assert(sizeof(FRigUnit_MathQuaternionSwingTwist) == 0x000090, "Wrong size on FRigUnit_MathQuaternionSwingTwist");
static_assert(offsetof(FRigUnit_MathQuaternionSwingTwist, Input) == 0x000010, "Member 'FRigUnit_MathQuaternionSwingTwist::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSwingTwist, TwistAxis) == 0x000030, "Member 'FRigUnit_MathQuaternionSwingTwist::TwistAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSwingTwist, Swing) == 0x000050, "Member 'FRigUnit_MathQuaternionSwingTwist::Swing' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSwingTwist, Twist) == 0x000070, "Member 'FRigUnit_MathQuaternionSwingTwist::Twist' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchyGetPoseItemArray
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_HierarchyGetPoseItemArray final : public FRigUnit_HierarchyBase
{
public:
	bool                                          Initial;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 ItemsToGet;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigPose                               Pose;                                              // 0x0020(0x0070)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchyGetPoseItemArray) == 0x000008, "Wrong alignment on FRigUnit_HierarchyGetPoseItemArray");
static_assert(sizeof(FRigUnit_HierarchyGetPoseItemArray) == 0x000090, "Wrong size on FRigUnit_HierarchyGetPoseItemArray");
static_assert(offsetof(FRigUnit_HierarchyGetPoseItemArray, Initial) == 0x000008, "Member 'FRigUnit_HierarchyGetPoseItemArray::Initial' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetPoseItemArray, ElementType) == 0x000009, "Member 'FRigUnit_HierarchyGetPoseItemArray::ElementType' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetPoseItemArray, ItemsToGet) == 0x000010, "Member 'FRigUnit_HierarchyGetPoseItemArray::ItemsToGet' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchyGetPoseItemArray, Pose) == 0x000020, "Member 'FRigUnit_HierarchyGetPoseItemArray::Pose' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionBinaryOp
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_MathQuaternionBinaryOp : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  A;                                                 // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0050(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionBinaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionBinaryOp");
static_assert(sizeof(FRigUnit_MathQuaternionBinaryOp) == 0x000070, "Wrong size on FRigUnit_MathQuaternionBinaryOp");
static_assert(offsetof(FRigUnit_MathQuaternionBinaryOp, A) == 0x000010, "Member 'FRigUnit_MathQuaternionBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionBinaryOp, B) == 0x000030, "Member 'FRigUnit_MathQuaternionBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionBinaryOp, Result) == 0x000050, "Member 'FRigUnit_MathQuaternionBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionMul
// 0x0000 (0x0070 - 0x0070)
struct FRigUnit_MathQuaternionMul final : public FRigUnit_MathQuaternionBinaryOp
{
};
static_assert(alignof(FRigUnit_MathQuaternionMul) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionMul");
static_assert(sizeof(FRigUnit_MathQuaternionMul) == 0x000070, "Wrong size on FRigUnit_MathQuaternionMul");

// ScriptStruct ControlRig.RigUnit_HierarchySetPose
// 0x0090 (0x0160 - 0x00D0)
struct FRigUnit_HierarchySetPose final : public FRigUnit_HierarchyBaseMutable
{
public:
	struct FRigPose                               Pose;                                              // 0x00D0(0x0070)(NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0141(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x6];                                      // 0x0142(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               ItemsToSet;                                        // 0x0148(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_HierarchySetPose) == 0x000010, "Wrong alignment on FRigUnit_HierarchySetPose");
static_assert(sizeof(FRigUnit_HierarchySetPose) == 0x000160, "Wrong size on FRigUnit_HierarchySetPose");
static_assert(offsetof(FRigUnit_HierarchySetPose, Pose) == 0x0000D0, "Member 'FRigUnit_HierarchySetPose::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetPose, ElementType) == 0x000140, "Member 'FRigUnit_HierarchySetPose::ElementType' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetPose, Space) == 0x000141, "Member 'FRigUnit_HierarchySetPose::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetPose, ItemsToSet) == 0x000148, "Member 'FRigUnit_HierarchySetPose::ItemsToSet' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetPose, Weight) == 0x000158, "Member 'FRigUnit_HierarchySetPose::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HierarchySetPoseItemArray
// 0x0090 (0x0160 - 0x00D0)
struct FRigUnit_HierarchySetPoseItemArray final : public FRigUnit_HierarchyBaseMutable
{
public:
	struct FRigPose                               Pose;                                              // 0x00D0(0x0070)(NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0141(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x6];                                      // 0x0142(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 ItemsToSet;                                        // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_HierarchySetPoseItemArray) == 0x000010, "Wrong alignment on FRigUnit_HierarchySetPoseItemArray");
static_assert(sizeof(FRigUnit_HierarchySetPoseItemArray) == 0x000160, "Wrong size on FRigUnit_HierarchySetPoseItemArray");
static_assert(offsetof(FRigUnit_HierarchySetPoseItemArray, Pose) == 0x0000D0, "Member 'FRigUnit_HierarchySetPoseItemArray::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetPoseItemArray, ElementType) == 0x000140, "Member 'FRigUnit_HierarchySetPoseItemArray::ElementType' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetPoseItemArray, Space) == 0x000141, "Member 'FRigUnit_HierarchySetPoseItemArray::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetPoseItemArray, ItemsToSet) == 0x000148, "Member 'FRigUnit_HierarchySetPoseItemArray::ItemsToSet' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySetPoseItemArray, Weight) == 0x000158, "Member 'FRigUnit_HierarchySetPoseItemArray::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PoseIsEmpty
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_PoseIsEmpty final : public FRigUnit_HierarchyBase
{
public:
	struct FRigPose                               Pose;                                              // 0x0008(0x0070)(NativeAccessSpecifierPublic)
	bool                                          IsEmpty;                                           // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PoseIsEmpty) == 0x000008, "Wrong alignment on FRigUnit_PoseIsEmpty");
static_assert(sizeof(FRigUnit_PoseIsEmpty) == 0x000080, "Wrong size on FRigUnit_PoseIsEmpty");
static_assert(offsetof(FRigUnit_PoseIsEmpty, Pose) == 0x000008, "Member 'FRigUnit_PoseIsEmpty::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseIsEmpty, IsEmpty) == 0x000078, "Member 'FRigUnit_PoseIsEmpty::IsEmpty' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PoseGetItems
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_PoseGetItems final : public FRigUnit_HierarchyBase
{
public:
	struct FRigPose                               Pose;                                              // 0x0008(0x0070)(NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               Items;                                             // 0x0080(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PoseGetItems) == 0x000008, "Wrong alignment on FRigUnit_PoseGetItems");
static_assert(sizeof(FRigUnit_PoseGetItems) == 0x000090, "Wrong size on FRigUnit_PoseGetItems");
static_assert(offsetof(FRigUnit_PoseGetItems, Pose) == 0x000008, "Member 'FRigUnit_PoseGetItems::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetItems, ElementType) == 0x000078, "Member 'FRigUnit_PoseGetItems::ElementType' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetItems, Items) == 0x000080, "Member 'FRigUnit_PoseGetItems::Items' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatMod
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathFloatMod final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatMod) == 0x000008, "Wrong alignment on FRigUnit_MathFloatMod");
static_assert(sizeof(FRigUnit_MathFloatMod) == 0x000018, "Wrong size on FRigUnit_MathFloatMod");

// ScriptStruct ControlRig.RigUnit_PoseGetItemsItemArray
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_PoseGetItemsItemArray final : public FRigUnit_HierarchyBase
{
public:
	struct FRigPose                               Pose;                                              // 0x0008(0x0070)(NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigElementKey>                 Items;                                             // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PoseGetItemsItemArray) == 0x000008, "Wrong alignment on FRigUnit_PoseGetItemsItemArray");
static_assert(sizeof(FRigUnit_PoseGetItemsItemArray) == 0x000090, "Wrong size on FRigUnit_PoseGetItemsItemArray");
static_assert(offsetof(FRigUnit_PoseGetItemsItemArray, Pose) == 0x000008, "Member 'FRigUnit_PoseGetItemsItemArray::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetItemsItemArray, ElementType) == 0x000078, "Member 'FRigUnit_PoseGetItemsItemArray::ElementType' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetItemsItemArray, Items) == 0x000080, "Member 'FRigUnit_PoseGetItemsItemArray::Items' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PoseGetDelta
// 0x0120 (0x0128 - 0x0008)
struct FRigUnit_PoseGetDelta final : public FRigUnit_HierarchyBase
{
public:
	struct FRigPose                               PoseA;                                             // 0x0008(0x0070)(NativeAccessSpecifierPublic)
	struct FRigPose                               PoseB;                                             // 0x0078(0x0070)(NativeAccessSpecifierPublic)
	float                                         PositionThreshold;                                 // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationThreshold;                                 // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleThreshold;                                    // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveThreshold;                                    // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigElementType                               ElementType;                                       // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               ItemsToCompare;                                    // 0x0100(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PosesAreEqual;                                     // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKeyCollection               ItemsWithDelta;                                    // 0x0118(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PoseGetDelta) == 0x000008, "Wrong alignment on FRigUnit_PoseGetDelta");
static_assert(sizeof(FRigUnit_PoseGetDelta) == 0x000128, "Wrong size on FRigUnit_PoseGetDelta");
static_assert(offsetof(FRigUnit_PoseGetDelta, PoseA) == 0x000008, "Member 'FRigUnit_PoseGetDelta::PoseA' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, PoseB) == 0x000078, "Member 'FRigUnit_PoseGetDelta::PoseB' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, PositionThreshold) == 0x0000E8, "Member 'FRigUnit_PoseGetDelta::PositionThreshold' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, RotationThreshold) == 0x0000EC, "Member 'FRigUnit_PoseGetDelta::RotationThreshold' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, ScaleThreshold) == 0x0000F0, "Member 'FRigUnit_PoseGetDelta::ScaleThreshold' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, CurveThreshold) == 0x0000F4, "Member 'FRigUnit_PoseGetDelta::CurveThreshold' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, ElementType) == 0x0000F8, "Member 'FRigUnit_PoseGetDelta::ElementType' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, Space) == 0x0000F9, "Member 'FRigUnit_PoseGetDelta::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, ItemsToCompare) == 0x000100, "Member 'FRigUnit_PoseGetDelta::ItemsToCompare' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, PosesAreEqual) == 0x000110, "Member 'FRigUnit_PoseGetDelta::PosesAreEqual' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetDelta, ItemsWithDelta) == 0x000118, "Member 'FRigUnit_PoseGetDelta::ItemsWithDelta' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PoseGetTransform
// 0x00F8 (0x0100 - 0x0008)
struct FRigUnit_PoseGetTransform final : public FRigUnit_HierarchyBase
{
public:
	struct FRigPose                               Pose;                                              // 0x0008(0x0070)(NativeAccessSpecifierPublic)
	struct FRigElementKey                         Item;                                              // 0x0078(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Valid;                                             // 0x0085(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0xA];                                       // 0x0086(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0090(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurveValue;                                        // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedPoseElementIndex;                            // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedPoseHash;                                    // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PoseGetTransform) == 0x000010, "Wrong alignment on FRigUnit_PoseGetTransform");
static_assert(sizeof(FRigUnit_PoseGetTransform) == 0x000100, "Wrong size on FRigUnit_PoseGetTransform");
static_assert(offsetof(FRigUnit_PoseGetTransform, Pose) == 0x000008, "Member 'FRigUnit_PoseGetTransform::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransform, Item) == 0x000078, "Member 'FRigUnit_PoseGetTransform::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransform, Space) == 0x000084, "Member 'FRigUnit_PoseGetTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransform, Valid) == 0x000085, "Member 'FRigUnit_PoseGetTransform::Valid' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransform, Transform) == 0x000090, "Member 'FRigUnit_PoseGetTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransform, CurveValue) == 0x0000F0, "Member 'FRigUnit_PoseGetTransform::CurveValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransform, CachedPoseElementIndex) == 0x0000F4, "Member 'FRigUnit_PoseGetTransform::CachedPoseElementIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransform, CachedPoseHash) == 0x0000F8, "Member 'FRigUnit_PoseGetTransform::CachedPoseHash' has a wrong offset!");

// ScriptStruct ControlRig.MathRBFInterpolateQuatFloat_Target
// 0x0030 (0x0030 - 0x0000)
struct FMathRBFInterpolateQuatFloat_Target final
{
public:
	struct FQuat                                  Target;                                            // 0x0000(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMathRBFInterpolateQuatFloat_Target) == 0x000010, "Wrong alignment on FMathRBFInterpolateQuatFloat_Target");
static_assert(sizeof(FMathRBFInterpolateQuatFloat_Target) == 0x000030, "Wrong size on FMathRBFInterpolateQuatFloat_Target");
static_assert(offsetof(FMathRBFInterpolateQuatFloat_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateQuatFloat_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateQuatFloat_Target, Value) == 0x000020, "Member 'FMathRBFInterpolateQuatFloat_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateQuatFloat
// 0x0020 (0x0110 - 0x00F0)
struct FRigUnit_MathRBFInterpolateQuatFloat final : public FRigUnit_MathRBFInterpolateQuatBase
{
public:
	TArray<struct FMathRBFInterpolateQuatFloat_Target> Targets;                                           // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Output;                                            // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0xC];                                      // 0x0104(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathRBFInterpolateQuatFloat) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateQuatFloat");
static_assert(sizeof(FRigUnit_MathRBFInterpolateQuatFloat) == 0x000110, "Wrong size on FRigUnit_MathRBFInterpolateQuatFloat");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatFloat, Targets) == 0x0000F0, "Member 'FRigUnit_MathRBFInterpolateQuatFloat::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatFloat, Output) == 0x000100, "Member 'FRigUnit_MathRBFInterpolateQuatFloat::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PoseGetTransformArray
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_PoseGetTransformArray final : public FRigUnit_HierarchyBase
{
public:
	struct FRigPose                               Pose;                                              // 0x0008(0x0070)(NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Valid;                                             // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Transforms;                                        // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PoseGetTransformArray) == 0x000008, "Wrong alignment on FRigUnit_PoseGetTransformArray");
static_assert(sizeof(FRigUnit_PoseGetTransformArray) == 0x000090, "Wrong size on FRigUnit_PoseGetTransformArray");
static_assert(offsetof(FRigUnit_PoseGetTransformArray, Pose) == 0x000008, "Member 'FRigUnit_PoseGetTransformArray::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransformArray, Space) == 0x000078, "Member 'FRigUnit_PoseGetTransformArray::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransformArray, Valid) == 0x000079, "Member 'FRigUnit_PoseGetTransformArray::Valid' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetTransformArray, Transforms) == 0x000080, "Member 'FRigUnit_PoseGetTransformArray::Transforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionRotateVector
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_MathQuaternionRotateVector final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quaternion;                                        // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionRotateVector) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionRotateVector");
static_assert(sizeof(FRigUnit_MathQuaternionRotateVector) == 0x000060, "Wrong size on FRigUnit_MathQuaternionRotateVector");
static_assert(offsetof(FRigUnit_MathQuaternionRotateVector, Quaternion) == 0x000010, "Member 'FRigUnit_MathQuaternionRotateVector::Quaternion' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionRotateVector, Vector) == 0x000030, "Member 'FRigUnit_MathQuaternionRotateVector::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionRotateVector, Result) == 0x000048, "Member 'FRigUnit_MathQuaternionRotateVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PoseGetCurve
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_PoseGetCurve final : public FRigUnit_HierarchyBase
{
public:
	struct FRigPose                               Pose;                                              // 0x0008(0x0070)(NativeAccessSpecifierPublic)
	class FName                                   Curve;                                             // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Valid;                                             // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurveValue;                                        // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedPoseElementIndex;                            // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedPoseHash;                                    // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PoseGetCurve) == 0x000008, "Wrong alignment on FRigUnit_PoseGetCurve");
static_assert(sizeof(FRigUnit_PoseGetCurve) == 0x000090, "Wrong size on FRigUnit_PoseGetCurve");
static_assert(offsetof(FRigUnit_PoseGetCurve, Pose) == 0x000008, "Member 'FRigUnit_PoseGetCurve::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetCurve, Curve) == 0x000078, "Member 'FRigUnit_PoseGetCurve::Curve' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetCurve, Valid) == 0x000080, "Member 'FRigUnit_PoseGetCurve::Valid' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetCurve, CurveValue) == 0x000084, "Member 'FRigUnit_PoseGetCurve::CurveValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetCurve, CachedPoseElementIndex) == 0x000088, "Member 'FRigUnit_PoseGetCurve::CachedPoseElementIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseGetCurve, CachedPoseHash) == 0x00008C, "Member 'FRigUnit_PoseGetCurve::CachedPoseHash' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PoseLoop
// 0x0220 (0x02F0 - 0x00D0)
struct FRigUnit_PoseLoop final : public FRigUnit_HierarchyBaseMutable
{
public:
	struct FRigPose                               Pose;                                              // 0x00D0(0x0070)(NativeAccessSpecifierPublic)
	struct FRigElementKey                         Item;                                              // 0x0140(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             GlobalTransform;                                   // 0x0150(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x01B0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurveValue;                                        // 0x0210(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0214(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0218(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x021C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Continue;                                          // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0xF];                                      // 0x0221(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              Completed;                                         // 0x0230(0x00C0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PoseLoop) == 0x000010, "Wrong alignment on FRigUnit_PoseLoop");
static_assert(sizeof(FRigUnit_PoseLoop) == 0x0002F0, "Wrong size on FRigUnit_PoseLoop");
static_assert(offsetof(FRigUnit_PoseLoop, Pose) == 0x0000D0, "Member 'FRigUnit_PoseLoop::Pose' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, Item) == 0x000140, "Member 'FRigUnit_PoseLoop::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, GlobalTransform) == 0x000150, "Member 'FRigUnit_PoseLoop::GlobalTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, LocalTransform) == 0x0001B0, "Member 'FRigUnit_PoseLoop::LocalTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, CurveValue) == 0x000210, "Member 'FRigUnit_PoseLoop::CurveValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, Index) == 0x000214, "Member 'FRigUnit_PoseLoop::Index' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, Count) == 0x000218, "Member 'FRigUnit_PoseLoop::Count' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, Ratio) == 0x00021C, "Member 'FRigUnit_PoseLoop::Ratio' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, Continue) == 0x000220, "Member 'FRigUnit_PoseLoop::Continue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PoseLoop, Completed) == 0x000230, "Member 'FRigUnit_PoseLoop::Completed' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_InverseExecution
// 0x00C8 (0x00D0 - 0x0008)
struct FRigUnit_InverseExecution final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              ExecuteContext;                                    // 0x0010(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_InverseExecution) == 0x000010, "Wrong alignment on FRigUnit_InverseExecution");
static_assert(sizeof(FRigUnit_InverseExecution) == 0x0000D0, "Wrong size on FRigUnit_InverseExecution");
static_assert(offsetof(FRigUnit_InverseExecution, ExecuteContext) == 0x000010, "Member 'FRigUnit_InverseExecution::ExecuteContext' has a wrong offset!");

// ScriptStruct ControlRig.MathRBFInterpolateQuatColor_Target
// 0x0030 (0x0030 - 0x0000)
struct FMathRBFInterpolateQuatColor_Target final
{
public:
	struct FQuat                                  Target;                                            // 0x0000(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathRBFInterpolateQuatColor_Target) == 0x000010, "Wrong alignment on FMathRBFInterpolateQuatColor_Target");
static_assert(sizeof(FMathRBFInterpolateQuatColor_Target) == 0x000030, "Wrong size on FMathRBFInterpolateQuatColor_Target");
static_assert(offsetof(FMathRBFInterpolateQuatColor_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateQuatColor_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateQuatColor_Target, Value) == 0x000020, "Member 'FMathRBFInterpolateQuatColor_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateQuatColor
// 0x0020 (0x0110 - 0x00F0)
struct FRigUnit_MathRBFInterpolateQuatColor final : public FRigUnit_MathRBFInterpolateQuatBase
{
public:
	TArray<struct FMathRBFInterpolateQuatColor_Target> Targets;                                           // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Output;                                            // 0x0100(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathRBFInterpolateQuatColor) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateQuatColor");
static_assert(sizeof(FRigUnit_MathRBFInterpolateQuatColor) == 0x000110, "Wrong size on FRigUnit_MathRBFInterpolateQuatColor");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatColor, Targets) == 0x0000F0, "Member 'FRigUnit_MathRBFInterpolateQuatColor::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatColor, Output) == 0x000100, "Member 'FRigUnit_MathRBFInterpolateQuatColor::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_IsInteracting
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_IsInteracting final : public FRigUnit
{
public:
	bool                                          bIsInteracting;                                    // 0x0008(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_IsInteracting) == 0x000008, "Wrong alignment on FRigUnit_IsInteracting");
static_assert(sizeof(FRigUnit_IsInteracting) == 0x000010, "Wrong size on FRigUnit_IsInteracting");
static_assert(offsetof(FRigUnit_IsInteracting, bIsInteracting) == 0x000008, "Member 'FRigUnit_IsInteracting::bIsInteracting' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionToAxisAndAngle
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathQuaternionToAxisAndAngle final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionToAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionToAxisAndAngle");
static_assert(sizeof(FRigUnit_MathQuaternionToAxisAndAngle) == 0x000050, "Wrong size on FRigUnit_MathQuaternionToAxisAndAngle");
static_assert(offsetof(FRigUnit_MathQuaternionToAxisAndAngle, Value) == 0x000010, "Member 'FRigUnit_MathQuaternionToAxisAndAngle::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToAxisAndAngle, Axis) == 0x000030, "Member 'FRigUnit_MathQuaternionToAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToAxisAndAngle, Angle) == 0x000048, "Member 'FRigUnit_MathQuaternionToAxisAndAngle::Angle' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ItemBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_ItemBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_ItemBase) == 0x000008, "Wrong alignment on FRigUnit_ItemBase");
static_assert(sizeof(FRigUnit_ItemBase) == 0x000008, "Wrong size on FRigUnit_ItemBase");

// ScriptStruct ControlRig.RigUnit_ItemBaseMutable
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_ItemBaseMutable final : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_ItemBaseMutable) == 0x000010, "Wrong alignment on FRigUnit_ItemBaseMutable");
static_assert(sizeof(FRigUnit_ItemBaseMutable) == 0x0000D0, "Wrong size on FRigUnit_ItemBaseMutable");

// ScriptStruct ControlRig.RigUnit_ItemExists
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_ItemExists final : public FRigUnit_ItemBase
{
public:
	struct FRigElementKey                         Item;                                              // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Exists;                                            // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedIndex;                                       // 0x0018(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ItemExists) == 0x000008, "Wrong alignment on FRigUnit_ItemExists");
static_assert(sizeof(FRigUnit_ItemExists) == 0x000038, "Wrong size on FRigUnit_ItemExists");
static_assert(offsetof(FRigUnit_ItemExists, Item) == 0x000008, "Member 'FRigUnit_ItemExists::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemExists, Exists) == 0x000014, "Member 'FRigUnit_ItemExists::Exists' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemExists, CachedIndex) == 0x000018, "Member 'FRigUnit_ItemExists::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntSub
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathIntSub final : public FRigUnit_MathIntBinaryOp
{
};
static_assert(alignof(FRigUnit_MathIntSub) == 0x000008, "Wrong alignment on FRigUnit_MathIntSub");
static_assert(sizeof(FRigUnit_MathIntSub) == 0x000018, "Wrong size on FRigUnit_MathIntSub");

// ScriptStruct ControlRig.RigUnit_ItemReplace
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_ItemReplace final : public FRigUnit_ItemBase
{
public:
	struct FRigElementKey                         Item;                                              // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Old;                                               // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   New;                                               // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Result;                                            // 0x0024(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ItemReplace) == 0x000008, "Wrong alignment on FRigUnit_ItemReplace");
static_assert(sizeof(FRigUnit_ItemReplace) == 0x000030, "Wrong size on FRigUnit_ItemReplace");
static_assert(offsetof(FRigUnit_ItemReplace, Item) == 0x000008, "Member 'FRigUnit_ItemReplace::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemReplace, Old) == 0x000014, "Member 'FRigUnit_ItemReplace::Old' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemReplace, New) == 0x00001C, "Member 'FRigUnit_ItemReplace::New' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemReplace, Result) == 0x000024, "Member 'FRigUnit_ItemReplace::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateVectorWorkData
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x10) FRigUnit_MathRBFInterpolateVectorWorkData final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathRBFInterpolateVectorWorkData) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateVectorWorkData");
static_assert(sizeof(FRigUnit_MathRBFInterpolateVectorWorkData) == 0x000090, "Wrong size on FRigUnit_MathRBFInterpolateVectorWorkData");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateVectorBase
// 0x00B8 (0x00C0 - 0x0008)
struct FRigUnit_MathRBFInterpolateVectorBase : public FRigUnit_MathRBFInterpolateBase
{
public:
	struct FVector                                Input;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERBFVectorDistanceType                        DistanceFunction;                                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERBFKernelType                                SmoothingFunction;                                 // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothingRadius;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalizeOutput;                                  // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_MathRBFInterpolateVectorWorkData WorkData;                                          // 0x0030(0x0090)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathRBFInterpolateVectorBase) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateVectorBase");
static_assert(sizeof(FRigUnit_MathRBFInterpolateVectorBase) == 0x0000C0, "Wrong size on FRigUnit_MathRBFInterpolateVectorBase");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorBase, Input) == 0x000008, "Member 'FRigUnit_MathRBFInterpolateVectorBase::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorBase, DistanceFunction) == 0x000020, "Member 'FRigUnit_MathRBFInterpolateVectorBase::DistanceFunction' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorBase, SmoothingFunction) == 0x000021, "Member 'FRigUnit_MathRBFInterpolateVectorBase::SmoothingFunction' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorBase, SmoothingRadius) == 0x000024, "Member 'FRigUnit_MathRBFInterpolateVectorBase::SmoothingRadius' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorBase, bNormalizeOutput) == 0x000028, "Member 'FRigUnit_MathRBFInterpolateVectorBase::bNormalizeOutput' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorBase, WorkData) == 0x000030, "Member 'FRigUnit_MathRBFInterpolateVectorBase::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ItemEquals
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_ItemEquals final : public FRigUnit_ItemBase
{
public:
	struct FRigElementKey                         A;                                                 // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         B;                                                 // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ItemEquals) == 0x000008, "Wrong alignment on FRigUnit_ItemEquals");
static_assert(sizeof(FRigUnit_ItemEquals) == 0x000028, "Wrong size on FRigUnit_ItemEquals");
static_assert(offsetof(FRigUnit_ItemEquals, A) == 0x000008, "Member 'FRigUnit_ItemEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemEquals, B) == 0x000014, "Member 'FRigUnit_ItemEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemEquals, Result) == 0x000020, "Member 'FRigUnit_ItemEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ItemNotEquals
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_ItemNotEquals final : public FRigUnit_ItemBase
{
public:
	struct FRigElementKey                         A;                                                 // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         B;                                                 // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ItemNotEquals) == 0x000008, "Wrong alignment on FRigUnit_ItemNotEquals");
static_assert(sizeof(FRigUnit_ItemNotEquals) == 0x000028, "Wrong size on FRigUnit_ItemNotEquals");
static_assert(offsetof(FRigUnit_ItemNotEquals, A) == 0x000008, "Member 'FRigUnit_ItemNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemNotEquals, B) == 0x000014, "Member 'FRigUnit_ItemNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemNotEquals, Result) == 0x000020, "Member 'FRigUnit_ItemNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ItemTypeEquals
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_ItemTypeEquals final : public FRigUnit_ItemBase
{
public:
	struct FRigElementKey                         A;                                                 // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         B;                                                 // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ItemTypeEquals) == 0x000008, "Wrong alignment on FRigUnit_ItemTypeEquals");
static_assert(sizeof(FRigUnit_ItemTypeEquals) == 0x000028, "Wrong size on FRigUnit_ItemTypeEquals");
static_assert(offsetof(FRigUnit_ItemTypeEquals, A) == 0x000008, "Member 'FRigUnit_ItemTypeEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemTypeEquals, B) == 0x000014, "Member 'FRigUnit_ItemTypeEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemTypeEquals, Result) == 0x000020, "Member 'FRigUnit_ItemTypeEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntMin
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathIntMin final : public FRigUnit_MathIntBinaryOp
{
};
static_assert(alignof(FRigUnit_MathIntMin) == 0x000008, "Wrong alignment on FRigUnit_MathIntMin");
static_assert(sizeof(FRigUnit_MathIntMin) == 0x000018, "Wrong size on FRigUnit_MathIntMin");

// ScriptStruct ControlRig.RigUnit_ItemTypeNotEquals
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_ItemTypeNotEquals final : public FRigUnit_ItemBase
{
public:
	struct FRigElementKey                         A;                                                 // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         B;                                                 // 0x0014(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ItemTypeNotEquals) == 0x000008, "Wrong alignment on FRigUnit_ItemTypeNotEquals");
static_assert(sizeof(FRigUnit_ItemTypeNotEquals) == 0x000028, "Wrong size on FRigUnit_ItemTypeNotEquals");
static_assert(offsetof(FRigUnit_ItemTypeNotEquals, A) == 0x000008, "Member 'FRigUnit_ItemTypeNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemTypeNotEquals, B) == 0x000014, "Member 'FRigUnit_ItemTypeNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_ItemTypeNotEquals, Result) == 0x000020, "Member 'FRigUnit_ItemTypeNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionNotEquals
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_MathQuaternionNotEquals final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  A;                                                 // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionNotEquals) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionNotEquals");
static_assert(sizeof(FRigUnit_MathQuaternionNotEquals) == 0x000060, "Wrong size on FRigUnit_MathQuaternionNotEquals");
static_assert(offsetof(FRigUnit_MathQuaternionNotEquals, A) == 0x000010, "Member 'FRigUnit_MathQuaternionNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionNotEquals, B) == 0x000030, "Member 'FRigUnit_MathQuaternionNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionNotEquals, Result) == 0x000050, "Member 'FRigUnit_MathQuaternionNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_KalmanFloat
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_KalmanFloat final : public FRigUnit_SimBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Buffer;                                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_KalmanFloat) == 0x000008, "Wrong alignment on FRigUnit_KalmanFloat");
static_assert(sizeof(FRigUnit_KalmanFloat) == 0x000030, "Wrong size on FRigUnit_KalmanFloat");
static_assert(offsetof(FRigUnit_KalmanFloat, Value) == 0x000008, "Member 'FRigUnit_KalmanFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanFloat, BufferSize) == 0x00000C, "Member 'FRigUnit_KalmanFloat::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanFloat, Result) == 0x000010, "Member 'FRigUnit_KalmanFloat::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanFloat, Buffer) == 0x000018, "Member 'FRigUnit_KalmanFloat::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanFloat, LastInsertIndex) == 0x000028, "Member 'FRigUnit_KalmanFloat::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_KalmanVector
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_KalmanVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Buffer;                                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_KalmanVector) == 0x000008, "Wrong alignment on FRigUnit_KalmanVector");
static_assert(sizeof(FRigUnit_KalmanVector) == 0x000058, "Wrong size on FRigUnit_KalmanVector");
static_assert(offsetof(FRigUnit_KalmanVector, Value) == 0x000008, "Member 'FRigUnit_KalmanVector::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanVector, BufferSize) == 0x000020, "Member 'FRigUnit_KalmanVector::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanVector, Result) == 0x000028, "Member 'FRigUnit_KalmanVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanVector, Buffer) == 0x000040, "Member 'FRigUnit_KalmanVector::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanVector, LastInsertIndex) == 0x000050, "Member 'FRigUnit_KalmanVector::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_KalmanTransform
// 0x00F8 (0x0100 - 0x0008)
struct FRigUnit_KalmanTransform final : public FRigUnit_SimBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0080(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Buffer;                                            // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_KalmanTransform) == 0x000010, "Wrong alignment on FRigUnit_KalmanTransform");
static_assert(sizeof(FRigUnit_KalmanTransform) == 0x000100, "Wrong size on FRigUnit_KalmanTransform");
static_assert(offsetof(FRigUnit_KalmanTransform, Value) == 0x000010, "Member 'FRigUnit_KalmanTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanTransform, BufferSize) == 0x000070, "Member 'FRigUnit_KalmanTransform::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanTransform, Result) == 0x000080, "Member 'FRigUnit_KalmanTransform::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanTransform, Buffer) == 0x0000E0, "Member 'FRigUnit_KalmanTransform::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanTransform, LastInsertIndex) == 0x0000F0, "Member 'FRigUnit_KalmanTransform::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntAbs
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathIntAbs final : public FRigUnit_MathIntUnaryOp
{
};
static_assert(alignof(FRigUnit_MathIntAbs) == 0x000008, "Wrong alignment on FRigUnit_MathIntAbs");
static_assert(sizeof(FRigUnit_MathIntAbs) == 0x000010, "Wrong size on FRigUnit_MathIntAbs");

// ScriptStruct ControlRig.MathRBFInterpolateQuatQuat_Target
// 0x0040 (0x0040 - 0x0000)
struct FMathRBFInterpolateQuatQuat_Target final
{
public:
	struct FQuat                                  Target;                                            // 0x0000(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Value;                                             // 0x0020(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathRBFInterpolateQuatQuat_Target) == 0x000010, "Wrong alignment on FMathRBFInterpolateQuatQuat_Target");
static_assert(sizeof(FMathRBFInterpolateQuatQuat_Target) == 0x000040, "Wrong size on FMathRBFInterpolateQuatQuat_Target");
static_assert(offsetof(FMathRBFInterpolateQuatQuat_Target, Target) == 0x000000, "Member 'FMathRBFInterpolateQuatQuat_Target::Target' has a wrong offset!");
static_assert(offsetof(FMathRBFInterpolateQuatQuat_Target, Value) == 0x000020, "Member 'FMathRBFInterpolateQuatQuat_Target::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateQuatQuat
// 0x0030 (0x0120 - 0x00F0)
struct FRigUnit_MathRBFInterpolateQuatQuat final : public FRigUnit_MathRBFInterpolateQuatBase
{
public:
	TArray<struct FMathRBFInterpolateQuatQuat_Target> Targets;                                           // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Output;                                            // 0x0100(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathRBFInterpolateQuatQuat) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateQuatQuat");
static_assert(sizeof(FRigUnit_MathRBFInterpolateQuatQuat) == 0x000120, "Wrong size on FRigUnit_MathRBFInterpolateQuatQuat");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatQuat, Targets) == 0x0000F0, "Member 'FRigUnit_MathRBFInterpolateQuatQuat::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatQuat, Output) == 0x000100, "Member 'FRigUnit_MathRBFInterpolateQuatQuat::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathMutableBase
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_MathMutableBase : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_MathMutableBase) == 0x000010, "Wrong alignment on FRigUnit_MathMutableBase");
static_assert(sizeof(FRigUnit_MathMutableBase) == 0x0000D0, "Wrong size on FRigUnit_MathMutableBase");

// ScriptStruct ControlRig.RigUnit_MathBoolConstant
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathBoolConstant : public FRigUnit_MathBoolBase
{
public:
	bool                                          Value;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolConstant) == 0x000008, "Wrong alignment on FRigUnit_MathBoolConstant");
static_assert(sizeof(FRigUnit_MathBoolConstant) == 0x000010, "Wrong size on FRigUnit_MathBoolConstant");
static_assert(offsetof(FRigUnit_MathBoolConstant, Value) == 0x000008, "Member 'FRigUnit_MathBoolConstant::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntEquals
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathIntEquals final : public FRigUnit_MathIntBase
{
public:
	int32                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathIntEquals) == 0x000008, "Wrong alignment on FRigUnit_MathIntEquals");
static_assert(sizeof(FRigUnit_MathIntEquals) == 0x000018, "Wrong size on FRigUnit_MathIntEquals");
static_assert(offsetof(FRigUnit_MathIntEquals, A) == 0x000008, "Member 'FRigUnit_MathIntEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntEquals, B) == 0x00000C, "Member 'FRigUnit_MathIntEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntEquals, Result) == 0x000010, "Member 'FRigUnit_MathIntEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolConstTrue
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathBoolConstTrue final : public FRigUnit_MathBoolConstant
{
};
static_assert(alignof(FRigUnit_MathBoolConstTrue) == 0x000008, "Wrong alignment on FRigUnit_MathBoolConstTrue");
static_assert(sizeof(FRigUnit_MathBoolConstTrue) == 0x000010, "Wrong size on FRigUnit_MathBoolConstTrue");

// ScriptStruct ControlRig.RigUnit_MathBoolConstFalse
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathBoolConstFalse final : public FRigUnit_MathBoolConstant
{
};
static_assert(alignof(FRigUnit_MathBoolConstFalse) == 0x000008, "Wrong alignment on FRigUnit_MathBoolConstFalse");
static_assert(sizeof(FRigUnit_MathBoolConstFalse) == 0x000010, "Wrong size on FRigUnit_MathBoolConstFalse");

// ScriptStruct ControlRig.RigUnit_MathBoolAnd
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathBoolAnd final : public FRigUnit_MathBoolBinaryOp
{
};
static_assert(alignof(FRigUnit_MathBoolAnd) == 0x000008, "Wrong alignment on FRigUnit_MathBoolAnd");
static_assert(sizeof(FRigUnit_MathBoolAnd) == 0x000010, "Wrong size on FRigUnit_MathBoolAnd");

// ScriptStruct ControlRig.RigUnit_MathBoolOr
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathBoolOr final : public FRigUnit_MathBoolBinaryOp
{
};
static_assert(alignof(FRigUnit_MathBoolOr) == 0x000008, "Wrong alignment on FRigUnit_MathBoolOr");
static_assert(sizeof(FRigUnit_MathBoolOr) == 0x000010, "Wrong size on FRigUnit_MathBoolOr");

// ScriptStruct ControlRig.RigUnit_MathBoolNotEquals
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathBoolNotEquals final : public FRigUnit_MathBoolBase
{
public:
	bool                                          A;                                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolNotEquals) == 0x000008, "Wrong alignment on FRigUnit_MathBoolNotEquals");
static_assert(sizeof(FRigUnit_MathBoolNotEquals) == 0x000010, "Wrong size on FRigUnit_MathBoolNotEquals");
static_assert(offsetof(FRigUnit_MathBoolNotEquals, A) == 0x000008, "Member 'FRigUnit_MathBoolNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolNotEquals, B) == 0x000009, "Member 'FRigUnit_MathBoolNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolNotEquals, Result) == 0x00000A, "Member 'FRigUnit_MathBoolNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathColorFromFloat
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_MathColorFromFloat final : public FRigUnit_MathColorBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Result;                                            // 0x000C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathColorFromFloat) == 0x000008, "Wrong alignment on FRigUnit_MathColorFromFloat");
static_assert(sizeof(FRigUnit_MathColorFromFloat) == 0x000020, "Wrong size on FRigUnit_MathColorFromFloat");
static_assert(offsetof(FRigUnit_MathColorFromFloat, Value) == 0x000008, "Member 'FRigUnit_MathColorFromFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathColorFromFloat, Result) == 0x00000C, "Member 'FRigUnit_MathColorFromFloat::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathColorSub
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathColorSub final : public FRigUnit_MathColorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathColorSub) == 0x000008, "Wrong alignment on FRigUnit_MathColorSub");
static_assert(sizeof(FRigUnit_MathColorSub) == 0x000038, "Wrong size on FRigUnit_MathColorSub");

// ScriptStruct ControlRig.RigUnit_MathColorLerp
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathColorLerp final : public FRigUnit_MathColorBase
{
public:
	struct FLinearColor                           A;                                                 // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           B;                                                 // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Result;                                            // 0x002C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathColorLerp) == 0x000008, "Wrong alignment on FRigUnit_MathColorLerp");
static_assert(sizeof(FRigUnit_MathColorLerp) == 0x000040, "Wrong size on FRigUnit_MathColorLerp");
static_assert(offsetof(FRigUnit_MathColorLerp, A) == 0x000008, "Member 'FRigUnit_MathColorLerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathColorLerp, B) == 0x000018, "Member 'FRigUnit_MathColorLerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathColorLerp, T) == 0x000028, "Member 'FRigUnit_MathColorLerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathColorLerp, Result) == 0x00002C, "Member 'FRigUnit_MathColorLerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatConstHalfPi
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatConstHalfPi final : public FRigUnit_MathFloatConstant
{
};
static_assert(alignof(FRigUnit_MathFloatConstHalfPi) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstHalfPi");
static_assert(sizeof(FRigUnit_MathFloatConstHalfPi) == 0x000010, "Wrong size on FRigUnit_MathFloatConstHalfPi");

// ScriptStruct ControlRig.RigUnit_MathFloatConstE
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatConstE final : public FRigUnit_MathFloatConstant
{
};
static_assert(alignof(FRigUnit_MathFloatConstE) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstE");
static_assert(sizeof(FRigUnit_MathFloatConstE) == 0x000010, "Wrong size on FRigUnit_MathFloatConstE");

// ScriptStruct ControlRig.RigUnit_MathFloatSub
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathFloatSub final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatSub) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSub");
static_assert(sizeof(FRigUnit_MathFloatSub) == 0x000018, "Wrong size on FRigUnit_MathFloatSub");

// ScriptStruct ControlRig.RigUnit_MathFloatDiv
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathFloatDiv final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatDiv) == 0x000008, "Wrong alignment on FRigUnit_MathFloatDiv");
static_assert(sizeof(FRigUnit_MathFloatDiv) == 0x000018, "Wrong size on FRigUnit_MathFloatDiv");

// ScriptStruct ControlRig.RigUnit_MathFloatMin
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathFloatMin final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatMin) == 0x000008, "Wrong alignment on FRigUnit_MathFloatMin");
static_assert(sizeof(FRigUnit_MathFloatMin) == 0x000018, "Wrong size on FRigUnit_MathFloatMin");

// ScriptStruct ControlRig.RigUnit_MathFloatPow
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathFloatPow final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatPow) == 0x000008, "Wrong alignment on FRigUnit_MathFloatPow");
static_assert(sizeof(FRigUnit_MathFloatPow) == 0x000018, "Wrong size on FRigUnit_MathFloatPow");

// ScriptStruct ControlRig.RigUnit_MathFloatNegate
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatNegate final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatNegate) == 0x000008, "Wrong alignment on FRigUnit_MathFloatNegate");
static_assert(sizeof(FRigUnit_MathFloatNegate) == 0x000010, "Wrong size on FRigUnit_MathFloatNegate");

// ScriptStruct ControlRig.RigUnit_MathFloatRound
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatRound final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatRound) == 0x000008, "Wrong alignment on FRigUnit_MathFloatRound");
static_assert(sizeof(FRigUnit_MathFloatRound) == 0x000018, "Wrong size on FRigUnit_MathFloatRound");
static_assert(offsetof(FRigUnit_MathFloatRound, Value) == 0x000008, "Member 'FRigUnit_MathFloatRound::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRound, Result) == 0x00000C, "Member 'FRigUnit_MathFloatRound::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRound, Int) == 0x000010, "Member 'FRigUnit_MathFloatRound::Int' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatLerp
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatLerp final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatLerp) == 0x000008, "Wrong alignment on FRigUnit_MathFloatLerp");
static_assert(sizeof(FRigUnit_MathFloatLerp) == 0x000018, "Wrong size on FRigUnit_MathFloatLerp");
static_assert(offsetof(FRigUnit_MathFloatLerp, A) == 0x000008, "Member 'FRigUnit_MathFloatLerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLerp, B) == 0x00000C, "Member 'FRigUnit_MathFloatLerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLerp, T) == 0x000010, "Member 'FRigUnit_MathFloatLerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLerp, Result) == 0x000014, "Member 'FRigUnit_MathFloatLerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatEquals
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatEquals final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatEquals) == 0x000008, "Wrong alignment on FRigUnit_MathFloatEquals");
static_assert(sizeof(FRigUnit_MathFloatEquals) == 0x000018, "Wrong size on FRigUnit_MathFloatEquals");
static_assert(offsetof(FRigUnit_MathFloatEquals, A) == 0x000008, "Member 'FRigUnit_MathFloatEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatEquals, B) == 0x00000C, "Member 'FRigUnit_MathFloatEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatEquals, Result) == 0x000010, "Member 'FRigUnit_MathFloatEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatGreater
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatGreater final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatGreater) == 0x000008, "Wrong alignment on FRigUnit_MathFloatGreater");
static_assert(sizeof(FRigUnit_MathFloatGreater) == 0x000018, "Wrong size on FRigUnit_MathFloatGreater");
static_assert(offsetof(FRigUnit_MathFloatGreater, A) == 0x000008, "Member 'FRigUnit_MathFloatGreater::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatGreater, B) == 0x00000C, "Member 'FRigUnit_MathFloatGreater::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatGreater, Result) == 0x000010, "Member 'FRigUnit_MathFloatGreater::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatGreaterEqual
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatGreaterEqual final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatGreaterEqual) == 0x000008, "Wrong alignment on FRigUnit_MathFloatGreaterEqual");
static_assert(sizeof(FRigUnit_MathFloatGreaterEqual) == 0x000018, "Wrong size on FRigUnit_MathFloatGreaterEqual");
static_assert(offsetof(FRigUnit_MathFloatGreaterEqual, A) == 0x000008, "Member 'FRigUnit_MathFloatGreaterEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatGreaterEqual, B) == 0x00000C, "Member 'FRigUnit_MathFloatGreaterEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatGreaterEqual, Result) == 0x000010, "Member 'FRigUnit_MathFloatGreaterEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatIsNearlyZero
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatIsNearlyZero final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatIsNearlyZero) == 0x000008, "Wrong alignment on FRigUnit_MathFloatIsNearlyZero");
static_assert(sizeof(FRigUnit_MathFloatIsNearlyZero) == 0x000018, "Wrong size on FRigUnit_MathFloatIsNearlyZero");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyZero, Value) == 0x000008, "Member 'FRigUnit_MathFloatIsNearlyZero::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyZero, Tolerance) == 0x00000C, "Member 'FRigUnit_MathFloatIsNearlyZero::Tolerance' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyZero, Result) == 0x000010, "Member 'FRigUnit_MathFloatIsNearlyZero::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatSelectBool
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathFloatSelectBool final : public FRigUnit_MathFloatBase
{
public:
	bool                                          Condition;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IfTrue;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IfFalse;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatSelectBool) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSelectBool");
static_assert(sizeof(FRigUnit_MathFloatSelectBool) == 0x000018, "Wrong size on FRigUnit_MathFloatSelectBool");
static_assert(offsetof(FRigUnit_MathFloatSelectBool, Condition) == 0x000008, "Member 'FRigUnit_MathFloatSelectBool::Condition' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatSelectBool, IfTrue) == 0x00000C, "Member 'FRigUnit_MathFloatSelectBool::IfTrue' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatSelectBool, IfFalse) == 0x000010, "Member 'FRigUnit_MathFloatSelectBool::IfFalse' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatSelectBool, Result) == 0x000014, "Member 'FRigUnit_MathFloatSelectBool::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatRad
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatRad final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatRad) == 0x000008, "Wrong alignment on FRigUnit_MathFloatRad");
static_assert(sizeof(FRigUnit_MathFloatRad) == 0x000010, "Wrong size on FRigUnit_MathFloatRad");

// ScriptStruct ControlRig.RigUnit_MathFloatCos
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatCos final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatCos) == 0x000008, "Wrong alignment on FRigUnit_MathFloatCos");
static_assert(sizeof(FRigUnit_MathFloatCos) == 0x000010, "Wrong size on FRigUnit_MathFloatCos");

// ScriptStruct ControlRig.RigUnit_MathFloatTan
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatTan final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatTan) == 0x000008, "Wrong alignment on FRigUnit_MathFloatTan");
static_assert(sizeof(FRigUnit_MathFloatTan) == 0x000010, "Wrong size on FRigUnit_MathFloatTan");

// ScriptStruct ControlRig.RigUnit_MathFloatAsin
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatAsin final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAsin) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAsin");
static_assert(sizeof(FRigUnit_MathFloatAsin) == 0x000010, "Wrong size on FRigUnit_MathFloatAsin");

// ScriptStruct ControlRig.RigUnit_MathFloatAtan
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatAtan final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAtan) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAtan");
static_assert(sizeof(FRigUnit_MathFloatAtan) == 0x000010, "Wrong size on FRigUnit_MathFloatAtan");

// ScriptStruct ControlRig.RigUnit_MathFloatExponential
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathFloatExponential final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatExponential) == 0x000008, "Wrong alignment on FRigUnit_MathFloatExponential");
static_assert(sizeof(FRigUnit_MathFloatExponential) == 0x000010, "Wrong size on FRigUnit_MathFloatExponential");

// ScriptStruct ControlRig.RigUnit_MathIntAdd
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathIntAdd final : public FRigUnit_MathIntBinaryOp
{
};
static_assert(alignof(FRigUnit_MathIntAdd) == 0x000008, "Wrong alignment on FRigUnit_MathIntAdd");
static_assert(sizeof(FRigUnit_MathIntAdd) == 0x000018, "Wrong size on FRigUnit_MathIntAdd");

// ScriptStruct ControlRig.RigUnit_MathIntMul
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathIntMul final : public FRigUnit_MathIntBinaryOp
{
};
static_assert(alignof(FRigUnit_MathIntMul) == 0x000008, "Wrong alignment on FRigUnit_MathIntMul");
static_assert(sizeof(FRigUnit_MathIntMul) == 0x000018, "Wrong size on FRigUnit_MathIntMul");

// ScriptStruct ControlRig.RigUnit_MathIntMod
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathIntMod final : public FRigUnit_MathIntBinaryOp
{
};
static_assert(alignof(FRigUnit_MathIntMod) == 0x000008, "Wrong alignment on FRigUnit_MathIntMod");
static_assert(sizeof(FRigUnit_MathIntMod) == 0x000018, "Wrong size on FRigUnit_MathIntMod");

// ScriptStruct ControlRig.RigUnit_MathIntMax
// 0x0000 (0x0018 - 0x0018)
struct FRigUnit_MathIntMax final : public FRigUnit_MathIntBinaryOp
{
};
static_assert(alignof(FRigUnit_MathIntMax) == 0x000008, "Wrong alignment on FRigUnit_MathIntMax");
static_assert(sizeof(FRigUnit_MathIntMax) == 0x000018, "Wrong size on FRigUnit_MathIntMax");

// ScriptStruct ControlRig.RigUnit_MathIntNegate
// 0x0000 (0x0010 - 0x0010)
struct FRigUnit_MathIntNegate final : public FRigUnit_MathIntUnaryOp
{
};
static_assert(alignof(FRigUnit_MathIntNegate) == 0x000008, "Wrong alignment on FRigUnit_MathIntNegate");
static_assert(sizeof(FRigUnit_MathIntNegate) == 0x000010, "Wrong size on FRigUnit_MathIntNegate");

// ScriptStruct ControlRig.RigUnit_MathIntToFloat
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathIntToFloat final : public FRigUnit_MathIntBase
{
public:
	int32                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathIntToFloat) == 0x000008, "Wrong alignment on FRigUnit_MathIntToFloat");
static_assert(sizeof(FRigUnit_MathIntToFloat) == 0x000010, "Wrong size on FRigUnit_MathIntToFloat");
static_assert(offsetof(FRigUnit_MathIntToFloat, Value) == 0x000008, "Member 'FRigUnit_MathIntToFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntToFloat, Result) == 0x00000C, "Member 'FRigUnit_MathIntToFloat::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntClamp
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathIntClamp final : public FRigUnit_MathIntBase
{
public:
	int32                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minimum;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Maximum;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathIntClamp) == 0x000008, "Wrong alignment on FRigUnit_MathIntClamp");
static_assert(sizeof(FRigUnit_MathIntClamp) == 0x000018, "Wrong size on FRigUnit_MathIntClamp");
static_assert(offsetof(FRigUnit_MathIntClamp, Value) == 0x000008, "Member 'FRigUnit_MathIntClamp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntClamp, Minimum) == 0x00000C, "Member 'FRigUnit_MathIntClamp::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntClamp, Maximum) == 0x000010, "Member 'FRigUnit_MathIntClamp::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntClamp, Result) == 0x000014, "Member 'FRigUnit_MathIntClamp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntNotEquals
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathIntNotEquals final : public FRigUnit_MathIntBase
{
public:
	int32                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathIntNotEquals) == 0x000008, "Wrong alignment on FRigUnit_MathIntNotEquals");
static_assert(sizeof(FRigUnit_MathIntNotEquals) == 0x000018, "Wrong size on FRigUnit_MathIntNotEquals");
static_assert(offsetof(FRigUnit_MathIntNotEquals, A) == 0x000008, "Member 'FRigUnit_MathIntNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntNotEquals, B) == 0x00000C, "Member 'FRigUnit_MathIntNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntNotEquals, Result) == 0x000010, "Member 'FRigUnit_MathIntNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathIntLessEqual
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_MathIntLessEqual final : public FRigUnit_MathIntBase
{
public:
	int32                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathIntLessEqual) == 0x000008, "Wrong alignment on FRigUnit_MathIntLessEqual");
static_assert(sizeof(FRigUnit_MathIntLessEqual) == 0x000018, "Wrong size on FRigUnit_MathIntLessEqual");
static_assert(offsetof(FRigUnit_MathIntLessEqual, A) == 0x000008, "Member 'FRigUnit_MathIntLessEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntLessEqual, B) == 0x00000C, "Member 'FRigUnit_MathIntLessEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathIntLessEqual, Result) == 0x000010, "Member 'FRigUnit_MathIntLessEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathMatrixToTransform
// 0x00E8 (0x00F0 - 0x0008)
struct FRigUnit_MathMatrixToTransform final : public FRigUnit_MathMatrixBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                Value;                                             // 0x0010(0x0080)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0090(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathMatrixToTransform) == 0x000010, "Wrong alignment on FRigUnit_MathMatrixToTransform");
static_assert(sizeof(FRigUnit_MathMatrixToTransform) == 0x0000F0, "Wrong size on FRigUnit_MathMatrixToTransform");
static_assert(offsetof(FRigUnit_MathMatrixToTransform, Value) == 0x000010, "Member 'FRigUnit_MathMatrixToTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathMatrixToTransform, Result) == 0x000090, "Member 'FRigUnit_MathMatrixToTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathMatrixMul
// 0x0000 (0x0190 - 0x0190)
struct FRigUnit_MathMatrixMul final : public FRigUnit_MathMatrixBinaryOp
{
};
static_assert(alignof(FRigUnit_MathMatrixMul) == 0x000010, "Wrong alignment on FRigUnit_MathMatrixMul");
static_assert(sizeof(FRigUnit_MathMatrixMul) == 0x000190, "Wrong size on FRigUnit_MathMatrixMul");

// ScriptStruct ControlRig.RigUnit_MathMatrixInverse
// 0x0000 (0x0110 - 0x0110)
struct FRigUnit_MathMatrixInverse final : public FRigUnit_MathMatrixUnaryOp
{
};
static_assert(alignof(FRigUnit_MathMatrixInverse) == 0x000010, "Wrong alignment on FRigUnit_MathMatrixInverse");
static_assert(sizeof(FRigUnit_MathMatrixInverse) == 0x000110, "Wrong size on FRigUnit_MathMatrixInverse");

// ScriptStruct ControlRig.RigUnit_MathQuaternionFromEuler
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathQuaternionFromEuler final : public FRigUnit_MathQuaternionBase
{
public:
	struct FVector                                Euler;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEulerRotationOrder                           RotationOrder;                                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionFromEuler) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionFromEuler");
static_assert(sizeof(FRigUnit_MathQuaternionFromEuler) == 0x000050, "Wrong size on FRigUnit_MathQuaternionFromEuler");
static_assert(offsetof(FRigUnit_MathQuaternionFromEuler, Euler) == 0x000008, "Member 'FRigUnit_MathQuaternionFromEuler::Euler' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromEuler, RotationOrder) == 0x000020, "Member 'FRigUnit_MathQuaternionFromEuler::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromEuler, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionFromEuler::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionFromTwoVectors
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_MathQuaternionFromTwoVectors final : public FRigUnit_MathQuaternionBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0040(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionFromTwoVectors) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionFromTwoVectors");
static_assert(sizeof(FRigUnit_MathQuaternionFromTwoVectors) == 0x000060, "Wrong size on FRigUnit_MathQuaternionFromTwoVectors");
static_assert(offsetof(FRigUnit_MathQuaternionFromTwoVectors, A) == 0x000008, "Member 'FRigUnit_MathQuaternionFromTwoVectors::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromTwoVectors, B) == 0x000020, "Member 'FRigUnit_MathQuaternionFromTwoVectors::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromTwoVectors, Result) == 0x000040, "Member 'FRigUnit_MathQuaternionFromTwoVectors::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionScale
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathQuaternionScale final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionScale) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionScale");
static_assert(sizeof(FRigUnit_MathQuaternionScale) == 0x000040, "Wrong size on FRigUnit_MathQuaternionScale");
static_assert(offsetof(FRigUnit_MathQuaternionScale, Value) == 0x000010, "Member 'FRigUnit_MathQuaternionScale::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionScale, Scale) == 0x000030, "Member 'FRigUnit_MathQuaternionScale::Scale' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionToRotator
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathQuaternionToRotator final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Result;                                            // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionToRotator) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionToRotator");
static_assert(sizeof(FRigUnit_MathQuaternionToRotator) == 0x000050, "Wrong size on FRigUnit_MathQuaternionToRotator");
static_assert(offsetof(FRigUnit_MathQuaternionToRotator, Value) == 0x000010, "Member 'FRigUnit_MathQuaternionToRotator::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToRotator, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionToRotator::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionInverse
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathQuaternionInverse final : public FRigUnit_MathQuaternionUnaryOp
{
};
static_assert(alignof(FRigUnit_MathQuaternionInverse) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionInverse");
static_assert(sizeof(FRigUnit_MathQuaternionInverse) == 0x000050, "Wrong size on FRigUnit_MathQuaternionInverse");

// ScriptStruct ControlRig.RigUnit_MathQuaternionEquals
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_MathQuaternionEquals final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  A;                                                 // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionEquals) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionEquals");
static_assert(sizeof(FRigUnit_MathQuaternionEquals) == 0x000060, "Wrong size on FRigUnit_MathQuaternionEquals");
static_assert(offsetof(FRigUnit_MathQuaternionEquals, A) == 0x000010, "Member 'FRigUnit_MathQuaternionEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionEquals, B) == 0x000030, "Member 'FRigUnit_MathQuaternionEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionEquals, Result) == 0x000050, "Member 'FRigUnit_MathQuaternionEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionSelectBool
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_MathQuaternionSelectBool final : public FRigUnit_MathQuaternionBase
{
public:
	bool                                          Condition;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  IfTrue;                                            // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  IfFalse;                                           // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0050(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionSelectBool) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionSelectBool");
static_assert(sizeof(FRigUnit_MathQuaternionSelectBool) == 0x000070, "Wrong size on FRigUnit_MathQuaternionSelectBool");
static_assert(offsetof(FRigUnit_MathQuaternionSelectBool, Condition) == 0x000008, "Member 'FRigUnit_MathQuaternionSelectBool::Condition' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSelectBool, IfTrue) == 0x000010, "Member 'FRigUnit_MathQuaternionSelectBool::IfTrue' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSelectBool, IfFalse) == 0x000030, "Member 'FRigUnit_MathQuaternionSelectBool::IfFalse' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSelectBool, Result) == 0x000050, "Member 'FRigUnit_MathQuaternionSelectBool::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionUnit
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathQuaternionUnit final : public FRigUnit_MathQuaternionUnaryOp
{
};
static_assert(alignof(FRigUnit_MathQuaternionUnit) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionUnit");
static_assert(sizeof(FRigUnit_MathQuaternionUnit) == 0x000050, "Wrong size on FRigUnit_MathQuaternionUnit");

// ScriptStruct ControlRig.RigUnit_MathQuaternionGetAxis
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathQuaternionGetAxis final : public FRigUnit_MathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quaternion;                                        // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAxis                                         Axis;                                              // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionGetAxis) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionGetAxis");
static_assert(sizeof(FRigUnit_MathQuaternionGetAxis) == 0x000050, "Wrong size on FRigUnit_MathQuaternionGetAxis");
static_assert(offsetof(FRigUnit_MathQuaternionGetAxis, Quaternion) == 0x000010, "Member 'FRigUnit_MathQuaternionGetAxis::Quaternion' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionGetAxis, Axis) == 0x000030, "Member 'FRigUnit_MathQuaternionGetAxis::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionGetAxis, Result) == 0x000038, "Member 'FRigUnit_MathQuaternionGetAxis::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionRotationOrder
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_MathQuaternionRotationOrder final : public FRigUnit_MathBase
{
public:
	EEulerRotationOrder                           RotationOrder;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionRotationOrder) == 0x000008, "Wrong alignment on FRigUnit_MathQuaternionRotationOrder");
static_assert(sizeof(FRigUnit_MathQuaternionRotationOrder) == 0x000010, "Wrong size on FRigUnit_MathQuaternionRotationOrder");
static_assert(offsetof(FRigUnit_MathQuaternionRotationOrder, RotationOrder) == 0x000008, "Member 'FRigUnit_MathQuaternionRotationOrder::RotationOrder' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateQuatXform
// 0x0070 (0x0160 - 0x00F0)
struct FRigUnit_MathRBFInterpolateQuatXform final : public FRigUnit_MathRBFInterpolateQuatBase
{
public:
	TArray<struct FMathRBFInterpolateQuatXform_Target> Targets;                                           // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             Output;                                            // 0x0100(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathRBFInterpolateQuatXform) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateQuatXform");
static_assert(sizeof(FRigUnit_MathRBFInterpolateQuatXform) == 0x000160, "Wrong size on FRigUnit_MathRBFInterpolateQuatXform");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatXform, Targets) == 0x0000F0, "Member 'FRigUnit_MathRBFInterpolateQuatXform::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateQuatXform, Output) == 0x000100, "Member 'FRigUnit_MathRBFInterpolateQuatXform::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateVectorFloat
// 0x0020 (0x00E0 - 0x00C0)
struct FRigUnit_MathRBFInterpolateVectorFloat final : public FRigUnit_MathRBFInterpolateVectorBase
{
public:
	TArray<struct FMathRBFInterpolateVectorFloat_Target> Targets;                                           // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Output;                                            // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0xC];                                       // 0x00D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathRBFInterpolateVectorFloat) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateVectorFloat");
static_assert(sizeof(FRigUnit_MathRBFInterpolateVectorFloat) == 0x0000E0, "Wrong size on FRigUnit_MathRBFInterpolateVectorFloat");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorFloat, Targets) == 0x0000C0, "Member 'FRigUnit_MathRBFInterpolateVectorFloat::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorFloat, Output) == 0x0000D0, "Member 'FRigUnit_MathRBFInterpolateVectorFloat::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateVectorVector
// 0x0030 (0x00F0 - 0x00C0)
struct FRigUnit_MathRBFInterpolateVectorVector final : public FRigUnit_MathRBFInterpolateVectorBase
{
public:
	TArray<struct FMathRBFInterpolateVectorVector_Target> Targets;                                           // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Output;                                            // 0x00D0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathRBFInterpolateVectorVector) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateVectorVector");
static_assert(sizeof(FRigUnit_MathRBFInterpolateVectorVector) == 0x0000F0, "Wrong size on FRigUnit_MathRBFInterpolateVectorVector");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorVector, Targets) == 0x0000C0, "Member 'FRigUnit_MathRBFInterpolateVectorVector::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorVector, Output) == 0x0000D0, "Member 'FRigUnit_MathRBFInterpolateVectorVector::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateVectorColor
// 0x0020 (0x00E0 - 0x00C0)
struct FRigUnit_MathRBFInterpolateVectorColor final : public FRigUnit_MathRBFInterpolateVectorBase
{
public:
	TArray<struct FMathRBFInterpolateVectorColor_Target> Targets;                                           // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Output;                                            // 0x00D0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathRBFInterpolateVectorColor) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateVectorColor");
static_assert(sizeof(FRigUnit_MathRBFInterpolateVectorColor) == 0x0000E0, "Wrong size on FRigUnit_MathRBFInterpolateVectorColor");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorColor, Targets) == 0x0000C0, "Member 'FRigUnit_MathRBFInterpolateVectorColor::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorColor, Output) == 0x0000D0, "Member 'FRigUnit_MathRBFInterpolateVectorColor::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateVectorQuat
// 0x0030 (0x00F0 - 0x00C0)
struct FRigUnit_MathRBFInterpolateVectorQuat final : public FRigUnit_MathRBFInterpolateVectorBase
{
public:
	TArray<struct FMathRBFInterpolateVectorQuat_Target> Targets;                                           // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Output;                                            // 0x00D0(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathRBFInterpolateVectorQuat) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateVectorQuat");
static_assert(sizeof(FRigUnit_MathRBFInterpolateVectorQuat) == 0x0000F0, "Wrong size on FRigUnit_MathRBFInterpolateVectorQuat");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorQuat, Targets) == 0x0000C0, "Member 'FRigUnit_MathRBFInterpolateVectorQuat::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorQuat, Output) == 0x0000D0, "Member 'FRigUnit_MathRBFInterpolateVectorQuat::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathRBFInterpolateVectorXform
// 0x0070 (0x0130 - 0x00C0)
struct FRigUnit_MathRBFInterpolateVectorXform final : public FRigUnit_MathRBFInterpolateVectorBase
{
public:
	TArray<struct FMathRBFInterpolateVectorXform_Target> Targets;                                           // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             Output;                                            // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathRBFInterpolateVectorXform) == 0x000010, "Wrong alignment on FRigUnit_MathRBFInterpolateVectorXform");
static_assert(sizeof(FRigUnit_MathRBFInterpolateVectorXform) == 0x000130, "Wrong size on FRigUnit_MathRBFInterpolateVectorXform");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorXform, Targets) == 0x0000C0, "Member 'FRigUnit_MathRBFInterpolateVectorXform::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathRBFInterpolateVectorXform, Output) == 0x0000D0, "Member 'FRigUnit_MathRBFInterpolateVectorXform::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformMutableBase
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_MathTransformMutableBase : public FRigUnit_MathMutableBase
{
};
static_assert(alignof(FRigUnit_MathTransformMutableBase) == 0x000010, "Wrong alignment on FRigUnit_MathTransformMutableBase");
static_assert(sizeof(FRigUnit_MathTransformMutableBase) == 0x0000D0, "Wrong size on FRigUnit_MathTransformMutableBase");

// ScriptStruct ControlRig.RigUnit_MathTransformToEulerTransform
// 0x00B8 (0x00C0 - 0x0008)
struct FRigUnit_MathTransformToEulerTransform final : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEulerTransform                        Result;                                            // 0x0070(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathTransformToEulerTransform) == 0x000010, "Wrong alignment on FRigUnit_MathTransformToEulerTransform");
static_assert(sizeof(FRigUnit_MathTransformToEulerTransform) == 0x0000C0, "Wrong size on FRigUnit_MathTransformToEulerTransform");
static_assert(offsetof(FRigUnit_MathTransformToEulerTransform, Value) == 0x000010, "Member 'FRigUnit_MathTransformToEulerTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformToEulerTransform, Result) == 0x000070, "Member 'FRigUnit_MathTransformToEulerTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformMakeRelative
// 0x0128 (0x0130 - 0x0008)
struct FRigUnit_MathTransformMakeRelative final : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Global;                                            // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Parent;                                            // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Local;                                             // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformMakeRelative) == 0x000010, "Wrong alignment on FRigUnit_MathTransformMakeRelative");
static_assert(sizeof(FRigUnit_MathTransformMakeRelative) == 0x000130, "Wrong size on FRigUnit_MathTransformMakeRelative");
static_assert(offsetof(FRigUnit_MathTransformMakeRelative, Global) == 0x000010, "Member 'FRigUnit_MathTransformMakeRelative::Global' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformMakeRelative, Parent) == 0x000070, "Member 'FRigUnit_MathTransformMakeRelative::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformMakeRelative, Local) == 0x0000D0, "Member 'FRigUnit_MathTransformMakeRelative::Local' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformAccumulateArray
// 0x0090 (0x0160 - 0x00D0)
struct FRigUnit_MathTransformAccumulateArray final : public FRigUnit_MathTransformMutableBase
{
public:
	TArray<struct FTransform>                     Transforms;                                        // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         TargetSpace;                                       // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0xF];                                       // 0x00E1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Root;                                              // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ParentIndices;                                     // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformAccumulateArray) == 0x000010, "Wrong alignment on FRigUnit_MathTransformAccumulateArray");
static_assert(sizeof(FRigUnit_MathTransformAccumulateArray) == 0x000160, "Wrong size on FRigUnit_MathTransformAccumulateArray");
static_assert(offsetof(FRigUnit_MathTransformAccumulateArray, Transforms) == 0x0000D0, "Member 'FRigUnit_MathTransformAccumulateArray::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformAccumulateArray, TargetSpace) == 0x0000E0, "Member 'FRigUnit_MathTransformAccumulateArray::TargetSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformAccumulateArray, Root) == 0x0000F0, "Member 'FRigUnit_MathTransformAccumulateArray::Root' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformAccumulateArray, ParentIndices) == 0x000150, "Member 'FRigUnit_MathTransformAccumulateArray::ParentIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformLerp
// 0x0138 (0x0140 - 0x0008)
struct FRigUnit_MathTransformLerp final : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             A;                                                 // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0xC];                                       // 0x00D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformLerp) == 0x000010, "Wrong alignment on FRigUnit_MathTransformLerp");
static_assert(sizeof(FRigUnit_MathTransformLerp) == 0x000140, "Wrong size on FRigUnit_MathTransformLerp");
static_assert(offsetof(FRigUnit_MathTransformLerp, A) == 0x000010, "Member 'FRigUnit_MathTransformLerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformLerp, B) == 0x000070, "Member 'FRigUnit_MathTransformLerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformLerp, T) == 0x0000D0, "Member 'FRigUnit_MathTransformLerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformLerp, Result) == 0x0000E0, "Member 'FRigUnit_MathTransformLerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformRotateVector
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_MathTransformRotateVector final : public FRigUnit_MathTransformBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformRotateVector) == 0x000010, "Wrong alignment on FRigUnit_MathTransformRotateVector");
static_assert(sizeof(FRigUnit_MathTransformRotateVector) == 0x0000A0, "Wrong size on FRigUnit_MathTransformRotateVector");
static_assert(offsetof(FRigUnit_MathTransformRotateVector, Transform) == 0x000010, "Member 'FRigUnit_MathTransformRotateVector::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformRotateVector, Direction) == 0x000070, "Member 'FRigUnit_MathTransformRotateVector::Direction' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformRotateVector, Result) == 0x000088, "Member 'FRigUnit_MathTransformRotateVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformFromSRT
// 0x0108 (0x0110 - 0x0008)
struct FRigUnit_MathTransformFromSRT final : public FRigUnit_MathTransformBase
{
public:
	struct FVector                                Location;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEulerRotationOrder                           RotationOrder;                                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0060(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEulerTransform                        EulerTransform;                                    // 0x00C0(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathTransformFromSRT) == 0x000010, "Wrong alignment on FRigUnit_MathTransformFromSRT");
static_assert(sizeof(FRigUnit_MathTransformFromSRT) == 0x000110, "Wrong size on FRigUnit_MathTransformFromSRT");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, Location) == 0x000008, "Member 'FRigUnit_MathTransformFromSRT::Location' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, Rotation) == 0x000020, "Member 'FRigUnit_MathTransformFromSRT::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, RotationOrder) == 0x000038, "Member 'FRigUnit_MathTransformFromSRT::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, Scale) == 0x000040, "Member 'FRigUnit_MathTransformFromSRT::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, Transform) == 0x000060, "Member 'FRigUnit_MathTransformFromSRT::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, EulerTransform) == 0x0000C0, "Member 'FRigUnit_MathTransformFromSRT::EulerTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMul
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathVectorMul final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorMul) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMul");
static_assert(sizeof(FRigUnit_MathVectorMul) == 0x000050, "Wrong size on FRigUnit_MathVectorMul");

// ScriptStruct ControlRig.RigUnit_MathVectorMod
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathVectorMod final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorMod) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMod");
static_assert(sizeof(FRigUnit_MathVectorMod) == 0x000050, "Wrong size on FRigUnit_MathVectorMod");

// ScriptStruct ControlRig.RigUnit_MathVectorMin
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathVectorMin final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorMin) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMin");
static_assert(sizeof(FRigUnit_MathVectorMin) == 0x000050, "Wrong size on FRigUnit_MathVectorMin");

// ScriptStruct ControlRig.RigUnit_MathVectorFloor
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorFloor final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorFloor) == 0x000008, "Wrong alignment on FRigUnit_MathVectorFloor");
static_assert(sizeof(FRigUnit_MathVectorFloor) == 0x000038, "Wrong size on FRigUnit_MathVectorFloor");

// ScriptStruct ControlRig.RigUnit_MathVectorSign
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorSign final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorSign) == 0x000008, "Wrong alignment on FRigUnit_MathVectorSign");
static_assert(sizeof(FRigUnit_MathVectorSign) == 0x000038, "Wrong size on FRigUnit_MathVectorSign");

// ScriptStruct ControlRig.RigUnit_MathVectorClamp
// 0x0060 (0x0068 - 0x0008)
struct FRigUnit_MathVectorClamp final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Minimum;                                           // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Maximum;                                           // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorClamp) == 0x000008, "Wrong alignment on FRigUnit_MathVectorClamp");
static_assert(sizeof(FRigUnit_MathVectorClamp) == 0x000068, "Wrong size on FRigUnit_MathVectorClamp");
static_assert(offsetof(FRigUnit_MathVectorClamp, Value) == 0x000008, "Member 'FRigUnit_MathVectorClamp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClamp, Minimum) == 0x000020, "Member 'FRigUnit_MathVectorClamp::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClamp, Maximum) == 0x000038, "Member 'FRigUnit_MathVectorClamp::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClamp, Result) == 0x000050, "Member 'FRigUnit_MathVectorClamp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorRemap
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_MathVectorRemap final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceMinimum;                                     // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceMaximum;                                     // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetMinimum;                                     // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetMaximum;                                     // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClamp;                                            // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorRemap) == 0x000008, "Wrong alignment on FRigUnit_MathVectorRemap");
static_assert(sizeof(FRigUnit_MathVectorRemap) == 0x0000A0, "Wrong size on FRigUnit_MathVectorRemap");
static_assert(offsetof(FRigUnit_MathVectorRemap, Value) == 0x000008, "Member 'FRigUnit_MathVectorRemap::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, SourceMinimum) == 0x000020, "Member 'FRigUnit_MathVectorRemap::SourceMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, SourceMaximum) == 0x000038, "Member 'FRigUnit_MathVectorRemap::SourceMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, TargetMinimum) == 0x000050, "Member 'FRigUnit_MathVectorRemap::TargetMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, TargetMaximum) == 0x000068, "Member 'FRigUnit_MathVectorRemap::TargetMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, bClamp) == 0x000080, "Member 'FRigUnit_MathVectorRemap::bClamp' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, Result) == 0x000088, "Member 'FRigUnit_MathVectorRemap::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorNotEquals
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorNotEquals final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorNotEquals) == 0x000008, "Wrong alignment on FRigUnit_MathVectorNotEquals");
static_assert(sizeof(FRigUnit_MathVectorNotEquals) == 0x000040, "Wrong size on FRigUnit_MathVectorNotEquals");
static_assert(offsetof(FRigUnit_MathVectorNotEquals, A) == 0x000008, "Member 'FRigUnit_MathVectorNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorNotEquals, B) == 0x000020, "Member 'FRigUnit_MathVectorNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorNotEquals, Result) == 0x000038, "Member 'FRigUnit_MathVectorNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorIsNearlyEqual
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorIsNearlyEqual final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorIsNearlyEqual) == 0x000008, "Wrong alignment on FRigUnit_MathVectorIsNearlyEqual");
static_assert(sizeof(FRigUnit_MathVectorIsNearlyEqual) == 0x000040, "Wrong size on FRigUnit_MathVectorIsNearlyEqual");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyEqual, A) == 0x000008, "Member 'FRigUnit_MathVectorIsNearlyEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyEqual, B) == 0x000020, "Member 'FRigUnit_MathVectorIsNearlyEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyEqual, Tolerance) == 0x000038, "Member 'FRigUnit_MathVectorIsNearlyEqual::Tolerance' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyEqual, Result) == 0x00003C, "Member 'FRigUnit_MathVectorIsNearlyEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorDeg
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorDeg final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorDeg) == 0x000008, "Wrong alignment on FRigUnit_MathVectorDeg");
static_assert(sizeof(FRigUnit_MathVectorDeg) == 0x000038, "Wrong size on FRigUnit_MathVectorDeg");

// ScriptStruct ControlRig.RigUnit_MathVectorLengthSquared
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_MathVectorLengthSquared final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorLengthSquared) == 0x000008, "Wrong alignment on FRigUnit_MathVectorLengthSquared");
static_assert(sizeof(FRigUnit_MathVectorLengthSquared) == 0x000028, "Wrong size on FRigUnit_MathVectorLengthSquared");
static_assert(offsetof(FRigUnit_MathVectorLengthSquared, Value) == 0x000008, "Member 'FRigUnit_MathVectorLengthSquared::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLengthSquared, Result) == 0x000020, "Member 'FRigUnit_MathVectorLengthSquared::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorLength
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_MathVectorLength final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorLength) == 0x000008, "Wrong alignment on FRigUnit_MathVectorLength");
static_assert(sizeof(FRigUnit_MathVectorLength) == 0x000028, "Wrong size on FRigUnit_MathVectorLength");
static_assert(offsetof(FRigUnit_MathVectorLength, Value) == 0x000008, "Member 'FRigUnit_MathVectorLength::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLength, Result) == 0x000020, "Member 'FRigUnit_MathVectorLength::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorDistance
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorDistance final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorDistance) == 0x000008, "Wrong alignment on FRigUnit_MathVectorDistance");
static_assert(sizeof(FRigUnit_MathVectorDistance) == 0x000040, "Wrong size on FRigUnit_MathVectorDistance");
static_assert(offsetof(FRigUnit_MathVectorDistance, A) == 0x000008, "Member 'FRigUnit_MathVectorDistance::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorDistance, B) == 0x000020, "Member 'FRigUnit_MathVectorDistance::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorDistance, Result) == 0x000038, "Member 'FRigUnit_MathVectorDistance::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorDot
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorDot final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorDot) == 0x000008, "Wrong alignment on FRigUnit_MathVectorDot");
static_assert(sizeof(FRigUnit_MathVectorDot) == 0x000040, "Wrong size on FRigUnit_MathVectorDot");
static_assert(offsetof(FRigUnit_MathVectorDot, A) == 0x000008, "Member 'FRigUnit_MathVectorDot::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorDot, B) == 0x000020, "Member 'FRigUnit_MathVectorDot::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorDot, Result) == 0x000038, "Member 'FRigUnit_MathVectorDot::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorSetLength
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorSetLength final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorSetLength) == 0x000008, "Wrong alignment on FRigUnit_MathVectorSetLength");
static_assert(sizeof(FRigUnit_MathVectorSetLength) == 0x000040, "Wrong size on FRigUnit_MathVectorSetLength");
static_assert(offsetof(FRigUnit_MathVectorSetLength, Value) == 0x000008, "Member 'FRigUnit_MathVectorSetLength::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorSetLength, Length) == 0x000020, "Member 'FRigUnit_MathVectorSetLength::Length' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorSetLength, Result) == 0x000028, "Member 'FRigUnit_MathVectorSetLength::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMirror
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_MathVectorMirror final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorMirror) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMirror");
static_assert(sizeof(FRigUnit_MathVectorMirror) == 0x000050, "Wrong size on FRigUnit_MathVectorMirror");
static_assert(offsetof(FRigUnit_MathVectorMirror, Value) == 0x000008, "Member 'FRigUnit_MathVectorMirror::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorMirror, Normal) == 0x000020, "Member 'FRigUnit_MathVectorMirror::Normal' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorMirror, Result) == 0x000038, "Member 'FRigUnit_MathVectorMirror::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorParallel
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MathVectorParallel final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorParallel) == 0x000008, "Wrong alignment on FRigUnit_MathVectorParallel");
static_assert(sizeof(FRigUnit_MathVectorParallel) == 0x000040, "Wrong size on FRigUnit_MathVectorParallel");
static_assert(offsetof(FRigUnit_MathVectorParallel, A) == 0x000008, "Member 'FRigUnit_MathVectorParallel::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorParallel, B) == 0x000020, "Member 'FRigUnit_MathVectorParallel::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorParallel, Result) == 0x000038, "Member 'FRigUnit_MathVectorParallel::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorBezierFourPoint
// 0x0098 (0x00A0 - 0x0008)
struct FRigUnit_MathVectorBezierFourPoint final : public FRigUnit_MathVectorBase
{
public:
	struct FCRFourPointBezier                     Bezier;                                            // 0x0008(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tangent;                                           // 0x0088(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorBezierFourPoint) == 0x000008, "Wrong alignment on FRigUnit_MathVectorBezierFourPoint");
static_assert(sizeof(FRigUnit_MathVectorBezierFourPoint) == 0x0000A0, "Wrong size on FRigUnit_MathVectorBezierFourPoint");
static_assert(offsetof(FRigUnit_MathVectorBezierFourPoint, Bezier) == 0x000008, "Member 'FRigUnit_MathVectorBezierFourPoint::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBezierFourPoint, T) == 0x000068, "Member 'FRigUnit_MathVectorBezierFourPoint::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBezierFourPoint, Result) == 0x000070, "Member 'FRigUnit_MathVectorBezierFourPoint::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBezierFourPoint, Tangent) == 0x000088, "Member 'FRigUnit_MathVectorBezierFourPoint::Tangent' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMakeBezierFourPoint
// 0x0060 (0x0068 - 0x0008)
struct FRigUnit_MathVectorMakeBezierFourPoint final : public FRigUnit_MathVectorBase
{
public:
	struct FCRFourPointBezier                     Bezier;                                            // 0x0008(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorMakeBezierFourPoint) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMakeBezierFourPoint");
static_assert(sizeof(FRigUnit_MathVectorMakeBezierFourPoint) == 0x000068, "Wrong size on FRigUnit_MathVectorMakeBezierFourPoint");
static_assert(offsetof(FRigUnit_MathVectorMakeBezierFourPoint, Bezier) == 0x000008, "Member 'FRigUnit_MathVectorMakeBezierFourPoint::Bezier' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorClampSpatially
// 0x00B8 (0x00C0 - 0x0008)
struct FRigUnit_MathVectorClampSpatially final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         Axis;                                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigClampSpatialMode                   Type;                                              // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Minimum;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Space;                                             // 0x0030(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DebugColor;                                        // 0x0094(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugThickness;                                    // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x00A8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorClampSpatially) == 0x000010, "Wrong alignment on FRigUnit_MathVectorClampSpatially");
static_assert(sizeof(FRigUnit_MathVectorClampSpatially) == 0x0000C0, "Wrong size on FRigUnit_MathVectorClampSpatially");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, Value) == 0x000008, "Member 'FRigUnit_MathVectorClampSpatially::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, Axis) == 0x000020, "Member 'FRigUnit_MathVectorClampSpatially::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, Type) == 0x000021, "Member 'FRigUnit_MathVectorClampSpatially::Type' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, Minimum) == 0x000024, "Member 'FRigUnit_MathVectorClampSpatially::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, Maximum) == 0x000028, "Member 'FRigUnit_MathVectorClampSpatially::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, Space) == 0x000030, "Member 'FRigUnit_MathVectorClampSpatially::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, bDrawDebug) == 0x000090, "Member 'FRigUnit_MathVectorClampSpatially::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, DebugColor) == 0x000094, "Member 'FRigUnit_MathVectorClampSpatially::DebugColor' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, DebugThickness) == 0x0000A4, "Member 'FRigUnit_MathVectorClampSpatially::DebugThickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClampSpatially, Result) == 0x0000A8, "Member 'FRigUnit_MathVectorClampSpatially::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathDistanceToPlane
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_MathDistanceToPlane final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Point;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlanePoint;                                        // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClosestPointOnPlane;                               // 0x0050(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SignedDistance;                                    // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathDistanceToPlane) == 0x000008, "Wrong alignment on FRigUnit_MathDistanceToPlane");
static_assert(sizeof(FRigUnit_MathDistanceToPlane) == 0x000070, "Wrong size on FRigUnit_MathDistanceToPlane");
static_assert(offsetof(FRigUnit_MathDistanceToPlane, Point) == 0x000008, "Member 'FRigUnit_MathDistanceToPlane::Point' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathDistanceToPlane, PlanePoint) == 0x000020, "Member 'FRigUnit_MathDistanceToPlane::PlanePoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathDistanceToPlane, PlaneNormal) == 0x000038, "Member 'FRigUnit_MathDistanceToPlane::PlaneNormal' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathDistanceToPlane, ClosestPointOnPlane) == 0x000050, "Member 'FRigUnit_MathDistanceToPlane::ClosestPointOnPlane' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathDistanceToPlane, SignedDistance) == 0x000068, "Member 'FRigUnit_MathDistanceToPlane::SignedDistance' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ModifyBoneTransforms
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_ModifyBoneTransforms final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigUnit_ModifyBoneTransforms_PerBone> BoneToModify;                                      // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightMinimum;                                     // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightMaximum;                                     // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigModifyBoneMode                     Mode;                                              // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_ModifyBoneTransforms_WorkData WorkData;                                          // 0x00F0(0x0010)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ModifyBoneTransforms) == 0x000010, "Wrong alignment on FRigUnit_ModifyBoneTransforms");
static_assert(sizeof(FRigUnit_ModifyBoneTransforms) == 0x000100, "Wrong size on FRigUnit_ModifyBoneTransforms");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, BoneToModify) == 0x0000D0, "Member 'FRigUnit_ModifyBoneTransforms::BoneToModify' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, Weight) == 0x0000E0, "Member 'FRigUnit_ModifyBoneTransforms::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, WeightMinimum) == 0x0000E4, "Member 'FRigUnit_ModifyBoneTransforms::WeightMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, WeightMaximum) == 0x0000E8, "Member 'FRigUnit_ModifyBoneTransforms::WeightMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, Mode) == 0x0000EC, "Member 'FRigUnit_ModifyBoneTransforms::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, WorkData) == 0x0000F0, "Member 'FRigUnit_ModifyBoneTransforms::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ModifyTransforms
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_ModifyTransforms final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigUnit_ModifyTransforms_PerItem> ItemToModify;                                      // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightMinimum;                                     // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightMaximum;                                     // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigModifyBoneMode                     Mode;                                              // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_ModifyTransforms_WorkData     WorkData;                                          // 0x00F0(0x0010)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ModifyTransforms) == 0x000010, "Wrong alignment on FRigUnit_ModifyTransforms");
static_assert(sizeof(FRigUnit_ModifyTransforms) == 0x000100, "Wrong size on FRigUnit_ModifyTransforms");
static_assert(offsetof(FRigUnit_ModifyTransforms, ItemToModify) == 0x0000D0, "Member 'FRigUnit_ModifyTransforms::ItemToModify' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyTransforms, Weight) == 0x0000E0, "Member 'FRigUnit_ModifyTransforms::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyTransforms, WeightMinimum) == 0x0000E4, "Member 'FRigUnit_ModifyTransforms::WeightMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyTransforms, WeightMaximum) == 0x0000E8, "Member 'FRigUnit_ModifyTransforms::WeightMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyTransforms, Mode) == 0x0000EC, "Member 'FRigUnit_ModifyTransforms::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyTransforms, WorkData) == 0x0000F0, "Member 'FRigUnit_ModifyTransforms::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MultiFABRIK_EndEffector
// 0x0020 (0x0020 - 0x0000)
struct FRigUnit_MultiFABRIK_EndEffector final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MultiFABRIK_EndEffector) == 0x000008, "Wrong alignment on FRigUnit_MultiFABRIK_EndEffector");
static_assert(sizeof(FRigUnit_MultiFABRIK_EndEffector) == 0x000020, "Wrong size on FRigUnit_MultiFABRIK_EndEffector");
static_assert(offsetof(FRigUnit_MultiFABRIK_EndEffector, bone) == 0x000000, "Member 'FRigUnit_MultiFABRIK_EndEffector::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_MultiFABRIK_EndEffector, Location) == 0x000008, "Member 'FRigUnit_MultiFABRIK_EndEffector::Location' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MultiFABRIK
// 0x0090 (0x0160 - 0x00D0)
struct FRigUnit_MultiFABRIK final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   RootBone;                                          // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_MultiFABRIK_EndEffector> Effectors;                                         // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxIterations;                                     // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_MultiFABRIK_WorkData          WorkData;                                          // 0x00F8(0x0068)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MultiFABRIK) == 0x000010, "Wrong alignment on FRigUnit_MultiFABRIK");
static_assert(sizeof(FRigUnit_MultiFABRIK) == 0x000160, "Wrong size on FRigUnit_MultiFABRIK");
static_assert(offsetof(FRigUnit_MultiFABRIK, RootBone) == 0x0000D0, "Member 'FRigUnit_MultiFABRIK::RootBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_MultiFABRIK, Effectors) == 0x0000D8, "Member 'FRigUnit_MultiFABRIK::Effectors' has a wrong offset!");
static_assert(offsetof(FRigUnit_MultiFABRIK, Precision) == 0x0000E8, "Member 'FRigUnit_MultiFABRIK::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_MultiFABRIK, bPropagateToChildren) == 0x0000EC, "Member 'FRigUnit_MultiFABRIK::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_MultiFABRIK, MaxIterations) == 0x0000F0, "Member 'FRigUnit_MultiFABRIK::MaxIterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_MultiFABRIK, WorkData) == 0x0000F8, "Member 'FRigUnit_MultiFABRIK::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_NameTruncate
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_NameTruncate final : public FRigUnit_NameBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromEnd;                                           // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Remainder;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Chopped;                                           // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_NameTruncate) == 0x000008, "Wrong alignment on FRigUnit_NameTruncate");
static_assert(sizeof(FRigUnit_NameTruncate) == 0x000028, "Wrong size on FRigUnit_NameTruncate");
static_assert(offsetof(FRigUnit_NameTruncate, Name) == 0x000008, "Member 'FRigUnit_NameTruncate::Name' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameTruncate, Count) == 0x000010, "Member 'FRigUnit_NameTruncate::Count' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameTruncate, FromEnd) == 0x000014, "Member 'FRigUnit_NameTruncate::FromEnd' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameTruncate, Remainder) == 0x000018, "Member 'FRigUnit_NameTruncate::Remainder' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameTruncate, Chopped) == 0x000020, "Member 'FRigUnit_NameTruncate::Chopped' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_NameReplace
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_NameReplace final : public FRigUnit_NameBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Old;                                               // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   New;                                               // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Result;                                            // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_NameReplace) == 0x000008, "Wrong alignment on FRigUnit_NameReplace");
static_assert(sizeof(FRigUnit_NameReplace) == 0x000028, "Wrong size on FRigUnit_NameReplace");
static_assert(offsetof(FRigUnit_NameReplace, Name) == 0x000008, "Member 'FRigUnit_NameReplace::Name' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameReplace, Old) == 0x000010, "Member 'FRigUnit_NameReplace::Old' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameReplace, New) == 0x000018, "Member 'FRigUnit_NameReplace::New' has a wrong offset!");
static_assert(offsetof(FRigUnit_NameReplace, Result) == 0x000020, "Member 'FRigUnit_NameReplace::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_EndsWith
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_EndsWith final : public FRigUnit_NameBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Ending;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_EndsWith) == 0x000008, "Wrong alignment on FRigUnit_EndsWith");
static_assert(sizeof(FRigUnit_EndsWith) == 0x000020, "Wrong size on FRigUnit_EndsWith");
static_assert(offsetof(FRigUnit_EndsWith, Name) == 0x000008, "Member 'FRigUnit_EndsWith::Name' has a wrong offset!");
static_assert(offsetof(FRigUnit_EndsWith, Ending) == 0x000010, "Member 'FRigUnit_EndsWith::Ending' has a wrong offset!");
static_assert(offsetof(FRigUnit_EndsWith, Result) == 0x000018, "Member 'FRigUnit_EndsWith::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Contains
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_Contains final : public FRigUnit_NameBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Search;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Contains) == 0x000008, "Wrong alignment on FRigUnit_Contains");
static_assert(sizeof(FRigUnit_Contains) == 0x000020, "Wrong size on FRigUnit_Contains");
static_assert(offsetof(FRigUnit_Contains, Name) == 0x000008, "Member 'FRigUnit_Contains::Name' has a wrong offset!");
static_assert(offsetof(FRigUnit_Contains, Search) == 0x000010, "Member 'FRigUnit_Contains::Search' has a wrong offset!");
static_assert(offsetof(FRigUnit_Contains, Result) == 0x000018, "Member 'FRigUnit_Contains::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_NoiseFloat
// 0x0020 (0x0028 - 0x0008)
struct FRigUnit_NoiseFloat final : public FRigUnit_MathBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_NoiseFloat) == 0x000008, "Wrong alignment on FRigUnit_NoiseFloat");
static_assert(sizeof(FRigUnit_NoiseFloat) == 0x000028, "Wrong size on FRigUnit_NoiseFloat");
static_assert(offsetof(FRigUnit_NoiseFloat, Value) == 0x000008, "Member 'FRigUnit_NoiseFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Speed) == 0x00000C, "Member 'FRigUnit_NoiseFloat::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Frequency) == 0x000010, "Member 'FRigUnit_NoiseFloat::Frequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Minimum) == 0x000014, "Member 'FRigUnit_NoiseFloat::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Maximum) == 0x000018, "Member 'FRigUnit_NoiseFloat::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Result) == 0x00001C, "Member 'FRigUnit_NoiseFloat::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Time) == 0x000020, "Member 'FRigUnit_NoiseFloat::Time' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_NoiseVector
// 0x0080 (0x0088 - 0x0008)
struct FRigUnit_NoiseVector final : public FRigUnit_MathBase
{
public:
	struct FVector                                Position;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Speed;                                             // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Frequency;                                         // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Time;                                              // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_NoiseVector) == 0x000008, "Wrong alignment on FRigUnit_NoiseVector");
static_assert(sizeof(FRigUnit_NoiseVector) == 0x000088, "Wrong size on FRigUnit_NoiseVector");
static_assert(offsetof(FRigUnit_NoiseVector, Position) == 0x000008, "Member 'FRigUnit_NoiseVector::Position' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Speed) == 0x000020, "Member 'FRigUnit_NoiseVector::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Frequency) == 0x000038, "Member 'FRigUnit_NoiseVector::Frequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Minimum) == 0x000050, "Member 'FRigUnit_NoiseVector::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Maximum) == 0x000054, "Member 'FRigUnit_NoiseVector::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Result) == 0x000058, "Member 'FRigUnit_NoiseVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Time) == 0x000070, "Member 'FRigUnit_NoiseVector::Time' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ParentSwitchConstraint
// 0x01A0 (0x0270 - 0x00D0)
struct FRigUnit_ParentSwitchConstraint final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Subject;                                           // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               Parents;                                           // 0x00E0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             InitialGlobalTransform;                            // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0xC];                                      // 0x0154(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Switched;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedSubject;                                     // 0x01C8(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedParent;                                      // 0x01E8(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeOffset;                                    // 0x0210(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ParentSwitchConstraint) == 0x000010, "Wrong alignment on FRigUnit_ParentSwitchConstraint");
static_assert(sizeof(FRigUnit_ParentSwitchConstraint) == 0x000270, "Wrong size on FRigUnit_ParentSwitchConstraint");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, Subject) == 0x0000D0, "Member 'FRigUnit_ParentSwitchConstraint::Subject' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, ParentIndex) == 0x0000DC, "Member 'FRigUnit_ParentSwitchConstraint::ParentIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, Parents) == 0x0000E0, "Member 'FRigUnit_ParentSwitchConstraint::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, InitialGlobalTransform) == 0x0000F0, "Member 'FRigUnit_ParentSwitchConstraint::InitialGlobalTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, Weight) == 0x000150, "Member 'FRigUnit_ParentSwitchConstraint::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, Transform) == 0x000160, "Member 'FRigUnit_ParentSwitchConstraint::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, Switched) == 0x0001C0, "Member 'FRigUnit_ParentSwitchConstraint::Switched' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, CachedSubject) == 0x0001C8, "Member 'FRigUnit_ParentSwitchConstraint::CachedSubject' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, CachedParent) == 0x0001E8, "Member 'FRigUnit_ParentSwitchConstraint::CachedParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraint, RelativeOffset) == 0x000210, "Member 'FRigUnit_ParentSwitchConstraint::RelativeOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ParentSwitchConstraintArray
// 0x01A0 (0x0270 - 0x00D0)
struct FRigUnit_ParentSwitchConstraintArray final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Subject;                                           // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigElementKey>                 Parents;                                           // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitialGlobalTransform;                            // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0xC];                                      // 0x0154(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0160(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Switched;                                          // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedSubject;                                     // 0x01C8(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedParent;                                      // 0x01E8(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeOffset;                                    // 0x0210(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ParentSwitchConstraintArray) == 0x000010, "Wrong alignment on FRigUnit_ParentSwitchConstraintArray");
static_assert(sizeof(FRigUnit_ParentSwitchConstraintArray) == 0x000270, "Wrong size on FRigUnit_ParentSwitchConstraintArray");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, Subject) == 0x0000D0, "Member 'FRigUnit_ParentSwitchConstraintArray::Subject' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, ParentIndex) == 0x0000DC, "Member 'FRigUnit_ParentSwitchConstraintArray::ParentIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, Parents) == 0x0000E0, "Member 'FRigUnit_ParentSwitchConstraintArray::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, InitialGlobalTransform) == 0x0000F0, "Member 'FRigUnit_ParentSwitchConstraintArray::InitialGlobalTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, Weight) == 0x000150, "Member 'FRigUnit_ParentSwitchConstraintArray::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, Transform) == 0x000160, "Member 'FRigUnit_ParentSwitchConstraintArray::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, Switched) == 0x0001C0, "Member 'FRigUnit_ParentSwitchConstraintArray::Switched' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, CachedSubject) == 0x0001C8, "Member 'FRigUnit_ParentSwitchConstraintArray::CachedSubject' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, CachedParent) == 0x0001E8, "Member 'FRigUnit_ParentSwitchConstraintArray::CachedParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentSwitchConstraintArray, RelativeOffset) == 0x000210, "Member 'FRigUnit_ParentSwitchConstraintArray::RelativeOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PointSimulation_DebugSettings
// 0x0080 (0x0080 - 0x0000)
struct FRigUnit_PointSimulation_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionScale;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawPointsAsSpheres;                              // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0020(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PointSimulation_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_PointSimulation_DebugSettings");
static_assert(sizeof(FRigUnit_PointSimulation_DebugSettings) == 0x000080, "Wrong size on FRigUnit_PointSimulation_DebugSettings");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_PointSimulation_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_PointSimulation_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, CollisionScale) == 0x000008, "Member 'FRigUnit_PointSimulation_DebugSettings::CollisionScale' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, bDrawPointsAsSpheres) == 0x00000C, "Member 'FRigUnit_PointSimulation_DebugSettings::bDrawPointsAsSpheres' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, Color) == 0x000010, "Member 'FRigUnit_PointSimulation_DebugSettings::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, WorldOffset) == 0x000020, "Member 'FRigUnit_PointSimulation_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PointSimulation_WorkData
// 0x0088 (0x0088 - 0x0000)
struct FRigUnit_PointSimulation_WorkData final
{
public:
	struct FCRSimPointContainer                   Simulation;                                        // 0x0000(0x0078)(NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              BoneIndices;                                       // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PointSimulation_WorkData) == 0x000008, "Wrong alignment on FRigUnit_PointSimulation_WorkData");
static_assert(sizeof(FRigUnit_PointSimulation_WorkData) == 0x000088, "Wrong size on FRigUnit_PointSimulation_WorkData");
static_assert(offsetof(FRigUnit_PointSimulation_WorkData, Simulation) == 0x000000, "Member 'FRigUnit_PointSimulation_WorkData::Simulation' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_WorkData, BoneIndices) == 0x000078, "Member 'FRigUnit_PointSimulation_WorkData::BoneIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SimBaseMutable
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_SimBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_SimBaseMutable) == 0x000010, "Wrong alignment on FRigUnit_SimBaseMutable");
static_assert(sizeof(FRigUnit_SimBaseMutable) == 0x0000D0, "Wrong size on FRigUnit_SimBaseMutable");

// ScriptStruct ControlRig.RigUnit_PointSimulation
// 0x0210 (0x02E0 - 0x00D0)
struct FRigUnit_PointSimulation final : public FRigUnit_SimBaseMutable
{
public:
	TArray<struct FCRSimPoint>                    Points;                                            // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimLinearSpring>             Links;                                             // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimPointForce>               Forces;                                            // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimSoftCollision>            CollisionVolumes;                                  // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SimulatedStepsPerSecond;                           // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECRSimPointIntegrateType                      IntegratorType;                                    // 0x0114(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerletBlend;                                       // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnit_PointSimulation_BoneTarget> BoneTargets;                                       // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLimitLocalPosition;                               // 0x0130(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0131(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PrimaryAimAxis;                                    // 0x0138(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAimAxis;                                  // 0x0150(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_PointSimulation_DebugSettings DebugSettings;                                     // 0x0170(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCRFourPointBezier                     Bezier;                                            // 0x01F0(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_PointSimulation_WorkData      WorkData;                                          // 0x0250(0x0088)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PointSimulation) == 0x000010, "Wrong alignment on FRigUnit_PointSimulation");
static_assert(sizeof(FRigUnit_PointSimulation) == 0x0002E0, "Wrong size on FRigUnit_PointSimulation");
static_assert(offsetof(FRigUnit_PointSimulation, Points) == 0x0000D0, "Member 'FRigUnit_PointSimulation::Points' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, Links) == 0x0000E0, "Member 'FRigUnit_PointSimulation::Links' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, Forces) == 0x0000F0, "Member 'FRigUnit_PointSimulation::Forces' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, CollisionVolumes) == 0x000100, "Member 'FRigUnit_PointSimulation::CollisionVolumes' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, SimulatedStepsPerSecond) == 0x000110, "Member 'FRigUnit_PointSimulation::SimulatedStepsPerSecond' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, IntegratorType) == 0x000114, "Member 'FRigUnit_PointSimulation::IntegratorType' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, VerletBlend) == 0x000118, "Member 'FRigUnit_PointSimulation::VerletBlend' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, BoneTargets) == 0x000120, "Member 'FRigUnit_PointSimulation::BoneTargets' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, bLimitLocalPosition) == 0x000130, "Member 'FRigUnit_PointSimulation::bLimitLocalPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, bPropagateToChildren) == 0x000131, "Member 'FRigUnit_PointSimulation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, PrimaryAimAxis) == 0x000138, "Member 'FRigUnit_PointSimulation::PrimaryAimAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, SecondaryAimAxis) == 0x000150, "Member 'FRigUnit_PointSimulation::SecondaryAimAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, DebugSettings) == 0x000170, "Member 'FRigUnit_PointSimulation::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, Bezier) == 0x0001F0, "Member 'FRigUnit_PointSimulation::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, WorkData) == 0x000250, "Member 'FRigUnit_PointSimulation::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_StartProfilingTimer
// 0x0000 (0x00D0 - 0x00D0)
struct FRigUnit_StartProfilingTimer final : public FRigUnit_DebugBaseMutable
{
};
static_assert(alignof(FRigUnit_StartProfilingTimer) == 0x000010, "Wrong alignment on FRigUnit_StartProfilingTimer");
static_assert(sizeof(FRigUnit_StartProfilingTimer) == 0x0000D0, "Wrong size on FRigUnit_StartProfilingTimer");

// ScriptStruct ControlRig.RigUnit_EndProfilingTimer
// 0x0020 (0x00F0 - 0x00D0)
struct FRigUnit_EndProfilingTimer final : public FRigUnit_DebugBaseMutable
{
public:
	int32                                         NumberOfMeasurements;                              // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Prefix;                                            // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTime;                                   // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeasurementsLeft;                                  // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_EndProfilingTimer) == 0x000010, "Wrong alignment on FRigUnit_EndProfilingTimer");
static_assert(sizeof(FRigUnit_EndProfilingTimer) == 0x0000F0, "Wrong size on FRigUnit_EndProfilingTimer");
static_assert(offsetof(FRigUnit_EndProfilingTimer, NumberOfMeasurements) == 0x0000D0, "Member 'FRigUnit_EndProfilingTimer::NumberOfMeasurements' has a wrong offset!");
static_assert(offsetof(FRigUnit_EndProfilingTimer, Prefix) == 0x0000D8, "Member 'FRigUnit_EndProfilingTimer::Prefix' has a wrong offset!");
static_assert(offsetof(FRigUnit_EndProfilingTimer, AccumulatedTime) == 0x0000E8, "Member 'FRigUnit_EndProfilingTimer::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_EndProfilingTimer, MeasurementsLeft) == 0x0000EC, "Member 'FRigUnit_EndProfilingTimer::MeasurementsLeft' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ProjectTransformToNewParent
// 0x00F8 (0x0100 - 0x0008)
struct FRigUnit_ProjectTransformToNewParent final : public FRigUnit
{
public:
	struct FRigElementKey                         Child;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChildInitial;                                     // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         OldParent;                                         // 0x0018(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOldParentInitial;                                 // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         NewParent;                                         // 0x0028(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewParentInitial;                                 // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0xB];                                       // 0x0035(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedChild;                                       // 0x00A0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedOldParent;                                   // 0x00C0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedNewParent;                                   // 0x00E0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ProjectTransformToNewParent) == 0x000010, "Wrong alignment on FRigUnit_ProjectTransformToNewParent");
static_assert(sizeof(FRigUnit_ProjectTransformToNewParent) == 0x000100, "Wrong size on FRigUnit_ProjectTransformToNewParent");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, Child) == 0x000008, "Member 'FRigUnit_ProjectTransformToNewParent::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, bChildInitial) == 0x000014, "Member 'FRigUnit_ProjectTransformToNewParent::bChildInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, OldParent) == 0x000018, "Member 'FRigUnit_ProjectTransformToNewParent::OldParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, bOldParentInitial) == 0x000024, "Member 'FRigUnit_ProjectTransformToNewParent::bOldParentInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, NewParent) == 0x000028, "Member 'FRigUnit_ProjectTransformToNewParent::NewParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, bNewParentInitial) == 0x000034, "Member 'FRigUnit_ProjectTransformToNewParent::bNewParentInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, Transform) == 0x000040, "Member 'FRigUnit_ProjectTransformToNewParent::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, CachedChild) == 0x0000A0, "Member 'FRigUnit_ProjectTransformToNewParent::CachedChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, CachedOldParent) == 0x0000C0, "Member 'FRigUnit_ProjectTransformToNewParent::CachedOldParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_ProjectTransformToNewParent, CachedNewParent) == 0x0000E0, "Member 'FRigUnit_ProjectTransformToNewParent::CachedNewParent' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryQuaternionOp
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_BinaryQuaternionOp : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Argument0;                                         // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Argument1;                                         // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0050(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BinaryQuaternionOp) == 0x000010, "Wrong alignment on FRigUnit_BinaryQuaternionOp");
static_assert(sizeof(FRigUnit_BinaryQuaternionOp) == 0x000070, "Wrong size on FRigUnit_BinaryQuaternionOp");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Argument0) == 0x000010, "Member 'FRigUnit_BinaryQuaternionOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Argument1) == 0x000030, "Member 'FRigUnit_BinaryQuaternionOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Result) == 0x000050, "Member 'FRigUnit_BinaryQuaternionOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MultiplyQuaternion
// 0x0000 (0x0070 - 0x0070)
struct FRigUnit_MultiplyQuaternion final : public FRigUnit_BinaryQuaternionOp
{
};
static_assert(alignof(FRigUnit_MultiplyQuaternion) == 0x000010, "Wrong alignment on FRigUnit_MultiplyQuaternion");
static_assert(sizeof(FRigUnit_MultiplyQuaternion) == 0x000070, "Wrong size on FRigUnit_MultiplyQuaternion");

// ScriptStruct ControlRig.RigUnit_QuaternionToAxisAndAngle
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_QuaternionToAxisAndAngle final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Argument;                                          // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_QuaternionToAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionToAxisAndAngle");
static_assert(sizeof(FRigUnit_QuaternionToAxisAndAngle) == 0x000050, "Wrong size on FRigUnit_QuaternionToAxisAndAngle");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Argument) == 0x000010, "Member 'FRigUnit_QuaternionToAxisAndAngle::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Axis) == 0x000030, "Member 'FRigUnit_QuaternionToAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Angle) == 0x000048, "Member 'FRigUnit_QuaternionToAxisAndAngle::Angle' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_QuaternionFromAxisAndAngle
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_QuaternionFromAxisAndAngle final : public FRigUnit
{
public:
	struct FVector                                Axis;                                              // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_QuaternionFromAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionFromAxisAndAngle");
static_assert(sizeof(FRigUnit_QuaternionFromAxisAndAngle) == 0x000050, "Wrong size on FRigUnit_QuaternionFromAxisAndAngle");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Axis) == 0x000008, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Angle) == 0x000020, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Angle' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Result) == 0x000030, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_QuaternionToAngle
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_QuaternionToAngle final : public FRigUnit
{
public:
	struct FVector                                Axis;                                              // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Argument;                                          // 0x0020(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_QuaternionToAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionToAngle");
static_assert(sizeof(FRigUnit_QuaternionToAngle) == 0x000050, "Wrong size on FRigUnit_QuaternionToAngle");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Axis) == 0x000008, "Member 'FRigUnit_QuaternionToAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Argument) == 0x000020, "Member 'FRigUnit_QuaternionToAngle::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Angle) == 0x000040, "Member 'FRigUnit_QuaternionToAngle::Angle' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_RandomVector
// 0x0050 (0x0058 - 0x0008)
struct FRigUnit_RandomVector final : public FRigUnit_MathBase
{
public:
	int32                                         Seed;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastResult;                                        // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSeed;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseSeed;                                          // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLeft;                                          // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_RandomVector) == 0x000008, "Wrong alignment on FRigUnit_RandomVector");
static_assert(sizeof(FRigUnit_RandomVector) == 0x000058, "Wrong size on FRigUnit_RandomVector");
static_assert(offsetof(FRigUnit_RandomVector, Seed) == 0x000008, "Member 'FRigUnit_RandomVector::Seed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, Minimum) == 0x00000C, "Member 'FRigUnit_RandomVector::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, Maximum) == 0x000010, "Member 'FRigUnit_RandomVector::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, Duration) == 0x000014, "Member 'FRigUnit_RandomVector::Duration' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, Result) == 0x000018, "Member 'FRigUnit_RandomVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, LastResult) == 0x000030, "Member 'FRigUnit_RandomVector::LastResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, LastSeed) == 0x000048, "Member 'FRigUnit_RandomVector::LastSeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, BaseSeed) == 0x00004C, "Member 'FRigUnit_RandomVector::BaseSeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, TimeLeft) == 0x000050, "Member 'FRigUnit_RandomVector::TimeLeft' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SendEvent
// 0x0020 (0x00F0 - 0x00D0)
struct FRigUnit_SendEvent final : public FRigUnitMutable
{
public:
	ERigEvent                                     Event;                                             // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         Item;                                              // 0x00D4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetInSeconds;                                   // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyDuringInteraction;                            // 0x00E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6[0xA];                                       // 0x00E6(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SendEvent) == 0x000010, "Wrong alignment on FRigUnit_SendEvent");
static_assert(sizeof(FRigUnit_SendEvent) == 0x0000F0, "Wrong size on FRigUnit_SendEvent");
static_assert(offsetof(FRigUnit_SendEvent, Event) == 0x0000D0, "Member 'FRigUnit_SendEvent::Event' has a wrong offset!");
static_assert(offsetof(FRigUnit_SendEvent, Item) == 0x0000D4, "Member 'FRigUnit_SendEvent::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_SendEvent, OffsetInSeconds) == 0x0000E0, "Member 'FRigUnit_SendEvent::OffsetInSeconds' has a wrong offset!");
static_assert(offsetof(FRigUnit_SendEvent, bEnable) == 0x0000E4, "Member 'FRigUnit_SendEvent::bEnable' has a wrong offset!");
static_assert(offsetof(FRigUnit_SendEvent, bOnlyDuringInteraction) == 0x0000E5, "Member 'FRigUnit_SendEvent::bOnlyDuringInteraction' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SequenceExecution
// 0x03C8 (0x03D0 - 0x0008)
struct FRigUnit_SequenceExecution final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              ExecuteContext;                                    // 0x0010(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
	struct FControlRigExecuteContext              A;                                                 // 0x00D0(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
	struct FControlRigExecuteContext              B;                                                 // 0x0190(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
	struct FControlRigExecuteContext              C;                                                 // 0x0250(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
	struct FControlRigExecuteContext              D;                                                 // 0x0310(0x00C0)(Edit, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SequenceExecution) == 0x000010, "Wrong alignment on FRigUnit_SequenceExecution");
static_assert(sizeof(FRigUnit_SequenceExecution) == 0x0003D0, "Wrong size on FRigUnit_SequenceExecution");
static_assert(offsetof(FRigUnit_SequenceExecution, ExecuteContext) == 0x000010, "Member 'FRigUnit_SequenceExecution::ExecuteContext' has a wrong offset!");
static_assert(offsetof(FRigUnit_SequenceExecution, A) == 0x0000D0, "Member 'FRigUnit_SequenceExecution::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_SequenceExecution, B) == 0x000190, "Member 'FRigUnit_SequenceExecution::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_SequenceExecution, C) == 0x000250, "Member 'FRigUnit_SequenceExecution::C' has a wrong offset!");
static_assert(offsetof(FRigUnit_SequenceExecution, D) == 0x000310, "Member 'FRigUnit_SequenceExecution::D' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetBoneRotation
// 0x0060 (0x0130 - 0x00D0)
struct FRigUnit_SetBoneRotation final : public FRigUnitMutable
{
public:
	class FName                                   bone;                                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x00E0(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0100(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedBone;                                        // 0x0110(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetBoneRotation) == 0x000010, "Wrong alignment on FRigUnit_SetBoneRotation");
static_assert(sizeof(FRigUnit_SetBoneRotation) == 0x000130, "Wrong size on FRigUnit_SetBoneRotation");
static_assert(offsetof(FRigUnit_SetBoneRotation, bone) == 0x0000D0, "Member 'FRigUnit_SetBoneRotation::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, Rotation) == 0x0000E0, "Member 'FRigUnit_SetBoneRotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, Space) == 0x000100, "Member 'FRigUnit_SetBoneRotation::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, Weight) == 0x000104, "Member 'FRigUnit_SetBoneRotation::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, bPropagateToChildren) == 0x000108, "Member 'FRigUnit_SetBoneRotation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, CachedBone) == 0x000110, "Member 'FRigUnit_SetBoneRotation::CachedBone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetBoneTransform
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_SetBoneTransform final : public FRigUnitMutable
{
public:
	class FName                                   bone;                                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0140(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x01A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x01A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedBone;                                        // 0x01B0(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_SetBoneTransform");
static_assert(sizeof(FRigUnit_SetBoneTransform) == 0x0001D0, "Wrong size on FRigUnit_SetBoneTransform");
static_assert(offsetof(FRigUnit_SetBoneTransform, bone) == 0x0000D0, "Member 'FRigUnit_SetBoneTransform::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, Transform) == 0x0000E0, "Member 'FRigUnit_SetBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, Result) == 0x000140, "Member 'FRigUnit_SetBoneTransform::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, Space) == 0x0001A0, "Member 'FRigUnit_SetBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, Weight) == 0x0001A4, "Member 'FRigUnit_SetBoneTransform::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, bPropagateToChildren) == 0x0001A8, "Member 'FRigUnit_SetBoneTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, CachedBone) == 0x0001B0, "Member 'FRigUnit_SetBoneTransform::CachedBone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetBoneTranslation
// 0x0050 (0x0120 - 0x00D0)
struct FRigUnit_SetBoneTranslation final : public FRigUnitMutable
{
public:
	class FName                                   bone;                                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x00D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedBone;                                        // 0x0100(0x0020)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetBoneTranslation) == 0x000010, "Wrong alignment on FRigUnit_SetBoneTranslation");
static_assert(sizeof(FRigUnit_SetBoneTranslation) == 0x000120, "Wrong size on FRigUnit_SetBoneTranslation");
static_assert(offsetof(FRigUnit_SetBoneTranslation, bone) == 0x0000D0, "Member 'FRigUnit_SetBoneTranslation::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, Translation) == 0x0000D8, "Member 'FRigUnit_SetBoneTranslation::Translation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, Space) == 0x0000F0, "Member 'FRigUnit_SetBoneTranslation::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, Weight) == 0x0000F4, "Member 'FRigUnit_SetBoneTranslation::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, bPropagateToChildren) == 0x0000F8, "Member 'FRigUnit_SetBoneTranslation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, CachedBone) == 0x000100, "Member 'FRigUnit_SetBoneTranslation::CachedBone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlOffset
// 0x00A0 (0x0170 - 0x00D0)
struct FRigUnit_SetControlOffset final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0148(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetControlOffset) == 0x000010, "Wrong alignment on FRigUnit_SetControlOffset");
static_assert(sizeof(FRigUnit_SetControlOffset) == 0x000170, "Wrong size on FRigUnit_SetControlOffset");
static_assert(offsetof(FRigUnit_SetControlOffset, Control) == 0x0000D0, "Member 'FRigUnit_SetControlOffset::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlOffset, Offset) == 0x0000E0, "Member 'FRigUnit_SetControlOffset::Offset' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlOffset, Space) == 0x000140, "Member 'FRigUnit_SetControlOffset::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlOffset, CachedControlIndex) == 0x000148, "Member 'FRigUnit_SetControlOffset::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlBool
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_SetControlBool final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolValue;                                         // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedControlIndex;                                // 0x00E0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetControlBool) == 0x000010, "Wrong alignment on FRigUnit_SetControlBool");
static_assert(sizeof(FRigUnit_SetControlBool) == 0x000100, "Wrong size on FRigUnit_SetControlBool");
static_assert(offsetof(FRigUnit_SetControlBool, Control) == 0x0000D0, "Member 'FRigUnit_SetControlBool::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlBool, BoolValue) == 0x0000D8, "Member 'FRigUnit_SetControlBool::BoolValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlBool, CachedControlIndex) == 0x0000E0, "Member 'FRigUnit_SetControlBool::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlFloat
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_SetControlFloat final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x00E0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetControlFloat) == 0x000010, "Wrong alignment on FRigUnit_SetControlFloat");
static_assert(sizeof(FRigUnit_SetControlFloat) == 0x000100, "Wrong size on FRigUnit_SetControlFloat");
static_assert(offsetof(FRigUnit_SetControlFloat, Control) == 0x0000D0, "Member 'FRigUnit_SetControlFloat::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlFloat, Weight) == 0x0000D8, "Member 'FRigUnit_SetControlFloat::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlFloat, FloatValue) == 0x0000DC, "Member 'FRigUnit_SetControlFloat::FloatValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlFloat, CachedControlIndex) == 0x0000E0, "Member 'FRigUnit_SetControlFloat::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlFloat_Entry
// 0x000C (0x000C - 0x0000)
struct FRigUnit_SetMultiControlFloat_Entry final
{
public:
	class FName                                   Control;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetMultiControlFloat_Entry) == 0x000004, "Wrong alignment on FRigUnit_SetMultiControlFloat_Entry");
static_assert(sizeof(FRigUnit_SetMultiControlFloat_Entry) == 0x00000C, "Wrong size on FRigUnit_SetMultiControlFloat_Entry");
static_assert(offsetof(FRigUnit_SetMultiControlFloat_Entry, Control) == 0x000000, "Member 'FRigUnit_SetMultiControlFloat_Entry::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlFloat_Entry, FloatValue) == 0x000008, "Member 'FRigUnit_SetMultiControlFloat_Entry::FloatValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlFloat
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_SetMultiControlFloat final : public FRigUnitMutable
{
public:
	TArray<struct FRigUnit_SetMultiControlFloat_Entry> Entries;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedRigElement>              CachedControlIndices;                              // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetMultiControlFloat) == 0x000010, "Wrong alignment on FRigUnit_SetMultiControlFloat");
static_assert(sizeof(FRigUnit_SetMultiControlFloat) == 0x000100, "Wrong size on FRigUnit_SetMultiControlFloat");
static_assert(offsetof(FRigUnit_SetMultiControlFloat, Entries) == 0x0000D0, "Member 'FRigUnit_SetMultiControlFloat::Entries' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlFloat, Weight) == 0x0000E0, "Member 'FRigUnit_SetMultiControlFloat::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlFloat, CachedControlIndices) == 0x0000E8, "Member 'FRigUnit_SetMultiControlFloat::CachedControlIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlInteger
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_SetControlInteger final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntegerValue;                                      // 0x00DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x00E0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetControlInteger) == 0x000010, "Wrong alignment on FRigUnit_SetControlInteger");
static_assert(sizeof(FRigUnit_SetControlInteger) == 0x000100, "Wrong size on FRigUnit_SetControlInteger");
static_assert(offsetof(FRigUnit_SetControlInteger, Control) == 0x0000D0, "Member 'FRigUnit_SetControlInteger::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlInteger, Weight) == 0x0000D8, "Member 'FRigUnit_SetControlInteger::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlInteger, IntegerValue) == 0x0000DC, "Member 'FRigUnit_SetControlInteger::IntegerValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlInteger, CachedControlIndex) == 0x0000E0, "Member 'FRigUnit_SetControlInteger::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlInteger_Entry
// 0x000C (0x000C - 0x0000)
struct FRigUnit_SetMultiControlInteger_Entry final
{
public:
	class FName                                   Control;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntegerValue;                                      // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetMultiControlInteger_Entry) == 0x000004, "Wrong alignment on FRigUnit_SetMultiControlInteger_Entry");
static_assert(sizeof(FRigUnit_SetMultiControlInteger_Entry) == 0x00000C, "Wrong size on FRigUnit_SetMultiControlInteger_Entry");
static_assert(offsetof(FRigUnit_SetMultiControlInteger_Entry, Control) == 0x000000, "Member 'FRigUnit_SetMultiControlInteger_Entry::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlInteger_Entry, IntegerValue) == 0x000008, "Member 'FRigUnit_SetMultiControlInteger_Entry::IntegerValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlInteger
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_SetMultiControlInteger final : public FRigUnitMutable
{
public:
	TArray<struct FRigUnit_SetMultiControlInteger_Entry> Entries;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedRigElement>              CachedControlIndices;                              // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetMultiControlInteger) == 0x000010, "Wrong alignment on FRigUnit_SetMultiControlInteger");
static_assert(sizeof(FRigUnit_SetMultiControlInteger) == 0x000100, "Wrong size on FRigUnit_SetMultiControlInteger");
static_assert(offsetof(FRigUnit_SetMultiControlInteger, Entries) == 0x0000D0, "Member 'FRigUnit_SetMultiControlInteger::Entries' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlInteger, Weight) == 0x0000E0, "Member 'FRigUnit_SetMultiControlInteger::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlInteger, CachedControlIndices) == 0x0000E8, "Member 'FRigUnit_SetMultiControlInteger::CachedControlIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlVector2D
// 0x0040 (0x0110 - 0x00D0)
struct FRigUnit_SetControlVector2D final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Vector;                                            // 0x00E0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedControlIndex;                                // 0x00F0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetControlVector2D) == 0x000010, "Wrong alignment on FRigUnit_SetControlVector2D");
static_assert(sizeof(FRigUnit_SetControlVector2D) == 0x000110, "Wrong size on FRigUnit_SetControlVector2D");
static_assert(offsetof(FRigUnit_SetControlVector2D, Control) == 0x0000D0, "Member 'FRigUnit_SetControlVector2D::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVector2D, Weight) == 0x0000D8, "Member 'FRigUnit_SetControlVector2D::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVector2D, Vector) == 0x0000E0, "Member 'FRigUnit_SetControlVector2D::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVector2D, CachedControlIndex) == 0x0000F0, "Member 'FRigUnit_SetControlVector2D::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlVector
// 0x0050 (0x0120 - 0x00D0)
struct FRigUnit_SetControlVector final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector;                                            // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0100(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetControlVector) == 0x000010, "Wrong alignment on FRigUnit_SetControlVector");
static_assert(sizeof(FRigUnit_SetControlVector) == 0x000120, "Wrong size on FRigUnit_SetControlVector");
static_assert(offsetof(FRigUnit_SetControlVector, Control) == 0x0000D0, "Member 'FRigUnit_SetControlVector::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVector, Weight) == 0x0000D8, "Member 'FRigUnit_SetControlVector::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVector, Vector) == 0x0000E0, "Member 'FRigUnit_SetControlVector::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVector, Space) == 0x0000F8, "Member 'FRigUnit_SetControlVector::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVector, CachedControlIndex) == 0x000100, "Member 'FRigUnit_SetControlVector::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlRotator
// 0x0050 (0x0120 - 0x00D0)
struct FRigUnit_SetControlRotator final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotator;                                           // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0100(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetControlRotator) == 0x000010, "Wrong alignment on FRigUnit_SetControlRotator");
static_assert(sizeof(FRigUnit_SetControlRotator) == 0x000120, "Wrong size on FRigUnit_SetControlRotator");
static_assert(offsetof(FRigUnit_SetControlRotator, Control) == 0x0000D0, "Member 'FRigUnit_SetControlRotator::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlRotator, Weight) == 0x0000D8, "Member 'FRigUnit_SetControlRotator::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlRotator, Rotator) == 0x0000E0, "Member 'FRigUnit_SetControlRotator::Rotator' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlRotator, Space) == 0x0000F8, "Member 'FRigUnit_SetControlRotator::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlRotator, CachedControlIndex) == 0x000100, "Member 'FRigUnit_SetControlRotator::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlRotator_Entry
// 0x0028 (0x0028 - 0x0000)
struct FRigUnit_SetMultiControlRotator_Entry final
{
public:
	class FName                                   Control;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetMultiControlRotator_Entry) == 0x000008, "Wrong alignment on FRigUnit_SetMultiControlRotator_Entry");
static_assert(sizeof(FRigUnit_SetMultiControlRotator_Entry) == 0x000028, "Wrong size on FRigUnit_SetMultiControlRotator_Entry");
static_assert(offsetof(FRigUnit_SetMultiControlRotator_Entry, Control) == 0x000000, "Member 'FRigUnit_SetMultiControlRotator_Entry::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlRotator_Entry, Rotator) == 0x000008, "Member 'FRigUnit_SetMultiControlRotator_Entry::Rotator' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlRotator_Entry, Space) == 0x000020, "Member 'FRigUnit_SetMultiControlRotator_Entry::Space' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetMultiControlRotator
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_SetMultiControlRotator final : public FRigUnitMutable
{
public:
	TArray<struct FRigUnit_SetMultiControlRotator_Entry> Entries;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedRigElement>              CachedControlIndices;                              // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetMultiControlRotator) == 0x000010, "Wrong alignment on FRigUnit_SetMultiControlRotator");
static_assert(sizeof(FRigUnit_SetMultiControlRotator) == 0x000100, "Wrong size on FRigUnit_SetMultiControlRotator");
static_assert(offsetof(FRigUnit_SetMultiControlRotator, Entries) == 0x0000D0, "Member 'FRigUnit_SetMultiControlRotator::Entries' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlRotator, Weight) == 0x0000E0, "Member 'FRigUnit_SetMultiControlRotator::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetMultiControlRotator, CachedControlIndices) == 0x0000E8, "Member 'FRigUnit_SetMultiControlRotator::CachedControlIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlTransform
// 0x00A0 (0x0170 - 0x00D0)
struct FRigUnit_SetControlTransform final : public FRigUnitMutable
{
public:
	class FName                                   Control;                                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedControlIndex;                                // 0x0148(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetControlTransform) == 0x000010, "Wrong alignment on FRigUnit_SetControlTransform");
static_assert(sizeof(FRigUnit_SetControlTransform) == 0x000170, "Wrong size on FRigUnit_SetControlTransform");
static_assert(offsetof(FRigUnit_SetControlTransform, Control) == 0x0000D0, "Member 'FRigUnit_SetControlTransform::Control' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlTransform, Weight) == 0x0000D8, "Member 'FRigUnit_SetControlTransform::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlTransform, Transform) == 0x0000E0, "Member 'FRigUnit_SetControlTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlTransform, Space) == 0x000140, "Member 'FRigUnit_SetControlTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlTransform, CachedControlIndex) == 0x000148, "Member 'FRigUnit_SetControlTransform::CachedControlIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetControlVisibility
// 0x0040 (0x0110 - 0x00D0)
struct FRigUnit_SetControlVisibility final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Pattern;                                           // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedRigElement>              CachedControlIndices;                              // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetControlVisibility) == 0x000010, "Wrong alignment on FRigUnit_SetControlVisibility");
static_assert(sizeof(FRigUnit_SetControlVisibility) == 0x000110, "Wrong size on FRigUnit_SetControlVisibility");
static_assert(offsetof(FRigUnit_SetControlVisibility, Item) == 0x0000D0, "Member 'FRigUnit_SetControlVisibility::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVisibility, Pattern) == 0x0000E0, "Member 'FRigUnit_SetControlVisibility::Pattern' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVisibility, bVisible) == 0x0000F0, "Member 'FRigUnit_SetControlVisibility::bVisible' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetControlVisibility, CachedControlIndices) == 0x0000F8, "Member 'FRigUnit_SetControlVisibility::CachedControlIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetCurveValue
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_SetCurveValue final : public FRigUnitMutable
{
public:
	class FName                                   Curve;                                             // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedCurveIndex;                                  // 0x00E0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigUnit_SetCurveValue) == 0x000010, "Wrong alignment on FRigUnit_SetCurveValue");
static_assert(sizeof(FRigUnit_SetCurveValue) == 0x000100, "Wrong size on FRigUnit_SetCurveValue");
static_assert(offsetof(FRigUnit_SetCurveValue, Curve) == 0x0000D0, "Member 'FRigUnit_SetCurveValue::Curve' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetCurveValue, Value) == 0x0000D8, "Member 'FRigUnit_SetCurveValue::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetCurveValue, CachedCurveIndex) == 0x0000E0, "Member 'FRigUnit_SetCurveValue::CachedCurveIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetRelativeTransformForItem
// 0x00D0 (0x01A0 - 0x00D0)
struct FRigUnit_SetRelativeTransformForItem final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Parent;                                            // 0x00DC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParentInitial;                                    // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0154(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedChild;                                       // 0x0158(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedParent;                                      // 0x0178(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetRelativeTransformForItem) == 0x000010, "Wrong alignment on FRigUnit_SetRelativeTransformForItem");
static_assert(sizeof(FRigUnit_SetRelativeTransformForItem) == 0x0001A0, "Wrong size on FRigUnit_SetRelativeTransformForItem");
static_assert(offsetof(FRigUnit_SetRelativeTransformForItem, Child) == 0x0000D0, "Member 'FRigUnit_SetRelativeTransformForItem::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeTransformForItem, Parent) == 0x0000DC, "Member 'FRigUnit_SetRelativeTransformForItem::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeTransformForItem, bParentInitial) == 0x0000E8, "Member 'FRigUnit_SetRelativeTransformForItem::bParentInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeTransformForItem, RelativeTransform) == 0x0000F0, "Member 'FRigUnit_SetRelativeTransformForItem::RelativeTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeTransformForItem, Weight) == 0x000150, "Member 'FRigUnit_SetRelativeTransformForItem::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeTransformForItem, bPropagateToChildren) == 0x000154, "Member 'FRigUnit_SetRelativeTransformForItem::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeTransformForItem, CachedChild) == 0x000158, "Member 'FRigUnit_SetRelativeTransformForItem::CachedChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeTransformForItem, CachedParent) == 0x000178, "Member 'FRigUnit_SetRelativeTransformForItem::CachedParent' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetSpaceInitialTransform
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_SetSpaceInitialTransform final : public FRigUnitMutable
{
public:
	class FName                                   SpaceName;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0140(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedSpaceIndex;                                  // 0x01A8(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetSpaceInitialTransform) == 0x000010, "Wrong alignment on FRigUnit_SetSpaceInitialTransform");
static_assert(sizeof(FRigUnit_SetSpaceInitialTransform) == 0x0001D0, "Wrong size on FRigUnit_SetSpaceInitialTransform");
static_assert(offsetof(FRigUnit_SetSpaceInitialTransform, SpaceName) == 0x0000D0, "Member 'FRigUnit_SetSpaceInitialTransform::SpaceName' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetSpaceInitialTransform, Transform) == 0x0000E0, "Member 'FRigUnit_SetSpaceInitialTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetSpaceInitialTransform, Result) == 0x000140, "Member 'FRigUnit_SetSpaceInitialTransform::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetSpaceInitialTransform, Space) == 0x0001A0, "Member 'FRigUnit_SetSpaceInitialTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetSpaceInitialTransform, CachedSpaceIndex) == 0x0001A8, "Member 'FRigUnit_SetSpaceInitialTransform::CachedSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetSpaceTransform
// 0x00A0 (0x0170 - 0x00D0)
struct FRigUnit_SetSpaceTransform final : public FRigUnitMutable
{
public:
	class FName                                   Space;                                             // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         SpaceType;                                         // 0x0140(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedSpaceIndex;                                  // 0x0148(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetSpaceTransform) == 0x000010, "Wrong alignment on FRigUnit_SetSpaceTransform");
static_assert(sizeof(FRigUnit_SetSpaceTransform) == 0x000170, "Wrong size on FRigUnit_SetSpaceTransform");
static_assert(offsetof(FRigUnit_SetSpaceTransform, Space) == 0x0000D0, "Member 'FRigUnit_SetSpaceTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetSpaceTransform, Weight) == 0x0000D8, "Member 'FRigUnit_SetSpaceTransform::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetSpaceTransform, Transform) == 0x0000E0, "Member 'FRigUnit_SetSpaceTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetSpaceTransform, SpaceType) == 0x000140, "Member 'FRigUnit_SetSpaceTransform::SpaceType' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetSpaceTransform, CachedSpaceIndex) == 0x000148, "Member 'FRigUnit_SetSpaceTransform::CachedSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetTransform
// 0x00A0 (0x0170 - 0x00D0)
struct FRigUnit_SetTransform final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitial;                                          // 0x00DD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0144(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedIndex;                                       // 0x0148(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetTransform) == 0x000010, "Wrong alignment on FRigUnit_SetTransform");
static_assert(sizeof(FRigUnit_SetTransform) == 0x000170, "Wrong size on FRigUnit_SetTransform");
static_assert(offsetof(FRigUnit_SetTransform, Item) == 0x0000D0, "Member 'FRigUnit_SetTransform::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransform, Space) == 0x0000DC, "Member 'FRigUnit_SetTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransform, bInitial) == 0x0000DD, "Member 'FRigUnit_SetTransform::bInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransform, Transform) == 0x0000E0, "Member 'FRigUnit_SetTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransform, Weight) == 0x000140, "Member 'FRigUnit_SetTransform::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransform, bPropagateToChildren) == 0x000144, "Member 'FRigUnit_SetTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransform, CachedIndex) == 0x000148, "Member 'FRigUnit_SetTransform::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetTranslation
// 0x0050 (0x0120 - 0x00D0)
struct FRigUnit_SetTranslation final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Translation;                                       // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedIndex;                                       // 0x0100(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetTranslation) == 0x000010, "Wrong alignment on FRigUnit_SetTranslation");
static_assert(sizeof(FRigUnit_SetTranslation) == 0x000120, "Wrong size on FRigUnit_SetTranslation");
static_assert(offsetof(FRigUnit_SetTranslation, Item) == 0x0000D0, "Member 'FRigUnit_SetTranslation::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTranslation, Space) == 0x0000DC, "Member 'FRigUnit_SetTranslation::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTranslation, Translation) == 0x0000E0, "Member 'FRigUnit_SetTranslation::Translation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTranslation, Weight) == 0x0000F8, "Member 'FRigUnit_SetTranslation::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTranslation, bPropagateToChildren) == 0x0000FC, "Member 'FRigUnit_SetTranslation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTranslation, CachedIndex) == 0x000100, "Member 'FRigUnit_SetTranslation::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetRotation
// 0x0060 (0x0130 - 0x00D0)
struct FRigUnit_SetRotation final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x00E0(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0104(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedIndex;                                       // 0x0108(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetRotation) == 0x000010, "Wrong alignment on FRigUnit_SetRotation");
static_assert(sizeof(FRigUnit_SetRotation) == 0x000130, "Wrong size on FRigUnit_SetRotation");
static_assert(offsetof(FRigUnit_SetRotation, Item) == 0x0000D0, "Member 'FRigUnit_SetRotation::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRotation, Space) == 0x0000DC, "Member 'FRigUnit_SetRotation::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRotation, Rotation) == 0x0000E0, "Member 'FRigUnit_SetRotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRotation, Weight) == 0x000100, "Member 'FRigUnit_SetRotation::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRotation, bPropagateToChildren) == 0x000104, "Member 'FRigUnit_SetRotation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRotation, CachedIndex) == 0x000108, "Member 'FRigUnit_SetRotation::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetScale
// 0x0050 (0x0120 - 0x00D0)
struct FRigUnit_SetScale final : public FRigUnitMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedRigElement                      CachedIndex;                                       // 0x0100(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetScale) == 0x000010, "Wrong alignment on FRigUnit_SetScale");
static_assert(sizeof(FRigUnit_SetScale) == 0x000120, "Wrong size on FRigUnit_SetScale");
static_assert(offsetof(FRigUnit_SetScale, Item) == 0x0000D0, "Member 'FRigUnit_SetScale::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetScale, Space) == 0x0000DC, "Member 'FRigUnit_SetScale::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetScale, Scale) == 0x0000E0, "Member 'FRigUnit_SetScale::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetScale, Weight) == 0x0000F8, "Member 'FRigUnit_SetScale::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetScale, bPropagateToChildren) == 0x0000FC, "Member 'FRigUnit_SetScale::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetScale, CachedIndex) == 0x000100, "Member 'FRigUnit_SetScale::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetTransformArray
// 0x0040 (0x0110 - 0x00D0)
struct FRigUnit_SetTransformArray final : public FRigUnitMutable
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x00D0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitial;                                          // 0x00E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Transforms;                                        // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedRigElement>              CachedIndex;                                       // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetTransformArray) == 0x000010, "Wrong alignment on FRigUnit_SetTransformArray");
static_assert(sizeof(FRigUnit_SetTransformArray) == 0x000110, "Wrong size on FRigUnit_SetTransformArray");
static_assert(offsetof(FRigUnit_SetTransformArray, Items) == 0x0000D0, "Member 'FRigUnit_SetTransformArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformArray, Space) == 0x0000E0, "Member 'FRigUnit_SetTransformArray::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformArray, bInitial) == 0x0000E1, "Member 'FRigUnit_SetTransformArray::bInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformArray, Transforms) == 0x0000E8, "Member 'FRigUnit_SetTransformArray::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformArray, Weight) == 0x0000F8, "Member 'FRigUnit_SetTransformArray::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformArray, bPropagateToChildren) == 0x0000FC, "Member 'FRigUnit_SetTransformArray::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformArray, CachedIndex) == 0x000100, "Member 'FRigUnit_SetTransformArray::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetTransformItemArray
// 0x0040 (0x0110 - 0x00D0)
struct FRigUnit_SetTransformItemArray final : public FRigUnitMutable
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitial;                                          // 0x00E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Transforms;                                        // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00FC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCachedRigElement>              CachedIndex;                                       // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SetTransformItemArray) == 0x000010, "Wrong alignment on FRigUnit_SetTransformItemArray");
static_assert(sizeof(FRigUnit_SetTransformItemArray) == 0x000110, "Wrong size on FRigUnit_SetTransformItemArray");
static_assert(offsetof(FRigUnit_SetTransformItemArray, Items) == 0x0000D0, "Member 'FRigUnit_SetTransformItemArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformItemArray, Space) == 0x0000E0, "Member 'FRigUnit_SetTransformItemArray::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformItemArray, bInitial) == 0x0000E1, "Member 'FRigUnit_SetTransformItemArray::bInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformItemArray, Transforms) == 0x0000E8, "Member 'FRigUnit_SetTransformItemArray::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformItemArray, Weight) == 0x0000F8, "Member 'FRigUnit_SetTransformItemArray::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformItemArray, bPropagateToChildren) == 0x0000FC, "Member 'FRigUnit_SetTransformItemArray::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetTransformItemArray, CachedIndex) == 0x000100, "Member 'FRigUnit_SetTransformItemArray::CachedIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SlideChain_WorkData
// 0x0048 (0x0048 - 0x0000)
struct FRigUnit_SlideChain_WorkData final
{
public:
	float                                         ChainLength;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ItemSegments;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCachedRigElement>              CachedItems;                                       // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Transforms;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     BlendedTransforms;                                 // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SlideChain_WorkData) == 0x000008, "Wrong alignment on FRigUnit_SlideChain_WorkData");
static_assert(sizeof(FRigUnit_SlideChain_WorkData) == 0x000048, "Wrong size on FRigUnit_SlideChain_WorkData");
static_assert(offsetof(FRigUnit_SlideChain_WorkData, ChainLength) == 0x000000, "Member 'FRigUnit_SlideChain_WorkData::ChainLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChain_WorkData, ItemSegments) == 0x000008, "Member 'FRigUnit_SlideChain_WorkData::ItemSegments' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChain_WorkData, CachedItems) == 0x000018, "Member 'FRigUnit_SlideChain_WorkData::CachedItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChain_WorkData, Transforms) == 0x000028, "Member 'FRigUnit_SlideChain_WorkData::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChain_WorkData, BlendedTransforms) == 0x000038, "Member 'FRigUnit_SlideChain_WorkData::BlendedTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SlideChain
// 0x0060 (0x0130 - 0x00D0)
struct FRigUnit_SlideChain final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBone;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideAmount;                                       // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_SlideChain_WorkData           WorkData;                                          // 0x00E8(0x0048)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SlideChain) == 0x000010, "Wrong alignment on FRigUnit_SlideChain");
static_assert(sizeof(FRigUnit_SlideChain) == 0x000130, "Wrong size on FRigUnit_SlideChain");
static_assert(offsetof(FRigUnit_SlideChain, StartBone) == 0x0000D0, "Member 'FRigUnit_SlideChain::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChain, EndBone) == 0x0000D8, "Member 'FRigUnit_SlideChain::EndBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChain, SlideAmount) == 0x0000E0, "Member 'FRigUnit_SlideChain::SlideAmount' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChain, bPropagateToChildren) == 0x0000E4, "Member 'FRigUnit_SlideChain::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChain, WorkData) == 0x0000E8, "Member 'FRigUnit_SlideChain::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SlideChainPerItem
// 0x0060 (0x0130 - 0x00D0)
struct FRigUnit_SlideChainPerItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x00D0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideAmount;                                       // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_SlideChain_WorkData           WorkData;                                          // 0x00E8(0x0048)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SlideChainPerItem) == 0x000010, "Wrong alignment on FRigUnit_SlideChainPerItem");
static_assert(sizeof(FRigUnit_SlideChainPerItem) == 0x000130, "Wrong size on FRigUnit_SlideChainPerItem");
static_assert(offsetof(FRigUnit_SlideChainPerItem, Items) == 0x0000D0, "Member 'FRigUnit_SlideChainPerItem::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChainPerItem, SlideAmount) == 0x0000E0, "Member 'FRigUnit_SlideChainPerItem::SlideAmount' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChainPerItem, bPropagateToChildren) == 0x0000E4, "Member 'FRigUnit_SlideChainPerItem::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChainPerItem, WorkData) == 0x0000E8, "Member 'FRigUnit_SlideChainPerItem::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SlideChainItemArray
// 0x0060 (0x0130 - 0x00D0)
struct FRigUnit_SlideChainItemArray final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigElementKey>                 Items;                                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SlideAmount;                                       // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_SlideChain_WorkData           WorkData;                                          // 0x00E8(0x0048)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SlideChainItemArray) == 0x000010, "Wrong alignment on FRigUnit_SlideChainItemArray");
static_assert(sizeof(FRigUnit_SlideChainItemArray) == 0x000130, "Wrong size on FRigUnit_SlideChainItemArray");
static_assert(offsetof(FRigUnit_SlideChainItemArray, Items) == 0x0000D0, "Member 'FRigUnit_SlideChainItemArray::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChainItemArray, SlideAmount) == 0x0000E0, "Member 'FRigUnit_SlideChainItemArray::SlideAmount' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChainItemArray, bPropagateToChildren) == 0x0000E4, "Member 'FRigUnit_SlideChainItemArray::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SlideChainItemArray, WorkData) == 0x0000E8, "Member 'FRigUnit_SlideChainItemArray::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RegionScaleFactors
// 0x0010 (0x0010 - 0x0000)
struct FRegionScaleFactors final
{
public:
	float                                         PositiveWidth;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NegativeWidth;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositiveHeight;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NegativeHeight;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegionScaleFactors) == 0x000004, "Wrong alignment on FRegionScaleFactors");
static_assert(sizeof(FRegionScaleFactors) == 0x000010, "Wrong size on FRegionScaleFactors");
static_assert(offsetof(FRegionScaleFactors, PositiveWidth) == 0x000000, "Member 'FRegionScaleFactors::PositiveWidth' has a wrong offset!");
static_assert(offsetof(FRegionScaleFactors, NegativeWidth) == 0x000004, "Member 'FRegionScaleFactors::NegativeWidth' has a wrong offset!");
static_assert(offsetof(FRegionScaleFactors, PositiveHeight) == 0x000008, "Member 'FRegionScaleFactors::PositiveHeight' has a wrong offset!");
static_assert(offsetof(FRegionScaleFactors, NegativeHeight) == 0x00000C, "Member 'FRegionScaleFactors::NegativeHeight' has a wrong offset!");

// ScriptStruct ControlRig.SphericalRegion
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FSphericalRegion final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSphericalRegion) == 0x000004, "Wrong alignment on FSphericalRegion");
static_assert(sizeof(FSphericalRegion) == 0x000014, "Wrong size on FSphericalRegion");

// ScriptStruct ControlRig.SphericalPoseReaderDebugSettings
// 0x0010 (0x0010 - 0x0000)
struct FSphericalPoseReaderDebugSettings final
{
public:
	bool                                          bDrawDebug;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDraw2D;                                           // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawLocalAxes;                                    // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugScale;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugSegments;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugThickness;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSphericalPoseReaderDebugSettings) == 0x000004, "Wrong alignment on FSphericalPoseReaderDebugSettings");
static_assert(sizeof(FSphericalPoseReaderDebugSettings) == 0x000010, "Wrong size on FSphericalPoseReaderDebugSettings");
static_assert(offsetof(FSphericalPoseReaderDebugSettings, bDrawDebug) == 0x000000, "Member 'FSphericalPoseReaderDebugSettings::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FSphericalPoseReaderDebugSettings, bDraw2D) == 0x000001, "Member 'FSphericalPoseReaderDebugSettings::bDraw2D' has a wrong offset!");
static_assert(offsetof(FSphericalPoseReaderDebugSettings, bDrawLocalAxes) == 0x000002, "Member 'FSphericalPoseReaderDebugSettings::bDrawLocalAxes' has a wrong offset!");
static_assert(offsetof(FSphericalPoseReaderDebugSettings, DebugScale) == 0x000004, "Member 'FSphericalPoseReaderDebugSettings::DebugScale' has a wrong offset!");
static_assert(offsetof(FSphericalPoseReaderDebugSettings, DebugSegments) == 0x000008, "Member 'FSphericalPoseReaderDebugSettings::DebugSegments' has a wrong offset!");
static_assert(offsetof(FSphericalPoseReaderDebugSettings, DebugThickness) == 0x00000C, "Member 'FSphericalPoseReaderDebugSettings::DebugThickness' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SphericalPoseReader
// 0x00E0 (0x01B0 - 0x00D0)
struct FRigUnit_SphericalPoseReader final : public FRigUnit_HighlevelBaseMutable
{
public:
	float                                         OutputParam;                                       // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         DriverItem;                                        // 0x00D4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DriverAxis;                                        // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationOffset;                                    // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveRegionSize;                                  // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRegionScaleFactors                    ActiveRegionScaleFactors;                          // 0x0114(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         FalloffSize;                                       // 0x0124(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRegionScaleFactors                    FalloffRegionScaleFactors;                         // 0x0128(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          FlipWidthScaling;                                  // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FlipHeightScaling;                                 // 0x0139(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13A[0x2];                                      // 0x013A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         OptionalParentItem;                                // 0x013C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSphericalPoseReaderDebugSettings      Debug;                                             // 0x0148(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FSphericalRegion                       InnerRegion;                                       // 0x0158(0x0014)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FSphericalRegion                       OuterRegion;                                       // 0x016C(0x0014)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                DriverNormal;                                      // 0x0180(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Driver2D;                                          // 0x0198(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SphericalPoseReader) == 0x000010, "Wrong alignment on FRigUnit_SphericalPoseReader");
static_assert(sizeof(FRigUnit_SphericalPoseReader) == 0x0001B0, "Wrong size on FRigUnit_SphericalPoseReader");
static_assert(offsetof(FRigUnit_SphericalPoseReader, OutputParam) == 0x0000D0, "Member 'FRigUnit_SphericalPoseReader::OutputParam' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, DriverItem) == 0x0000D4, "Member 'FRigUnit_SphericalPoseReader::DriverItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, DriverAxis) == 0x0000E0, "Member 'FRigUnit_SphericalPoseReader::DriverAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, RotationOffset) == 0x0000F8, "Member 'FRigUnit_SphericalPoseReader::RotationOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, ActiveRegionSize) == 0x000110, "Member 'FRigUnit_SphericalPoseReader::ActiveRegionSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, ActiveRegionScaleFactors) == 0x000114, "Member 'FRigUnit_SphericalPoseReader::ActiveRegionScaleFactors' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, FalloffSize) == 0x000124, "Member 'FRigUnit_SphericalPoseReader::FalloffSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, FalloffRegionScaleFactors) == 0x000128, "Member 'FRigUnit_SphericalPoseReader::FalloffRegionScaleFactors' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, FlipWidthScaling) == 0x000138, "Member 'FRigUnit_SphericalPoseReader::FlipWidthScaling' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, FlipHeightScaling) == 0x000139, "Member 'FRigUnit_SphericalPoseReader::FlipHeightScaling' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, OptionalParentItem) == 0x00013C, "Member 'FRigUnit_SphericalPoseReader::OptionalParentItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, Debug) == 0x000148, "Member 'FRigUnit_SphericalPoseReader::Debug' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, InnerRegion) == 0x000158, "Member 'FRigUnit_SphericalPoseReader::InnerRegion' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, OuterRegion) == 0x00016C, "Member 'FRigUnit_SphericalPoseReader::OuterRegion' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, DriverNormal) == 0x000180, "Member 'FRigUnit_SphericalPoseReader::DriverNormal' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphericalPoseReader, Driver2D) == 0x000198, "Member 'FRigUnit_SphericalPoseReader::Driver2D' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringIK_DebugSettings
// 0x0080 (0x0080 - 0x0000)
struct FRigUnit_SpringIK_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0020(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpringIK_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_SpringIK_DebugSettings");
static_assert(sizeof(FRigUnit_SpringIK_DebugSettings) == 0x000080, "Wrong size on FRigUnit_SpringIK_DebugSettings");
static_assert(offsetof(FRigUnit_SpringIK_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_SpringIK_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_SpringIK_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_DebugSettings, Color) == 0x000008, "Member 'FRigUnit_SpringIK_DebugSettings::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_DebugSettings, WorldOffset) == 0x000020, "Member 'FRigUnit_SpringIK_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringIK_WorkData
// 0x00B8 (0x00B8 - 0x0000)
struct FRigUnit_SpringIK_WorkData final
{
public:
	TArray<struct FCachedRigElement>              CachedBones;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedPoleVector;                                  // 0x0010(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Transforms;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCRSimPointContainer                   Simulation;                                        // 0x0040(0x0078)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpringIK_WorkData) == 0x000008, "Wrong alignment on FRigUnit_SpringIK_WorkData");
static_assert(sizeof(FRigUnit_SpringIK_WorkData) == 0x0000B8, "Wrong size on FRigUnit_SpringIK_WorkData");
static_assert(offsetof(FRigUnit_SpringIK_WorkData, CachedBones) == 0x000000, "Member 'FRigUnit_SpringIK_WorkData::CachedBones' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_WorkData, CachedPoleVector) == 0x000010, "Member 'FRigUnit_SpringIK_WorkData::CachedPoleVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_WorkData, Transforms) == 0x000030, "Member 'FRigUnit_SpringIK_WorkData::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_WorkData, Simulation) == 0x000040, "Member 'FRigUnit_SpringIK_WorkData::Simulation' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringIK
// 0x01D0 (0x02A0 - 0x00D0)
struct FRigUnit_SpringIK final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBone;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HierarchyStrength;                                 // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectorStrength;                                  // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectorRatio;                                     // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootStrength;                                      // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootRatio;                                         // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleVector;                                        // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipPolePlane;                                    // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigVectorKind                         PoleVectorKind;                                    // 0x0111(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x2];                                      // 0x0112(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PoleVectorSpace;                                   // 0x0114(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PrimaryAxis;                                       // 0x0120(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0138(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLiveSimulation;                                   // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Iterations;                                        // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitLocalPosition;                               // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0159(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_SpringIK_DebugSettings        DebugSettings;                                     // 0x0160(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_SpringIK_WorkData             WorkData;                                          // 0x01E0(0x00B8)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SpringIK) == 0x000010, "Wrong alignment on FRigUnit_SpringIK");
static_assert(sizeof(FRigUnit_SpringIK) == 0x0002A0, "Wrong size on FRigUnit_SpringIK");
static_assert(offsetof(FRigUnit_SpringIK, StartBone) == 0x0000D0, "Member 'FRigUnit_SpringIK::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, EndBone) == 0x0000D8, "Member 'FRigUnit_SpringIK::EndBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, HierarchyStrength) == 0x0000E0, "Member 'FRigUnit_SpringIK::HierarchyStrength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, EffectorStrength) == 0x0000E4, "Member 'FRigUnit_SpringIK::EffectorStrength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, EffectorRatio) == 0x0000E8, "Member 'FRigUnit_SpringIK::EffectorRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, RootStrength) == 0x0000EC, "Member 'FRigUnit_SpringIK::RootStrength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, RootRatio) == 0x0000F0, "Member 'FRigUnit_SpringIK::RootRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, Damping) == 0x0000F4, "Member 'FRigUnit_SpringIK::Damping' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PoleVector) == 0x0000F8, "Member 'FRigUnit_SpringIK::PoleVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, bFlipPolePlane) == 0x000110, "Member 'FRigUnit_SpringIK::bFlipPolePlane' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PoleVectorKind) == 0x000111, "Member 'FRigUnit_SpringIK::PoleVectorKind' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PoleVectorSpace) == 0x000114, "Member 'FRigUnit_SpringIK::PoleVectorSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PrimaryAxis) == 0x000120, "Member 'FRigUnit_SpringIK::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, SecondaryAxis) == 0x000138, "Member 'FRigUnit_SpringIK::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, bLiveSimulation) == 0x000150, "Member 'FRigUnit_SpringIK::bLiveSimulation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, Iterations) == 0x000154, "Member 'FRigUnit_SpringIK::Iterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, bLimitLocalPosition) == 0x000158, "Member 'FRigUnit_SpringIK::bLimitLocalPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, bPropagateToChildren) == 0x000159, "Member 'FRigUnit_SpringIK::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, DebugSettings) == 0x000160, "Member 'FRigUnit_SpringIK::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, WorkData) == 0x0001E0, "Member 'FRigUnit_SpringIK::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringInterp
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_SpringInterp final : public FRigUnit_SimBase
{
public:
	float                                         Current;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Target;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamping;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      SpringState;                                       // 0x0020(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SpringInterp) == 0x000008, "Wrong alignment on FRigUnit_SpringInterp");
static_assert(sizeof(FRigUnit_SpringInterp) == 0x000030, "Wrong size on FRigUnit_SpringInterp");
static_assert(offsetof(FRigUnit_SpringInterp, Current) == 0x000008, "Member 'FRigUnit_SpringInterp::Current' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterp, Target) == 0x00000C, "Member 'FRigUnit_SpringInterp::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterp, Stiffness) == 0x000010, "Member 'FRigUnit_SpringInterp::Stiffness' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterp, CriticalDamping) == 0x000014, "Member 'FRigUnit_SpringInterp::CriticalDamping' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterp, Mass) == 0x000018, "Member 'FRigUnit_SpringInterp::Mass' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterp, Result) == 0x00001C, "Member 'FRigUnit_SpringInterp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterp, SpringState) == 0x000020, "Member 'FRigUnit_SpringInterp::SpringState' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringInterpVector
// 0x0090 (0x0098 - 0x0008)
struct FRigUnit_SpringInterpVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Current;                                           // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamping;                                   // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorSpringState                     SpringState;                                       // 0x0060(0x0038)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpringInterpVector) == 0x000008, "Wrong alignment on FRigUnit_SpringInterpVector");
static_assert(sizeof(FRigUnit_SpringInterpVector) == 0x000098, "Wrong size on FRigUnit_SpringInterpVector");
static_assert(offsetof(FRigUnit_SpringInterpVector, Current) == 0x000008, "Member 'FRigUnit_SpringInterpVector::Current' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVector, Target) == 0x000020, "Member 'FRigUnit_SpringInterpVector::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVector, Stiffness) == 0x000038, "Member 'FRigUnit_SpringInterpVector::Stiffness' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVector, CriticalDamping) == 0x00003C, "Member 'FRigUnit_SpringInterpVector::CriticalDamping' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVector, Mass) == 0x000040, "Member 'FRigUnit_SpringInterpVector::Mass' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVector, Result) == 0x000048, "Member 'FRigUnit_SpringInterpVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVector, SpringState) == 0x000060, "Member 'FRigUnit_SpringInterpVector::SpringState' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringInterpV2
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_SpringInterpV2 final : public FRigUnit_SimBase
{
public:
	float                                         Target;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamping;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurrentInput;                                  // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Current;                                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetVelocityAmount;                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializeFromTarget;                             // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Velocity;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimulatedResult;                                   // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      SpringState;                                       // 0x0034(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpringInterpV2) == 0x000008, "Wrong alignment on FRigUnit_SpringInterpV2");
static_assert(sizeof(FRigUnit_SpringInterpV2) == 0x000040, "Wrong size on FRigUnit_SpringInterpV2");
static_assert(offsetof(FRigUnit_SpringInterpV2, Target) == 0x000008, "Member 'FRigUnit_SpringInterpV2::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, Strength) == 0x00000C, "Member 'FRigUnit_SpringInterpV2::Strength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, CriticalDamping) == 0x000010, "Member 'FRigUnit_SpringInterpV2::CriticalDamping' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, Force) == 0x000014, "Member 'FRigUnit_SpringInterpV2::Force' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, bUseCurrentInput) == 0x000018, "Member 'FRigUnit_SpringInterpV2::bUseCurrentInput' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, Current) == 0x00001C, "Member 'FRigUnit_SpringInterpV2::Current' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, TargetVelocityAmount) == 0x000020, "Member 'FRigUnit_SpringInterpV2::TargetVelocityAmount' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, bInitializeFromTarget) == 0x000024, "Member 'FRigUnit_SpringInterpV2::bInitializeFromTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, Result) == 0x000028, "Member 'FRigUnit_SpringInterpV2::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, Velocity) == 0x00002C, "Member 'FRigUnit_SpringInterpV2::Velocity' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, SimulatedResult) == 0x000030, "Member 'FRigUnit_SpringInterpV2::SimulatedResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpV2, SpringState) == 0x000034, "Member 'FRigUnit_SpringInterpV2::SpringState' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringInterpVectorV2
// 0x00E0 (0x00E8 - 0x0008)
struct FRigUnit_SpringInterpVectorV2 final : public FRigUnit_SimBase
{
public:
	struct FVector                                Target;                                            // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamping;                                   // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Force;                                             // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurrentInput;                                  // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Current;                                           // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetVelocityAmount;                              // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializeFromTarget;                             // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0080(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SimulatedResult;                                   // 0x0098(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorSpringState                     SpringState;                                       // 0x00B0(0x0038)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpringInterpVectorV2) == 0x000008, "Wrong alignment on FRigUnit_SpringInterpVectorV2");
static_assert(sizeof(FRigUnit_SpringInterpVectorV2) == 0x0000E8, "Wrong size on FRigUnit_SpringInterpVectorV2");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, Target) == 0x000008, "Member 'FRigUnit_SpringInterpVectorV2::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, Strength) == 0x000020, "Member 'FRigUnit_SpringInterpVectorV2::Strength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, CriticalDamping) == 0x000024, "Member 'FRigUnit_SpringInterpVectorV2::CriticalDamping' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, Force) == 0x000028, "Member 'FRigUnit_SpringInterpVectorV2::Force' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, bUseCurrentInput) == 0x000040, "Member 'FRigUnit_SpringInterpVectorV2::bUseCurrentInput' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, Current) == 0x000048, "Member 'FRigUnit_SpringInterpVectorV2::Current' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, TargetVelocityAmount) == 0x000060, "Member 'FRigUnit_SpringInterpVectorV2::TargetVelocityAmount' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, bInitializeFromTarget) == 0x000064, "Member 'FRigUnit_SpringInterpVectorV2::bInitializeFromTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, Result) == 0x000068, "Member 'FRigUnit_SpringInterpVectorV2::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, Velocity) == 0x000080, "Member 'FRigUnit_SpringInterpVectorV2::Velocity' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, SimulatedResult) == 0x000098, "Member 'FRigUnit_SpringInterpVectorV2::SimulatedResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpVectorV2, SpringState) == 0x0000B0, "Member 'FRigUnit_SpringInterpVectorV2::SpringState' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringInterpQuaternionV2
// 0x0128 (0x0130 - 0x0008)
struct FRigUnit_SpringInterpQuaternionV2 final : public FRigUnit_SimBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Target;                                            // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamping;                                   // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Torque;                                            // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurrentInput;                                  // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Current;                                           // 0x0060(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TargetVelocityAmount;                              // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitializeFromTarget;                             // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0xB];                                       // 0x0085(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0090(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x00B0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  SimulatedResult;                                   // 0x00D0(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuaternionSpringState                 SpringState;                                       // 0x00F0(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpringInterpQuaternionV2) == 0x000010, "Wrong alignment on FRigUnit_SpringInterpQuaternionV2");
static_assert(sizeof(FRigUnit_SpringInterpQuaternionV2) == 0x000130, "Wrong size on FRigUnit_SpringInterpQuaternionV2");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, Target) == 0x000010, "Member 'FRigUnit_SpringInterpQuaternionV2::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, Strength) == 0x000030, "Member 'FRigUnit_SpringInterpQuaternionV2::Strength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, CriticalDamping) == 0x000034, "Member 'FRigUnit_SpringInterpQuaternionV2::CriticalDamping' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, Torque) == 0x000038, "Member 'FRigUnit_SpringInterpQuaternionV2::Torque' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, bUseCurrentInput) == 0x000050, "Member 'FRigUnit_SpringInterpQuaternionV2::bUseCurrentInput' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, Current) == 0x000060, "Member 'FRigUnit_SpringInterpQuaternionV2::Current' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, TargetVelocityAmount) == 0x000080, "Member 'FRigUnit_SpringInterpQuaternionV2::TargetVelocityAmount' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, bInitializeFromTarget) == 0x000084, "Member 'FRigUnit_SpringInterpQuaternionV2::bInitializeFromTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, Result) == 0x000090, "Member 'FRigUnit_SpringInterpQuaternionV2::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, AngularVelocity) == 0x0000B0, "Member 'FRigUnit_SpringInterpQuaternionV2::AngularVelocity' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, SimulatedResult) == 0x0000D0, "Member 'FRigUnit_SpringInterpQuaternionV2::SimulatedResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringInterpQuaternionV2, SpringState) == 0x0000F0, "Member 'FRigUnit_SpringInterpQuaternionV2::SpringState' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FramesToSeconds
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_FramesToSeconds final : public FRigUnit_AnimBase
{
public:
	float                                         Frames;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Seconds;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FramesToSeconds) == 0x000008, "Wrong alignment on FRigUnit_FramesToSeconds");
static_assert(sizeof(FRigUnit_FramesToSeconds) == 0x000010, "Wrong size on FRigUnit_FramesToSeconds");
static_assert(offsetof(FRigUnit_FramesToSeconds, Frames) == 0x000008, "Member 'FRigUnit_FramesToSeconds::Frames' has a wrong offset!");
static_assert(offsetof(FRigUnit_FramesToSeconds, Seconds) == 0x00000C, "Member 'FRigUnit_FramesToSeconds::Seconds' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SecondsToFrames
// 0x0008 (0x0010 - 0x0008)
struct FRigUnit_SecondsToFrames final : public FRigUnit_AnimBase
{
public:
	float                                         Seconds;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frames;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SecondsToFrames) == 0x000008, "Wrong alignment on FRigUnit_SecondsToFrames");
static_assert(sizeof(FRigUnit_SecondsToFrames) == 0x000010, "Wrong size on FRigUnit_SecondsToFrames");
static_assert(offsetof(FRigUnit_SecondsToFrames, Seconds) == 0x000008, "Member 'FRigUnit_SecondsToFrames::Seconds' has a wrong offset!");
static_assert(offsetof(FRigUnit_SecondsToFrames, Frames) == 0x00000C, "Member 'FRigUnit_SecondsToFrames::Frames' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Timeline
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_Timeline final : public FRigUnit_SimBase
{
public:
	float                                         Speed;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedValue;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Timeline) == 0x000008, "Wrong alignment on FRigUnit_Timeline");
static_assert(sizeof(FRigUnit_Timeline) == 0x000018, "Wrong size on FRigUnit_Timeline");
static_assert(offsetof(FRigUnit_Timeline, Speed) == 0x000008, "Member 'FRigUnit_Timeline::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_Timeline, Time) == 0x00000C, "Member 'FRigUnit_Timeline::Time' has a wrong offset!");
static_assert(offsetof(FRigUnit_Timeline, AccumulatedValue) == 0x000010, "Member 'FRigUnit_Timeline::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TimeOffsetFloat
// 0x0040 (0x0048 - 0x0008)
struct FRigUnit_TimeOffsetFloat final : public FRigUnit_SimBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsAgo;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRange;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Buffer;                                            // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 DeltaTimes;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBound;                                        // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TimeOffsetFloat) == 0x000008, "Wrong alignment on FRigUnit_TimeOffsetFloat");
static_assert(sizeof(FRigUnit_TimeOffsetFloat) == 0x000048, "Wrong size on FRigUnit_TimeOffsetFloat");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, Value) == 0x000008, "Member 'FRigUnit_TimeOffsetFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, SecondsAgo) == 0x00000C, "Member 'FRigUnit_TimeOffsetFloat::SecondsAgo' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, BufferSize) == 0x000010, "Member 'FRigUnit_TimeOffsetFloat::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, TimeRange) == 0x000014, "Member 'FRigUnit_TimeOffsetFloat::TimeRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, Result) == 0x000018, "Member 'FRigUnit_TimeOffsetFloat::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, Buffer) == 0x000020, "Member 'FRigUnit_TimeOffsetFloat::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, DeltaTimes) == 0x000030, "Member 'FRigUnit_TimeOffsetFloat::DeltaTimes' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, LastInsertIndex) == 0x000040, "Member 'FRigUnit_TimeOffsetFloat::LastInsertIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, UpperBound) == 0x000044, "Member 'FRigUnit_TimeOffsetFloat::UpperBound' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TimeOffsetVector
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_TimeOffsetVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsAgo;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRange;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Buffer;                                            // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 DeltaTimes;                                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBound;                                        // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TimeOffsetVector) == 0x000008, "Wrong alignment on FRigUnit_TimeOffsetVector");
static_assert(sizeof(FRigUnit_TimeOffsetVector) == 0x000070, "Wrong size on FRigUnit_TimeOffsetVector");
static_assert(offsetof(FRigUnit_TimeOffsetVector, Value) == 0x000008, "Member 'FRigUnit_TimeOffsetVector::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, SecondsAgo) == 0x000020, "Member 'FRigUnit_TimeOffsetVector::SecondsAgo' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, BufferSize) == 0x000024, "Member 'FRigUnit_TimeOffsetVector::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, TimeRange) == 0x000028, "Member 'FRigUnit_TimeOffsetVector::TimeRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, Result) == 0x000030, "Member 'FRigUnit_TimeOffsetVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, Buffer) == 0x000048, "Member 'FRigUnit_TimeOffsetVector::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, DeltaTimes) == 0x000058, "Member 'FRigUnit_TimeOffsetVector::DeltaTimes' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, LastInsertIndex) == 0x000068, "Member 'FRigUnit_TimeOffsetVector::LastInsertIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, UpperBound) == 0x00006C, "Member 'FRigUnit_TimeOffsetVector::UpperBound' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TimeOffsetTransform
// 0x0108 (0x0110 - 0x0008)
struct FRigUnit_TimeOffsetTransform final : public FRigUnit_SimBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SecondsAgo;                                        // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRange;                                         // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0080(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Buffer;                                            // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 DeltaTimes;                                        // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpperBound;                                        // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TimeOffsetTransform) == 0x000010, "Wrong alignment on FRigUnit_TimeOffsetTransform");
static_assert(sizeof(FRigUnit_TimeOffsetTransform) == 0x000110, "Wrong size on FRigUnit_TimeOffsetTransform");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, Value) == 0x000010, "Member 'FRigUnit_TimeOffsetTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, SecondsAgo) == 0x000070, "Member 'FRigUnit_TimeOffsetTransform::SecondsAgo' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, BufferSize) == 0x000074, "Member 'FRigUnit_TimeOffsetTransform::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, TimeRange) == 0x000078, "Member 'FRigUnit_TimeOffsetTransform::TimeRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, Result) == 0x000080, "Member 'FRigUnit_TimeOffsetTransform::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, Buffer) == 0x0000E0, "Member 'FRigUnit_TimeOffsetTransform::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, DeltaTimes) == 0x0000F0, "Member 'FRigUnit_TimeOffsetTransform::DeltaTimes' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, LastInsertIndex) == 0x000100, "Member 'FRigUnit_TimeOffsetTransform::LastInsertIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, UpperBound) == 0x000104, "Member 'FRigUnit_TimeOffsetTransform::UpperBound' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryTransformOp
// 0x0128 (0x0130 - 0x0008)
struct FRigUnit_BinaryTransformOp : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Argument0;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Argument1;                                         // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x00D0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BinaryTransformOp) == 0x000010, "Wrong alignment on FRigUnit_BinaryTransformOp");
static_assert(sizeof(FRigUnit_BinaryTransformOp) == 0x000130, "Wrong size on FRigUnit_BinaryTransformOp");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Argument0) == 0x000010, "Member 'FRigUnit_BinaryTransformOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Argument1) == 0x000070, "Member 'FRigUnit_BinaryTransformOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Result) == 0x0000D0, "Member 'FRigUnit_BinaryTransformOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MultiplyTransform
// 0x0000 (0x0130 - 0x0130)
struct FRigUnit_MultiplyTransform final : public FRigUnit_BinaryTransformOp
{
};
static_assert(alignof(FRigUnit_MultiplyTransform) == 0x000010, "Wrong alignment on FRigUnit_MultiplyTransform");
static_assert(sizeof(FRigUnit_MultiplyTransform) == 0x000130, "Wrong size on FRigUnit_MultiplyTransform");

// ScriptStruct ControlRig.RigUnit_GetRelativeTransform
// 0x0000 (0x0130 - 0x0130)
struct FRigUnit_GetRelativeTransform final : public FRigUnit_BinaryTransformOp
{
};
static_assert(alignof(FRigUnit_GetRelativeTransform) == 0x000010, "Wrong alignment on FRigUnit_GetRelativeTransform");
static_assert(sizeof(FRigUnit_GetRelativeTransform) == 0x000130, "Wrong size on FRigUnit_GetRelativeTransform");

// ScriptStruct ControlRig.ConstraintTarget
// 0x0070 (0x0070 - 0x0000)
struct FConstraintTarget final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x0065(0x0009)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConstraintTarget) == 0x000010, "Wrong alignment on FConstraintTarget");
static_assert(sizeof(FConstraintTarget) == 0x000070, "Wrong size on FConstraintTarget");
static_assert(offsetof(FConstraintTarget, Transform) == 0x000000, "Member 'FConstraintTarget::Transform' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, Weight) == 0x000060, "Member 'FConstraintTarget::Weight' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, bMaintainOffset) == 0x000064, "Member 'FConstraintTarget::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, Filter) == 0x000065, "Member 'FConstraintTarget::Filter' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TransformConstraint_WorkData
// 0x0060 (0x0060 - 0x0000)
struct FRigUnit_TransformConstraint_WorkData final
{
public:
	TArray<struct FConstraintData>                ConstraintData;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            ConstraintDataToTargets;                           // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TransformConstraint_WorkData) == 0x000008, "Wrong alignment on FRigUnit_TransformConstraint_WorkData");
static_assert(sizeof(FRigUnit_TransformConstraint_WorkData) == 0x000060, "Wrong size on FRigUnit_TransformConstraint_WorkData");
static_assert(offsetof(FRigUnit_TransformConstraint_WorkData, ConstraintData) == 0x000000, "Member 'FRigUnit_TransformConstraint_WorkData::ConstraintData' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint_WorkData, ConstraintDataToTargets) == 0x000010, "Member 'FRigUnit_TransformConstraint_WorkData::ConstraintDataToTargets' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TransformConstraint
// 0x00F0 (0x01C0 - 0x00D0)
struct FRigUnit_TransformConstraint final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   bone;                                              // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           BaseTransformSpace;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x00E0(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseBone;                                          // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConstraintTarget>              Targets;                                           // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseInitialTransforms;                             // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_TransformConstraint_WorkData  WorkData;                                          // 0x0160(0x0060)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRigUnit_TransformConstraint) == 0x000010, "Wrong alignment on FRigUnit_TransformConstraint");
static_assert(sizeof(FRigUnit_TransformConstraint) == 0x0001C0, "Wrong size on FRigUnit_TransformConstraint");
static_assert(offsetof(FRigUnit_TransformConstraint, bone) == 0x0000D0, "Member 'FRigUnit_TransformConstraint::bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseTransformSpace) == 0x0000D8, "Member 'FRigUnit_TransformConstraint::BaseTransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseTransform) == 0x0000E0, "Member 'FRigUnit_TransformConstraint::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseBone) == 0x000140, "Member 'FRigUnit_TransformConstraint::BaseBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, Targets) == 0x000148, "Member 'FRigUnit_TransformConstraint::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, bUseInitialTransforms) == 0x000158, "Member 'FRigUnit_TransformConstraint::bUseInitialTransforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, WorkData) == 0x000160, "Member 'FRigUnit_TransformConstraint::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TransformConstraintPerItem
// 0x0100 (0x01D0 - 0x00D0)
struct FRigUnit_TransformConstraintPerItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x00D0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           BaseTransformSpace;                                // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x00E0(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigElementKey                         BaseItem;                                          // 0x0140(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConstraintTarget>              Targets;                                           // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseInitialTransforms;                             // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_TransformConstraint_WorkData  WorkData;                                          // 0x0168(0x0060)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TransformConstraintPerItem) == 0x000010, "Wrong alignment on FRigUnit_TransformConstraintPerItem");
static_assert(sizeof(FRigUnit_TransformConstraintPerItem) == 0x0001D0, "Wrong size on FRigUnit_TransformConstraintPerItem");
static_assert(offsetof(FRigUnit_TransformConstraintPerItem, Item) == 0x0000D0, "Member 'FRigUnit_TransformConstraintPerItem::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraintPerItem, BaseTransformSpace) == 0x0000DC, "Member 'FRigUnit_TransformConstraintPerItem::BaseTransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraintPerItem, BaseTransform) == 0x0000E0, "Member 'FRigUnit_TransformConstraintPerItem::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraintPerItem, BaseItem) == 0x000140, "Member 'FRigUnit_TransformConstraintPerItem::BaseItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraintPerItem, Targets) == 0x000150, "Member 'FRigUnit_TransformConstraintPerItem::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraintPerItem, bUseInitialTransforms) == 0x000160, "Member 'FRigUnit_TransformConstraintPerItem::bUseInitialTransforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraintPerItem, WorkData) == 0x000168, "Member 'FRigUnit_TransformConstraintPerItem::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.ConstraintParent
// 0x0010 (0x0010 - 0x0000)
struct FConstraintParent final
{
public:
	struct FRigElementKey                         Item;                                              // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConstraintParent) == 0x000004, "Wrong alignment on FConstraintParent");
static_assert(sizeof(FConstraintParent) == 0x000010, "Wrong size on FConstraintParent");
static_assert(offsetof(FConstraintParent, Item) == 0x000000, "Member 'FConstraintParent::Item' has a wrong offset!");
static_assert(offsetof(FConstraintParent, Weight) == 0x00000C, "Member 'FConstraintParent::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ParentConstraint_AdvancedSettings
// 0x0002 (0x0002 - 0x0000)
struct FRigUnit_ParentConstraint_AdvancedSettings final
{
public:
	EConstraintInterpType                         InterpolationType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEulerRotationOrder                           RotationOrderForFilter;                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ParentConstraint_AdvancedSettings) == 0x000001, "Wrong alignment on FRigUnit_ParentConstraint_AdvancedSettings");
static_assert(sizeof(FRigUnit_ParentConstraint_AdvancedSettings) == 0x000002, "Wrong size on FRigUnit_ParentConstraint_AdvancedSettings");
static_assert(offsetof(FRigUnit_ParentConstraint_AdvancedSettings, InterpolationType) == 0x000000, "Member 'FRigUnit_ParentConstraint_AdvancedSettings::InterpolationType' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentConstraint_AdvancedSettings, RotationOrderForFilter) == 0x000001, "Member 'FRigUnit_ParentConstraint_AdvancedSettings::RotationOrderForFilter' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ParentConstraint
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_ParentConstraint final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x00DD(0x0009)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FConstraintParent>              Parents;                                           // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigUnit_ParentConstraint_AdvancedSettings AdvancedSettings;                                  // 0x00F8(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ParentConstraint) == 0x000010, "Wrong alignment on FRigUnit_ParentConstraint");
static_assert(sizeof(FRigUnit_ParentConstraint) == 0x000100, "Wrong size on FRigUnit_ParentConstraint");
static_assert(offsetof(FRigUnit_ParentConstraint, Child) == 0x0000D0, "Member 'FRigUnit_ParentConstraint::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentConstraint, bMaintainOffset) == 0x0000DC, "Member 'FRigUnit_ParentConstraint::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentConstraint, Filter) == 0x0000DD, "Member 'FRigUnit_ParentConstraint::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentConstraint, Parents) == 0x0000E8, "Member 'FRigUnit_ParentConstraint::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentConstraint, AdvancedSettings) == 0x0000F8, "Member 'FRigUnit_ParentConstraint::AdvancedSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_ParentConstraint, Weight) == 0x0000FC, "Member 'FRigUnit_ParentConstraint::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PositionConstraint
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_PositionConstraint final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilterOptionPerAxis                   Filter;                                            // 0x00DD(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FConstraintParent>              Parents;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PositionConstraint) == 0x000010, "Wrong alignment on FRigUnit_PositionConstraint");
static_assert(sizeof(FRigUnit_PositionConstraint) == 0x000100, "Wrong size on FRigUnit_PositionConstraint");
static_assert(offsetof(FRigUnit_PositionConstraint, Child) == 0x0000D0, "Member 'FRigUnit_PositionConstraint::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_PositionConstraint, bMaintainOffset) == 0x0000DC, "Member 'FRigUnit_PositionConstraint::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_PositionConstraint, Filter) == 0x0000DD, "Member 'FRigUnit_PositionConstraint::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_PositionConstraint, Parents) == 0x0000E0, "Member 'FRigUnit_PositionConstraint::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_PositionConstraint, Weight) == 0x0000F0, "Member 'FRigUnit_PositionConstraint::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PositionConstraintLocalSpaceOffset
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_PositionConstraintLocalSpaceOffset final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilterOptionPerAxis                   Filter;                                            // 0x00DD(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FConstraintParent>              Parents;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PositionConstraintLocalSpaceOffset) == 0x000010, "Wrong alignment on FRigUnit_PositionConstraintLocalSpaceOffset");
static_assert(sizeof(FRigUnit_PositionConstraintLocalSpaceOffset) == 0x000100, "Wrong size on FRigUnit_PositionConstraintLocalSpaceOffset");
static_assert(offsetof(FRigUnit_PositionConstraintLocalSpaceOffset, Child) == 0x0000D0, "Member 'FRigUnit_PositionConstraintLocalSpaceOffset::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_PositionConstraintLocalSpaceOffset, bMaintainOffset) == 0x0000DC, "Member 'FRigUnit_PositionConstraintLocalSpaceOffset::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_PositionConstraintLocalSpaceOffset, Filter) == 0x0000DD, "Member 'FRigUnit_PositionConstraintLocalSpaceOffset::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_PositionConstraintLocalSpaceOffset, Parents) == 0x0000E0, "Member 'FRigUnit_PositionConstraintLocalSpaceOffset::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_PositionConstraintLocalSpaceOffset, Weight) == 0x0000F0, "Member 'FRigUnit_PositionConstraintLocalSpaceOffset::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_RotationConstraint_AdvancedSettings
// 0x0002 (0x0002 - 0x0000)
struct FRigUnit_RotationConstraint_AdvancedSettings final
{
public:
	EConstraintInterpType                         InterpolationType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEulerRotationOrder                           RotationOrderForFilter;                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_RotationConstraint_AdvancedSettings) == 0x000001, "Wrong alignment on FRigUnit_RotationConstraint_AdvancedSettings");
static_assert(sizeof(FRigUnit_RotationConstraint_AdvancedSettings) == 0x000002, "Wrong size on FRigUnit_RotationConstraint_AdvancedSettings");
static_assert(offsetof(FRigUnit_RotationConstraint_AdvancedSettings, InterpolationType) == 0x000000, "Member 'FRigUnit_RotationConstraint_AdvancedSettings::InterpolationType' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraint_AdvancedSettings, RotationOrderForFilter) == 0x000001, "Member 'FRigUnit_RotationConstraint_AdvancedSettings::RotationOrderForFilter' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_RotationConstraint
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_RotationConstraint final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilterOptionPerAxis                   Filter;                                            // 0x00DD(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FConstraintParent>              Parents;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigUnit_RotationConstraint_AdvancedSettings AdvancedSettings;                                  // 0x00F0(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_RotationConstraint) == 0x000010, "Wrong alignment on FRigUnit_RotationConstraint");
static_assert(sizeof(FRigUnit_RotationConstraint) == 0x000100, "Wrong size on FRigUnit_RotationConstraint");
static_assert(offsetof(FRigUnit_RotationConstraint, Child) == 0x0000D0, "Member 'FRigUnit_RotationConstraint::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraint, bMaintainOffset) == 0x0000DC, "Member 'FRigUnit_RotationConstraint::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraint, Filter) == 0x0000DD, "Member 'FRigUnit_RotationConstraint::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraint, Parents) == 0x0000E0, "Member 'FRigUnit_RotationConstraint::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraint, AdvancedSettings) == 0x0000F0, "Member 'FRigUnit_RotationConstraint::AdvancedSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraint, Weight) == 0x0000F4, "Member 'FRigUnit_RotationConstraint::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_RotationConstraintLocalSpaceOffset
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_RotationConstraintLocalSpaceOffset final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilterOptionPerAxis                   Filter;                                            // 0x00DD(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FConstraintParent>              Parents;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigUnit_RotationConstraint_AdvancedSettings AdvancedSettings;                                  // 0x00F0(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_RotationConstraintLocalSpaceOffset) == 0x000010, "Wrong alignment on FRigUnit_RotationConstraintLocalSpaceOffset");
static_assert(sizeof(FRigUnit_RotationConstraintLocalSpaceOffset) == 0x000100, "Wrong size on FRigUnit_RotationConstraintLocalSpaceOffset");
static_assert(offsetof(FRigUnit_RotationConstraintLocalSpaceOffset, Child) == 0x0000D0, "Member 'FRigUnit_RotationConstraintLocalSpaceOffset::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraintLocalSpaceOffset, bMaintainOffset) == 0x0000DC, "Member 'FRigUnit_RotationConstraintLocalSpaceOffset::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraintLocalSpaceOffset, Filter) == 0x0000DD, "Member 'FRigUnit_RotationConstraintLocalSpaceOffset::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraintLocalSpaceOffset, Parents) == 0x0000E0, "Member 'FRigUnit_RotationConstraintLocalSpaceOffset::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraintLocalSpaceOffset, AdvancedSettings) == 0x0000F0, "Member 'FRigUnit_RotationConstraintLocalSpaceOffset::AdvancedSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_RotationConstraintLocalSpaceOffset, Weight) == 0x0000F4, "Member 'FRigUnit_RotationConstraintLocalSpaceOffset::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ScaleConstraint
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_ScaleConstraint final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilterOptionPerAxis                   Filter;                                            // 0x00DD(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FConstraintParent>              Parents;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ScaleConstraint) == 0x000010, "Wrong alignment on FRigUnit_ScaleConstraint");
static_assert(sizeof(FRigUnit_ScaleConstraint) == 0x000100, "Wrong size on FRigUnit_ScaleConstraint");
static_assert(offsetof(FRigUnit_ScaleConstraint, Child) == 0x0000D0, "Member 'FRigUnit_ScaleConstraint::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_ScaleConstraint, bMaintainOffset) == 0x0000DC, "Member 'FRigUnit_ScaleConstraint::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ScaleConstraint, Filter) == 0x0000DD, "Member 'FRigUnit_ScaleConstraint::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_ScaleConstraint, Parents) == 0x0000E0, "Member 'FRigUnit_ScaleConstraint::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_ScaleConstraint, Weight) == 0x0000F0, "Member 'FRigUnit_ScaleConstraint::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ScaleConstraintLocalSpaceOffset
// 0x0030 (0x0100 - 0x00D0)
struct FRigUnit_ScaleConstraintLocalSpaceOffset final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Child;                                             // 0x00D0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilterOptionPerAxis                   Filter;                                            // 0x00DD(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FConstraintParent>              Parents;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ScaleConstraintLocalSpaceOffset) == 0x000010, "Wrong alignment on FRigUnit_ScaleConstraintLocalSpaceOffset");
static_assert(sizeof(FRigUnit_ScaleConstraintLocalSpaceOffset) == 0x000100, "Wrong size on FRigUnit_ScaleConstraintLocalSpaceOffset");
static_assert(offsetof(FRigUnit_ScaleConstraintLocalSpaceOffset, Child) == 0x0000D0, "Member 'FRigUnit_ScaleConstraintLocalSpaceOffset::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_ScaleConstraintLocalSpaceOffset, bMaintainOffset) == 0x0000DC, "Member 'FRigUnit_ScaleConstraintLocalSpaceOffset::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ScaleConstraintLocalSpaceOffset, Filter) == 0x0000DD, "Member 'FRigUnit_ScaleConstraintLocalSpaceOffset::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_ScaleConstraintLocalSpaceOffset, Parents) == 0x0000E0, "Member 'FRigUnit_ScaleConstraintLocalSpaceOffset::Parents' has a wrong offset!");
static_assert(offsetof(FRigUnit_ScaleConstraintLocalSpaceOffset, Weight) == 0x0000F0, "Member 'FRigUnit_ScaleConstraintLocalSpaceOffset::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwistBones_WorkData
// 0x0030 (0x0030 - 0x0000)
struct FRigUnit_TwistBones_WorkData final
{
public:
	TArray<struct FCachedRigElement>              CachedItems;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ItemRatios;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ItemTransforms;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwistBones_WorkData) == 0x000008, "Wrong alignment on FRigUnit_TwistBones_WorkData");
static_assert(sizeof(FRigUnit_TwistBones_WorkData) == 0x000030, "Wrong size on FRigUnit_TwistBones_WorkData");
static_assert(offsetof(FRigUnit_TwistBones_WorkData, CachedItems) == 0x000000, "Member 'FRigUnit_TwistBones_WorkData::CachedItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones_WorkData, ItemRatios) == 0x000010, "Member 'FRigUnit_TwistBones_WorkData::ItemRatios' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones_WorkData, ItemTransforms) == 0x000020, "Member 'FRigUnit_TwistBones_WorkData::ItemTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwistBones
// 0x0080 (0x0150 - 0x00D0)
struct FRigUnit_TwistBones final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBone;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TwistAxis;                                         // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleAxis;                                          // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     TwistEaseType;                                     // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_TwistBones_WorkData           WorkData;                                          // 0x0120(0x0030)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwistBones) == 0x000010, "Wrong alignment on FRigUnit_TwistBones");
static_assert(sizeof(FRigUnit_TwistBones) == 0x000150, "Wrong size on FRigUnit_TwistBones");
static_assert(offsetof(FRigUnit_TwistBones, StartBone) == 0x0000D0, "Member 'FRigUnit_TwistBones::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones, EndBone) == 0x0000D8, "Member 'FRigUnit_TwistBones::EndBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones, TwistAxis) == 0x0000E0, "Member 'FRigUnit_TwistBones::TwistAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones, PoleAxis) == 0x0000F8, "Member 'FRigUnit_TwistBones::PoleAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones, TwistEaseType) == 0x000110, "Member 'FRigUnit_TwistBones::TwistEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones, Weight) == 0x000114, "Member 'FRigUnit_TwistBones::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones, bPropagateToChildren) == 0x000118, "Member 'FRigUnit_TwistBones::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBones, WorkData) == 0x000120, "Member 'FRigUnit_TwistBones::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwistBonesPerItem
// 0x0080 (0x0150 - 0x00D0)
struct FRigUnit_TwistBonesPerItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKeyCollection               Items;                                             // 0x00D0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TwistAxis;                                         // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleAxis;                                          // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     TwistEaseType;                                     // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_TwistBones_WorkData           WorkData;                                          // 0x0120(0x0030)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwistBonesPerItem) == 0x000010, "Wrong alignment on FRigUnit_TwistBonesPerItem");
static_assert(sizeof(FRigUnit_TwistBonesPerItem) == 0x000150, "Wrong size on FRigUnit_TwistBonesPerItem");
static_assert(offsetof(FRigUnit_TwistBonesPerItem, Items) == 0x0000D0, "Member 'FRigUnit_TwistBonesPerItem::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBonesPerItem, TwistAxis) == 0x0000E0, "Member 'FRigUnit_TwistBonesPerItem::TwistAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBonesPerItem, PoleAxis) == 0x0000F8, "Member 'FRigUnit_TwistBonesPerItem::PoleAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBonesPerItem, TwistEaseType) == 0x000110, "Member 'FRigUnit_TwistBonesPerItem::TwistEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBonesPerItem, Weight) == 0x000114, "Member 'FRigUnit_TwistBonesPerItem::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBonesPerItem, bPropagateToChildren) == 0x000118, "Member 'FRigUnit_TwistBonesPerItem::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwistBonesPerItem, WorkData) == 0x000120, "Member 'FRigUnit_TwistBonesPerItem::WorkData' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKFK
// 0x0310 (0x03E0 - 0x00D0)
struct FRigUnit_TwoBoneIKFK final : public FRigUnitMutable
{
public:
	class FName                                   StartJoint;                                        // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndJoint;                                          // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleTarget;                                        // 0x00E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spin;                                              // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EndEffector;                                       // 0x0100(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IKBlend;                                           // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0xC];                                      // 0x0164(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartJointFKTransform;                             // 0x0170(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             MidJointFKTransform;                               // 0x01D0(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             EndJointFKTransform;                               // 0x0230(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         PreviousFKIKBlend;                                 // 0x0290(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_294[0xC];                                      // 0x0294(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartJointIKTransform;                             // 0x02A0(0x0060)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             MidJointIKTransform;                               // 0x0300(0x0060)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             EndJointIKTransform;                               // 0x0360(0x0060)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         StartJointIndex;                                   // 0x03C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MidJointIndex;                                     // 0x03C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EndJointIndex;                                     // 0x03C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpperLimbLength;                                   // 0x03CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LowerLimbLength;                                   // 0x03D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0xC];                                      // 0x03D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TwoBoneIKFK) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKFK");
static_assert(sizeof(FRigUnit_TwoBoneIKFK) == 0x0003E0, "Wrong size on FRigUnit_TwoBoneIKFK");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, StartJoint) == 0x0000D0, "Member 'FRigUnit_TwoBoneIKFK::StartJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndJoint) == 0x0000D8, "Member 'FRigUnit_TwoBoneIKFK::EndJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, PoleTarget) == 0x0000E0, "Member 'FRigUnit_TwoBoneIKFK::PoleTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, Spin) == 0x0000F8, "Member 'FRigUnit_TwoBoneIKFK::Spin' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndEffector) == 0x000100, "Member 'FRigUnit_TwoBoneIKFK::EndEffector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, IKBlend) == 0x000160, "Member 'FRigUnit_TwoBoneIKFK::IKBlend' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, StartJointFKTransform) == 0x000170, "Member 'FRigUnit_TwoBoneIKFK::StartJointFKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, MidJointFKTransform) == 0x0001D0, "Member 'FRigUnit_TwoBoneIKFK::MidJointFKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndJointFKTransform) == 0x000230, "Member 'FRigUnit_TwoBoneIKFK::EndJointFKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, PreviousFKIKBlend) == 0x000290, "Member 'FRigUnit_TwoBoneIKFK::PreviousFKIKBlend' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, StartJointIKTransform) == 0x0002A0, "Member 'FRigUnit_TwoBoneIKFK::StartJointIKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, MidJointIKTransform) == 0x000300, "Member 'FRigUnit_TwoBoneIKFK::MidJointIKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndJointIKTransform) == 0x000360, "Member 'FRigUnit_TwoBoneIKFK::EndJointIKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, StartJointIndex) == 0x0003C0, "Member 'FRigUnit_TwoBoneIKFK::StartJointIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, MidJointIndex) == 0x0003C4, "Member 'FRigUnit_TwoBoneIKFK::MidJointIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndJointIndex) == 0x0003C8, "Member 'FRigUnit_TwoBoneIKFK::EndJointIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, UpperLimbLength) == 0x0003CC, "Member 'FRigUnit_TwoBoneIKFK::UpperLimbLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, LowerLimbLength) == 0x0003D0, "Member 'FRigUnit_TwoBoneIKFK::LowerLimbLength' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKSimple_DebugSettings
// 0x0070 (0x0070 - 0x0000)
struct FRigUnit_TwoBoneIKSimple_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0010(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwoBoneIKSimple_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKSimple_DebugSettings");
static_assert(sizeof(FRigUnit_TwoBoneIKSimple_DebugSettings) == 0x000070, "Wrong size on FRigUnit_TwoBoneIKSimple_DebugSettings");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_TwoBoneIKSimple_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_TwoBoneIKSimple_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple_DebugSettings, WorldOffset) == 0x000010, "Member 'FRigUnit_TwoBoneIKSimple_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKSimple
// 0x01F0 (0x02C0 - 0x00D0)
struct FRigUnit_TwoBoneIKSimple final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   BoneA;                                             // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneB;                                             // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectorBone;                                      // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Effector;                                          // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x0150(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0168(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryAxisWeight;                               // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PoleVector;                                        // 0x0188(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigVectorKind                         PoleVectorKind;                                    // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PoleVectorSpace;                                   // 0x01A4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStretch;                                    // 0x01AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StretchStartRatio;                                 // 0x01B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StretchMaximumRatio;                               // 0x01B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x01B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneALength;                                       // 0x01BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneBLength;                                       // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x01C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0xB];                                      // 0x01C5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_TwoBoneIKSimple_DebugSettings DebugSettings;                                     // 0x01D0(0x0070)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedBoneAIndex;                                  // 0x0240(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedBoneBIndex;                                  // 0x0260(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedEffectorBoneIndex;                           // 0x0280(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedPoleVectorSpaceIndex;                        // 0x02A0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwoBoneIKSimple) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKSimple");
static_assert(sizeof(FRigUnit_TwoBoneIKSimple) == 0x0002C0, "Wrong size on FRigUnit_TwoBoneIKSimple");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneA) == 0x0000D0, "Member 'FRigUnit_TwoBoneIKSimple::BoneA' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneB) == 0x0000D8, "Member 'FRigUnit_TwoBoneIKSimple::BoneB' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, EffectorBone) == 0x0000E0, "Member 'FRigUnit_TwoBoneIKSimple::EffectorBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, Effector) == 0x0000F0, "Member 'FRigUnit_TwoBoneIKSimple::Effector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PrimaryAxis) == 0x000150, "Member 'FRigUnit_TwoBoneIKSimple::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, SecondaryAxis) == 0x000168, "Member 'FRigUnit_TwoBoneIKSimple::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, SecondaryAxisWeight) == 0x000180, "Member 'FRigUnit_TwoBoneIKSimple::SecondaryAxisWeight' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PoleVector) == 0x000188, "Member 'FRigUnit_TwoBoneIKSimple::PoleVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PoleVectorKind) == 0x0001A0, "Member 'FRigUnit_TwoBoneIKSimple::PoleVectorKind' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PoleVectorSpace) == 0x0001A4, "Member 'FRigUnit_TwoBoneIKSimple::PoleVectorSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, bEnableStretch) == 0x0001AC, "Member 'FRigUnit_TwoBoneIKSimple::bEnableStretch' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, StretchStartRatio) == 0x0001B0, "Member 'FRigUnit_TwoBoneIKSimple::StretchStartRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, StretchMaximumRatio) == 0x0001B4, "Member 'FRigUnit_TwoBoneIKSimple::StretchMaximumRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, Weight) == 0x0001B8, "Member 'FRigUnit_TwoBoneIKSimple::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneALength) == 0x0001BC, "Member 'FRigUnit_TwoBoneIKSimple::BoneALength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneBLength) == 0x0001C0, "Member 'FRigUnit_TwoBoneIKSimple::BoneBLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, bPropagateToChildren) == 0x0001C4, "Member 'FRigUnit_TwoBoneIKSimple::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, DebugSettings) == 0x0001D0, "Member 'FRigUnit_TwoBoneIKSimple::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, CachedBoneAIndex) == 0x000240, "Member 'FRigUnit_TwoBoneIKSimple::CachedBoneAIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, CachedBoneBIndex) == 0x000260, "Member 'FRigUnit_TwoBoneIKSimple::CachedBoneBIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, CachedEffectorBoneIndex) == 0x000280, "Member 'FRigUnit_TwoBoneIKSimple::CachedEffectorBoneIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, CachedPoleVectorSpaceIndex) == 0x0002A0, "Member 'FRigUnit_TwoBoneIKSimple::CachedPoleVectorSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKSimplePerItem
// 0x0200 (0x02D0 - 0x00D0)
struct FRigUnit_TwoBoneIKSimplePerItem final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         ItemA;                                             // 0x00D0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         ItemB;                                             // 0x00DC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         EffectorItem;                                      // 0x00E8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Effector;                                          // 0x0100(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x0160(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0178(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryAxisWeight;                               // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PoleVector;                                        // 0x0198(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigVectorKind                         PoleVectorKind;                                    // 0x01B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         PoleVectorSpace;                                   // 0x01B4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStretch;                                    // 0x01C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StretchStartRatio;                                 // 0x01C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StretchMaximumRatio;                               // 0x01C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x01CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemALength;                                       // 0x01D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemBLength;                                       // 0x01D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x01D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_TwoBoneIKSimple_DebugSettings DebugSettings;                                     // 0x01E0(0x0070)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedItemAIndex;                                  // 0x0250(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedItemBIndex;                                  // 0x0270(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedEffectorItemIndex;                           // 0x0290(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedRigElement                      CachedPoleVectorSpaceIndex;                        // 0x02B0(0x0020)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwoBoneIKSimplePerItem) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKSimplePerItem");
static_assert(sizeof(FRigUnit_TwoBoneIKSimplePerItem) == 0x0002D0, "Wrong size on FRigUnit_TwoBoneIKSimplePerItem");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, ItemA) == 0x0000D0, "Member 'FRigUnit_TwoBoneIKSimplePerItem::ItemA' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, ItemB) == 0x0000DC, "Member 'FRigUnit_TwoBoneIKSimplePerItem::ItemB' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, EffectorItem) == 0x0000E8, "Member 'FRigUnit_TwoBoneIKSimplePerItem::EffectorItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, Effector) == 0x000100, "Member 'FRigUnit_TwoBoneIKSimplePerItem::Effector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, PrimaryAxis) == 0x000160, "Member 'FRigUnit_TwoBoneIKSimplePerItem::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, SecondaryAxis) == 0x000178, "Member 'FRigUnit_TwoBoneIKSimplePerItem::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, SecondaryAxisWeight) == 0x000190, "Member 'FRigUnit_TwoBoneIKSimplePerItem::SecondaryAxisWeight' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, PoleVector) == 0x000198, "Member 'FRigUnit_TwoBoneIKSimplePerItem::PoleVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, PoleVectorKind) == 0x0001B0, "Member 'FRigUnit_TwoBoneIKSimplePerItem::PoleVectorKind' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, PoleVectorSpace) == 0x0001B4, "Member 'FRigUnit_TwoBoneIKSimplePerItem::PoleVectorSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, bEnableStretch) == 0x0001C0, "Member 'FRigUnit_TwoBoneIKSimplePerItem::bEnableStretch' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, StretchStartRatio) == 0x0001C4, "Member 'FRigUnit_TwoBoneIKSimplePerItem::StretchStartRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, StretchMaximumRatio) == 0x0001C8, "Member 'FRigUnit_TwoBoneIKSimplePerItem::StretchMaximumRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, Weight) == 0x0001CC, "Member 'FRigUnit_TwoBoneIKSimplePerItem::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, ItemALength) == 0x0001D0, "Member 'FRigUnit_TwoBoneIKSimplePerItem::ItemALength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, ItemBLength) == 0x0001D4, "Member 'FRigUnit_TwoBoneIKSimplePerItem::ItemBLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, bPropagateToChildren) == 0x0001D8, "Member 'FRigUnit_TwoBoneIKSimplePerItem::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, DebugSettings) == 0x0001E0, "Member 'FRigUnit_TwoBoneIKSimplePerItem::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, CachedItemAIndex) == 0x000250, "Member 'FRigUnit_TwoBoneIKSimplePerItem::CachedItemAIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, CachedItemBIndex) == 0x000270, "Member 'FRigUnit_TwoBoneIKSimplePerItem::CachedItemBIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, CachedEffectorItemIndex) == 0x000290, "Member 'FRigUnit_TwoBoneIKSimplePerItem::CachedEffectorItemIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimplePerItem, CachedPoleVectorSpaceIndex) == 0x0002B0, "Member 'FRigUnit_TwoBoneIKSimplePerItem::CachedPoleVectorSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKSimpleVectors
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_TwoBoneIKSimpleVectors final : public FRigUnit_HighlevelBase
{
public:
	struct FVector                                Root;                                              // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleVector;                                        // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Effector;                                          // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStretch;                                    // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StretchStartRatio;                                 // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StretchMaximumRatio;                               // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneALength;                                       // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneBLength;                                       // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Elbow;                                             // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwoBoneIKSimpleVectors) == 0x000008, "Wrong alignment on FRigUnit_TwoBoneIKSimpleVectors");
static_assert(sizeof(FRigUnit_TwoBoneIKSimpleVectors) == 0x000080, "Wrong size on FRigUnit_TwoBoneIKSimpleVectors");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, Root) == 0x000008, "Member 'FRigUnit_TwoBoneIKSimpleVectors::Root' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, PoleVector) == 0x000020, "Member 'FRigUnit_TwoBoneIKSimpleVectors::PoleVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, Effector) == 0x000038, "Member 'FRigUnit_TwoBoneIKSimpleVectors::Effector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, bEnableStretch) == 0x000050, "Member 'FRigUnit_TwoBoneIKSimpleVectors::bEnableStretch' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, StretchStartRatio) == 0x000054, "Member 'FRigUnit_TwoBoneIKSimpleVectors::StretchStartRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, StretchMaximumRatio) == 0x000058, "Member 'FRigUnit_TwoBoneIKSimpleVectors::StretchMaximumRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, BoneALength) == 0x00005C, "Member 'FRigUnit_TwoBoneIKSimpleVectors::BoneALength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, BoneBLength) == 0x000060, "Member 'FRigUnit_TwoBoneIKSimpleVectors::BoneBLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimpleVectors, Elbow) == 0x000068, "Member 'FRigUnit_TwoBoneIKSimpleVectors::Elbow' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Multiply_VectorVector
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_Multiply_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Multiply_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Multiply_VectorVector");
static_assert(sizeof(FRigUnit_Multiply_VectorVector) == 0x000050, "Wrong size on FRigUnit_Multiply_VectorVector");

// ScriptStruct ControlRig.RigUnit_Add_VectorVector
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_Add_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Add_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Add_VectorVector");
static_assert(sizeof(FRigUnit_Add_VectorVector) == 0x000050, "Wrong size on FRigUnit_Add_VectorVector");

// ScriptStruct ControlRig.RigUnit_Divide_VectorVector
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_Divide_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Divide_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Divide_VectorVector");
static_assert(sizeof(FRigUnit_Divide_VectorVector) == 0x000050, "Wrong size on FRigUnit_Divide_VectorVector");

// ScriptStruct ControlRig.RigUnit_Distance_VectorVector
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_Distance_VectorVector final : public FRigUnit
{
public:
	struct FVector                                Argument0;                                         // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Argument1;                                         // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Distance_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Distance_VectorVector");
static_assert(sizeof(FRigUnit_Distance_VectorVector) == 0x000040, "Wrong size on FRigUnit_Distance_VectorVector");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Argument0) == 0x000008, "Member 'FRigUnit_Distance_VectorVector::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Argument1) == 0x000020, "Member 'FRigUnit_Distance_VectorVector::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Result) == 0x000038, "Member 'FRigUnit_Distance_VectorVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_VerletIntegrateVector
// 0x00D0 (0x00D8 - 0x0008)
struct FRigUnit_VerletIntegrateVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Target;                                            // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damp;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Force;                                             // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0060(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration;                                      // 0x0078(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCRSimPoint                            Point;                                             // 0x0090(0x0040)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bInitialized;                                      // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_VerletIntegrateVector) == 0x000008, "Wrong alignment on FRigUnit_VerletIntegrateVector");
static_assert(sizeof(FRigUnit_VerletIntegrateVector) == 0x0000D8, "Wrong size on FRigUnit_VerletIntegrateVector");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Target) == 0x000008, "Member 'FRigUnit_VerletIntegrateVector::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Strength) == 0x000020, "Member 'FRigUnit_VerletIntegrateVector::Strength' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Damp) == 0x000024, "Member 'FRigUnit_VerletIntegrateVector::Damp' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Blend) == 0x000028, "Member 'FRigUnit_VerletIntegrateVector::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Force) == 0x000030, "Member 'FRigUnit_VerletIntegrateVector::Force' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Position) == 0x000048, "Member 'FRigUnit_VerletIntegrateVector::Position' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Velocity) == 0x000060, "Member 'FRigUnit_VerletIntegrateVector::Velocity' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Acceleration) == 0x000078, "Member 'FRigUnit_VerletIntegrateVector::Acceleration' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Point) == 0x000090, "Member 'FRigUnit_VerletIntegrateVector::Point' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, bInitialized) == 0x0000D0, "Member 'FRigUnit_VerletIntegrateVector::bInitialized' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_VisualDebugVectorItemSpace
// 0x0040 (0x0048 - 0x0008)
struct FRigUnit_VisualDebugVectorItemSpace final : public FRigUnit_DebugBase
{
public:
	struct FVector                                Value;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigUnitVisualDebugPointMode                  Mode;                                              // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0024(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x003C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_VisualDebugVectorItemSpace) == 0x000008, "Wrong alignment on FRigUnit_VisualDebugVectorItemSpace");
static_assert(sizeof(FRigUnit_VisualDebugVectorItemSpace) == 0x000048, "Wrong size on FRigUnit_VisualDebugVectorItemSpace");
static_assert(offsetof(FRigUnit_VisualDebugVectorItemSpace, Value) == 0x000008, "Member 'FRigUnit_VisualDebugVectorItemSpace::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVectorItemSpace, bEnabled) == 0x000020, "Member 'FRigUnit_VisualDebugVectorItemSpace::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVectorItemSpace, Mode) == 0x000021, "Member 'FRigUnit_VisualDebugVectorItemSpace::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVectorItemSpace, Color) == 0x000024, "Member 'FRigUnit_VisualDebugVectorItemSpace::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVectorItemSpace, Thickness) == 0x000034, "Member 'FRigUnit_VisualDebugVectorItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVectorItemSpace, Scale) == 0x000038, "Member 'FRigUnit_VisualDebugVectorItemSpace::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugVectorItemSpace, Space) == 0x00003C, "Member 'FRigUnit_VisualDebugVectorItemSpace::Space' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_VisualDebugQuat
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_VisualDebugQuat final : public FRigUnit_DebugBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneSpace;                                         // 0x003C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_VisualDebugQuat) == 0x000010, "Wrong alignment on FRigUnit_VisualDebugQuat");
static_assert(sizeof(FRigUnit_VisualDebugQuat) == 0x000050, "Wrong size on FRigUnit_VisualDebugQuat");
static_assert(offsetof(FRigUnit_VisualDebugQuat, Value) == 0x000010, "Member 'FRigUnit_VisualDebugQuat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugQuat, bEnabled) == 0x000030, "Member 'FRigUnit_VisualDebugQuat::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugQuat, Thickness) == 0x000034, "Member 'FRigUnit_VisualDebugQuat::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugQuat, Scale) == 0x000038, "Member 'FRigUnit_VisualDebugQuat::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugQuat, BoneSpace) == 0x00003C, "Member 'FRigUnit_VisualDebugQuat::BoneSpace' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_VisualDebugQuatItemSpace
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_VisualDebugQuatItemSpace final : public FRigUnit_DebugBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Value;                                             // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x003C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_VisualDebugQuatItemSpace) == 0x000010, "Wrong alignment on FRigUnit_VisualDebugQuatItemSpace");
static_assert(sizeof(FRigUnit_VisualDebugQuatItemSpace) == 0x000050, "Wrong size on FRigUnit_VisualDebugQuatItemSpace");
static_assert(offsetof(FRigUnit_VisualDebugQuatItemSpace, Value) == 0x000010, "Member 'FRigUnit_VisualDebugQuatItemSpace::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugQuatItemSpace, bEnabled) == 0x000030, "Member 'FRigUnit_VisualDebugQuatItemSpace::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugQuatItemSpace, Thickness) == 0x000034, "Member 'FRigUnit_VisualDebugQuatItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugQuatItemSpace, Scale) == 0x000038, "Member 'FRigUnit_VisualDebugQuatItemSpace::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugQuatItemSpace, Space) == 0x00003C, "Member 'FRigUnit_VisualDebugQuatItemSpace::Space' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_VisualDebugTransformItemSpace
// 0x0088 (0x0090 - 0x0008)
struct FRigUnit_VisualDebugTransformItemSpace final : public FRigUnit_DebugBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Value;                                             // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         Space;                                             // 0x007C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_VisualDebugTransformItemSpace) == 0x000010, "Wrong alignment on FRigUnit_VisualDebugTransformItemSpace");
static_assert(sizeof(FRigUnit_VisualDebugTransformItemSpace) == 0x000090, "Wrong size on FRigUnit_VisualDebugTransformItemSpace");
static_assert(offsetof(FRigUnit_VisualDebugTransformItemSpace, Value) == 0x000010, "Member 'FRigUnit_VisualDebugTransformItemSpace::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugTransformItemSpace, bEnabled) == 0x000070, "Member 'FRigUnit_VisualDebugTransformItemSpace::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugTransformItemSpace, Thickness) == 0x000074, "Member 'FRigUnit_VisualDebugTransformItemSpace::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugTransformItemSpace, Scale) == 0x000078, "Member 'FRigUnit_VisualDebugTransformItemSpace::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_VisualDebugTransformItemSpace, Space) == 0x00007C, "Member 'FRigUnit_VisualDebugTransformItemSpace::Space' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SphereTraceWorld
// 0x0070 (0x0078 - 0x0008)
struct FRigUnit_SphereTraceWorld final : public FRigUnit
{
public:
	struct FVector                                Start;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             Channel;                                           // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0060(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SphereTraceWorld) == 0x000008, "Wrong alignment on FRigUnit_SphereTraceWorld");
static_assert(sizeof(FRigUnit_SphereTraceWorld) == 0x000078, "Wrong size on FRigUnit_SphereTraceWorld");
static_assert(offsetof(FRigUnit_SphereTraceWorld, Start) == 0x000008, "Member 'FRigUnit_SphereTraceWorld::Start' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceWorld, End) == 0x000020, "Member 'FRigUnit_SphereTraceWorld::End' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceWorld, Channel) == 0x000038, "Member 'FRigUnit_SphereTraceWorld::Channel' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceWorld, Radius) == 0x00003C, "Member 'FRigUnit_SphereTraceWorld::Radius' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceWorld, bHit) == 0x000040, "Member 'FRigUnit_SphereTraceWorld::bHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceWorld, HitLocation) == 0x000048, "Member 'FRigUnit_SphereTraceWorld::HitLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceWorld, HitNormal) == 0x000060, "Member 'FRigUnit_SphereTraceWorld::HitNormal' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SphereTraceByTraceChannel
// 0x0070 (0x0078 - 0x0008)
struct FRigUnit_SphereTraceByTraceChannel final : public FRigUnit
{
public:
	struct FVector                                Start;                                             // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0060(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SphereTraceByTraceChannel) == 0x000008, "Wrong alignment on FRigUnit_SphereTraceByTraceChannel");
static_assert(sizeof(FRigUnit_SphereTraceByTraceChannel) == 0x000078, "Wrong size on FRigUnit_SphereTraceByTraceChannel");
static_assert(offsetof(FRigUnit_SphereTraceByTraceChannel, Start) == 0x000008, "Member 'FRigUnit_SphereTraceByTraceChannel::Start' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByTraceChannel, End) == 0x000020, "Member 'FRigUnit_SphereTraceByTraceChannel::End' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByTraceChannel, TraceChannel) == 0x000038, "Member 'FRigUnit_SphereTraceByTraceChannel::TraceChannel' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByTraceChannel, Radius) == 0x00003C, "Member 'FRigUnit_SphereTraceByTraceChannel::Radius' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByTraceChannel, bHit) == 0x000040, "Member 'FRigUnit_SphereTraceByTraceChannel::bHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByTraceChannel, HitLocation) == 0x000048, "Member 'FRigUnit_SphereTraceByTraceChannel::HitLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceByTraceChannel, HitNormal) == 0x000060, "Member 'FRigUnit_SphereTraceByTraceChannel::HitNormal' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToWorldSpace_Transform
// 0x00C8 (0x00D0 - 0x0008)
struct FRigUnit_ToWorldSpace_Transform final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             World;                                             // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToWorldSpace_Transform) == 0x000010, "Wrong alignment on FRigUnit_ToWorldSpace_Transform");
static_assert(sizeof(FRigUnit_ToWorldSpace_Transform) == 0x0000D0, "Wrong size on FRigUnit_ToWorldSpace_Transform");
static_assert(offsetof(FRigUnit_ToWorldSpace_Transform, Transform) == 0x000010, "Member 'FRigUnit_ToWorldSpace_Transform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToWorldSpace_Transform, World) == 0x000070, "Member 'FRigUnit_ToWorldSpace_Transform::World' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToRigSpace_Transform
// 0x00C8 (0x00D0 - 0x0008)
struct FRigUnit_ToRigSpace_Transform final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Global;                                            // 0x0070(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToRigSpace_Transform) == 0x000010, "Wrong alignment on FRigUnit_ToRigSpace_Transform");
static_assert(sizeof(FRigUnit_ToRigSpace_Transform) == 0x0000D0, "Wrong size on FRigUnit_ToRigSpace_Transform");
static_assert(offsetof(FRigUnit_ToRigSpace_Transform, Transform) == 0x000010, "Member 'FRigUnit_ToRigSpace_Transform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToRigSpace_Transform, Global) == 0x000070, "Member 'FRigUnit_ToRigSpace_Transform::Global' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToWorldSpace_Location
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_ToWorldSpace_Location final : public FRigUnit
{
public:
	struct FVector                                Location;                                          // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                World;                                             // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToWorldSpace_Location) == 0x000008, "Wrong alignment on FRigUnit_ToWorldSpace_Location");
static_assert(sizeof(FRigUnit_ToWorldSpace_Location) == 0x000038, "Wrong size on FRigUnit_ToWorldSpace_Location");
static_assert(offsetof(FRigUnit_ToWorldSpace_Location, Location) == 0x000008, "Member 'FRigUnit_ToWorldSpace_Location::Location' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToWorldSpace_Location, World) == 0x000020, "Member 'FRigUnit_ToWorldSpace_Location::World' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToWorldSpace_Rotation
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_ToWorldSpace_Rotation final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  World;                                             // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToWorldSpace_Rotation) == 0x000010, "Wrong alignment on FRigUnit_ToWorldSpace_Rotation");
static_assert(sizeof(FRigUnit_ToWorldSpace_Rotation) == 0x000050, "Wrong size on FRigUnit_ToWorldSpace_Rotation");
static_assert(offsetof(FRigUnit_ToWorldSpace_Rotation, Rotation) == 0x000010, "Member 'FRigUnit_ToWorldSpace_Rotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToWorldSpace_Rotation, World) == 0x000030, "Member 'FRigUnit_ToWorldSpace_Rotation::World' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToRigSpace_Rotation
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_ToRigSpace_Rotation final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0010(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Global;                                            // 0x0030(0x0020)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToRigSpace_Rotation) == 0x000010, "Wrong alignment on FRigUnit_ToRigSpace_Rotation");
static_assert(sizeof(FRigUnit_ToRigSpace_Rotation) == 0x000050, "Wrong size on FRigUnit_ToRigSpace_Rotation");
static_assert(offsetof(FRigUnit_ToRigSpace_Rotation, Rotation) == 0x000010, "Member 'FRigUnit_ToRigSpace_Rotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToRigSpace_Rotation, Global) == 0x000030, "Member 'FRigUnit_ToRigSpace_Rotation::Global' has a wrong offset!");

// ScriptStruct ControlRig.StructReference
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FStructReference final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStructReference) == 0x000008, "Wrong alignment on FStructReference");
static_assert(sizeof(FStructReference) == 0x000008, "Wrong size on FStructReference");

}

