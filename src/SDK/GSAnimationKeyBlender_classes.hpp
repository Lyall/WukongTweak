#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GSAnimationKeyBlender

#include "Basic.hpp"

#include "GSAnimationKeyBlender_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class GSAnimationKeyBlender.AnimKeyBlenderSettings
// 0x0008 (0x0040 - 0x0038)
class UAnimKeyBlenderSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnableDebugLogs;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimKeyBlenderSettings">();
	}
	static class UAnimKeyBlenderSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimKeyBlenderSettings>();
	}
};
static_assert(alignof(UAnimKeyBlenderSettings) == 0x000008, "Wrong alignment on UAnimKeyBlenderSettings");
static_assert(sizeof(UAnimKeyBlenderSettings) == 0x000040, "Wrong size on UAnimKeyBlenderSettings");
static_assert(offsetof(UAnimKeyBlenderSettings, bEnableDebugLogs) == 0x000038, "Member 'UAnimKeyBlenderSettings::bEnableDebugLogs' has a wrong offset!");

// Class GSAnimationKeyBlender.GSAnimKeyStateBlender
// 0x0240 (0x0268 - 0x0028)
class UGSAnimKeyStateBlender final : public UObject
{
public:
	class UWidgetAnimation*                       RefAnimation;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULevelSequence*                         RefLevelSequence;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                RefObject;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FGSAnimKeyCachedMatParamData> CurrentObjMatParamData;                            // 0x0040(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<uint32, struct FGSAnimKeyCachedMatParamData> CurrentMPCMatParamData;                            // 0x0090(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FGSAKObjectEasingOneToOneStateData> EasingOneToOneStateData;                           // 0x00E0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      StateNameIndexMap;                                 // 0x00F0(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FGSAKBStateEasingCfg> StateToStateEasingCfgMap;                          // 0x0140(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPrivate)
	bool                                          IsStrictStateMatchCfg;                             // 0x0190(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAlwaysUsingEndStateAsChanging;                   // 0x0191(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsWithRegStateName;                                // 0x0192(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_193[0x5];                                      // 0x0193(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGSAnimKeyObjST>                AKObjSTList;                                       // 0x0198(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	bool                                          IsTicking;                                         // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAKBStateBegin;                                   // 0x01B0(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAKBStateEnd;                                     // 0x01C0(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAKBStateInterupt;                                // 0x01D0(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   BeginStateName;                                    // 0x01E0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CurrentStateName;                                  // 0x01E8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EndStateName;                                      // 0x01F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                RefWorldTranslation;                               // 0x01F8(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGSAKBStateEasingCfg                   DefaultEasingCfg;                                  // 0x0210(0x0018)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGSAKBStateEasingCfg                   WorkingEasingCfg;                                  // 0x0228(0x0018)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         StateEasedTime;                                    // 0x0240(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StateDelayEasingTime;                              // 0x0244(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StateOverideEasingTime;                            // 0x0248(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsWidgetBlender;                                   // 0x024C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24D[0x1B];                                     // 0x024D(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeforeInitAddBindingActor(class ALevelSequenceActor* RefLevelSequenceActor, class FName BindingActorTagName, class AActor* InActor);
	void DoDebug();
	void DoTick(float DeltaTime);
	void EasingToEndState(float Alpha, bool IsFromForceSetStateImmediately);
	void ForceSetStateImmediately(class FName TargetStateName);
	const class FName GetBeginStateName();
	const class FName GetCurrentStateName();
	const class FName GetEndStateName();
	float GetPredicToStateCfgEasingTime(class FName TargetStateName, float* OutDelayEasingTime);
	void InitAddStateToStateEasingCfg(class FName FromStateName, class FName ToStateName, float InEasingTime, EEasingFunc InEasingFunc, float InEasingBlendExp, int32 InEasingSteps, EGSAnimKBEnumBoolEasing InEnumValEasingType, EGSAnimKBEnumBoolEasing InBoolValEasingType, float InDelayEasingTime);
	void InitResetState();
	void InitSetDefaultEasingCfg(float InEasingTime, EEasingFunc InEasingFunc, float InEasingBlendExp, int32 InEasingSteps, EGSAnimKBEnumBoolEasing InEnumValEasingType, EGSAnimKBEnumBoolEasing InBoolValEasingType, float InDelayEasingTime);
	void InitSetLevelSequence(class UObject* InRefObject, class ULevelSequence* InLevelSequence, bool InIsStrictStateMatchCfg, bool InIsAlwaysUsingEndStateAsChanging);
	void InitSetWidgetAnimation(class UUserWidget* InRefUserWidget, class UWidgetAnimation* InWidgetAnimation, bool InIsStrictStateMatchCfg, bool InIsAlwaysUsingEndStateAsChanging);
	bool IsInBlending();
	void ToState(class FName TargetStateName, float InStateDelayEasingTime, float InStateOverideEasingTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSAnimKeyStateBlender">();
	}
	static class UGSAnimKeyStateBlender* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSAnimKeyStateBlender>();
	}
};
static_assert(alignof(UGSAnimKeyStateBlender) == 0x000008, "Wrong alignment on UGSAnimKeyStateBlender");
static_assert(sizeof(UGSAnimKeyStateBlender) == 0x000268, "Wrong size on UGSAnimKeyStateBlender");
static_assert(offsetof(UGSAnimKeyStateBlender, RefAnimation) == 0x000028, "Member 'UGSAnimKeyStateBlender::RefAnimation' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, RefLevelSequence) == 0x000030, "Member 'UGSAnimKeyStateBlender::RefLevelSequence' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, RefObject) == 0x000038, "Member 'UGSAnimKeyStateBlender::RefObject' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, CurrentObjMatParamData) == 0x000040, "Member 'UGSAnimKeyStateBlender::CurrentObjMatParamData' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, CurrentMPCMatParamData) == 0x000090, "Member 'UGSAnimKeyStateBlender::CurrentMPCMatParamData' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, EasingOneToOneStateData) == 0x0000E0, "Member 'UGSAnimKeyStateBlender::EasingOneToOneStateData' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, StateNameIndexMap) == 0x0000F0, "Member 'UGSAnimKeyStateBlender::StateNameIndexMap' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, StateToStateEasingCfgMap) == 0x000140, "Member 'UGSAnimKeyStateBlender::StateToStateEasingCfgMap' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, IsStrictStateMatchCfg) == 0x000190, "Member 'UGSAnimKeyStateBlender::IsStrictStateMatchCfg' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, IsAlwaysUsingEndStateAsChanging) == 0x000191, "Member 'UGSAnimKeyStateBlender::IsAlwaysUsingEndStateAsChanging' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, IsWithRegStateName) == 0x000192, "Member 'UGSAnimKeyStateBlender::IsWithRegStateName' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, AKObjSTList) == 0x000198, "Member 'UGSAnimKeyStateBlender::AKObjSTList' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, IsTicking) == 0x0001A8, "Member 'UGSAnimKeyStateBlender::IsTicking' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, OnAKBStateBegin) == 0x0001B0, "Member 'UGSAnimKeyStateBlender::OnAKBStateBegin' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, OnAKBStateEnd) == 0x0001C0, "Member 'UGSAnimKeyStateBlender::OnAKBStateEnd' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, OnAKBStateInterupt) == 0x0001D0, "Member 'UGSAnimKeyStateBlender::OnAKBStateInterupt' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, BeginStateName) == 0x0001E0, "Member 'UGSAnimKeyStateBlender::BeginStateName' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, CurrentStateName) == 0x0001E8, "Member 'UGSAnimKeyStateBlender::CurrentStateName' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, EndStateName) == 0x0001F0, "Member 'UGSAnimKeyStateBlender::EndStateName' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, RefWorldTranslation) == 0x0001F8, "Member 'UGSAnimKeyStateBlender::RefWorldTranslation' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, DefaultEasingCfg) == 0x000210, "Member 'UGSAnimKeyStateBlender::DefaultEasingCfg' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, WorkingEasingCfg) == 0x000228, "Member 'UGSAnimKeyStateBlender::WorkingEasingCfg' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, StateEasedTime) == 0x000240, "Member 'UGSAnimKeyStateBlender::StateEasedTime' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, StateDelayEasingTime) == 0x000244, "Member 'UGSAnimKeyStateBlender::StateDelayEasingTime' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, StateOverideEasingTime) == 0x000248, "Member 'UGSAnimKeyStateBlender::StateOverideEasingTime' has a wrong offset!");
static_assert(offsetof(UGSAnimKeyStateBlender, IsWidgetBlender) == 0x00024C, "Member 'UGSAnimKeyStateBlender::IsWidgetBlender' has a wrong offset!");

// Class GSAnimationKeyBlender.GSAnimKeyStateBlenderSubsystem
// 0x0018 (0x0048 - 0x0030)
class UGSAnimKeyStateBlenderSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGSAnimKeyStateBlender*>         AnimKeyStateBlenderContainer;                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSAnimKeyStateBlenderSubsystem">();
	}
	static class UGSAnimKeyStateBlenderSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSAnimKeyStateBlenderSubsystem>();
	}
};
static_assert(alignof(UGSAnimKeyStateBlenderSubsystem) == 0x000008, "Wrong alignment on UGSAnimKeyStateBlenderSubsystem");
static_assert(sizeof(UGSAnimKeyStateBlenderSubsystem) == 0x000048, "Wrong size on UGSAnimKeyStateBlenderSubsystem");
static_assert(offsetof(UGSAnimKeyStateBlenderSubsystem, AnimKeyStateBlenderContainer) == 0x000038, "Member 'UGSAnimKeyStateBlenderSubsystem::AnimKeyStateBlenderContainer' has a wrong offset!");

// Class GSAnimationKeyBlender.GSAnimKeyStateBlenderUtil
// 0x0000 (0x0028 - 0x0028)
class UGSAnimKeyStateBlenderUtil final : public UBlueprintFunctionLibrary
{
public:
	static void RegAnimKeyStateBlenderObjForTick(class UGSAnimKeyStateBlender* AnimKeyStateBlender);
	static void UnRegAnimKeyStateBlenderObjForTick(class UGSAnimKeyStateBlender* AnimKeyStateBlender);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSAnimKeyStateBlenderUtil">();
	}
	static class UGSAnimKeyStateBlenderUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSAnimKeyStateBlenderUtil>();
	}
};
static_assert(alignof(UGSAnimKeyStateBlenderUtil) == 0x000008, "Wrong alignment on UGSAnimKeyStateBlenderUtil");
static_assert(sizeof(UGSAnimKeyStateBlenderUtil) == 0x000028, "Wrong size on UGSAnimKeyStateBlenderUtil");

}

