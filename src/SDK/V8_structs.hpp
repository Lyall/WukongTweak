#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: V8

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum V8.EJavascriptStatDataType
// NumValues: 0x0007
enum class EJavascriptStatDataType : uint8
{
	Invalid                                  = 0,
	ST_None                                  = 1,
	ST_int64                                 = 2,
	ST_double                                = 3,
	ST_FName                                 = 4,
	ST_Ptr                                   = 5,
	EJavascriptStatDataType_MAX              = 6,
};

// Enum V8.EJavascriptEncodingOptions
// NumValues: 0x0006
enum class EJavascriptEncodingOptions : uint8
{
	AutoDetect                               = 0,
	ForceAnsi                                = 1,
	ForceUnicode                             = 2,
	ForceUTF8                                = 3,
	ForceUTF8WithoutBOM                      = 4,
	EJavascriptEncodingOptions_MAX           = 5,
};

// Enum V8.EJavascriptStatOperation
// NumValues: 0x0011
enum class EJavascriptStatOperation : uint8
{
	Invalid                                  = 0,
	SetLongName                              = 1,
	AdvanceFrameEventGameThread              = 2,
	AdvanceFrameEventRenderThread            = 3,
	CycleScopeStart                          = 4,
	CycleScopeEnd                            = 5,
	SpecialMessageMarker                     = 6,
	Set                                      = 7,
	Clear                                    = 8,
	Add                                      = 9,
	Subtract                                 = 10,
	ChildrenStart                            = 11,
	ChildrenEnd                              = 12,
	Leaf                                     = 13,
	MaxVal                                   = 14,
	Memory                                   = 15,
	EJavascriptStatOperation_MAX             = 16,
};

// Enum V8.ELogVerbosity_JS
// NumValues: 0x0009
enum class ELogVerbosity_JS : uint8
{
	NoLogging                                = 0,
	Fatal                                    = 1,
	Error                                    = 2,
	Warning                                  = 3,
	Display                                  = 4,
	Log                                      = 5,
	Verbose                                  = 6,
	VeryVerbose                              = 7,
	ELogVerbosity_MAX                        = 8,
};

// ScriptStruct V8.JavascriptClassAsset
// 0x0010 (0x0010 - 0x0000)
struct FJavascriptClassAsset final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    Class;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJavascriptClassAsset) == 0x000008, "Wrong alignment on FJavascriptClassAsset");
static_assert(sizeof(FJavascriptClassAsset) == 0x000010, "Wrong size on FJavascriptClassAsset");
static_assert(offsetof(FJavascriptClassAsset, Name) == 0x000000, "Member 'FJavascriptClassAsset::Name' has a wrong offset!");
static_assert(offsetof(FJavascriptClassAsset, Class) == 0x000008, "Member 'FJavascriptClassAsset::Class' has a wrong offset!");

// ScriptStruct V8.JavascriptMemoryStruct
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FJavascriptMemoryStruct final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptMemoryStruct) == 0x000008, "Wrong alignment on FJavascriptMemoryStruct");
static_assert(sizeof(FJavascriptMemoryStruct) == 0x000008, "Wrong size on FJavascriptMemoryStruct");

// ScriptStruct V8.JavascriptAsset
// 0x0020 (0x0020 - 0x0000)
struct FJavascriptAsset final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Asset;                                             // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJavascriptAsset) == 0x000008, "Wrong alignment on FJavascriptAsset");
static_assert(sizeof(FJavascriptAsset) == 0x000020, "Wrong size on FJavascriptAsset");
static_assert(offsetof(FJavascriptAsset, Name) == 0x000000, "Member 'FJavascriptAsset::Name' has a wrong offset!");
static_assert(offsetof(FJavascriptAsset, Asset) == 0x000008, "Member 'FJavascriptAsset::Asset' has a wrong offset!");

// ScriptStruct V8.JavascriptRawAccess_Data
// 0x0001 (0x0001 - 0x0000)
struct FJavascriptRawAccess_Data final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptRawAccess_Data) == 0x000001, "Wrong alignment on FJavascriptRawAccess_Data");
static_assert(sizeof(FJavascriptRawAccess_Data) == 0x000001, "Wrong size on FJavascriptRawAccess_Data");

// ScriptStruct V8.JavascriptRawAccess
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FJavascriptRawAccess final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptRawAccess) == 0x000008, "Wrong alignment on FJavascriptRawAccess");
static_assert(sizeof(FJavascriptRawAccess) == 0x000008, "Wrong size on FJavascriptRawAccess");

// ScriptStruct V8.JavascriptFunction
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FJavascriptFunction final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptFunction) == 0x000008, "Wrong alignment on FJavascriptFunction");
static_assert(sizeof(FJavascriptFunction) == 0x000010, "Wrong size on FJavascriptFunction");

// ScriptStruct V8.JavascriptRef
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FJavascriptRef final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptRef) == 0x000008, "Wrong alignment on FJavascriptRef");
static_assert(sizeof(FJavascriptRef) == 0x000010, "Wrong size on FJavascriptRef");

// ScriptStruct V8.JavascriptHeapStatistics
// 0x0020 (0x0020 - 0x0000)
struct FJavascriptHeapStatistics final
{
public:
	int32                                         TotalHeapSize;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalHeapSizeExecutable;                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalPhysicalSize;                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalAvailableSize;                                // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedHeapSize;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeapSizeLimit;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MallocedMemory;                                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoesZapGarbage;                                   // 0x001C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptHeapStatistics) == 0x000004, "Wrong alignment on FJavascriptHeapStatistics");
static_assert(sizeof(FJavascriptHeapStatistics) == 0x000020, "Wrong size on FJavascriptHeapStatistics");
static_assert(offsetof(FJavascriptHeapStatistics, TotalHeapSize) == 0x000000, "Member 'FJavascriptHeapStatistics::TotalHeapSize' has a wrong offset!");
static_assert(offsetof(FJavascriptHeapStatistics, TotalHeapSizeExecutable) == 0x000004, "Member 'FJavascriptHeapStatistics::TotalHeapSizeExecutable' has a wrong offset!");
static_assert(offsetof(FJavascriptHeapStatistics, TotalPhysicalSize) == 0x000008, "Member 'FJavascriptHeapStatistics::TotalPhysicalSize' has a wrong offset!");
static_assert(offsetof(FJavascriptHeapStatistics, TotalAvailableSize) == 0x00000C, "Member 'FJavascriptHeapStatistics::TotalAvailableSize' has a wrong offset!");
static_assert(offsetof(FJavascriptHeapStatistics, UsedHeapSize) == 0x000010, "Member 'FJavascriptHeapStatistics::UsedHeapSize' has a wrong offset!");
static_assert(offsetof(FJavascriptHeapStatistics, HeapSizeLimit) == 0x000014, "Member 'FJavascriptHeapStatistics::HeapSizeLimit' has a wrong offset!");
static_assert(offsetof(FJavascriptHeapStatistics, MallocedMemory) == 0x000018, "Member 'FJavascriptHeapStatistics::MallocedMemory' has a wrong offset!");
static_assert(offsetof(FJavascriptHeapStatistics, bDoesZapGarbage) == 0x00001C, "Member 'FJavascriptHeapStatistics::bDoesZapGarbage' has a wrong offset!");

// ScriptStruct V8.ReadStringFromFileHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FReadStringFromFileHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReadStringFromFileHandle) == 0x000008, "Wrong alignment on FReadStringFromFileHandle");
static_assert(sizeof(FReadStringFromFileHandle) == 0x000010, "Wrong size on FReadStringFromFileHandle");

// ScriptStruct V8.ReadStringFromFileAsyncData
// 0x0010 (0x0010 - 0x0000)
struct FReadStringFromFileAsyncData final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReadStringFromFileAsyncData) == 0x000008, "Wrong alignment on FReadStringFromFileAsyncData");
static_assert(sizeof(FReadStringFromFileAsyncData) == 0x000010, "Wrong size on FReadStringFromFileAsyncData");
static_assert(offsetof(FReadStringFromFileAsyncData, String) == 0x000000, "Member 'FReadStringFromFileAsyncData::String' has a wrong offset!");

// ScriptStruct V8.DirectoryItem
// 0x0018 (0x0018 - 0x0000)
struct FDirectoryItem final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDirectory;                                      // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDirectoryItem) == 0x000008, "Wrong alignment on FDirectoryItem");
static_assert(sizeof(FDirectoryItem) == 0x000018, "Wrong size on FDirectoryItem");
static_assert(offsetof(FDirectoryItem, Name) == 0x000000, "Member 'FDirectoryItem::Name' has a wrong offset!");
static_assert(offsetof(FDirectoryItem, bIsDirectory) == 0x000010, "Member 'FDirectoryItem::bIsDirectory' has a wrong offset!");

// ScriptStruct V8.JavascriptStat
// 0x0001 (0x0001 - 0x0000)
struct FJavascriptStat final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptStat) == 0x000001, "Wrong alignment on FJavascriptStat");
static_assert(sizeof(FJavascriptStat) == 0x000001, "Wrong size on FJavascriptStat");

// ScriptStruct V8.JavascriptLogCategory
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FJavascriptLogCategory final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptLogCategory) == 0x000008, "Wrong alignment on FJavascriptLogCategory");
static_assert(sizeof(FJavascriptLogCategory) == 0x000010, "Wrong size on FJavascriptLogCategory");

// ScriptStruct V8.JavascriptStreamableManager
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FJavascriptStreamableManager final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptStreamableManager) == 0x000008, "Wrong alignment on FJavascriptStreamableManager");
static_assert(sizeof(FJavascriptStreamableManager) == 0x000010, "Wrong size on FJavascriptStreamableManager");

// ScriptStruct V8.JavascriptStubStruct
// 0x0001 (0x0001 - 0x0000)
struct FJavascriptStubStruct final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptStubStruct) == 0x000001, "Wrong alignment on FJavascriptStubStruct");
static_assert(sizeof(FJavascriptStubStruct) == 0x000001, "Wrong size on FJavascriptStubStruct");

// ScriptStruct V8.JavascriptSocket
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FJavascriptSocket final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptSocket) == 0x000008, "Wrong alignment on FJavascriptSocket");
static_assert(sizeof(FJavascriptSocket) == 0x000010, "Wrong size on FJavascriptSocket");

// ScriptStruct V8.JavascriptInternetAddr
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FJavascriptInternetAddr final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptInternetAddr) == 0x000008, "Wrong alignment on FJavascriptInternetAddr");
static_assert(sizeof(FJavascriptInternetAddr) == 0x000010, "Wrong size on FJavascriptInternetAddr");

// ScriptStruct V8.JavscriptProperty
// 0x0020 (0x0020 - 0x0000)
struct FJavscriptProperty final
{
public:
	class FString                                 Type;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJavscriptProperty) == 0x000008, "Wrong alignment on FJavscriptProperty");
static_assert(sizeof(FJavscriptProperty) == 0x000020, "Wrong size on FJavscriptProperty");
static_assert(offsetof(FJavscriptProperty, Type) == 0x000000, "Member 'FJavscriptProperty::Type' has a wrong offset!");
static_assert(offsetof(FJavscriptProperty, Name) == 0x000010, "Member 'FJavscriptProperty::Name' has a wrong offset!");

// ScriptStruct V8.JavascriptText
// 0x0050 (0x0050 - 0x0000)
struct FJavascriptText final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Namespace;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TableId;                                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptText) == 0x000008, "Wrong alignment on FJavascriptText");
static_assert(sizeof(FJavascriptText) == 0x000050, "Wrong size on FJavascriptText");
static_assert(offsetof(FJavascriptText, String) == 0x000000, "Member 'FJavascriptText::String' has a wrong offset!");
static_assert(offsetof(FJavascriptText, Namespace) == 0x000010, "Member 'FJavascriptText::Namespace' has a wrong offset!");
static_assert(offsetof(FJavascriptText, Key) == 0x000020, "Member 'FJavascriptText::Key' has a wrong offset!");
static_assert(offsetof(FJavascriptText, TableId) == 0x000030, "Member 'FJavascriptText::TableId' has a wrong offset!");

// ScriptStruct V8.JavascriptCpuProfiler
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FJavascriptCpuProfiler final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptCpuProfiler) == 0x000008, "Wrong alignment on FJavascriptCpuProfiler");
static_assert(sizeof(FJavascriptCpuProfiler) == 0x000008, "Wrong size on FJavascriptCpuProfiler");

// ScriptStruct V8.JavascriptProfileNode
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FJavascriptProfileNode final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptProfileNode) == 0x000008, "Wrong alignment on FJavascriptProfileNode");
static_assert(sizeof(FJavascriptProfileNode) == 0x000008, "Wrong size on FJavascriptProfileNode");

// ScriptStruct V8.JavascriptAutomatedTestInstance
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FJavascriptAutomatedTestInstance final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FJavascriptAutomatedTestInstance) == 0x000008, "Wrong alignment on FJavascriptAutomatedTestInstance");
static_assert(sizeof(FJavascriptAutomatedTestInstance) == 0x000010, "Wrong size on FJavascriptAutomatedTestInstance");

// ScriptStruct V8.JavascriptAutomatedTestParameters
// 0x0020 (0x0020 - 0x0000)
struct FJavascriptAutomatedTestParameters final
{
public:
	class FString                                 TestFunctionName;                                  // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJavascriptAutomatedTestInstance       Tester;                                            // 0x0010(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FJavascriptAutomatedTestParameters) == 0x000008, "Wrong alignment on FJavascriptAutomatedTestParameters");
static_assert(sizeof(FJavascriptAutomatedTestParameters) == 0x000020, "Wrong size on FJavascriptAutomatedTestParameters");
static_assert(offsetof(FJavascriptAutomatedTestParameters, TestFunctionName) == 0x000000, "Member 'FJavascriptAutomatedTestParameters::TestFunctionName' has a wrong offset!");
static_assert(offsetof(FJavascriptAutomatedTestParameters, Tester) == 0x000010, "Member 'FJavascriptAutomatedTestParameters::Tester' has a wrong offset!");

// ScriptStruct V8.JavascriptAutomatedTest
// 0x0040 (0x0040 - 0x0000)
struct FJavascriptAutomatedTest final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComplexTask;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TestFlags;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredDeviceNum;                                 // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TestFunctionNames;                                 // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FJavascriptFunction                    Function;                                          // 0x0030(0x0010)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FJavascriptAutomatedTest) == 0x000008, "Wrong alignment on FJavascriptAutomatedTest");
static_assert(sizeof(FJavascriptAutomatedTest) == 0x000040, "Wrong size on FJavascriptAutomatedTest");
static_assert(offsetof(FJavascriptAutomatedTest, Name) == 0x000000, "Member 'FJavascriptAutomatedTest::Name' has a wrong offset!");
static_assert(offsetof(FJavascriptAutomatedTest, bComplexTask) == 0x000010, "Member 'FJavascriptAutomatedTest::bComplexTask' has a wrong offset!");
static_assert(offsetof(FJavascriptAutomatedTest, TestFlags) == 0x000014, "Member 'FJavascriptAutomatedTest::TestFlags' has a wrong offset!");
static_assert(offsetof(FJavascriptAutomatedTest, RequiredDeviceNum) == 0x000018, "Member 'FJavascriptAutomatedTest::RequiredDeviceNum' has a wrong offset!");
static_assert(offsetof(FJavascriptAutomatedTest, TestFunctionNames) == 0x000020, "Member 'FJavascriptAutomatedTest::TestFunctionNames' has a wrong offset!");
static_assert(offsetof(FJavascriptAutomatedTest, Function) == 0x000030, "Member 'FJavascriptAutomatedTest::Function' has a wrong offset!");

}

