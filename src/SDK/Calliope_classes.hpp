#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Calliope

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "GameplayTags_classes.hpp"
#include "Calliope_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "LevelSequence_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "MovieSceneTracks_structs.hpp"


namespace SDK
{

// Class Calliope.CalliopeSequencePerformer
// 0x0000 (0x0028 - 0x0028)
class ICalliopeSequencePerformer final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeSequencePerformer">();
	}
	static class ICalliopeSequencePerformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICalliopeSequencePerformer>();
	}
};
static_assert(alignof(ICalliopeSequencePerformer) == 0x000008, "Wrong alignment on ICalliopeSequencePerformer");
static_assert(sizeof(ICalliopeSequencePerformer) == 0x000028, "Wrong size on ICalliopeSequencePerformer");

// Class Calliope.CalliopeAsset
// 0x03C8 (0x03F0 - 0x0028)
class UCalliopeAsset : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CustomInputs;                                      // 0x0048(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CustomOutputs;                                     // 0x0068(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FCalliopeGuid, class UCalliopeNode*> Nodes;                                             // 0x0088(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TSet<class UCalliopeNode*>                    PreloadedNodes;                                    // 0x00D8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UCalliopeNode*>                  ActiveNodes;                                       // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCalliopeNode*>                  RecordedNodes;                                     // 0x0138(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExecuteHistory;                                    // 0x0148(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEditedDocumentInfo>            LastEditedDocuments;                               // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             BranchGraphNames;                                  // 0x0168(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UEdGraphSchema>             BranchGraphSchema;                                 // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           CategorySorting;                                   // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                NeedPreloadAssets;                                 // 0x01D0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCalliopeParameters                    CalliopeParameters;                                // 0x01E0(0x0170)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 SearchNodeGuid;                                    // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SearchNodeIndex;                                   // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x64];                                     // 0x0364(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	class UCalliopeAsset*                         TemplateAsset;                                     // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCalliopeAsset*>                 ActiveInstances;                                   // 0x03D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCalliopeAsset* CreateInstance(class UObject* Owner, class UCalliopeAsset* CalliopeAsset, const class FString& InstancePrefixName);

	void AddBranchGraph(const class FName& GraphName);
	bool AddParameter(const EGsManagedParamType& ParamType, const class FString& ObjectPath, const class FString& ActorGuid, const class FName& AliasName, int32 State, struct FCalliopeGuid* OutConfigGuid);
	void AssignParameterUnitTamerReference(const struct FCalliopeGuid& InConfigGuid, const class FString& ObjectPath);
	void ClearInvalidBranchGraph();
	void ClearParameters();
	void ClearRecordData();
	void DeactivateNode(const struct FCalliopeGuid& InGuid);
	void ExecuteSubGraphReconstructionRequested();
	bool ExportToData();
	void FinishInstance();
	bool GetParameterActorGuidByConfigGuid(const struct FCalliopeGuid& InConfigGuid, class FString* OutActorGuid);
	bool GetParameterBuffIDByConfigGuid(const struct FCalliopeGuid& InConfigGuid, int32* OutBuffID);
	bool GetParameterConfigGuidByActorGuid(const EGsManagedParamType& ParamType, const class FString& ParamValueString, const int32 ParamValueInt, const class FName& ParamValueName, struct FCalliopeGuid* OutGuid);
	bool GetParameterDisplayNameByConfigGuid(const struct FCalliopeGuid& InConfigGuid, const class FString& InPropertyName, class FString* OutDisplayName);
	bool GetParameterSequenceIDByConfigGuid(const struct FCalliopeGuid& InConfigGuid, int32* OutSequenceID);
	bool GetParameterTaskStateIDByConfigGuid(const struct FCalliopeGuid& InConfigGuid, int32* OutTaskStageID);
	void HarvestNodeConnections();
	void OnNodeActivate(const class UCalliopeNode* Node);
	void OnNodeDeactivate(const class UCalliopeNode* Node);
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);
	void OnRefreshAssetInCS();
	void PostDuplicateInCS(bool bDuplicateForPIE);
	void PostRefreshAssetInCS();
	void RecordInput(const struct FCalliopeGuid& InGuid, const class FName& InPinName);
	void RecordOnlyNode(const struct FCalliopeGuid& InGuid);
	void RecordOutput(const struct FCalliopeGuid& InGuid, const class FName& InPinName);
	void RegisterNode(const struct FCalliopeGuid& NewGuid, class UCalliopeNode* NewNode);
	void RemoveBranchGraph(const class FName& GraphName);
	void SetSubGraphAssetInPIE(const struct FCalliopeGuid& InGuid, class UCalliopeAsset* CalliopeAsset);
	void StartAsSubInstance(class UCalliopeAsset* ParentInstance, const struct FCalliopeGuid& InSubNodeGuid);
	void StartInstance();
	void UnregisterNode(const struct FCalliopeGuid& NodeGuid);
	void UpdateParameterActorReferenceAndAliasName(const class FString& ObjectPath, const class FString& ActorGuid, const class FName& AliasName);

	void BroadcastRegenerateToolbars() const;
	TArray<class FName> GetCustomInputs() const;
	TArray<class FName> GetCustomOutputs() const;
	int32 GetExtraDefaultInputNodes(TArray<class UClass*>* OutClasses) const;
	int32 GetExtraDefaultInputNodesInBranchGraph(TArray<class UClass*>* OutClasses) const;
	int32 GetExtraDefaultOutputNodes(TArray<class UClass*>* OutClasses) const;
	int32 GetExtraDefaultOutputNodesInBranchGraph(TArray<class UClass*>* OutClasses) const;
	class UCalliopeNode* GetNode(const struct FCalliopeGuid& InGuid) const;
	TMap<struct FCalliopeGuid, class UCalliopeNode*> GetNodes() const;
	class UClass* GetRerouteNodeClass() const;
	class UClass* GetRerouteNodeClassInBranchGraph() const;
	class UClass* GetStartNodeClass() const;
	class UClass* GetStartNodeClassInBranchGraph() const;
	ECalliopeViewType GetViewType() const;
	bool IsEditorOnlyCS() const;
	void PostStartInstance() const;
	void PreFinishInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeAsset">();
	}
	static class UCalliopeAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeAsset>();
	}
};
static_assert(alignof(UCalliopeAsset) == 0x000008, "Wrong alignment on UCalliopeAsset");
static_assert(sizeof(UCalliopeAsset) == 0x0003F0, "Wrong size on UCalliopeAsset");
static_assert(offsetof(UCalliopeAsset, CustomInputs) == 0x000048, "Member 'UCalliopeAsset::CustomInputs' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, CustomOutputs) == 0x000068, "Member 'UCalliopeAsset::CustomOutputs' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, Nodes) == 0x000088, "Member 'UCalliopeAsset::Nodes' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, PreloadedNodes) == 0x0000D8, "Member 'UCalliopeAsset::PreloadedNodes' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, ActiveNodes) == 0x000128, "Member 'UCalliopeAsset::ActiveNodes' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, RecordedNodes) == 0x000138, "Member 'UCalliopeAsset::RecordedNodes' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, ExecuteHistory) == 0x000148, "Member 'UCalliopeAsset::ExecuteHistory' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, LastEditedDocuments) == 0x000158, "Member 'UCalliopeAsset::LastEditedDocuments' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, BranchGraphNames) == 0x000168, "Member 'UCalliopeAsset::BranchGraphNames' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, BranchGraphSchema) == 0x0001B8, "Member 'UCalliopeAsset::BranchGraphSchema' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, CategorySorting) == 0x0001C0, "Member 'UCalliopeAsset::CategorySorting' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, NeedPreloadAssets) == 0x0001D0, "Member 'UCalliopeAsset::NeedPreloadAssets' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, CalliopeParameters) == 0x0001E0, "Member 'UCalliopeAsset::CalliopeParameters' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, SearchNodeGuid) == 0x000350, "Member 'UCalliopeAsset::SearchNodeGuid' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, SearchNodeIndex) == 0x000360, "Member 'UCalliopeAsset::SearchNodeIndex' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, TemplateAsset) == 0x0003C8, "Member 'UCalliopeAsset::TemplateAsset' has a wrong offset!");
static_assert(offsetof(UCalliopeAsset, ActiveInstances) == 0x0003D8, "Member 'UCalliopeAsset::ActiveInstances' has a wrong offset!");

// Class Calliope.CalliopeParameterMappingDataAsset
// 0x0040 (0x0070 - 0x0030)
class UCalliopeParameterMappingDataAsset final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UCalliopeAsset>          MappedAsset;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunTemplateInstance;                              // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCalliopeParameterMappingGroup> Groups;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void RefreshGroupsParameterValue();
	void RefreshParameters();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeParameterMappingDataAsset">();
	}
	static class UCalliopeParameterMappingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeParameterMappingDataAsset>();
	}
};
static_assert(alignof(UCalliopeParameterMappingDataAsset) == 0x000008, "Wrong alignment on UCalliopeParameterMappingDataAsset");
static_assert(sizeof(UCalliopeParameterMappingDataAsset) == 0x000070, "Wrong size on UCalliopeParameterMappingDataAsset");
static_assert(offsetof(UCalliopeParameterMappingDataAsset, MappedAsset) == 0x000030, "Member 'UCalliopeParameterMappingDataAsset::MappedAsset' has a wrong offset!");
static_assert(offsetof(UCalliopeParameterMappingDataAsset, bRunTemplateInstance) == 0x000058, "Member 'UCalliopeParameterMappingDataAsset::bRunTemplateInstance' has a wrong offset!");
static_assert(offsetof(UCalliopeParameterMappingDataAsset, Groups) == 0x000060, "Member 'UCalliopeParameterMappingDataAsset::Groups' has a wrong offset!");

// Class Calliope.CalliopeLevelSequenceActor
// 0x00B0 (0x03A0 - 0x02F0)
class ACalliopeLevelSequenceActor final : public ALevelSequenceActor
{
public:
	uint8                                         Pad_2F0[0xA8];                                     // 0x02F0(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationTime;                                      // 0x0398(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindActorByName(const class FName& BindingName, class AActor* BindingActor);
	void BindActorsByTag(const TMap<class FName, class AActor*>& TagActors);
	void LocateBoundActors();
	void MeshPrestreamTextures(class UMeshComponent* Mesh, float DurationTimeSeconds, bool bEnable);
	void MeshSetClothLocalSpaceSimulation(class UMeshComponent* Mesh, bool bEnable);
	void ReSetSequence(class ULevelSequence* InSequence);
	void SetAllMeshPropertyInSequence(bool bEnable);
	void SetAllPerformerTickEnabled(bool bEnable, TSet<class AActor*>* OutPerformers);
	void SetPaused(bool bInPaused);

	int32 GetBindingTags(TSet<class FName>* OutBindingTags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeLevelSequenceActor">();
	}
	static class ACalliopeLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACalliopeLevelSequenceActor>();
	}
};
static_assert(alignof(ACalliopeLevelSequenceActor) == 0x000008, "Wrong alignment on ACalliopeLevelSequenceActor");
static_assert(sizeof(ACalliopeLevelSequenceActor) == 0x0003A0, "Wrong size on ACalliopeLevelSequenceActor");
static_assert(offsetof(ACalliopeLevelSequenceActor, DurationTime) == 0x000398, "Member 'ACalliopeLevelSequenceActor::DurationTime' has a wrong offset!");

// Class Calliope.CalliopeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UCalliopeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MarkDirtyAllCalliopeTrack(class UMovieScene* InSequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeFunctionLibrary">();
	}
	static class UCalliopeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeFunctionLibrary>();
	}
};
static_assert(alignof(UCalliopeFunctionLibrary) == 0x000008, "Wrong alignment on UCalliopeFunctionLibrary");
static_assert(sizeof(UCalliopeFunctionLibrary) == 0x000028, "Wrong size on UCalliopeFunctionLibrary");

// Class Calliope.CalliopeGameplayTagLibrary
// 0x0000 (0x0028 - 0x0028)
class UCalliopeGameplayTagLibrary final : public UBlueprintGameplayTagLibrary
{
public:
	static bool AddGamePlayTagToINI(const class FString& NewTag, const class FString& Comment, class FName TagSourceName, bool bIsRestrictedTag, bool bAllowNonRestrictedChildren);
	static struct FGameplayTagContainer FilterTag(const struct FGameplayTagContainer& Container, const struct FGameplayTag& Tag, bool bExactMatch);
	static struct FGameplayTagContainer FilterTags(const struct FGameplayTagContainer& Container, const struct FGameplayTagContainer& OtherContainer, bool bExactMatch);
	static bool HasTagName(const struct FGameplayTagContainer& TagContainer, class FName TagName, bool bExactMatch);
	static struct FGameplayTagContainer MakeGameplayTagContainer();
	static struct FGameplayTag MakeGameplayTagFromName(const class FName& TagName);
	static struct FGameplayTag MakeGameplayTagFromString(const class FString& TagStr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeGameplayTagLibrary">();
	}
	static class UCalliopeGameplayTagLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeGameplayTagLibrary>();
	}
};
static_assert(alignof(UCalliopeGameplayTagLibrary) == 0x000008, "Wrong alignment on UCalliopeGameplayTagLibrary");
static_assert(sizeof(UCalliopeGameplayTagLibrary) == 0x000028, "Wrong size on UCalliopeGameplayTagLibrary");

// Class Calliope.CalliopeInteract
// 0x0000 (0x0028 - 0x0028)
class ICalliopeInteract final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeInteract">();
	}
	static class ICalliopeInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICalliopeInteract>();
	}
};
static_assert(alignof(ICalliopeInteract) == 0x000008, "Wrong alignment on ICalliopeInteract");
static_assert(sizeof(ICalliopeInteract) == 0x000028, "Wrong size on ICalliopeInteract");

// Class Calliope.CalliopeInteractor
// 0x0050 (0x0078 - 0x0028)
class UCalliopeInteractor : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FGuid ConvertCalliopeGuidToGuid(const struct FCalliopeGuid& InCalliopeGuid);
	static class UCalliopeInteractor* GetInstanceChecked();
	static void RegisterInstance(class UCalliopeInteractor* Instance);
	static void UnregisterInstance();

	class UClass* GetAssetClass(ECalliopeViewType InViewType);
	bool SetCustomInputNodeEventName(class UCalliopeNode* Node, const class FName& InEventName);
	bool SetCustomOutputNodeEventName(class UCalliopeNode* Node, const class FName& InEventName);

	int32 GetComponentObserverNodeClasses(TArray<class UClass*>* OutClasses) const;
	int32 GetCustomInputNodeClasses(TArray<class UClass*>* OutClasses) const;
	bool GetCustomInputNodeEventName(class UCalliopeNode* Node, class FName* OutEventName) const;
	int32 GetCustomOutputNodeClasses(TArray<class UClass*>* OutClasses) const;
	bool GetCustomOutputNodeEventName(class UCalliopeNode* Node, class FName* OutEventName) const;
	int32 GetExecutionMultiGateNodeClasses(TArray<class UClass*>* OutClasses) const;
	int32 GetExecutionSequenceNodeClasses(TArray<class UClass*>* OutClasses) const;
	int32 GetFinishNodeClasses(TArray<class UClass*>* OutClasses) const;
	int32 GetRerouteNodeClasses(TArray<class UClass*>* OutClasses) const;
	int32 GetStartNodeClasses(TArray<class UClass*>* OutClasses) const;
	int32 GetSubGraphNodeClasses(TArray<class UClass*>* OutClasses) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeInteractor">();
	}
	static class UCalliopeInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeInteractor>();
	}
};
static_assert(alignof(UCalliopeInteractor) == 0x000008, "Wrong alignment on UCalliopeInteractor");
static_assert(sizeof(UCalliopeInteractor) == 0x000078, "Wrong size on UCalliopeInteractor");

// Class Calliope.CalliopeLevelSequencePlayer
// 0x0010 (0x05E0 - 0x05D0)
class UCalliopeLevelSequencePlayer final : public ULevelSequencePlayer
{
public:
	int32                                         MovieInstanceIndex;                                // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeqJumpError;                                      // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                EventReceiver;                                     // 0x05D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UCalliopeLevelSequencePlayer* CreateCalliopeLevelSequencePlayer(class UObject* WorldContextObject, class ULevelSequence* LevelSequence, const struct FMovieSceneSequencePlaybackSettings& Settings, const struct FLevelSequenceCameraSettings& CameraSettings, class ACalliopeLevelSequenceActor** OutActor);
	static void FixSectionData(const class UMovieScene* InMovieScene);

	void SetEventReceiver(class UObject* InEventReceiver);
	void StopLooping();

	class UObject* GetPlaybackContext() const;
	bool TryGetMarkedFrameTime(const class FString& InFrameLabel, struct FFrameTime* OutFrameTime) const;
	bool TryGetMarkedSecond(const class FString& InFrameLabel, float* OutTimeSecond) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeLevelSequencePlayer">();
	}
	static class UCalliopeLevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeLevelSequencePlayer>();
	}
};
static_assert(alignof(UCalliopeLevelSequencePlayer) == 0x000008, "Wrong alignment on UCalliopeLevelSequencePlayer");
static_assert(sizeof(UCalliopeLevelSequencePlayer) == 0x0005E0, "Wrong size on UCalliopeLevelSequencePlayer");
static_assert(offsetof(UCalliopeLevelSequencePlayer, MovieInstanceIndex) == 0x0005D0, "Member 'UCalliopeLevelSequencePlayer::MovieInstanceIndex' has a wrong offset!");
static_assert(offsetof(UCalliopeLevelSequencePlayer, SeqJumpError) == 0x0005D4, "Member 'UCalliopeLevelSequencePlayer::SeqJumpError' has a wrong offset!");
static_assert(offsetof(UCalliopeLevelSequencePlayer, EventReceiver) == 0x0005D8, "Member 'UCalliopeLevelSequencePlayer::EventReceiver' has a wrong offset!");

// Class Calliope.CalliopeMovieSceneCameraCutSection
// 0x00A8 (0x0190 - 0x00E8)
class UCalliopeMovieSceneCameraCutSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLockPreviousCamera;                               // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  CameraGuid;                                        // 0x00F4(0x0010)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMovieSceneObjectBindingID             CameraBindingID;                                   // 0x0104(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialCameraCutTransform;                         // 0x0120(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bHasInitialCameraCutTransform;                     // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCameraBindingID(const struct FMovieSceneObjectBindingID& InCameraBindingID);

	const struct FMovieSceneObjectBindingID GetCameraBindingID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeMovieSceneCameraCutSection">();
	}
	static class UCalliopeMovieSceneCameraCutSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeMovieSceneCameraCutSection>();
	}
};
static_assert(alignof(UCalliopeMovieSceneCameraCutSection) == 0x000010, "Wrong alignment on UCalliopeMovieSceneCameraCutSection");
static_assert(sizeof(UCalliopeMovieSceneCameraCutSection) == 0x000190, "Wrong size on UCalliopeMovieSceneCameraCutSection");
static_assert(offsetof(UCalliopeMovieSceneCameraCutSection, bLockPreviousCamera) == 0x0000F0, "Member 'UCalliopeMovieSceneCameraCutSection::bLockPreviousCamera' has a wrong offset!");
static_assert(offsetof(UCalliopeMovieSceneCameraCutSection, CameraGuid) == 0x0000F4, "Member 'UCalliopeMovieSceneCameraCutSection::CameraGuid' has a wrong offset!");
static_assert(offsetof(UCalliopeMovieSceneCameraCutSection, CameraBindingID) == 0x000104, "Member 'UCalliopeMovieSceneCameraCutSection::CameraBindingID' has a wrong offset!");
static_assert(offsetof(UCalliopeMovieSceneCameraCutSection, InitialCameraCutTransform) == 0x000120, "Member 'UCalliopeMovieSceneCameraCutSection::InitialCameraCutTransform' has a wrong offset!");
static_assert(offsetof(UCalliopeMovieSceneCameraCutSection, bHasInitialCameraCutTransform) == 0x000180, "Member 'UCalliopeMovieSceneCameraCutSection::bHasInitialCameraCutTransform' has a wrong offset!");

// Class Calliope.CalliopeMovieSceneCameraCutTrack
// 0x0018 (0x00A8 - 0x0090)
class UCalliopeMovieSceneCameraCutTrack final : public UMovieSceneNameableTrack
{
public:
	bool                                          bCanBlend;                                         // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x0098(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeMovieSceneCameraCutTrack">();
	}
	static class UCalliopeMovieSceneCameraCutTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeMovieSceneCameraCutTrack>();
	}
};
static_assert(alignof(UCalliopeMovieSceneCameraCutTrack) == 0x000008, "Wrong alignment on UCalliopeMovieSceneCameraCutTrack");
static_assert(sizeof(UCalliopeMovieSceneCameraCutTrack) == 0x0000A8, "Wrong size on UCalliopeMovieSceneCameraCutTrack");
static_assert(offsetof(UCalliopeMovieSceneCameraCutTrack, bCanBlend) == 0x000090, "Member 'UCalliopeMovieSceneCameraCutTrack::bCanBlend' has a wrong offset!");
static_assert(offsetof(UCalliopeMovieSceneCameraCutTrack, Sections) == 0x000098, "Member 'UCalliopeMovieSceneCameraCutTrack::Sections' has a wrong offset!");

// Class Calliope.CalliopeMovieSceneCameraCutTrackInstance
// 0x0068 (0x00B8 - 0x0050)
class UCalliopeMovieSceneCameraCutTrackInstance final : public UMovieSceneTrackInstance
{
public:
	uint8                                         Pad_50[0x68];                                      // 0x0050(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeMovieSceneCameraCutTrackInstance">();
	}
	static class UCalliopeMovieSceneCameraCutTrackInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeMovieSceneCameraCutTrackInstance>();
	}
};
static_assert(alignof(UCalliopeMovieSceneCameraCutTrackInstance) == 0x000008, "Wrong alignment on UCalliopeMovieSceneCameraCutTrackInstance");
static_assert(sizeof(UCalliopeMovieSceneCameraCutTrackInstance) == 0x0000B8, "Wrong size on UCalliopeMovieSceneCameraCutTrackInstance");

// Class Calliope.CalliopeMovieSceneCinematicShotTrack
// 0x0000 (0x00A0 - 0x00A0)
class UCalliopeMovieSceneCinematicShotTrack final : public UMovieSceneSubTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeMovieSceneCinematicShotTrack">();
	}
	static class UCalliopeMovieSceneCinematicShotTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeMovieSceneCinematicShotTrack>();
	}
};
static_assert(alignof(UCalliopeMovieSceneCinematicShotTrack) == 0x000008, "Wrong alignment on UCalliopeMovieSceneCinematicShotTrack");
static_assert(sizeof(UCalliopeMovieSceneCinematicShotTrack) == 0x0000A0, "Wrong size on UCalliopeMovieSceneCinematicShotTrack");

// Class Calliope.CalliopeNode
// 0x0268 (0x0290 - 0x0028)
class UCalliopeNode : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEdGraphNode*                           GraphNode;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSupportsContextPins;                              // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Category;                                          // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECalliopeNodeStyle                            NodeStyle;                                         // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCalliopePin>                   InputPins;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCalliopePin>                   OutputPins;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCalliopeConnectedPin> Connections;                                       // 0x0078(0x0050)(Edit, BlueprintVisible, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0xE8];                                      // 0x00C8(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  NodeGuid;                                          // 0x01B0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNodeHasError;                                     // 0x01C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBossPhaseRequireActive;                           // 0x01C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0x2];                                      // 0x01C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NodeIndex;                                         // 0x01C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           InputNames;                                        // 0x01C8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<class FName>                           OutputNames;                                       // 0x01D8(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	struct FGsCalliopeNodeParam                   ParentNode;                                        // 0x01E8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSceneObjPoliceConfig                SceneObjPoliceConfig;                              // 0x01F8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void AddInputPins(const TArray<class FName>& PinNames);
	void AddOutputPins(const TArray<class FName>& PinNames);
	void AssignInteractorGroupIDPolice(int32 InIndex, int32 InGroupIDIndex);
	void BindAssetOnSubGraphReconstructionRequested(class UCalliopeAsset* Asset);
	bool CheckCanPassNodeInfo(const struct FCalliopeGuid& PreviousNodeGuid);
	void Cleanup();
	void Deactivate();
	void ExecuteOnReconstructionRequested();
	void ForceRefreshDetailView();
	class AActor* GetActorToFocusInCS();
	class FString GetAssetPathInCS();
	class UObject* GetAssetToEditInCS();
	bool GetBranchGraphToEditInCS(class FString* OutBranchGraphIdentifier);
	TMap<class FName, struct FCalliopeConnectedPin> GetConnections();
	TArray<class FName> GetContextInputsInCS();
	TArray<class FName> GetContextOutputsInCS();
	struct FCalliopePin GetDefaultInputPin();
	struct FCalliopePin GetDefaultOutputPin();
	bool IsBattleStateNode();
	bool IsCalliopeActive();
	bool IsCalliopeNeverActivated();
	bool IsCalliopeWasActive();
	void JumpToMe();
	class UCalliopeAsset* LoadAssetInCS(TSoftObjectPtr<class UCalliopeAsset> AssetPtr);
	void LogError(const class FString& Message);
	void PostLoadInCS();
	void PostPropertyChanged(const class FString& MemberName, const class FString& PropertyName);
	void PrePropertyChanged(const class FString& PropertyName);
	void RecordInput(const class FName& PinName);
	void RecordOutput(const class FName& PinName);
	void RefreshParentNode();
	void RefreshSceneObjPoliceConfig(class UCalliopeNode* PreviousNode);
	void ResetRecordsInCS();
	void SetConnections(TMap<class FName, struct FCalliopeConnectedPin>* InConnections);
	void SetInputPins(const TArray<struct FCalliopePin>& InInputPins);
	void SetOutputPins(const TArray<struct FCalliopePin>& InOutputPins);
	void SyncSceneObjPoliceConfig();
	void UnBindAssetOnSubGraphReconstructionRequested(class UCalliopeAsset* Asset);

	bool CanUserAddInputInCS() const;
	bool CanUserAddOutputInCS() const;
	class UCalliopeAsset* GetCalliopeAsset() const;
	struct FCalliopeConnectedPin GetConnection(const class FName OutputName) const;
	bool GetGraphGuidInCS(struct FCalliopeGuid* OutGraphGuid) const;
	bool GetGraphIdentifierInCS(class FName* OutGraphIdentifier) const;
	class UEdGraphNode* GetGraphNodeInCS() const;
	struct FCalliopeGuid GetGuid() const;
	TArray<class FName> GetInputNames() const;
	TArray<struct FCalliopePin> GetInputPins() const;
	class FString GetNodeDescriptionInCS() const;
	TArray<class FName> GetOutputNames() const;
	TArray<struct FCalliopePin> GetOutputPins() const;
	TArray<struct FCalliopeGuid> GetParentNodes() const;
	class FString GetStatusStringInCS() const;
	bool IsBranchGraphNode() const;
	bool IsOutputConnectTo(const struct FCalliopeGuid& TargetNodeGuid) const;
	bool IsPlayInEditor() const;
	bool IsPreloaded() const;
	bool IsSubGraphNode() const;
	bool IsSupportViewType(const ECalliopeViewType& InViewType) const;
	void OnRefreshAssetInCS() const;
	void OnSelectNodeInCS() const;
	void SetSubGraphAssetInPIE(class UCalliopeAsset* InSubGraphAsset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeNode">();
	}
	static class UCalliopeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeNode>();
	}
};
static_assert(alignof(UCalliopeNode) == 0x000008, "Wrong alignment on UCalliopeNode");
static_assert(sizeof(UCalliopeNode) == 0x000290, "Wrong size on UCalliopeNode");
static_assert(offsetof(UCalliopeNode, GraphNode) == 0x000030, "Member 'UCalliopeNode::GraphNode' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, bSupportsContextPins) == 0x000038, "Member 'UCalliopeNode::bSupportsContextPins' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, Category) == 0x000040, "Member 'UCalliopeNode::Category' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, NodeStyle) == 0x000050, "Member 'UCalliopeNode::NodeStyle' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, InputPins) == 0x000058, "Member 'UCalliopeNode::InputPins' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, OutputPins) == 0x000068, "Member 'UCalliopeNode::OutputPins' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, Connections) == 0x000078, "Member 'UCalliopeNode::Connections' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, NodeGuid) == 0x0001B0, "Member 'UCalliopeNode::NodeGuid' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, bNodeHasError) == 0x0001C0, "Member 'UCalliopeNode::bNodeHasError' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, bBossPhaseRequireActive) == 0x0001C1, "Member 'UCalliopeNode::bBossPhaseRequireActive' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, NodeIndex) == 0x0001C4, "Member 'UCalliopeNode::NodeIndex' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, InputNames) == 0x0001C8, "Member 'UCalliopeNode::InputNames' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, OutputNames) == 0x0001D8, "Member 'UCalliopeNode::OutputNames' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, ParentNode) == 0x0001E8, "Member 'UCalliopeNode::ParentNode' has a wrong offset!");
static_assert(offsetof(UCalliopeNode, SceneObjPoliceConfig) == 0x0001F8, "Member 'UCalliopeNode::SceneObjPoliceConfig' has a wrong offset!");

// Class Calliope.CalliopeSettings
// 0x0058 (0x0090 - 0x0038)
class UCalliopeSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnableDebugLogs;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateCalliopeSubsystemOnClients;                 // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UCalliopeNode>, int32> DefaultPreloadDepth;                               // 0x0040(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalliopeSettings">();
	}
	static class UCalliopeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalliopeSettings>();
	}
};
static_assert(alignof(UCalliopeSettings) == 0x000008, "Wrong alignment on UCalliopeSettings");
static_assert(sizeof(UCalliopeSettings) == 0x000090, "Wrong size on UCalliopeSettings");
static_assert(offsetof(UCalliopeSettings, bEnableDebugLogs) == 0x000038, "Member 'UCalliopeSettings::bEnableDebugLogs' has a wrong offset!");
static_assert(offsetof(UCalliopeSettings, bCreateCalliopeSubsystemOnClients) == 0x000039, "Member 'UCalliopeSettings::bCreateCalliopeSubsystemOnClients' has a wrong offset!");
static_assert(offsetof(UCalliopeSettings, DefaultPreloadDepth) == 0x000040, "Member 'UCalliopeSettings::DefaultPreloadDepth' has a wrong offset!");

// Class Calliope.GsSmartParamObject
// 0x0000 (0x0028 - 0x0028)
class IGsSmartParamObject final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GsSmartParamObject">();
	}
	static class IGsSmartParamObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGsSmartParamObject>();
	}
};
static_assert(alignof(IGsSmartParamObject) == 0x000008, "Wrong alignment on IGsSmartParamObject");
static_assert(sizeof(IGsSmartParamObject) == 0x000028, "Wrong size on IGsSmartParamObject");

// Class Calliope.MovieSceneCalliopeSectionData
// 0x0098 (0x00C0 - 0x0028)
class UMovieSceneCalliopeSectionData : public UObject
{
public:
	bool                                          bValid;                                            // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPreview;                                        // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x96];                                      // 0x002A(0x0096)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCalliopeLevelSequencePlayer* GetCalliopePlayer();
	class UObject* GetPlaybackContext();

	struct FCalliopeGuid GetObjectBindingID() const;
	int32 GetSequenceID() const;
	EMovieScenePlayerStatus GetStatus() const;
	float GetTimeInSeconds() const;
	bool HasJumped() const;
	bool IsForwardPlay() const;
	bool IsOperandValid() const;
	bool IsSilent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneCalliopeSectionData">();
	}
	static class UMovieSceneCalliopeSectionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneCalliopeSectionData>();
	}
};
static_assert(alignof(UMovieSceneCalliopeSectionData) == 0x000008, "Wrong alignment on UMovieSceneCalliopeSectionData");
static_assert(sizeof(UMovieSceneCalliopeSectionData) == 0x0000C0, "Wrong size on UMovieSceneCalliopeSectionData");
static_assert(offsetof(UMovieSceneCalliopeSectionData, bValid) == 0x000028, "Member 'UMovieSceneCalliopeSectionData::bValid' has a wrong offset!");
static_assert(offsetof(UMovieSceneCalliopeSectionData, bIsPreview) == 0x000029, "Member 'UMovieSceneCalliopeSectionData::bIsPreview' has a wrong offset!");

// Class Calliope.MovieSceneCalliopeSectionBase
// 0x0010 (0x00F8 - 0x00E8)
class UMovieSceneCalliopeSectionBase : public UMovieSceneSection
{
public:
	struct FMovieSceneFrameRange                  PlaybackRange;                                     // 0x00E8(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	class FString GetDisplayName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneCalliopeSectionBase">();
	}
	static class UMovieSceneCalliopeSectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneCalliopeSectionBase>();
	}
};
static_assert(alignof(UMovieSceneCalliopeSectionBase) == 0x000008, "Wrong alignment on UMovieSceneCalliopeSectionBase");
static_assert(sizeof(UMovieSceneCalliopeSectionBase) == 0x0000F8, "Wrong size on UMovieSceneCalliopeSectionBase");
static_assert(offsetof(UMovieSceneCalliopeSectionBase, PlaybackRange) == 0x0000E8, "Member 'UMovieSceneCalliopeSectionBase::PlaybackRange' has a wrong offset!");

// Class Calliope.MovieSceneCalliopeNormalSection
// 0x0008 (0x0100 - 0x00F8)
class UMovieSceneCalliopeNormalSection : public UMovieSceneCalliopeSectionBase
{
public:
	class FName                                   SectionNameForShow;                                // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Evaluate(class UMovieSceneCalliopeSectionData* InSectionData);
	float GetDurationTime();

	float GetEndTime() const;
	float GetMovieMaxDuration() const;
	float GetStartTime() const;
	class UMovieSceneCalliopeSectionData* MakeSectionData() const;
	void SectionBeingDestroyed(class UMovieSceneCalliopeSectionData* InSectionData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneCalliopeNormalSection">();
	}
	static class UMovieSceneCalliopeNormalSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneCalliopeNormalSection>();
	}
};
static_assert(alignof(UMovieSceneCalliopeNormalSection) == 0x000008, "Wrong alignment on UMovieSceneCalliopeNormalSection");
static_assert(sizeof(UMovieSceneCalliopeNormalSection) == 0x000100, "Wrong size on UMovieSceneCalliopeNormalSection");
static_assert(offsetof(UMovieSceneCalliopeNormalSection, SectionNameForShow) == 0x0000F8, "Member 'UMovieSceneCalliopeNormalSection::SectionNameForShow' has a wrong offset!");

// Class Calliope.MovieSceneCalliopeNotifySection
// 0x0008 (0x0100 - 0x00F8)
class UMovieSceneCalliopeNotifySection : public UMovieSceneCalliopeSectionBase
{
public:
	class FName                                   NotifyNameForShow;                                 // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetDurationTime();
	void OnNotify(class UCalliopeLevelSequencePlayer* Player, int32 InStatus, bool bInBackwards);
	void OnPreviewNotify(class UObject* InPlaybackContext, int32 InStatus, bool bInBackwards);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneCalliopeNotifySection">();
	}
	static class UMovieSceneCalliopeNotifySection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneCalliopeNotifySection>();
	}
};
static_assert(alignof(UMovieSceneCalliopeNotifySection) == 0x000008, "Wrong alignment on UMovieSceneCalliopeNotifySection");
static_assert(sizeof(UMovieSceneCalliopeNotifySection) == 0x000100, "Wrong size on UMovieSceneCalliopeNotifySection");
static_assert(offsetof(UMovieSceneCalliopeNotifySection, NotifyNameForShow) == 0x0000F8, "Member 'UMovieSceneCalliopeNotifySection::NotifyNameForShow' has a wrong offset!");

// Class Calliope.MovieSceneCalliopeNotifyStateSection
// 0x0008 (0x0100 - 0x00F8)
class UMovieSceneCalliopeNotifyStateSection : public UMovieSceneCalliopeSectionBase
{
public:
	class FName                                   NotifyStateNameForShow;                            // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetDurationTime();
	void OnNotifyBegin(class UCalliopeLevelSequencePlayer* Player, int32 InStatus, bool bInBackwards);
	void OnNotifyEnd(class UCalliopeLevelSequencePlayer* Player, int32 InStatus, bool bInBackwards);
	void OnNotifyTick(class UCalliopeLevelSequencePlayer* Player, int32 InStatus, bool bInBackwards);
	void OnPreviewNotifyBegin(class UObject* InPlaybackContext, int32 InStatus, bool bInBackwards);
	void OnPreviewNotifyEnd(class UObject* InPlaybackContext, int32 InStatus, bool bInBackwards);
	void OnPreviewNotifyTick(class UObject* InPlaybackContext, int32 InStatus, bool bInBackwards);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneCalliopeNotifyStateSection">();
	}
	static class UMovieSceneCalliopeNotifyStateSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneCalliopeNotifyStateSection>();
	}
};
static_assert(alignof(UMovieSceneCalliopeNotifyStateSection) == 0x000008, "Wrong alignment on UMovieSceneCalliopeNotifyStateSection");
static_assert(sizeof(UMovieSceneCalliopeNotifyStateSection) == 0x000100, "Wrong size on UMovieSceneCalliopeNotifyStateSection");
static_assert(offsetof(UMovieSceneCalliopeNotifyStateSection, NotifyStateNameForShow) == 0x0000F8, "Member 'UMovieSceneCalliopeNotifyStateSection::NotifyStateNameForShow' has a wrong offset!");

// Class Calliope.MovieSceneCalliopeTrack
// 0x0020 (0x00B0 - 0x0090)
class UMovieSceneCalliopeTrack final : public UMovieSceneNameableTrack
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFireEventsAtPosition                         EventPosition;                                     // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneCalliopeTrack">();
	}
	static class UMovieSceneCalliopeTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneCalliopeTrack>();
	}
};
static_assert(alignof(UMovieSceneCalliopeTrack) == 0x000008, "Wrong alignment on UMovieSceneCalliopeTrack");
static_assert(sizeof(UMovieSceneCalliopeTrack) == 0x0000B0, "Wrong size on UMovieSceneCalliopeTrack");
static_assert(offsetof(UMovieSceneCalliopeTrack, EventPosition) == 0x00009C, "Member 'UMovieSceneCalliopeTrack::EventPosition' has a wrong offset!");
static_assert(offsetof(UMovieSceneCalliopeTrack, Sections) == 0x0000A0, "Member 'UMovieSceneCalliopeTrack::Sections' has a wrong offset!");

}

