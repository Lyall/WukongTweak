#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: b1

#include "Basic.hpp"

#include "b1_structs.hpp"
#include "AIModule_structs.hpp"
#include "ProceduralMeshComponent_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Calliope_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "UnrealExtent_structs.hpp"
#include "AkAudio_structs.hpp"
#include "AsyncLoadingScreen_structs.hpp"
#include "NetCore_structs.hpp"


namespace SDK::Params
{

// Function b1.ActorDataContainer.AddDataObjInCS
// 0x0008 (0x0008 - 0x0000)
struct ActorDataContainer_AddDataObjInCS final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorDataContainer_AddDataObjInCS) == 0x000008, "Wrong alignment on ActorDataContainer_AddDataObjInCS");
static_assert(sizeof(ActorDataContainer_AddDataObjInCS) == 0x000008, "Wrong size on ActorDataContainer_AddDataObjInCS");
static_assert(offsetof(ActorDataContainer_AddDataObjInCS, Obj) == 0x000000, "Member 'ActorDataContainer_AddDataObjInCS::Obj' has a wrong offset!");

// Function b1.ActorCompContainer.FillDataContainer
// 0x0008 (0x0008 - 0x0000)
struct ActorCompContainer_FillDataContainer final
{
public:
	class UActorDataContainer*                    DataObj;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorCompContainer_FillDataContainer) == 0x000008, "Wrong alignment on ActorCompContainer_FillDataContainer");
static_assert(sizeof(ActorCompContainer_FillDataContainer) == 0x000008, "Wrong size on ActorCompContainer_FillDataContainer");
static_assert(offsetof(ActorCompContainer_FillDataContainer, DataObj) == 0x000000, "Member 'ActorCompContainer_FillDataContainer::DataObj' has a wrong offset!");

// Function b1.ActorCompContainer.FillEventCollection
// 0x0008 (0x0008 - 0x0000)
struct ActorCompContainer_FillEventCollection final
{
public:
	class UObject*                                DataObj;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorCompContainer_FillEventCollection) == 0x000008, "Wrong alignment on ActorCompContainer_FillEventCollection");
static_assert(sizeof(ActorCompContainer_FillEventCollection) == 0x000008, "Wrong size on ActorCompContainer_FillEventCollection");
static_assert(offsetof(ActorCompContainer_FillEventCollection, DataObj) == 0x000000, "Member 'ActorCompContainer_FillEventCollection::DataObj' has a wrong offset!");

// Function b1.ActorCompContainer.SetTeamID
// 0x0004 (0x0004 - 0x0000)
struct ActorCompContainer_SetTeamID final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorCompContainer_SetTeamID) == 0x000004, "Wrong alignment on ActorCompContainer_SetTeamID");
static_assert(sizeof(ActorCompContainer_SetTeamID) == 0x000004, "Wrong size on ActorCompContainer_SetTeamID");
static_assert(offsetof(ActorCompContainer_SetTeamID, ID) == 0x000000, "Member 'ActorCompContainer_SetTeamID::ID' has a wrong offset!");

// Function b1.BGUCrowdFollowingComponent.SetCrowdFollowingEnabled
// 0x0002 (0x0002 - 0x0000)
struct BGUCrowdFollowingComponent_SetCrowdFollowingEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsObstacle;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCrowdFollowingComponent_SetCrowdFollowingEnabled) == 0x000001, "Wrong alignment on BGUCrowdFollowingComponent_SetCrowdFollowingEnabled");
static_assert(sizeof(BGUCrowdFollowingComponent_SetCrowdFollowingEnabled) == 0x000002, "Wrong size on BGUCrowdFollowingComponent_SetCrowdFollowingEnabled");
static_assert(offsetof(BGUCrowdFollowingComponent_SetCrowdFollowingEnabled, bEnabled) == 0x000000, "Member 'BGUCrowdFollowingComponent_SetCrowdFollowingEnabled::bEnabled' has a wrong offset!");
static_assert(offsetof(BGUCrowdFollowingComponent_SetCrowdFollowingEnabled, bIsObstacle) == 0x000001, "Member 'BGUCrowdFollowingComponent_SetCrowdFollowingEnabled::bIsObstacle' has a wrong offset!");

// Function b1.BGUCrowdFollowingComponent.SetCrowdFollowingParam
// 0x0010 (0x0010 - 0x0000)
struct BGUCrowdFollowingComponent_SetCrowdFollowingParam final
{
public:
	float                                         FSeparationWeight;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCollisionQueryRange;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPathOptimizationRange;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IAvoidanceQualityLevel;                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCrowdFollowingComponent_SetCrowdFollowingParam) == 0x000004, "Wrong alignment on BGUCrowdFollowingComponent_SetCrowdFollowingParam");
static_assert(sizeof(BGUCrowdFollowingComponent_SetCrowdFollowingParam) == 0x000010, "Wrong size on BGUCrowdFollowingComponent_SetCrowdFollowingParam");
static_assert(offsetof(BGUCrowdFollowingComponent_SetCrowdFollowingParam, FSeparationWeight) == 0x000000, "Member 'BGUCrowdFollowingComponent_SetCrowdFollowingParam::FSeparationWeight' has a wrong offset!");
static_assert(offsetof(BGUCrowdFollowingComponent_SetCrowdFollowingParam, FCollisionQueryRange) == 0x000004, "Member 'BGUCrowdFollowingComponent_SetCrowdFollowingParam::FCollisionQueryRange' has a wrong offset!");
static_assert(offsetof(BGUCrowdFollowingComponent_SetCrowdFollowingParam, FPathOptimizationRange) == 0x000008, "Member 'BGUCrowdFollowingComponent_SetCrowdFollowingParam::FPathOptimizationRange' has a wrong offset!");
static_assert(offsetof(BGUCrowdFollowingComponent_SetCrowdFollowingParam, IAvoidanceQualityLevel) == 0x00000C, "Member 'BGUCrowdFollowingComponent_SetCrowdFollowingParam::IAvoidanceQualityLevel' has a wrong offset!");

// Function b1.AnimNotifyFuncLibrary.DeleteAnimNotifyAndAnimNotifyState
// 0x0028 (0x0028 - 0x0000)
struct AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGsEnAnimN>                            NotifyTypeList;                                    // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EGsEnAnimNS>                           NotifyStateTypeList;                               // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState) == 0x000008, "Wrong alignment on AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState");
static_assert(sizeof(AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState) == 0x000028, "Wrong size on AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState");
static_assert(offsetof(AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState, AnimMontage) == 0x000000, "Member 'AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState::AnimMontage' has a wrong offset!");
static_assert(offsetof(AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState, NotifyTypeList) == 0x000008, "Member 'AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState::NotifyTypeList' has a wrong offset!");
static_assert(offsetof(AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState, NotifyStateTypeList) == 0x000018, "Member 'AnimNotifyFuncLibrary_DeleteAnimNotifyAndAnimNotifyState::NotifyStateTypeList' has a wrong offset!");

// Function b1.AnimNotifyFuncLibrary.GetAllAnimNotifySoftAsset
// 0x00A8 (0x00A8 - 0x0000)
struct AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset final
{
public:
	class UAnimSequenceBase*                      AnimBase;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UAnimNotify_GSBase*, struct FNotifySoftRefs> OutNotifyRefs;                                     // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<class UAnimNotifyState_GSBase*, struct FNotifySoftRefs> OutNotifyStateRefs;                                // 0x0058(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset) == 0x000008, "Wrong alignment on AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset");
static_assert(sizeof(AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset) == 0x0000A8, "Wrong size on AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset");
static_assert(offsetof(AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset, AnimBase) == 0x000000, "Member 'AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset::AnimBase' has a wrong offset!");
static_assert(offsetof(AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset, OutNotifyRefs) == 0x000008, "Member 'AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset::OutNotifyRefs' has a wrong offset!");
static_assert(offsetof(AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset, OutNotifyStateRefs) == 0x000058, "Member 'AnimNotifyFuncLibrary_GetAllAnimNotifySoftAsset::OutNotifyStateRefs' has a wrong offset!");

// Function b1.AnimNotifyFuncLibrary.PrepareAnimationsNotifySoftAsset
// 0x00B0 (0x00B0 - 0x0000)
struct AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset final
{
public:
	TArray<class UAnimSequenceBase*>              AnimBases;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UAnimNotify_GSBase*, struct FNotifySoftRefs> OutNotifyRefs;                                     // 0x0010(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<class UAnimNotifyState_GSBase*, struct FNotifySoftRefs> OutNotifyStateRefs;                                // 0x0060(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset) == 0x000008, "Wrong alignment on AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset");
static_assert(sizeof(AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset) == 0x0000B0, "Wrong size on AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset");
static_assert(offsetof(AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset, AnimBases) == 0x000000, "Member 'AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset::AnimBases' has a wrong offset!");
static_assert(offsetof(AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset, OutNotifyRefs) == 0x000010, "Member 'AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset::OutNotifyRefs' has a wrong offset!");
static_assert(offsetof(AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset, OutNotifyStateRefs) == 0x000060, "Member 'AnimNotifyFuncLibrary_PrepareAnimationsNotifySoftAsset::OutNotifyStateRefs' has a wrong offset!");

// Function b1.AnimNotifyFuncLibrary.PrepareAnimNotifySoftAsset
// 0x00A8 (0x00A8 - 0x0000)
struct AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset final
{
public:
	class UAnimSequenceBase*                      AnimBase;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UAnimNotify_GSBase*, struct FNotifySoftRefs> OutNotifyRefs;                                     // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<class UAnimNotifyState_GSBase*, struct FNotifySoftRefs> OutNotifyStateRefs;                                // 0x0058(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset) == 0x000008, "Wrong alignment on AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset");
static_assert(sizeof(AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset) == 0x0000A8, "Wrong size on AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset");
static_assert(offsetof(AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset, AnimBase) == 0x000000, "Member 'AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset::AnimBase' has a wrong offset!");
static_assert(offsetof(AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset, OutNotifyRefs) == 0x000008, "Member 'AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset::OutNotifyRefs' has a wrong offset!");
static_assert(offsetof(AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset, OutNotifyStateRefs) == 0x000058, "Member 'AnimNotifyFuncLibrary_PrepareAnimNotifySoftAsset::OutNotifyStateRefs' has a wrong offset!");

// Function b1.BGUDataComp.InitWithAIController
// 0x0008 (0x0008 - 0x0000)
struct BGUDataComp_InitWithAIController final
{
public:
	class ABGUAIController*                       AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDataComp_InitWithAIController) == 0x000008, "Wrong alignment on BGUDataComp_InitWithAIController");
static_assert(sizeof(BGUDataComp_InitWithAIController) == 0x000008, "Wrong size on BGUDataComp_InitWithAIController");
static_assert(offsetof(BGUDataComp_InitWithAIController, AIController) == 0x000000, "Member 'BGUDataComp_InitWithAIController::AIController' has a wrong offset!");

// Function b1.BGUDataComp.InitWithCharacter
// 0x0008 (0x0008 - 0x0000)
struct BGUDataComp_InitWithCharacter final
{
public:
	class ABGUCharacter*                          Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDataComp_InitWithCharacter) == 0x000008, "Wrong alignment on BGUDataComp_InitWithCharacter");
static_assert(sizeof(BGUDataComp_InitWithCharacter) == 0x000008, "Wrong size on BGUDataComp_InitWithCharacter");
static_assert(offsetof(BGUDataComp_InitWithCharacter, Character) == 0x000000, "Member 'BGUDataComp_InitWithCharacter::Character' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.AddPreloadedAsset
// 0x0008 (0x0008 - 0x0000)
struct AnimNotifyState_GSBase_AddPreloadedAsset final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_AddPreloadedAsset) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_AddPreloadedAsset");
static_assert(sizeof(AnimNotifyState_GSBase_AddPreloadedAsset) == 0x000008, "Wrong size on AnimNotifyState_GSBase_AddPreloadedAsset");
static_assert(offsetof(AnimNotifyState_GSBase_AddPreloadedAsset, Obj) == 0x000000, "Member 'AnimNotifyState_GSBase_AddPreloadedAsset::Obj' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GetAnimNSType
// 0x0001 (0x0001 - 0x0000)
struct AnimNotifyState_GSBase_GetAnimNSType final
{
public:
	EGsEnAnimNS                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_GetAnimNSType) == 0x000001, "Wrong alignment on AnimNotifyState_GSBase_GetAnimNSType");
static_assert(sizeof(AnimNotifyState_GSBase_GetAnimNSType) == 0x000001, "Wrong size on AnimNotifyState_GSBase_GetAnimNSType");
static_assert(offsetof(AnimNotifyState_GSBase_GetAnimNSType, ReturnValue) == 0x000000, "Member 'AnimNotifyState_GSBase_GetAnimNSType::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GetJumpableSectionPrefix
// 0x0010 (0x0010 - 0x0000)
struct AnimNotifyState_GSBase_GetJumpableSectionPrefix final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_GetJumpableSectionPrefix) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GetJumpableSectionPrefix");
static_assert(sizeof(AnimNotifyState_GSBase_GetJumpableSectionPrefix) == 0x000010, "Wrong size on AnimNotifyState_GSBase_GetJumpableSectionPrefix");
static_assert(offsetof(AnimNotifyState_GSBase_GetJumpableSectionPrefix, ReturnValue) == 0x000000, "Member 'AnimNotifyState_GSBase_GetJumpableSectionPrefix::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GetModifySpeedRate
// 0x0004 (0x0004 - 0x0000)
struct AnimNotifyState_GSBase_GetModifySpeedRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_GetModifySpeedRate) == 0x000004, "Wrong alignment on AnimNotifyState_GSBase_GetModifySpeedRate");
static_assert(sizeof(AnimNotifyState_GSBase_GetModifySpeedRate) == 0x000004, "Wrong size on AnimNotifyState_GSBase_GetModifySpeedRate");
static_assert(offsetof(AnimNotifyState_GSBase_GetModifySpeedRate, ReturnValue) == 0x000000, "Member 'AnimNotifyState_GSBase_GetModifySpeedRate::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GetPreloadedAssets
// 0x0010 (0x0010 - 0x0000)
struct AnimNotifyState_GSBase_GetPreloadedAssets final
{
public:
	TArray<class UObject*>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_GetPreloadedAssets) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GetPreloadedAssets");
static_assert(sizeof(AnimNotifyState_GSBase_GetPreloadedAssets) == 0x000010, "Wrong size on AnimNotifyState_GSBase_GetPreloadedAssets");
static_assert(offsetof(AnimNotifyState_GSBase_GetPreloadedAssets, ReturnValue) == 0x000000, "Member 'AnimNotifyState_GSBase_GetPreloadedAssets::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GetSoftReferences
// 0x0010 (0x0010 - 0x0000)
struct AnimNotifyState_GSBase_GetSoftReferences final
{
public:
	TArray<struct FSoftObjectPath>                ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_GetSoftReferences) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GetSoftReferences");
static_assert(sizeof(AnimNotifyState_GSBase_GetSoftReferences) == 0x000010, "Wrong size on AnimNotifyState_GSBase_GetSoftReferences");
static_assert(offsetof(AnimNotifyState_GSBase_GetSoftReferences, ReturnValue) == 0x000000, "Member 'AnimNotifyState_GSBase_GetSoftReferences::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSAllowCrossSection
// 0x0001 (0x0001 - 0x0000)
struct AnimNotifyState_GSBase_GSAllowCrossSection final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_GSAllowCrossSection) == 0x000001, "Wrong alignment on AnimNotifyState_GSBase_GSAllowCrossSection");
static_assert(sizeof(AnimNotifyState_GSBase_GSAllowCrossSection) == 0x000001, "Wrong size on AnimNotifyState_GSBase_GSAllowCrossSection");
static_assert(offsetof(AnimNotifyState_GSBase_GSAllowCrossSection, ReturnValue) == 0x000000, "Member 'AnimNotifyState_GSBase_GSAllowCrossSection::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyBeginCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyBeginCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TotalDuration;                                     // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyBeginCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyBeginCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyBeginCS) == 0x000048, "Wrong size on AnimNotifyState_GSBase_GSNotifyBeginCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyBeginCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyBeginCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyBeginCS, TotalDuration) == 0x000040, "Member 'AnimNotifyState_GSBase_GSNotifyBeginCS::TotalDuration' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyDebugPostBeginCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS) == 0x000048, "Wrong size on AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS, ReturnValue) == 0x000040, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPostBeginCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyDebugPostEndCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyDebugPostEndCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyDebugPostEndCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyDebugPostEndCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyDebugPostEndCS) == 0x000048, "Wrong size on AnimNotifyState_GSBase_GSNotifyDebugPostEndCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPostEndCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPostEndCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPostEndCS, ReturnValue) == 0x000040, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPostEndCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyDebugPostTickCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyDebugPostTickCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyDebugPostTickCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyDebugPostTickCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyDebugPostTickCS) == 0x000048, "Wrong size on AnimNotifyState_GSBase_GSNotifyDebugPostTickCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPostTickCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPostTickCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPostTickCS, ReturnValue) == 0x000040, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPostTickCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyDebugPreBeginCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS) == 0x000048, "Wrong size on AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS, ReturnValue) == 0x000040, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPreBeginCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyDebugPreEndCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyDebugPreEndCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyDebugPreEndCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyDebugPreEndCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyDebugPreEndCS) == 0x000048, "Wrong size on AnimNotifyState_GSBase_GSNotifyDebugPreEndCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPreEndCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPreEndCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPreEndCS, ReturnValue) == 0x000040, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPreEndCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyDebugPreTickCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyDebugPreTickCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyDebugPreTickCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyDebugPreTickCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyDebugPreTickCS) == 0x000048, "Wrong size on AnimNotifyState_GSBase_GSNotifyDebugPreTickCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPreTickCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPreTickCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyDebugPreTickCS, ReturnValue) == 0x000040, "Member 'AnimNotifyState_GSBase_GSNotifyDebugPreTickCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyEndCS
// 0x0040 (0x0040 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyEndCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyEndCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyEndCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyEndCS) == 0x000040, "Wrong size on AnimNotifyState_GSBase_GSNotifyEndCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyEndCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyEndCS::NotifyParam' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSNotifyTickCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotifyState_GSBase_GSNotifyTickCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         FrameDeltaTime;                                    // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSNotifyTickCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSNotifyTickCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSNotifyTickCS) == 0x000048, "Wrong size on AnimNotifyState_GSBase_GSNotifyTickCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyTickCS, NotifyParam) == 0x000000, "Member 'AnimNotifyState_GSBase_GSNotifyTickCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSNotifyTickCS, FrameDeltaTime) == 0x000040, "Member 'AnimNotifyState_GSBase_GSNotifyTickCS::FrameDeltaTime' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSOnSectionManuallyChanged
// 0x0010 (0x0010 - 0x0000)
struct AnimNotifyState_GSBase_GSOnSectionManuallyChanged final
{
public:
	class ABGUCharacter*                          OwnerChar;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingDuration;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_GSBase_GSOnSectionManuallyChanged) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSOnSectionManuallyChanged");
static_assert(sizeof(AnimNotifyState_GSBase_GSOnSectionManuallyChanged) == 0x000010, "Wrong size on AnimNotifyState_GSBase_GSOnSectionManuallyChanged");
static_assert(offsetof(AnimNotifyState_GSBase_GSOnSectionManuallyChanged, OwnerChar) == 0x000000, "Member 'AnimNotifyState_GSBase_GSOnSectionManuallyChanged::OwnerChar' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSBase_GSOnSectionManuallyChanged, RemainingDuration) == 0x000008, "Member 'AnimNotifyState_GSBase_GSOnSectionManuallyChanged::RemainingDuration' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.GSValidateInputCS
// 0x0008 (0x0008 - 0x0000)
struct AnimNotifyState_GSBase_GSValidateInputCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_GSValidateInputCS) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_GSValidateInputCS");
static_assert(sizeof(AnimNotifyState_GSBase_GSValidateInputCS) == 0x000008, "Wrong size on AnimNotifyState_GSBase_GSValidateInputCS");
static_assert(offsetof(AnimNotifyState_GSBase_GSValidateInputCS, Actor) == 0x000000, "Member 'AnimNotifyState_GSBase_GSValidateInputCS::Actor' has a wrong offset!");

// Function b1.AnimNotifyState_GSBase.UpdateDataOnNotifyStateReplace
// 0x0008 (0x0008 - 0x0000)
struct AnimNotifyState_GSBase_UpdateDataOnNotifyStateReplace final
{
public:
	const class UAnimNotifyState*                 NewNotifyState;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSBase_UpdateDataOnNotifyStateReplace) == 0x000008, "Wrong alignment on AnimNotifyState_GSBase_UpdateDataOnNotifyStateReplace");
static_assert(sizeof(AnimNotifyState_GSBase_UpdateDataOnNotifyStateReplace) == 0x000008, "Wrong size on AnimNotifyState_GSBase_UpdateDataOnNotifyStateReplace");
static_assert(offsetof(AnimNotifyState_GSBase_UpdateDataOnNotifyStateReplace, NewNotifyState) == 0x000000, "Member 'AnimNotifyState_GSBase_UpdateDataOnNotifyStateReplace::NewNotifyState' has a wrong offset!");

// Function b1.BGUDebugCircleComponent.SetCircleRadius
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugCircleComponent_SetCircleRadius final
{
public:
	float                                         InCircleRadius;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugCircleComponent_SetCircleRadius) == 0x000004, "Wrong alignment on BGUDebugCircleComponent_SetCircleRadius");
static_assert(sizeof(BGUDebugCircleComponent_SetCircleRadius) == 0x000004, "Wrong size on BGUDebugCircleComponent_SetCircleRadius");
static_assert(offsetof(BGUDebugCircleComponent_SetCircleRadius, InCircleRadius) == 0x000000, "Member 'BGUDebugCircleComponent_SetCircleRadius::InCircleRadius' has a wrong offset!");

// Function b1.BGUDebugCircleComponent.GetScaledCircleRadius
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugCircleComponent_GetScaledCircleRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugCircleComponent_GetScaledCircleRadius) == 0x000004, "Wrong alignment on BGUDebugCircleComponent_GetScaledCircleRadius");
static_assert(sizeof(BGUDebugCircleComponent_GetScaledCircleRadius) == 0x000004, "Wrong size on BGUDebugCircleComponent_GetScaledCircleRadius");
static_assert(offsetof(BGUDebugCircleComponent_GetScaledCircleRadius, ReturnValue) == 0x000000, "Member 'BGUDebugCircleComponent_GetScaledCircleRadius::ReturnValue' has a wrong offset!");

// Function b1.BGUDebugCircleComponent.GetShapeScale
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugCircleComponent_GetShapeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugCircleComponent_GetShapeScale) == 0x000004, "Wrong alignment on BGUDebugCircleComponent_GetShapeScale");
static_assert(sizeof(BGUDebugCircleComponent_GetShapeScale) == 0x000004, "Wrong size on BGUDebugCircleComponent_GetShapeScale");
static_assert(offsetof(BGUDebugCircleComponent_GetShapeScale, ReturnValue) == 0x000000, "Member 'BGUDebugCircleComponent_GetShapeScale::ReturnValue' has a wrong offset!");

// Function b1.BGUDebugCircleComponent.GetUnscaledCircleRadius
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugCircleComponent_GetUnscaledCircleRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugCircleComponent_GetUnscaledCircleRadius) == 0x000004, "Wrong alignment on BGUDebugCircleComponent_GetUnscaledCircleRadius");
static_assert(sizeof(BGUDebugCircleComponent_GetUnscaledCircleRadius) == 0x000004, "Wrong size on BGUDebugCircleComponent_GetUnscaledCircleRadius");
static_assert(offsetof(BGUDebugCircleComponent_GetUnscaledCircleRadius, ReturnValue) == 0x000000, "Member 'BGUDebugCircleComponent_GetUnscaledCircleRadius::ReturnValue' has a wrong offset!");

// Function b1.BGUDebugSectorComponent.SetSectorMaxAngle
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugSectorComponent_SetSectorMaxAngle final
{
public:
	float                                         InMaxAngle;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugSectorComponent_SetSectorMaxAngle) == 0x000004, "Wrong alignment on BGUDebugSectorComponent_SetSectorMaxAngle");
static_assert(sizeof(BGUDebugSectorComponent_SetSectorMaxAngle) == 0x000004, "Wrong size on BGUDebugSectorComponent_SetSectorMaxAngle");
static_assert(offsetof(BGUDebugSectorComponent_SetSectorMaxAngle, InMaxAngle) == 0x000000, "Member 'BGUDebugSectorComponent_SetSectorMaxAngle::InMaxAngle' has a wrong offset!");

// Function b1.BGUDebugSectorComponent.SetSectorMinAngle
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugSectorComponent_SetSectorMinAngle final
{
public:
	float                                         InMinAngle;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugSectorComponent_SetSectorMinAngle) == 0x000004, "Wrong alignment on BGUDebugSectorComponent_SetSectorMinAngle");
static_assert(sizeof(BGUDebugSectorComponent_SetSectorMinAngle) == 0x000004, "Wrong size on BGUDebugSectorComponent_SetSectorMinAngle");
static_assert(offsetof(BGUDebugSectorComponent_SetSectorMinAngle, InMinAngle) == 0x000000, "Member 'BGUDebugSectorComponent_SetSectorMinAngle::InMinAngle' has a wrong offset!");

// Function b1.BGUDebugSectorComponent.SetSectorRadius
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugSectorComponent_SetSectorRadius final
{
public:
	float                                         InSectorRadius;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugSectorComponent_SetSectorRadius) == 0x000004, "Wrong alignment on BGUDebugSectorComponent_SetSectorRadius");
static_assert(sizeof(BGUDebugSectorComponent_SetSectorRadius) == 0x000004, "Wrong size on BGUDebugSectorComponent_SetSectorRadius");
static_assert(offsetof(BGUDebugSectorComponent_SetSectorRadius, InSectorRadius) == 0x000000, "Member 'BGUDebugSectorComponent_SetSectorRadius::InSectorRadius' has a wrong offset!");

// Function b1.BGUDebugSectorComponent.GetScaledSectorRadius
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugSectorComponent_GetScaledSectorRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugSectorComponent_GetScaledSectorRadius) == 0x000004, "Wrong alignment on BGUDebugSectorComponent_GetScaledSectorRadius");
static_assert(sizeof(BGUDebugSectorComponent_GetScaledSectorRadius) == 0x000004, "Wrong size on BGUDebugSectorComponent_GetScaledSectorRadius");
static_assert(offsetof(BGUDebugSectorComponent_GetScaledSectorRadius, ReturnValue) == 0x000000, "Member 'BGUDebugSectorComponent_GetScaledSectorRadius::ReturnValue' has a wrong offset!");

// Function b1.BGUDebugSectorComponent.GetShapeScale
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugSectorComponent_GetShapeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugSectorComponent_GetShapeScale) == 0x000004, "Wrong alignment on BGUDebugSectorComponent_GetShapeScale");
static_assert(sizeof(BGUDebugSectorComponent_GetShapeScale) == 0x000004, "Wrong size on BGUDebugSectorComponent_GetShapeScale");
static_assert(offsetof(BGUDebugSectorComponent_GetShapeScale, ReturnValue) == 0x000000, "Member 'BGUDebugSectorComponent_GetShapeScale::ReturnValue' has a wrong offset!");

// Function b1.BGUDebugSectorComponent.GetUnscaledSectorRadius
// 0x0004 (0x0004 - 0x0000)
struct BGUDebugSectorComponent_GetUnscaledSectorRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUDebugSectorComponent_GetUnscaledSectorRadius) == 0x000004, "Wrong alignment on BGUDebugSectorComponent_GetUnscaledSectorRadius");
static_assert(sizeof(BGUDebugSectorComponent_GetUnscaledSectorRadius) == 0x000004, "Wrong size on BGUDebugSectorComponent_GetUnscaledSectorRadius");
static_assert(offsetof(BGUDebugSectorComponent_GetUnscaledSectorRadius, ReturnValue) == 0x000000, "Member 'BGUDebugSectorComponent_GetUnscaledSectorRadius::ReturnValue' has a wrong offset!");

// Function b1.BGUEditorTickableActor.GetViewportCameraLocation
// 0x0018 (0x0018 - 0x0000)
struct BGUEditorTickableActor_GetViewportCameraLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUEditorTickableActor_GetViewportCameraLocation) == 0x000008, "Wrong alignment on BGUEditorTickableActor_GetViewportCameraLocation");
static_assert(sizeof(BGUEditorTickableActor_GetViewportCameraLocation) == 0x000018, "Wrong size on BGUEditorTickableActor_GetViewportCameraLocation");
static_assert(offsetof(BGUEditorTickableActor_GetViewportCameraLocation, ReturnValue) == 0x000000, "Member 'BGUEditorTickableActor_GetViewportCameraLocation::ReturnValue' has a wrong offset!");

// Function b1.BGUEQSObject.EQSObjRun
// 0x0028 (0x0028 - 0x0000)
struct BGUEQSObject_EQSObjRun final
{
public:
	const class UEnvQuery*                        EnvQueryObj;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Querier;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGURunEQSObjReason                           Reason;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGSEQSExParam                          _ExParam;                                          // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUEQSObject_EQSObjRun) == 0x000008, "Wrong alignment on BGUEQSObject_EQSObjRun");
static_assert(sizeof(BGUEQSObject_EQSObjRun) == 0x000028, "Wrong size on BGUEQSObject_EQSObjRun");
static_assert(offsetof(BGUEQSObject_EQSObjRun, EnvQueryObj) == 0x000000, "Member 'BGUEQSObject_EQSObjRun::EnvQueryObj' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRun, Querier) == 0x000008, "Member 'BGUEQSObject_EQSObjRun::Querier' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRun, Reason) == 0x000010, "Member 'BGUEQSObject_EQSObjRun::Reason' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRun, _ExParam) == 0x000014, "Member 'BGUEQSObject_EQSObjRun::_ExParam' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRun, ReturnValue) == 0x000020, "Member 'BGUEQSObject_EQSObjRun::ReturnValue' has a wrong offset!");

// Function b1.BGUEQSObject.EQSObjRunInstant
// 0x0030 (0x0030 - 0x0000)
struct BGUEQSObject_EQSObjRunInstant final
{
public:
	const class UEnvQuery*                        EnvQueryObj;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Querier;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Locations;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Scores;                                            // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUEQSObject_EQSObjRunInstant) == 0x000008, "Wrong alignment on BGUEQSObject_EQSObjRunInstant");
static_assert(sizeof(BGUEQSObject_EQSObjRunInstant) == 0x000030, "Wrong size on BGUEQSObject_EQSObjRunInstant");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstant, EnvQueryObj) == 0x000000, "Member 'BGUEQSObject_EQSObjRunInstant::EnvQueryObj' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstant, Querier) == 0x000008, "Member 'BGUEQSObject_EQSObjRunInstant::Querier' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstant, Locations) == 0x000010, "Member 'BGUEQSObject_EQSObjRunInstant::Locations' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstant, Scores) == 0x000020, "Member 'BGUEQSObject_EQSObjRunInstant::Scores' has a wrong offset!");

// Function b1.BGUEQSObject.EQSObjRunInstantWithCustomParams
// 0x0040 (0x0040 - 0x0000)
struct BGUEQSObject_EQSObjRunInstantWithCustomParams final
{
public:
	const class UEnvQuery*                        EnvQueryObj;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Querier;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGSEnvNamedValue>               NamedParams;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Locations;                                         // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Scores;                                            // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUEQSObject_EQSObjRunInstantWithCustomParams) == 0x000008, "Wrong alignment on BGUEQSObject_EQSObjRunInstantWithCustomParams");
static_assert(sizeof(BGUEQSObject_EQSObjRunInstantWithCustomParams) == 0x000040, "Wrong size on BGUEQSObject_EQSObjRunInstantWithCustomParams");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstantWithCustomParams, EnvQueryObj) == 0x000000, "Member 'BGUEQSObject_EQSObjRunInstantWithCustomParams::EnvQueryObj' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstantWithCustomParams, Querier) == 0x000008, "Member 'BGUEQSObject_EQSObjRunInstantWithCustomParams::Querier' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstantWithCustomParams, NamedParams) == 0x000010, "Member 'BGUEQSObject_EQSObjRunInstantWithCustomParams::NamedParams' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstantWithCustomParams, Locations) == 0x000020, "Member 'BGUEQSObject_EQSObjRunInstantWithCustomParams::Locations' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunInstantWithCustomParams, Scores) == 0x000030, "Member 'BGUEQSObject_EQSObjRunInstantWithCustomParams::Scores' has a wrong offset!");

// Function b1.BGUEQSObject.EQSObjRunWithCustomParams
// 0x0030 (0x0030 - 0x0000)
struct BGUEQSObject_EQSObjRunWithCustomParams final
{
public:
	const class UEnvQuery*                        EnvQueryObj;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Querier;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGURunEQSObjReason                           Reason;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGSEnvNamedValue>               NamedParams;                                       // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUEQSObject_EQSObjRunWithCustomParams) == 0x000008, "Wrong alignment on BGUEQSObject_EQSObjRunWithCustomParams");
static_assert(sizeof(BGUEQSObject_EQSObjRunWithCustomParams) == 0x000030, "Wrong size on BGUEQSObject_EQSObjRunWithCustomParams");
static_assert(offsetof(BGUEQSObject_EQSObjRunWithCustomParams, EnvQueryObj) == 0x000000, "Member 'BGUEQSObject_EQSObjRunWithCustomParams::EnvQueryObj' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunWithCustomParams, Querier) == 0x000008, "Member 'BGUEQSObject_EQSObjRunWithCustomParams::Querier' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunWithCustomParams, Reason) == 0x000010, "Member 'BGUEQSObject_EQSObjRunWithCustomParams::Reason' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunWithCustomParams, NamedParams) == 0x000018, "Member 'BGUEQSObject_EQSObjRunWithCustomParams::NamedParams' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSObjRunWithCustomParams, ReturnValue) == 0x000028, "Member 'BGUEQSObject_EQSObjRunWithCustomParams::ReturnValue' has a wrong offset!");

// Function b1.BGUEQSObject.EQSRun
// 0x0030 (0x0030 - 0x0000)
struct BGUEQSObject_EQSRun final
{
public:
	class FString                                 EQSPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Querier;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGURunEQSObjReason                           Reason;                                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGSEQSExParam                          _ExParam;                                          // 0x001C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUEQSObject_EQSRun) == 0x000008, "Wrong alignment on BGUEQSObject_EQSRun");
static_assert(sizeof(BGUEQSObject_EQSRun) == 0x000030, "Wrong size on BGUEQSObject_EQSRun");
static_assert(offsetof(BGUEQSObject_EQSRun, EQSPath) == 0x000000, "Member 'BGUEQSObject_EQSRun::EQSPath' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSRun, Querier) == 0x000010, "Member 'BGUEQSObject_EQSRun::Querier' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSRun, Reason) == 0x000018, "Member 'BGUEQSObject_EQSRun::Reason' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSRun, _ExParam) == 0x00001C, "Member 'BGUEQSObject_EQSRun::_ExParam' has a wrong offset!");
static_assert(offsetof(BGUEQSObject_EQSRun, ReturnValue) == 0x000028, "Member 'BGUEQSObject_EQSRun::ReturnValue' has a wrong offset!");

// Function b1.BGUFluid2DComponent.GetPressureDivergenceTexture
// 0x0008 (0x0008 - 0x0000)
struct BGUFluid2DComponent_GetPressureDivergenceTexture final
{
public:
	class UTextureRenderTarget2D*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFluid2DComponent_GetPressureDivergenceTexture) == 0x000008, "Wrong alignment on BGUFluid2DComponent_GetPressureDivergenceTexture");
static_assert(sizeof(BGUFluid2DComponent_GetPressureDivergenceTexture) == 0x000008, "Wrong size on BGUFluid2DComponent_GetPressureDivergenceTexture");
static_assert(offsetof(BGUFluid2DComponent_GetPressureDivergenceTexture, ReturnValue) == 0x000000, "Member 'BGUFluid2DComponent_GetPressureDivergenceTexture::ReturnValue' has a wrong offset!");

// Function b1.BGUFluid2DComponent.GetVeloDensityTexture
// 0x0008 (0x0008 - 0x0000)
struct BGUFluid2DComponent_GetVeloDensityTexture final
{
public:
	class UTextureRenderTarget2D*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFluid2DComponent_GetVeloDensityTexture) == 0x000008, "Wrong alignment on BGUFluid2DComponent_GetVeloDensityTexture");
static_assert(sizeof(BGUFluid2DComponent_GetVeloDensityTexture) == 0x000008, "Wrong size on BGUFluid2DComponent_GetVeloDensityTexture");
static_assert(offsetof(BGUFluid2DComponent_GetVeloDensityTexture, ReturnValue) == 0x000000, "Member 'BGUFluid2DComponent_GetVeloDensityTexture::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUGetTagEnum
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUGetTagEnum final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Out;                                               // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibData_BGUGetTagEnum) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUGetTagEnum");
static_assert(sizeof(BGUFuncLibData_BGUGetTagEnum) == 0x000018, "Wrong size on BGUFuncLibData_BGUGetTagEnum");
static_assert(offsetof(BGUFuncLibData_BGUGetTagEnum, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUGetTagEnum::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagEnum, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUGetTagEnum::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagEnum, IsValid) == 0x000010, "Member 'BGUFuncLibData_BGUGetTagEnum::IsValid' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagEnum, Out) == 0x000011, "Member 'BGUFuncLibData_BGUGetTagEnum::Out' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUGetTagFloat
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUGetTagFloat final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Out;                                               // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUGetTagFloat) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUGetTagFloat");
static_assert(sizeof(BGUFuncLibData_BGUGetTagFloat) == 0x000018, "Wrong size on BGUFuncLibData_BGUGetTagFloat");
static_assert(offsetof(BGUFuncLibData_BGUGetTagFloat, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUGetTagFloat::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagFloat, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUGetTagFloat::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagFloat, IsValid) == 0x000010, "Member 'BGUFuncLibData_BGUGetTagFloat::IsValid' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagFloat, Out) == 0x000014, "Member 'BGUFuncLibData_BGUGetTagFloat::Out' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUGetTagFloatByName
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUGetTagFloatByName final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Out;                                               // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUGetTagFloatByName) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUGetTagFloatByName");
static_assert(sizeof(BGUFuncLibData_BGUGetTagFloatByName) == 0x000018, "Wrong size on BGUFuncLibData_BGUGetTagFloatByName");
static_assert(offsetof(BGUFuncLibData_BGUGetTagFloatByName, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUGetTagFloatByName::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagFloatByName, TagName) == 0x000008, "Member 'BGUFuncLibData_BGUGetTagFloatByName::TagName' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagFloatByName, IsValid) == 0x000010, "Member 'BGUFuncLibData_BGUGetTagFloatByName::IsValid' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagFloatByName, Out) == 0x000014, "Member 'BGUFuncLibData_BGUGetTagFloatByName::Out' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUGetTagInt
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUGetTagInt final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Out;                                               // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUGetTagInt) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUGetTagInt");
static_assert(sizeof(BGUFuncLibData_BGUGetTagInt) == 0x000018, "Wrong size on BGUFuncLibData_BGUGetTagInt");
static_assert(offsetof(BGUFuncLibData_BGUGetTagInt, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUGetTagInt::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagInt, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUGetTagInt::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagInt, IsValid) == 0x000010, "Member 'BGUFuncLibData_BGUGetTagInt::IsValid' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagInt, Out) == 0x000014, "Member 'BGUFuncLibData_BGUGetTagInt::Out' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUGetTagIntByName
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUGetTagIntByName final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Out;                                               // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUGetTagIntByName) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUGetTagIntByName");
static_assert(sizeof(BGUFuncLibData_BGUGetTagIntByName) == 0x000018, "Wrong size on BGUFuncLibData_BGUGetTagIntByName");
static_assert(offsetof(BGUFuncLibData_BGUGetTagIntByName, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUGetTagIntByName::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagIntByName, TagName) == 0x000008, "Member 'BGUFuncLibData_BGUGetTagIntByName::TagName' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagIntByName, IsValid) == 0x000010, "Member 'BGUFuncLibData_BGUGetTagIntByName::IsValid' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagIntByName, Out) == 0x000014, "Member 'BGUFuncLibData_BGUGetTagIntByName::Out' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUGetTagName
// 0x0020 (0x0020 - 0x0000)
struct BGUFuncLibData_BGUGetTagName final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Out;                                               // 0x0014(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibData_BGUGetTagName) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUGetTagName");
static_assert(sizeof(BGUFuncLibData_BGUGetTagName) == 0x000020, "Wrong size on BGUFuncLibData_BGUGetTagName");
static_assert(offsetof(BGUFuncLibData_BGUGetTagName, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUGetTagName::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagName, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUGetTagName::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagName, IsValid) == 0x000010, "Member 'BGUFuncLibData_BGUGetTagName::IsValid' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagName, Out) == 0x000014, "Member 'BGUFuncLibData_BGUGetTagName::Out' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUGetTagObject
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUGetTagObject final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUGetTagObject) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUGetTagObject");
static_assert(sizeof(BGUFuncLibData_BGUGetTagObject) == 0x000018, "Wrong size on BGUFuncLibData_BGUGetTagObject");
static_assert(offsetof(BGUFuncLibData_BGUGetTagObject, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUGetTagObject::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagObject, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUGetTagObject::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagObject, ReturnValue) == 0x000010, "Member 'BGUFuncLibData_BGUGetTagObject::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUGetTagVector
// 0x0030 (0x0030 - 0x0000)
struct BGUFuncLibData_BGUGetTagVector final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Out;                                               // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUGetTagVector) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUGetTagVector");
static_assert(sizeof(BGUFuncLibData_BGUGetTagVector) == 0x000030, "Wrong size on BGUFuncLibData_BGUGetTagVector");
static_assert(offsetof(BGUFuncLibData_BGUGetTagVector, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUGetTagVector::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagVector, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUGetTagVector::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagVector, IsValid) == 0x000010, "Member 'BGUFuncLibData_BGUGetTagVector::IsValid' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUGetTagVector, Out) == 0x000018, "Member 'BGUFuncLibData_BGUGetTagVector::Out' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagEnum
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUSetTagEnum final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Val;                                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibData_BGUSetTagEnum) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagEnum");
static_assert(sizeof(BGUFuncLibData_BGUSetTagEnum) == 0x000018, "Wrong size on BGUFuncLibData_BGUSetTagEnum");
static_assert(offsetof(BGUFuncLibData_BGUSetTagEnum, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagEnum::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagEnum, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagEnum::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagEnum, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagEnum::Val' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagFloat
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUSetTagFloat final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Val;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibData_BGUSetTagFloat) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagFloat");
static_assert(sizeof(BGUFuncLibData_BGUSetTagFloat) == 0x000018, "Wrong size on BGUFuncLibData_BGUSetTagFloat");
static_assert(offsetof(BGUFuncLibData_BGUSetTagFloat, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagFloat::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagFloat, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagFloat::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagFloat, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagFloat::Val' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagFloatByName
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUSetTagFloatByName final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Val;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibData_BGUSetTagFloatByName) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagFloatByName");
static_assert(sizeof(BGUFuncLibData_BGUSetTagFloatByName) == 0x000018, "Wrong size on BGUFuncLibData_BGUSetTagFloatByName");
static_assert(offsetof(BGUFuncLibData_BGUSetTagFloatByName, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagFloatByName::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagFloatByName, TagName) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagFloatByName::TagName' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagFloatByName, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagFloatByName::Val' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagInt
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUSetTagInt final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Val;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibData_BGUSetTagInt) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagInt");
static_assert(sizeof(BGUFuncLibData_BGUSetTagInt) == 0x000018, "Wrong size on BGUFuncLibData_BGUSetTagInt");
static_assert(offsetof(BGUFuncLibData_BGUSetTagInt, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagInt::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagInt, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagInt::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagInt, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagInt::Val' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagIntByName
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUSetTagIntByName final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Val;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibData_BGUSetTagIntByName) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagIntByName");
static_assert(sizeof(BGUFuncLibData_BGUSetTagIntByName) == 0x000018, "Wrong size on BGUFuncLibData_BGUSetTagIntByName");
static_assert(offsetof(BGUFuncLibData_BGUSetTagIntByName, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagIntByName::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagIntByName, TagName) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagIntByName::TagName' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagIntByName, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagIntByName::Val' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagName
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUSetTagName final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Val;                                               // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUSetTagName) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagName");
static_assert(sizeof(BGUFuncLibData_BGUSetTagName) == 0x000018, "Wrong size on BGUFuncLibData_BGUSetTagName");
static_assert(offsetof(BGUFuncLibData_BGUSetTagName, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagName::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagName, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagName::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagName, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagName::Val' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagNameWithGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUSetTagNameWithGameplayTag final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Val;                                               // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUSetTagNameWithGameplayTag) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagNameWithGameplayTag");
static_assert(sizeof(BGUFuncLibData_BGUSetTagNameWithGameplayTag) == 0x000018, "Wrong size on BGUFuncLibData_BGUSetTagNameWithGameplayTag");
static_assert(offsetof(BGUFuncLibData_BGUSetTagNameWithGameplayTag, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagNameWithGameplayTag::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagNameWithGameplayTag, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagNameWithGameplayTag::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagNameWithGameplayTag, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagNameWithGameplayTag::Val' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagObject
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibData_BGUSetTagObject final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Val;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUSetTagObject) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagObject");
static_assert(sizeof(BGUFuncLibData_BGUSetTagObject) == 0x000018, "Wrong size on BGUFuncLibData_BGUSetTagObject");
static_assert(offsetof(BGUFuncLibData_BGUSetTagObject, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagObject::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagObject, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagObject::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagObject, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagObject::Val' has a wrong offset!");

// Function b1.BGUFuncLibData.BGUSetTagVector
// 0x0028 (0x0028 - 0x0000)
struct BGUFuncLibData_BGUSetTagVector final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Val;                                               // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibData_BGUSetTagVector) == 0x000008, "Wrong alignment on BGUFuncLibData_BGUSetTagVector");
static_assert(sizeof(BGUFuncLibData_BGUSetTagVector) == 0x000028, "Wrong size on BGUFuncLibData_BGUSetTagVector");
static_assert(offsetof(BGUFuncLibData_BGUSetTagVector, Unit) == 0x000000, "Member 'BGUFuncLibData_BGUSetTagVector::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagVector, Tag) == 0x000008, "Member 'BGUFuncLibData_BGUSetTagVector::Tag' has a wrong offset!");
static_assert(offsetof(BGUFuncLibData_BGUSetTagVector, Val) == 0x000010, "Member 'BGUFuncLibData_BGUSetTagVector::Val' has a wrong offset!");

// Function b1.BGUFuncLibMove.BGUMovementForceSaveBaseLocation
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibMove_BGUMovementForceSaveBaseLocation final
{
public:
	class UCharacterMovementComponent*            MoveComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibMove_BGUMovementForceSaveBaseLocation) == 0x000008, "Wrong alignment on BGUFuncLibMove_BGUMovementForceSaveBaseLocation");
static_assert(sizeof(BGUFuncLibMove_BGUMovementForceSaveBaseLocation) == 0x000008, "Wrong size on BGUFuncLibMove_BGUMovementForceSaveBaseLocation");
static_assert(offsetof(BGUFuncLibMove_BGUMovementForceSaveBaseLocation, MoveComp) == 0x000000, "Member 'BGUFuncLibMove_BGUMovementForceSaveBaseLocation::MoveComp' has a wrong offset!");

// Function b1.BGUFuncLibAI.BGUAICaculateTargetAngle
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibAI_BGUAICaculateTargetAngle final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MySelf;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibAI_BGUAICaculateTargetAngle) == 0x000008, "Wrong alignment on BGUFuncLibAI_BGUAICaculateTargetAngle");
static_assert(sizeof(BGUFuncLibAI_BGUAICaculateTargetAngle) == 0x000018, "Wrong size on BGUFuncLibAI_BGUAICaculateTargetAngle");
static_assert(offsetof(BGUFuncLibAI_BGUAICaculateTargetAngle, Target) == 0x000000, "Member 'BGUFuncLibAI_BGUAICaculateTargetAngle::Target' has a wrong offset!");
static_assert(offsetof(BGUFuncLibAI_BGUAICaculateTargetAngle, MySelf) == 0x000008, "Member 'BGUFuncLibAI_BGUAICaculateTargetAngle::MySelf' has a wrong offset!");
static_assert(offsetof(BGUFuncLibAI_BGUAICaculateTargetAngle, ReturnValue) == 0x000010, "Member 'BGUFuncLibAI_BGUAICaculateTargetAngle::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibAI.BGUIsAIRequestActive
// 0x0010 (0x0010 - 0x0000)
struct BGUFuncLibAI_BGUIsAIRequestActive final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequestID;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibAI_BGUIsAIRequestActive) == 0x000008, "Wrong alignment on BGUFuncLibAI_BGUIsAIRequestActive");
static_assert(sizeof(BGUFuncLibAI_BGUIsAIRequestActive) == 0x000010, "Wrong size on BGUFuncLibAI_BGUIsAIRequestActive");
static_assert(offsetof(BGUFuncLibAI_BGUIsAIRequestActive, Unit) == 0x000000, "Member 'BGUFuncLibAI_BGUIsAIRequestActive::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibAI_BGUIsAIRequestActive, RequestID) == 0x000008, "Member 'BGUFuncLibAI_BGUIsAIRequestActive::RequestID' has a wrong offset!");
static_assert(offsetof(BGUFuncLibAI_BGUIsAIRequestActive, ReturnValue) == 0x00000C, "Member 'BGUFuncLibAI_BGUIsAIRequestActive::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibAI.BGURequestAITurnTo
// 0x0028 (0x0028 - 0x0000)
struct BGUFuncLibAI_BGURequestAITurnTo final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibAI_BGURequestAITurnTo) == 0x000008, "Wrong alignment on BGUFuncLibAI_BGURequestAITurnTo");
static_assert(sizeof(BGUFuncLibAI_BGURequestAITurnTo) == 0x000028, "Wrong size on BGUFuncLibAI_BGURequestAITurnTo");
static_assert(offsetof(BGUFuncLibAI_BGURequestAITurnTo, Unit) == 0x000000, "Member 'BGUFuncLibAI_BGURequestAITurnTo::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibAI_BGURequestAITurnTo, Position) == 0x000008, "Member 'BGUFuncLibAI_BGURequestAITurnTo::Position' has a wrong offset!");
static_assert(offsetof(BGUFuncLibAI_BGURequestAITurnTo, ReturnValue) == 0x000020, "Member 'BGUFuncLibAI_BGURequestAITurnTo::ReturnValue' has a wrong offset!");

// Function b1.AnimNotifyState_GSTrailWithArray.OverridePSTemplate
// 0x0018 (0x0018 - 0x0000)
struct AnimNotifyState_GSTrailWithArray_OverridePSTemplate final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GSTrailWithArray_OverridePSTemplate) == 0x000008, "Wrong alignment on AnimNotifyState_GSTrailWithArray_OverridePSTemplate");
static_assert(sizeof(AnimNotifyState_GSTrailWithArray_OverridePSTemplate) == 0x000018, "Wrong size on AnimNotifyState_GSTrailWithArray_OverridePSTemplate");
static_assert(offsetof(AnimNotifyState_GSTrailWithArray_OverridePSTemplate, MeshComp) == 0x000000, "Member 'AnimNotifyState_GSTrailWithArray_OverridePSTemplate::MeshComp' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSTrailWithArray_OverridePSTemplate, Animation) == 0x000008, "Member 'AnimNotifyState_GSTrailWithArray_OverridePSTemplate::Animation' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_GSTrailWithArray_OverridePSTemplate, ReturnValue) == 0x000010, "Member 'AnimNotifyState_GSTrailWithArray_OverridePSTemplate::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.BGUCalcMontageNeedModifyTotalTime
// 0x0010 (0x0010 - 0x0000)
struct BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime final
{
public:
	class ACharacter*                             Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FromAMInstanceID;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime) == 0x000008, "Wrong alignment on BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime");
static_assert(sizeof(BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime) == 0x000010, "Wrong size on BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime, Unit) == 0x000000, "Member 'BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime, FromAMInstanceID) == 0x000008, "Member 'BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime::FromAMInstanceID' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime, ReturnValue) == 0x00000C, "Member 'BGUFuncLibSkill_BGUCalcMontageNeedModifyTotalTime::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.BGUCalcMontageSpecificRangeTime
// 0x0028 (0x0028 - 0x0000)
struct BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FromAMInstanceID;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftTime;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightTime;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurMontage;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime) == 0x000008, "Wrong alignment on BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime");
static_assert(sizeof(BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime) == 0x000028, "Wrong size on BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime, Unit) == 0x000000, "Member 'BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime, FromAMInstanceID) == 0x000008, "Member 'BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime::FromAMInstanceID' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime, LeftTime) == 0x00000C, "Member 'BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime::LeftTime' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime, RightTime) == 0x000010, "Member 'BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime::RightTime' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime, CurMontage) == 0x000018, "Member 'BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime::CurMontage' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime, ReturnValue) == 0x000020, "Member 'BGUFuncLibSkill_BGUCalcMontageSpecificRangeTime::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.BGUCalcNotifyNeedModifyTotalTime
// 0x0020 (0x0020 - 0x0000)
struct BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime final
{
public:
	class ACharacter*                             Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimNotifyState*                 NotifyEvent;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FromAMInstanceID;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurNSLeftTime;                                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurNSRightTime;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime) == 0x000008, "Wrong alignment on BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime");
static_assert(sizeof(BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime) == 0x000020, "Wrong size on BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime, Unit) == 0x000000, "Member 'BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime::Unit' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime, NotifyEvent) == 0x000008, "Member 'BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime::NotifyEvent' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime, FromAMInstanceID) == 0x000010, "Member 'BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime::FromAMInstanceID' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime, CurNSLeftTime) == 0x000014, "Member 'BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime::CurNSLeftTime' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime, CurNSRightTime) == 0x000018, "Member 'BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime::CurNSRightTime' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime, ReturnValue) == 0x00001C, "Member 'BGUFuncLibSkill_BGUCalcNotifyNeedModifyTotalTime::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.BGUGetActiveInstanceIDForMontage
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage) == 0x000008, "Wrong alignment on BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage");
static_assert(sizeof(BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage) == 0x000018, "Wrong size on BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage");
static_assert(offsetof(BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage, AnimInstance) == 0x000000, "Member 'BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage::AnimInstance' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage, Montage) == 0x000008, "Member 'BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage::Montage' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage, ReturnValue) == 0x000010, "Member 'BGUFuncLibSkill_BGUGetActiveInstanceIDForMontage::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.BGUGetMontageHasRootMotion
// 0x0010 (0x0010 - 0x0000)
struct BGUFuncLibSkill_BGUGetMontageHasRootMotion final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSkill_BGUGetMontageHasRootMotion) == 0x000008, "Wrong alignment on BGUFuncLibSkill_BGUGetMontageHasRootMotion");
static_assert(sizeof(BGUFuncLibSkill_BGUGetMontageHasRootMotion) == 0x000010, "Wrong size on BGUFuncLibSkill_BGUGetMontageHasRootMotion");
static_assert(offsetof(BGUFuncLibSkill_BGUGetMontageHasRootMotion, Montage) == 0x000000, "Member 'BGUFuncLibSkill_BGUGetMontageHasRootMotion::Montage' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUGetMontageHasRootMotion, ReturnValue) == 0x000008, "Member 'BGUFuncLibSkill_BGUGetMontageHasRootMotion::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.BGUGetMontageNotifies
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibSkill_BGUGetMontageNotifies final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimNotifyEvent>               OutActiveNotifies;                                 // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibSkill_BGUGetMontageNotifies) == 0x000008, "Wrong alignment on BGUFuncLibSkill_BGUGetMontageNotifies");
static_assert(sizeof(BGUFuncLibSkill_BGUGetMontageNotifies) == 0x000018, "Wrong size on BGUFuncLibSkill_BGUGetMontageNotifies");
static_assert(offsetof(BGUFuncLibSkill_BGUGetMontageNotifies, Montage) == 0x000000, "Member 'BGUFuncLibSkill_BGUGetMontageNotifies::Montage' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUGetMontageNotifies, OutActiveNotifies) == 0x000008, "Member 'BGUFuncLibSkill_BGUGetMontageNotifies::OutActiveNotifies' has a wrong offset!");

// Function b1.BGUFuncLibSkill.BGUGetMotionDirFromSkill
// 0x0020 (0x0020 - 0x0000)
struct BGUFuncLibSkill_BGUGetMotionDirFromSkill final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibSkill_BGUGetMotionDirFromSkill) == 0x000008, "Wrong alignment on BGUFuncLibSkill_BGUGetMotionDirFromSkill");
static_assert(sizeof(BGUFuncLibSkill_BGUGetMotionDirFromSkill) == 0x000020, "Wrong size on BGUFuncLibSkill_BGUGetMotionDirFromSkill");
static_assert(offsetof(BGUFuncLibSkill_BGUGetMotionDirFromSkill, SkillID) == 0x000000, "Member 'BGUFuncLibSkill_BGUGetMotionDirFromSkill::SkillID' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_BGUGetMotionDirFromSkill, ReturnValue) == 0x000008, "Member 'BGUFuncLibSkill_BGUGetMotionDirFromSkill::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.MontageInstanceBindUFunctionToMontageBlendOutDel
// 0x0028 (0x0028 - 0x0000)
struct BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel) == 0x000008, "Wrong alignment on BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel");
static_assert(sizeof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel) == 0x000028, "Wrong size on BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel, AnimInstance) == 0x000000, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel::AnimInstance' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel, Montage) == 0x000008, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel::Montage' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel, Object) == 0x000010, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel::Object' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel, FunctionName) == 0x000018, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel::FunctionName' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel, ReturnValue) == 0x000020, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontageBlendOutDel::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.MontageInstanceBindUFunctionToMontegeEndDel
// 0x0028 (0x0028 - 0x0000)
struct BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FunctionName;                                      // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel) == 0x000008, "Wrong alignment on BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel");
static_assert(sizeof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel) == 0x000028, "Wrong size on BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel, AnimInstance) == 0x000000, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel::AnimInstance' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel, Montage) == 0x000008, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel::Montage' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel, Object) == 0x000010, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel::Object' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel, FunctionName) == 0x000018, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel::FunctionName' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel, ReturnValue) == 0x000020, "Member 'BGUFuncLibSkill_MontageInstanceBindUFunctionToMontegeEndDel::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.MontageInstanceUnBindUFunctionToMontageBlendOutDel
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel) == 0x000008, "Wrong alignment on BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel");
static_assert(sizeof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel) == 0x000018, "Wrong size on BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel, AnimInstance) == 0x000000, "Member 'BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel::AnimInstance' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel, Montage) == 0x000008, "Member 'BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel::Montage' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel, ReturnValue) == 0x000010, "Member 'BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontageBlendOutDel::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSkill.MontageInstanceUnBindUFunctionToMontegeEndDel
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel) == 0x000008, "Wrong alignment on BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel");
static_assert(sizeof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel) == 0x000018, "Wrong size on BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel, AnimInstance) == 0x000000, "Member 'BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel::AnimInstance' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel, Montage) == 0x000008, "Member 'BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel::Montage' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel, ReturnValue) == 0x000010, "Member 'BGUFuncLibSkill_MontageInstanceUnBindUFunctionToMontegeEndDel::ReturnValue' has a wrong offset!");

// Function b1.AnimNotify_GSBase.AddPreloadedAsset
// 0x0008 (0x0008 - 0x0000)
struct AnimNotify_GSBase_AddPreloadedAsset final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GSBase_AddPreloadedAsset) == 0x000008, "Wrong alignment on AnimNotify_GSBase_AddPreloadedAsset");
static_assert(sizeof(AnimNotify_GSBase_AddPreloadedAsset) == 0x000008, "Wrong size on AnimNotify_GSBase_AddPreloadedAsset");
static_assert(offsetof(AnimNotify_GSBase_AddPreloadedAsset, Obj) == 0x000000, "Member 'AnimNotify_GSBase_AddPreloadedAsset::Obj' has a wrong offset!");

// Function b1.AnimNotify_GSBase.bIsNativeBranchingPointCS
// 0x0001 (0x0001 - 0x0000)
struct AnimNotify_GSBase_bIsNativeBranchingPointCS final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GSBase_bIsNativeBranchingPointCS) == 0x000001, "Wrong alignment on AnimNotify_GSBase_bIsNativeBranchingPointCS");
static_assert(sizeof(AnimNotify_GSBase_bIsNativeBranchingPointCS) == 0x000001, "Wrong size on AnimNotify_GSBase_bIsNativeBranchingPointCS");
static_assert(offsetof(AnimNotify_GSBase_bIsNativeBranchingPointCS, ReturnValue) == 0x000000, "Member 'AnimNotify_GSBase_bIsNativeBranchingPointCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotify_GSBase.GetAnimNType
// 0x0001 (0x0001 - 0x0000)
struct AnimNotify_GSBase_GetAnimNType final
{
public:
	EGsEnAnimN                                    ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GSBase_GetAnimNType) == 0x000001, "Wrong alignment on AnimNotify_GSBase_GetAnimNType");
static_assert(sizeof(AnimNotify_GSBase_GetAnimNType) == 0x000001, "Wrong size on AnimNotify_GSBase_GetAnimNType");
static_assert(offsetof(AnimNotify_GSBase_GetAnimNType, ReturnValue) == 0x000000, "Member 'AnimNotify_GSBase_GetAnimNType::ReturnValue' has a wrong offset!");

// Function b1.AnimNotify_GSBase.GetJumpableSectionPrefix
// 0x0010 (0x0010 - 0x0000)
struct AnimNotify_GSBase_GetJumpableSectionPrefix final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GSBase_GetJumpableSectionPrefix) == 0x000008, "Wrong alignment on AnimNotify_GSBase_GetJumpableSectionPrefix");
static_assert(sizeof(AnimNotify_GSBase_GetJumpableSectionPrefix) == 0x000010, "Wrong size on AnimNotify_GSBase_GetJumpableSectionPrefix");
static_assert(offsetof(AnimNotify_GSBase_GetJumpableSectionPrefix, ReturnValue) == 0x000000, "Member 'AnimNotify_GSBase_GetJumpableSectionPrefix::ReturnValue' has a wrong offset!");

// Function b1.AnimNotify_GSBase.GetPreloadedAssets
// 0x0010 (0x0010 - 0x0000)
struct AnimNotify_GSBase_GetPreloadedAssets final
{
public:
	TArray<class UObject*>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GSBase_GetPreloadedAssets) == 0x000008, "Wrong alignment on AnimNotify_GSBase_GetPreloadedAssets");
static_assert(sizeof(AnimNotify_GSBase_GetPreloadedAssets) == 0x000010, "Wrong size on AnimNotify_GSBase_GetPreloadedAssets");
static_assert(offsetof(AnimNotify_GSBase_GetPreloadedAssets, ReturnValue) == 0x000000, "Member 'AnimNotify_GSBase_GetPreloadedAssets::ReturnValue' has a wrong offset!");

// Function b1.AnimNotify_GSBase.GetSoftReferences
// 0x0010 (0x0010 - 0x0000)
struct AnimNotify_GSBase_GetSoftReferences final
{
public:
	TArray<struct FSoftObjectPath>                ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GSBase_GetSoftReferences) == 0x000008, "Wrong alignment on AnimNotify_GSBase_GetSoftReferences");
static_assert(sizeof(AnimNotify_GSBase_GetSoftReferences) == 0x000010, "Wrong size on AnimNotify_GSBase_GetSoftReferences");
static_assert(offsetof(AnimNotify_GSBase_GetSoftReferences, ReturnValue) == 0x000000, "Member 'AnimNotify_GSBase_GetSoftReferences::ReturnValue' has a wrong offset!");

// Function b1.AnimNotify_GSBase.GSNotifyCS
// 0x0040 (0x0040 - 0x0000)
struct AnimNotify_GSBase_GSNotifyCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GSBase_GSNotifyCS) == 0x000008, "Wrong alignment on AnimNotify_GSBase_GSNotifyCS");
static_assert(sizeof(AnimNotify_GSBase_GSNotifyCS) == 0x000040, "Wrong size on AnimNotify_GSBase_GSNotifyCS");
static_assert(offsetof(AnimNotify_GSBase_GSNotifyCS, NotifyParam) == 0x000000, "Member 'AnimNotify_GSBase_GSNotifyCS::NotifyParam' has a wrong offset!");

// Function b1.AnimNotify_GSBase.GSPostNotifyDebugCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotify_GSBase_GSPostNotifyDebugCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotify_GSBase_GSPostNotifyDebugCS) == 0x000008, "Wrong alignment on AnimNotify_GSBase_GSPostNotifyDebugCS");
static_assert(sizeof(AnimNotify_GSBase_GSPostNotifyDebugCS) == 0x000048, "Wrong size on AnimNotify_GSBase_GSPostNotifyDebugCS");
static_assert(offsetof(AnimNotify_GSBase_GSPostNotifyDebugCS, NotifyParam) == 0x000000, "Member 'AnimNotify_GSBase_GSPostNotifyDebugCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotify_GSBase_GSPostNotifyDebugCS, ReturnValue) == 0x000040, "Member 'AnimNotify_GSBase_GSPostNotifyDebugCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotify_GSBase.GSPreNotifyDebugCS
// 0x0048 (0x0048 - 0x0000)
struct AnimNotify_GSBase_GSPreNotifyDebugCS final
{
public:
	struct FUStGSNotifyParam                      NotifyParam;                                       // 0x0000(0x0040)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotify_GSBase_GSPreNotifyDebugCS) == 0x000008, "Wrong alignment on AnimNotify_GSBase_GSPreNotifyDebugCS");
static_assert(sizeof(AnimNotify_GSBase_GSPreNotifyDebugCS) == 0x000048, "Wrong size on AnimNotify_GSBase_GSPreNotifyDebugCS");
static_assert(offsetof(AnimNotify_GSBase_GSPreNotifyDebugCS, NotifyParam) == 0x000000, "Member 'AnimNotify_GSBase_GSPreNotifyDebugCS::NotifyParam' has a wrong offset!");
static_assert(offsetof(AnimNotify_GSBase_GSPreNotifyDebugCS, ReturnValue) == 0x000040, "Member 'AnimNotify_GSBase_GSPreNotifyDebugCS::ReturnValue' has a wrong offset!");

// Function b1.AnimNotify_GSBase.GSValidateInputCS
// 0x0008 (0x0008 - 0x0000)
struct AnimNotify_GSBase_GSValidateInputCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GSBase_GSValidateInputCS) == 0x000008, "Wrong alignment on AnimNotify_GSBase_GSValidateInputCS");
static_assert(sizeof(AnimNotify_GSBase_GSValidateInputCS) == 0x000008, "Wrong size on AnimNotify_GSBase_GSValidateInputCS");
static_assert(offsetof(AnimNotify_GSBase_GSValidateInputCS, Actor) == 0x000000, "Member 'AnimNotify_GSBase_GSValidateInputCS::Actor' has a wrong offset!");

// Function b1.BGUFuncLibGM.TestIntPtr
// 0x0014 (0x0014 - 0x0000)
struct BGUFuncLibGM_TestIntPtr final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPtr                                InputPtr;                                          // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntPtr                                ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibGM_TestIntPtr) == 0x000004, "Wrong alignment on BGUFuncLibGM_TestIntPtr");
static_assert(sizeof(BGUFuncLibGM_TestIntPtr) == 0x000014, "Wrong size on BGUFuncLibGM_TestIntPtr");
static_assert(offsetof(BGUFuncLibGM_TestIntPtr, Count) == 0x000000, "Member 'BGUFuncLibGM_TestIntPtr::Count' has a wrong offset!");
static_assert(offsetof(BGUFuncLibGM_TestIntPtr, InputPtr) == 0x000004, "Member 'BGUFuncLibGM_TestIntPtr::InputPtr' has a wrong offset!");
static_assert(offsetof(BGUFuncLibGM_TestIntPtr, ReturnValue) == 0x00000C, "Member 'BGUFuncLibGM_TestIntPtr::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUComponentSweepMulti
// 0x00C0 (0x00C0 - 0x0000)
struct BGUFuncLibSelectTargets_BGUComponentSweepMulti final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    PrimComp;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rot;                                               // 0x0050(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FUStGSHitResult>                SweepResults;                                      // 0x0070(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0080(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     BlockChannelsForFilter;                            // 0x0090(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     OverlapChannelsForFilter;                          // 0x00A0(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUComponentSweepMulti) == 0x000010, "Wrong alignment on BGUFuncLibSelectTargets_BGUComponentSweepMulti");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUComponentSweepMulti) == 0x0000C0, "Wrong size on BGUFuncLibSelectTargets_BGUComponentSweepMulti");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, WorldContextObject) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, TraceChannel) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::TraceChannel' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, PrimComp) == 0x000010, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::PrimComp' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, Start) == 0x000018, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::Start' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, End) == 0x000030, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::End' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, Rot) == 0x000050, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::Rot' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, SweepResults) == 0x000070, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::SweepResults' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, IgnoreActors) == 0x000080, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::IgnoreActors' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, BlockChannelsForFilter) == 0x000090, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::BlockChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, OverlapChannelsForFilter) == 0x0000A0, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::OverlapChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComponentSweepMulti, ReturnValue) == 0x0000B0, "Member 'BGUFuncLibSelectTargets_BGUComponentSweepMulti::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUCompOverlapCompsByChannel
// 0x0040 (0x0040 - 0x0000)
struct BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ComponentClassFilter;                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OutComponents;                                     // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel) == 0x000040, "Wrong size on BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel, Component) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel::Component' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel, TraceChannel) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel::TraceChannel' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel, ComponentClassFilter) == 0x000010, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel::ComponentClassFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel, ActorsToIgnore) == 0x000018, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel, OutComponents) == 0x000028, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel::OutComponents' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel, ReturnValue) == 0x000038, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByChannel::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUCompOverlapCompsByObjectType
// 0x0048 (0x0048 - 0x0000)
struct BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ComponentClassFilter;                              // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OutComponents;                                     // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType) == 0x000048, "Wrong size on BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType, Component) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType::Component' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType, ObjectTypes) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType, ComponentClassFilter) == 0x000018, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType::ComponentClassFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType, ActorsToIgnore) == 0x000020, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType, OutComponents) == 0x000030, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType::OutComponents' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType, ReturnValue) == 0x000040, "Member 'BGUFuncLibSelectTargets_BGUCompOverlapCompsByObjectType::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUComputePenetration
// 0x0080 (0x0080 - 0x0000)
struct BGUFuncLibSelectTargets_BGUComputePenetration final
{
public:
	class UPrimitiveComponent*                    SelfComponent;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    OtherComponent;                                    // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rot;                                               // 0x0050(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUComputePenetration) == 0x000010, "Wrong alignment on BGUFuncLibSelectTargets_BGUComputePenetration");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUComputePenetration) == 0x000080, "Wrong size on BGUFuncLibSelectTargets_BGUComputePenetration");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComputePenetration, SelfComponent) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUComputePenetration::SelfComponent' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComputePenetration, Direction) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUComputePenetration::Direction' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComputePenetration, Distance) == 0x000020, "Member 'BGUFuncLibSelectTargets_BGUComputePenetration::Distance' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComputePenetration, OtherComponent) == 0x000028, "Member 'BGUFuncLibSelectTargets_BGUComputePenetration::OtherComponent' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComputePenetration, Pos) == 0x000030, "Member 'BGUFuncLibSelectTargets_BGUComputePenetration::Pos' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComputePenetration, Rot) == 0x000050, "Member 'BGUFuncLibSelectTargets_BGUComputePenetration::Rot' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUComputePenetration, ReturnValue) == 0x000070, "Member 'BGUFuncLibSelectTargets_BGUComputePenetration::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUGetPerceivedActors
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibSelectTargets_BGUGetPerceivedActors final
{
public:
	const class UAIPerceptionComponent*           PerceptionComp;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUGetPerceivedActors) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGUGetPerceivedActors");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUGetPerceivedActors) == 0x000018, "Wrong size on BGUFuncLibSelectTargets_BGUGetPerceivedActors");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetPerceivedActors, PerceptionComp) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUGetPerceivedActors::PerceptionComp' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetPerceivedActors, ReturnValue) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUGetPerceivedActors::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUGetSightPerceivedActors
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibSelectTargets_BGUGetSightPerceivedActors final
{
public:
	const class UAIPerceptionComponent*           PerceptionComp;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUGetSightPerceivedActors) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGUGetSightPerceivedActors");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUGetSightPerceivedActors) == 0x000018, "Wrong size on BGUFuncLibSelectTargets_BGUGetSightPerceivedActors");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSightPerceivedActors, PerceptionComp) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUGetSightPerceivedActors::PerceptionComp' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSightPerceivedActors, ReturnValue) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUGetSightPerceivedActors::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUGetSweepCheckResultsByCollisionChannel
// 0x0170 (0x0170 - 0x0000)
struct BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PreTransform;                                      // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             CurTransform;                                      // 0x0070(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Rot;                                               // 0x00D0(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x00F0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGSSweepCheckShapeInfo                 SweepCheckShapeInfo;                               // 0x00F8(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FUStGSHitResult>                SweepResults;                                      // 0x0120(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0130(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     BlockChannelsForFilter;                            // 0x0140(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     OverlapChannelsForFilter;                          // 0x0150(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsDrawDebugShape;                                  // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel) == 0x000010, "Wrong alignment on BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel) == 0x000170, "Wrong size on BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, WorldContextObject) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, PreTransform) == 0x000010, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::PreTransform' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, CurTransform) == 0x000070, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::CurTransform' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, Rot) == 0x0000D0, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::Rot' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, CollisionChannel) == 0x0000F0, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::CollisionChannel' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, SweepCheckShapeInfo) == 0x0000F8, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::SweepCheckShapeInfo' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, SweepResults) == 0x000120, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::SweepResults' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, IgnoreActors) == 0x000130, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::IgnoreActors' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, BlockChannelsForFilter) == 0x000140, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::BlockChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, OverlapChannelsForFilter) == 0x000150, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::OverlapChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel, IsDrawDebugShape) == 0x000160, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannel::IsDrawDebugShape' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUGetSweepCheckResultsByCollisionChannelWithCaster
// 0x0180 (0x0180 - 0x0000)
struct BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PreTransform;                                      // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             CurTransform;                                      // 0x0070(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Rot;                                               // 0x00D0(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x00F0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGSSweepCheckShapeInfo                 SweepCheckShapeInfo;                               // 0x00F8(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FUStGSHitResult>                SweepResults;                                      // 0x0120(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0130(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     BlockChannelsForFilter;                            // 0x0140(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     OverlapChannelsForFilter;                          // 0x0150(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsDrawDebugShape;                                  // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Caster;                                            // 0x0168(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupId;                                           // 0x0170(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESweepCheckType                               SweepCheckType;                                    // 0x0174(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0xB];                                      // 0x0175(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster) == 0x000010, "Wrong alignment on BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster) == 0x000180, "Wrong size on BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, WorldContextObject) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, PreTransform) == 0x000010, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::PreTransform' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, CurTransform) == 0x000070, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::CurTransform' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, Rot) == 0x0000D0, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::Rot' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, CollisionChannel) == 0x0000F0, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::CollisionChannel' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, SweepCheckShapeInfo) == 0x0000F8, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::SweepCheckShapeInfo' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, SweepResults) == 0x000120, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::SweepResults' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, IgnoreActors) == 0x000130, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::IgnoreActors' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, BlockChannelsForFilter) == 0x000140, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::BlockChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, OverlapChannelsForFilter) == 0x000150, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::OverlapChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, IsDrawDebugShape) == 0x000160, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::IsDrawDebugShape' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, Caster) == 0x000168, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::Caster' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, GroupId) == 0x000170, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::GroupId' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster, SweepCheckType) == 0x000174, "Member 'BGUFuncLibSelectTargets_BGUGetSweepCheckResultsByCollisionChannelWithCaster::SweepCheckType' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUIsSelectTargetInFilterBP
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP final
{
public:
	class AActor*                                 Caster;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Filter;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP) == 0x000018, "Wrong size on BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP, Caster) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP::Caster' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP, Target) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP::Target' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP, Filter) == 0x000010, "Member 'BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP::Filter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP, ReturnValue) == 0x000014, "Member 'BGUFuncLibSelectTargets_BGUIsSelectTargetInFilterBP::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGULineTraceMultiByCollisionChannel
// 0x0088 (0x0088 - 0x0000)
struct BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUStGSHitResult>                SweepResults;                                      // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0050(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     BlockChannelsForFilter;                            // 0x0060(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     OverlapChannelsForFilter;                          // 0x0070(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsDrawDebug;                                       // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0081(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel");
static_assert(sizeof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel) == 0x000088, "Wrong size on BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, WorldContextObject) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, Start) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::Start' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, End) == 0x000020, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::End' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, CollisionChannel) == 0x000038, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::CollisionChannel' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, SweepResults) == 0x000040, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::SweepResults' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, IgnoreActors) == 0x000050, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::IgnoreActors' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, BlockChannelsForFilter) == 0x000060, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::BlockChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, OverlapChannelsForFilter) == 0x000070, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::OverlapChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, IsDrawDebug) == 0x000080, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::IsDrawDebug' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel, ReturnValue) == 0x000081, "Member 'BGUFuncLibSelectTargets_BGULineTraceMultiByCollisionChannel::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGULineTraceSingleByCollisionChannel
// 0x00F0 (0x00F0 - 0x0000)
struct BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUStGSHitResult                        SweepResult;                                       // 0x0040(0x0078)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x00B8(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     BlockChannelsForFilter;                            // 0x00C8(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECollisionChannel>                     OverlapChannelsForFilter;                          // 0x00D8(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsDrawDebug;                                       // 0x00E8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E9(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel");
static_assert(sizeof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel) == 0x0000F0, "Wrong size on BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, WorldContextObject) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, Start) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::Start' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, End) == 0x000020, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::End' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, CollisionChannel) == 0x000038, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::CollisionChannel' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, SweepResult) == 0x000040, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::SweepResult' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, IgnoreActors) == 0x0000B8, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::IgnoreActors' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, BlockChannelsForFilter) == 0x0000C8, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::BlockChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, OverlapChannelsForFilter) == 0x0000D8, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::OverlapChannelsForFilter' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, IsDrawDebug) == 0x0000E8, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::IsDrawDebug' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel, ReturnValue) == 0x0000E9, "Member 'BGUFuncLibSelectTargets_BGULineTraceSingleByCollisionChannel::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUMultiCompOverlapByObjectType
// 0x0070 (0x0070 - 0x0000)
struct BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UShapeComponent*>                OverlapShapeComponents;                            // 0x0008(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UShapeComponent*>                OverlapComps;                                      // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OverlapOtherActors;                                // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OverlapOtherComps;                                 // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType) == 0x000070, "Wrong size on BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType, WorldContextObject) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType, OverlapShapeComponents) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType::OverlapShapeComponents' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType, ObjectTypes) == 0x000018, "Member 'BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType, IgnoreActors) == 0x000028, "Member 'BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType::IgnoreActors' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType, OverlapComps) == 0x000038, "Member 'BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType::OverlapComps' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType, OverlapOtherActors) == 0x000048, "Member 'BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType::OverlapOtherActors' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType, OverlapOtherComps) == 0x000058, "Member 'BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType::OverlapOtherComps' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType, ReturnValue) == 0x000068, "Member 'BGUFuncLibSelectTargets_BGUMultiCompOverlapByObjectType::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUOverlapAnyTestByObjectType
// 0x0058 (0x0058 - 0x0000)
struct BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType final
{
public:
	class UWorld*                                 WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EGSSweepCheckShapeType                        CollisionShape;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ShapeExtent;                                       // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType) == 0x000008, "Wrong alignment on BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType) == 0x000058, "Wrong size on BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType, WorldContextObject) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType, Pos) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType::Pos' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType, ObjectTypes) == 0x000020, "Member 'BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType, CollisionShape) == 0x000030, "Member 'BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType::CollisionShape' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType, ShapeExtent) == 0x000038, "Member 'BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType::ShapeExtent' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType, ReturnValue) == 0x000050, "Member 'BGUFuncLibSelectTargets_BGUOverlapAnyTestByObjectType::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibSelectTargets.BGUOverlapMultiByObjectType
// 0x00A0 (0x00A0 - 0x0000)
struct BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rot;                                               // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGSSweepCheckShapeInfo                 OverlapShapeInfo;                                  // 0x0050(0x0028)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0078(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FUStGSOverlapResult>            OverlapResults;                                    // 0x0088(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          IsDrawDebugShape;                                  // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType) == 0x000010, "Wrong alignment on BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType");
static_assert(sizeof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType) == 0x0000A0, "Wrong size on BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType, WorldContextObject) == 0x000000, "Member 'BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType, Origin) == 0x000008, "Member 'BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType::Origin' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType, Rot) == 0x000020, "Member 'BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType::Rot' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType, ObjectTypes) == 0x000040, "Member 'BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType, OverlapShapeInfo) == 0x000050, "Member 'BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType::OverlapShapeInfo' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType, IgnoreActors) == 0x000078, "Member 'BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType::IgnoreActors' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType, OverlapResults) == 0x000088, "Member 'BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType::OverlapResults' has a wrong offset!");
static_assert(offsetof(BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType, IsDrawDebugShape) == 0x000098, "Member 'BGUFuncLibSelectTargets_BGUOverlapMultiByObjectType::IsDrawDebugShape' has a wrong offset!");

// Function b1.AutoMovePerfEditorVisualizer.DisplayVisualizedPerfInfo
// 0x0040 (0x0040 - 0x0000)
struct AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo final
{
public:
	TArray<float>                                 InTileSourceInfoArray;                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector2D                              InResolution;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              InTileCount;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InIntensityScaleFactor;                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InBaseImagePath;                                   // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo) == 0x000008, "Wrong alignment on AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo");
static_assert(sizeof(AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo) == 0x000040, "Wrong size on AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo");
static_assert(offsetof(AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo, InTileSourceInfoArray) == 0x000000, "Member 'AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo::InTileSourceInfoArray' has a wrong offset!");
static_assert(offsetof(AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo, InResolution) == 0x000010, "Member 'AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo::InResolution' has a wrong offset!");
static_assert(offsetof(AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo, InTileCount) == 0x000020, "Member 'AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo::InTileCount' has a wrong offset!");
static_assert(offsetof(AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo, InIntensityScaleFactor) == 0x000028, "Member 'AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo::InIntensityScaleFactor' has a wrong offset!");
static_assert(offsetof(AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo, InBaseImagePath) == 0x000030, "Member 'AutoMovePerfEditorVisualizer_DisplayVisualizedPerfInfo::InBaseImagePath' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.ActorChannelOpenAcked
// 0x0018 (0x0018 - 0x0000)
struct GSE_OnlineFuncLib_ActorChannelOpenAcked final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSE_OnlineFuncLib_ActorChannelOpenAcked) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_ActorChannelOpenAcked");
static_assert(sizeof(GSE_OnlineFuncLib_ActorChannelOpenAcked) == 0x000018, "Wrong size on GSE_OnlineFuncLib_ActorChannelOpenAcked");
static_assert(offsetof(GSE_OnlineFuncLib_ActorChannelOpenAcked, Actor) == 0x000000, "Member 'GSE_OnlineFuncLib_ActorChannelOpenAcked::Actor' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_ActorChannelOpenAcked, PlayerController) == 0x000008, "Member 'GSE_OnlineFuncLib_ActorChannelOpenAcked::PlayerController' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_ActorChannelOpenAcked, ReturnValue) == 0x000010, "Member 'GSE_OnlineFuncLib_ActorChannelOpenAcked::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.ActorChannelValid
// 0x0018 (0x0018 - 0x0000)
struct GSE_OnlineFuncLib_ActorChannelValid final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSE_OnlineFuncLib_ActorChannelValid) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_ActorChannelValid");
static_assert(sizeof(GSE_OnlineFuncLib_ActorChannelValid) == 0x000018, "Wrong size on GSE_OnlineFuncLib_ActorChannelValid");
static_assert(offsetof(GSE_OnlineFuncLib_ActorChannelValid, Actor) == 0x000000, "Member 'GSE_OnlineFuncLib_ActorChannelValid::Actor' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_ActorChannelValid, PlayerController) == 0x000008, "Member 'GSE_OnlineFuncLib_ActorChannelValid::PlayerController' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_ActorChannelValid, ReturnValue) == 0x000010, "Member 'GSE_OnlineFuncLib_ActorChannelValid::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.CloseActorChannelByActorAndPlayerController
// 0x0018 (0x0018 - 0x0000)
struct GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CloseReason;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController");
static_assert(sizeof(GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController) == 0x000018, "Wrong size on GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController");
static_assert(offsetof(GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController, Actor) == 0x000000, "Member 'GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController::Actor' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController, PlayerController) == 0x000008, "Member 'GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController::PlayerController' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController, CloseReason) == 0x000010, "Member 'GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController::CloseReason' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController, ReturnValue) == 0x000014, "Member 'GSE_OnlineFuncLib_CloseActorChannelByActorAndPlayerController::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.CloseClientConnection
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_CloseClientConnection final
{
public:
	EGSNetCloseResult                             CloseResult;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      ClientPlayerController;                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_CloseClientConnection) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_CloseClientConnection");
static_assert(sizeof(GSE_OnlineFuncLib_CloseClientConnection) == 0x000010, "Wrong size on GSE_OnlineFuncLib_CloseClientConnection");
static_assert(offsetof(GSE_OnlineFuncLib_CloseClientConnection, CloseResult) == 0x000000, "Member 'GSE_OnlineFuncLib_CloseClientConnection::CloseResult' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_CloseClientConnection, ClientPlayerController) == 0x000008, "Member 'GSE_OnlineFuncLib_CloseClientConnection::ClientPlayerController' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.CloseServerConnection
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_CloseServerConnection final
{
public:
	EGSNetCloseResult                             CloseResult;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContext;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_CloseServerConnection) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_CloseServerConnection");
static_assert(sizeof(GSE_OnlineFuncLib_CloseServerConnection) == 0x000010, "Wrong size on GSE_OnlineFuncLib_CloseServerConnection");
static_assert(offsetof(GSE_OnlineFuncLib_CloseServerConnection, CloseResult) == 0x000000, "Member 'GSE_OnlineFuncLib_CloseServerConnection::CloseResult' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_CloseServerConnection, WorldContext) == 0x000008, "Member 'GSE_OnlineFuncLib_CloseServerConnection::WorldContext' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.ForceRemoveNetGuid
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_ForceRemoveNetGuid final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSE_OnlineFuncLib_ForceRemoveNetGuid) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_ForceRemoveNetGuid");
static_assert(sizeof(GSE_OnlineFuncLib_ForceRemoveNetGuid) == 0x000010, "Wrong size on GSE_OnlineFuncLib_ForceRemoveNetGuid");
static_assert(offsetof(GSE_OnlineFuncLib_ForceRemoveNetGuid, Obj) == 0x000000, "Member 'GSE_OnlineFuncLib_ForceRemoveNetGuid::Obj' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_ForceRemoveNetGuid, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_ForceRemoveNetGuid::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GEngineHandleDisconnect
// 0x0008 (0x0008 - 0x0000)
struct GSE_OnlineFuncLib_GEngineHandleDisconnect final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GEngineHandleDisconnect) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GEngineHandleDisconnect");
static_assert(sizeof(GSE_OnlineFuncLib_GEngineHandleDisconnect) == 0x000008, "Wrong size on GSE_OnlineFuncLib_GEngineHandleDisconnect");
static_assert(offsetof(GSE_OnlineFuncLib_GEngineHandleDisconnect, World) == 0x000000, "Member 'GSE_OnlineFuncLib_GEngineHandleDisconnect::World' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetActorChannelActor
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_GetActorChannelActor final
{
public:
	class UActorChannel*                          Channel;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetActorChannelActor) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetActorChannelActor");
static_assert(sizeof(GSE_OnlineFuncLib_GetActorChannelActor) == 0x000010, "Wrong size on GSE_OnlineFuncLib_GetActorChannelActor");
static_assert(offsetof(GSE_OnlineFuncLib_GetActorChannelActor, Channel) == 0x000000, "Member 'GSE_OnlineFuncLib_GetActorChannelActor::Channel' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetActorChannelActor, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_GetActorChannelActor::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetGameDefaultMap
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_GetGameDefaultMap final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetGameDefaultMap) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetGameDefaultMap");
static_assert(sizeof(GSE_OnlineFuncLib_GetGameDefaultMap) == 0x000010, "Wrong size on GSE_OnlineFuncLib_GetGameDefaultMap");
static_assert(offsetof(GSE_OnlineFuncLib_GetGameDefaultMap, ReturnValue) == 0x000000, "Member 'GSE_OnlineFuncLib_GetGameDefaultMap::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetObjByNetGuid
// 0x0018 (0x0018 - 0x0000)
struct GSE_OnlineFuncLib_GetObjByNetGuid final
{
public:
	class UObject*                                WorldCtx;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Guid;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetObjByNetGuid) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetObjByNetGuid");
static_assert(sizeof(GSE_OnlineFuncLib_GetObjByNetGuid) == 0x000018, "Wrong size on GSE_OnlineFuncLib_GetObjByNetGuid");
static_assert(offsetof(GSE_OnlineFuncLib_GetObjByNetGuid, WorldCtx) == 0x000000, "Member 'GSE_OnlineFuncLib_GetObjByNetGuid::WorldCtx' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetObjByNetGuid, Guid) == 0x000008, "Member 'GSE_OnlineFuncLib_GetObjByNetGuid::Guid' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetObjByNetGuid, ReturnValue) == 0x000010, "Member 'GSE_OnlineFuncLib_GetObjByNetGuid::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetObjNetGuid
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_GetObjNetGuid final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetObjNetGuid) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetObjNetGuid");
static_assert(sizeof(GSE_OnlineFuncLib_GetObjNetGuid) == 0x000010, "Wrong size on GSE_OnlineFuncLib_GetObjNetGuid");
static_assert(offsetof(GSE_OnlineFuncLib_GetObjNetGuid, Obj) == 0x000000, "Member 'GSE_OnlineFuncLib_GetObjNetGuid::Obj' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetObjNetGuid, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_GetObjNetGuid::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetObjNetGuidByChannel
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_GetObjNetGuidByChannel final
{
public:
	class UActorChannel*                          Channel;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetObjNetGuidByChannel) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetObjNetGuidByChannel");
static_assert(sizeof(GSE_OnlineFuncLib_GetObjNetGuidByChannel) == 0x000010, "Wrong size on GSE_OnlineFuncLib_GetObjNetGuidByChannel");
static_assert(offsetof(GSE_OnlineFuncLib_GetObjNetGuidByChannel, Channel) == 0x000000, "Member 'GSE_OnlineFuncLib_GetObjNetGuidByChannel::Channel' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetObjNetGuidByChannel, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_GetObjNetGuidByChannel::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetReplicationGraph
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_GetReplicationGraph final
{
public:
	class UObject*                                WorldCtx;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetReplicationGraph) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetReplicationGraph");
static_assert(sizeof(GSE_OnlineFuncLib_GetReplicationGraph) == 0x000010, "Wrong size on GSE_OnlineFuncLib_GetReplicationGraph");
static_assert(offsetof(GSE_OnlineFuncLib_GetReplicationGraph, WorldCtx) == 0x000000, "Member 'GSE_OnlineFuncLib_GetReplicationGraph::WorldCtx' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetReplicationGraph, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_GetReplicationGraph::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetUniqueNetIdStringByFUniqueNetIdRepl
// 0x0040 (0x0040 - 0x0000)
struct GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl final
{
public:
	struct FUniqueNetIdRepl                       UniqueId;                                          // 0x0000(0x0030)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl");
static_assert(sizeof(GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl) == 0x000040, "Wrong size on GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl");
static_assert(offsetof(GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl, UniqueId) == 0x000000, "Member 'GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl::UniqueId' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl, ReturnValue) == 0x000030, "Member 'GSE_OnlineFuncLib_GetUniqueNetIdStringByFUniqueNetIdRepl::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetUniqueNetIdStringByPlayerController
// 0x0018 (0x0018 - 0x0000)
struct GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController final
{
public:
	class APlayerController*                      Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController");
static_assert(sizeof(GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController) == 0x000018, "Wrong size on GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController");
static_assert(offsetof(GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController, Controller) == 0x000000, "Member 'GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController::Controller' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerController::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.GetUniqueNetIdStringByPlayerState
// 0x0018 (0x0018 - 0x0000)
struct GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState final
{
public:
	class APlayerState*                           PlayerState;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState");
static_assert(sizeof(GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState) == 0x000018, "Wrong size on GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState");
static_assert(offsetof(GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState, PlayerState) == 0x000000, "Member 'GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState::PlayerState' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_GetUniqueNetIdStringByPlayerState::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.InServerReal
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_InServerReal final
{
public:
	class UObject*                                WorldCtx;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSE_OnlineFuncLib_InServerReal) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_InServerReal");
static_assert(sizeof(GSE_OnlineFuncLib_InServerReal) == 0x000010, "Wrong size on GSE_OnlineFuncLib_InServerReal");
static_assert(offsetof(GSE_OnlineFuncLib_InServerReal, WorldCtx) == 0x000000, "Member 'GSE_OnlineFuncLib_InServerReal::WorldCtx' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_InServerReal, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_InServerReal::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.IsActorChannelReadyForClient
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_IsActorChannelReadyForClient final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSE_OnlineFuncLib_IsActorChannelReadyForClient) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_IsActorChannelReadyForClient");
static_assert(sizeof(GSE_OnlineFuncLib_IsActorChannelReadyForClient) == 0x000010, "Wrong size on GSE_OnlineFuncLib_IsActorChannelReadyForClient");
static_assert(offsetof(GSE_OnlineFuncLib_IsActorChannelReadyForClient, Actor) == 0x000000, "Member 'GSE_OnlineFuncLib_IsActorChannelReadyForClient::Actor' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_IsActorChannelReadyForClient, ReturnValue) == 0x000008, "Member 'GSE_OnlineFuncLib_IsActorChannelReadyForClient::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.IsActorChannelReadyForServer
// 0x0018 (0x0018 - 0x0000)
struct GSE_OnlineFuncLib_IsActorChannelReadyForServer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSE_OnlineFuncLib_IsActorChannelReadyForServer) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_IsActorChannelReadyForServer");
static_assert(sizeof(GSE_OnlineFuncLib_IsActorChannelReadyForServer) == 0x000018, "Wrong size on GSE_OnlineFuncLib_IsActorChannelReadyForServer");
static_assert(offsetof(GSE_OnlineFuncLib_IsActorChannelReadyForServer, Actor) == 0x000000, "Member 'GSE_OnlineFuncLib_IsActorChannelReadyForServer::Actor' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_IsActorChannelReadyForServer, PlayerController) == 0x000008, "Member 'GSE_OnlineFuncLib_IsActorChannelReadyForServer::PlayerController' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_IsActorChannelReadyForServer, ReturnValue) == 0x000010, "Member 'GSE_OnlineFuncLib_IsActorChannelReadyForServer::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.MarkActorRoleDirty
// 0x0008 (0x0008 - 0x0000)
struct GSE_OnlineFuncLib_MarkActorRoleDirty final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_MarkActorRoleDirty) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_MarkActorRoleDirty");
static_assert(sizeof(GSE_OnlineFuncLib_MarkActorRoleDirty) == 0x000008, "Wrong size on GSE_OnlineFuncLib_MarkActorRoleDirty");
static_assert(offsetof(GSE_OnlineFuncLib_MarkActorRoleDirty, Actor) == 0x000000, "Member 'GSE_OnlineFuncLib_MarkActorRoleDirty::Actor' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.RegisterNetGuid
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_RegisterNetGuid final
{
public:
	int64                                         Guid;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_RegisterNetGuid) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_RegisterNetGuid");
static_assert(sizeof(GSE_OnlineFuncLib_RegisterNetGuid) == 0x000010, "Wrong size on GSE_OnlineFuncLib_RegisterNetGuid");
static_assert(offsetof(GSE_OnlineFuncLib_RegisterNetGuid, Guid) == 0x000000, "Member 'GSE_OnlineFuncLib_RegisterNetGuid::Guid' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_RegisterNetGuid, Obj) == 0x000008, "Member 'GSE_OnlineFuncLib_RegisterNetGuid::Obj' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.ResetNetGuidAckStat
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_ResetNetGuidAckStat final
{
public:
	int64                                         Guid;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetConnection*                         NetConnection;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_ResetNetGuidAckStat) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_ResetNetGuidAckStat");
static_assert(sizeof(GSE_OnlineFuncLib_ResetNetGuidAckStat) == 0x000010, "Wrong size on GSE_OnlineFuncLib_ResetNetGuidAckStat");
static_assert(offsetof(GSE_OnlineFuncLib_ResetNetGuidAckStat, Guid) == 0x000000, "Member 'GSE_OnlineFuncLib_ResetNetGuidAckStat::Guid' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_ResetNetGuidAckStat, NetConnection) == 0x000008, "Member 'GSE_OnlineFuncLib_ResetNetGuidAckStat::NetConnection' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.ServerReplicateOneActorToPlayer
// 0x0018 (0x0018 - 0x0000)
struct GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer");
static_assert(sizeof(GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer) == 0x000018, "Wrong size on GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer");
static_assert(offsetof(GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer, Actor) == 0x000000, "Member 'GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer::Actor' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer, PlayerController) == 0x000008, "Member 'GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer::PlayerController' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer, ReturnValue) == 0x000010, "Member 'GSE_OnlineFuncLib_ServerReplicateOneActorToPlayer::ReturnValue' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.SetGameDefaultMap
// 0x0010 (0x0010 - 0x0000)
struct GSE_OnlineFuncLib_SetGameDefaultMap final
{
public:
	class FString                                 NewMap;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_SetGameDefaultMap) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_SetGameDefaultMap");
static_assert(sizeof(GSE_OnlineFuncLib_SetGameDefaultMap) == 0x000010, "Wrong size on GSE_OnlineFuncLib_SetGameDefaultMap");
static_assert(offsetof(GSE_OnlineFuncLib_SetGameDefaultMap, NewMap) == 0x000000, "Member 'GSE_OnlineFuncLib_SetGameDefaultMap::NewMap' has a wrong offset!");

// Function b1.GSE_OnlineFuncLib.SlowMakeUniqueObjectName
// 0x0020 (0x0020 - 0x0000)
struct GSE_OnlineFuncLib_SlowMakeUniqueObjectName final
{
public:
	class UObject*                                Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UClass*                           Class_0;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InBaseName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSE_OnlineFuncLib_SlowMakeUniqueObjectName) == 0x000008, "Wrong alignment on GSE_OnlineFuncLib_SlowMakeUniqueObjectName");
static_assert(sizeof(GSE_OnlineFuncLib_SlowMakeUniqueObjectName) == 0x000020, "Wrong size on GSE_OnlineFuncLib_SlowMakeUniqueObjectName");
static_assert(offsetof(GSE_OnlineFuncLib_SlowMakeUniqueObjectName, Parent) == 0x000000, "Member 'GSE_OnlineFuncLib_SlowMakeUniqueObjectName::Parent' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_SlowMakeUniqueObjectName, Class_0) == 0x000008, "Member 'GSE_OnlineFuncLib_SlowMakeUniqueObjectName::Class_0' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_SlowMakeUniqueObjectName, InBaseName) == 0x000010, "Member 'GSE_OnlineFuncLib_SlowMakeUniqueObjectName::InBaseName' has a wrong offset!");
static_assert(offsetof(GSE_OnlineFuncLib_SlowMakeUniqueObjectName, ReturnValue) == 0x000018, "Member 'GSE_OnlineFuncLib_SlowMakeUniqueObjectName::ReturnValue' has a wrong offset!");

// Function b1.B1OnlineSession.EndOnlineSessionCS
// 0x0008 (0x0008 - 0x0000)
struct B1OnlineSession_EndOnlineSessionCS final
{
public:
	class FName                                   SessionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1OnlineSession_EndOnlineSessionCS) == 0x000004, "Wrong alignment on B1OnlineSession_EndOnlineSessionCS");
static_assert(sizeof(B1OnlineSession_EndOnlineSessionCS) == 0x000008, "Wrong size on B1OnlineSession_EndOnlineSessionCS");
static_assert(offsetof(B1OnlineSession_EndOnlineSessionCS, SessionName) == 0x000000, "Member 'B1OnlineSession_EndOnlineSessionCS::SessionName' has a wrong offset!");

// Function b1.B1OnlineSession.HandleDisconnectCS
// 0x0010 (0x0010 - 0x0000)
struct B1OnlineSession_HandleDisconnectCS final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetDriver*                             NetDriver;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1OnlineSession_HandleDisconnectCS) == 0x000008, "Wrong alignment on B1OnlineSession_HandleDisconnectCS");
static_assert(sizeof(B1OnlineSession_HandleDisconnectCS) == 0x000010, "Wrong size on B1OnlineSession_HandleDisconnectCS");
static_assert(offsetof(B1OnlineSession_HandleDisconnectCS, World) == 0x000000, "Member 'B1OnlineSession_HandleDisconnectCS::World' has a wrong offset!");
static_assert(offsetof(B1OnlineSession_HandleDisconnectCS, NetDriver) == 0x000008, "Member 'B1OnlineSession_HandleDisconnectCS::NetDriver' has a wrong offset!");

// Function b1.B1OnlineSession.OnSessionUserInviteAcceptedCS
// 0x0008 (0x0008 - 0x0000)
struct B1OnlineSession_OnSessionUserInviteAcceptedCS final
{
public:
	bool                                          bWasSuccess;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControllerId;                                      // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1OnlineSession_OnSessionUserInviteAcceptedCS) == 0x000004, "Wrong alignment on B1OnlineSession_OnSessionUserInviteAcceptedCS");
static_assert(sizeof(B1OnlineSession_OnSessionUserInviteAcceptedCS) == 0x000008, "Wrong size on B1OnlineSession_OnSessionUserInviteAcceptedCS");
static_assert(offsetof(B1OnlineSession_OnSessionUserInviteAcceptedCS, bWasSuccess) == 0x000000, "Member 'B1OnlineSession_OnSessionUserInviteAcceptedCS::bWasSuccess' has a wrong offset!");
static_assert(offsetof(B1OnlineSession_OnSessionUserInviteAcceptedCS, ControllerId) == 0x000004, "Member 'B1OnlineSession_OnSessionUserInviteAcceptedCS::ControllerId' has a wrong offset!");

// Function b1.B1OnlineSession.StartOnlineSessionCS
// 0x0008 (0x0008 - 0x0000)
struct B1OnlineSession_StartOnlineSessionCS final
{
public:
	class FName                                   SessionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1OnlineSession_StartOnlineSessionCS) == 0x000004, "Wrong alignment on B1OnlineSession_StartOnlineSessionCS");
static_assert(sizeof(B1OnlineSession_StartOnlineSessionCS) == 0x000008, "Wrong size on B1OnlineSession_StartOnlineSessionCS");
static_assert(offsetof(B1OnlineSession_StartOnlineSessionCS, SessionName) == 0x000000, "Member 'B1OnlineSession_StartOnlineSessionCS::SessionName' has a wrong offset!");

// Function b1.B1NetReplicationGraphConnection.GetPlayerControllerCS
// 0x0008 (0x0008 - 0x0000)
struct B1NetReplicationGraphConnection_GetPlayerControllerCS final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1NetReplicationGraphConnection_GetPlayerControllerCS) == 0x000008, "Wrong alignment on B1NetReplicationGraphConnection_GetPlayerControllerCS");
static_assert(sizeof(B1NetReplicationGraphConnection_GetPlayerControllerCS) == 0x000008, "Wrong size on B1NetReplicationGraphConnection_GetPlayerControllerCS");
static_assert(offsetof(B1NetReplicationGraphConnection_GetPlayerControllerCS, ReturnValue) == 0x000000, "Member 'B1NetReplicationGraphConnection_GetPlayerControllerCS::ReturnValue' has a wrong offset!");

// Function b1.B1NetReplicationGraphConnection.GSAddB1ActorChannel
// 0x0008 (0x0008 - 0x0000)
struct B1NetReplicationGraphConnection_GSAddB1ActorChannel final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1NetReplicationGraphConnection_GSAddB1ActorChannel) == 0x000008, "Wrong alignment on B1NetReplicationGraphConnection_GSAddB1ActorChannel");
static_assert(sizeof(B1NetReplicationGraphConnection_GSAddB1ActorChannel) == 0x000008, "Wrong size on B1NetReplicationGraphConnection_GSAddB1ActorChannel");
static_assert(offsetof(B1NetReplicationGraphConnection_GSAddB1ActorChannel, Actor) == 0x000000, "Member 'B1NetReplicationGraphConnection_GSAddB1ActorChannel::Actor' has a wrong offset!");

// Function b1.B1NetReplicationGraphConnection.IsInServerReal
// 0x0001 (0x0001 - 0x0000)
struct B1NetReplicationGraphConnection_IsInServerReal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1NetReplicationGraphConnection_IsInServerReal) == 0x000001, "Wrong alignment on B1NetReplicationGraphConnection_IsInServerReal");
static_assert(sizeof(B1NetReplicationGraphConnection_IsInServerReal) == 0x000001, "Wrong size on B1NetReplicationGraphConnection_IsInServerReal");
static_assert(offsetof(B1NetReplicationGraphConnection_IsInServerReal, ReturnValue) == 0x000000, "Member 'B1NetReplicationGraphConnection_IsInServerReal::ReturnValue' has a wrong offset!");

// Function b1.B1NetReplicationGraphConnection.NotifyActorChannelAddedCS
// 0x0010 (0x0010 - 0x0000)
struct B1NetReplicationGraphConnection_NotifyActorChannelAddedCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorChannel*                          Channel;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1NetReplicationGraphConnection_NotifyActorChannelAddedCS) == 0x000008, "Wrong alignment on B1NetReplicationGraphConnection_NotifyActorChannelAddedCS");
static_assert(sizeof(B1NetReplicationGraphConnection_NotifyActorChannelAddedCS) == 0x000010, "Wrong size on B1NetReplicationGraphConnection_NotifyActorChannelAddedCS");
static_assert(offsetof(B1NetReplicationGraphConnection_NotifyActorChannelAddedCS, Actor) == 0x000000, "Member 'B1NetReplicationGraphConnection_NotifyActorChannelAddedCS::Actor' has a wrong offset!");
static_assert(offsetof(B1NetReplicationGraphConnection_NotifyActorChannelAddedCS, Channel) == 0x000008, "Member 'B1NetReplicationGraphConnection_NotifyActorChannelAddedCS::Channel' has a wrong offset!");

// Function b1.B1NetReplicationGraphConnection.NotifyActorChannelCleanedUpCS
// 0x0010 (0x0010 - 0x0000)
struct B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS final
{
public:
	class UActorChannel*                          ActorChannel;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CloseReason;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS) == 0x000008, "Wrong alignment on B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS");
static_assert(sizeof(B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS) == 0x000010, "Wrong size on B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS");
static_assert(offsetof(B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS, ActorChannel) == 0x000000, "Member 'B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS::ActorChannel' has a wrong offset!");
static_assert(offsetof(B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS, CloseReason) == 0x000008, "Member 'B1NetReplicationGraphConnection_NotifyActorChannelCleanedUpCS::CloseReason' has a wrong offset!");

// Function b1.B1NetReplicationGraphConnection.NotifyActorChannelRemovedCS
// 0x0008 (0x0008 - 0x0000)
struct B1NetReplicationGraphConnection_NotifyActorChannelRemovedCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1NetReplicationGraphConnection_NotifyActorChannelRemovedCS) == 0x000008, "Wrong alignment on B1NetReplicationGraphConnection_NotifyActorChannelRemovedCS");
static_assert(sizeof(B1NetReplicationGraphConnection_NotifyActorChannelRemovedCS) == 0x000008, "Wrong size on B1NetReplicationGraphConnection_NotifyActorChannelRemovedCS");
static_assert(offsetof(B1NetReplicationGraphConnection_NotifyActorChannelRemovedCS, Actor) == 0x000000, "Member 'B1NetReplicationGraphConnection_NotifyActorChannelRemovedCS::Actor' has a wrong offset!");

// Function b1.B1NetReplicationGraphConnection.SetActorNotDormantOnConnectionCS
// 0x0008 (0x0008 - 0x0000)
struct B1NetReplicationGraphConnection_SetActorNotDormantOnConnectionCS final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1NetReplicationGraphConnection_SetActorNotDormantOnConnectionCS) == 0x000008, "Wrong alignment on B1NetReplicationGraphConnection_SetActorNotDormantOnConnectionCS");
static_assert(sizeof(B1NetReplicationGraphConnection_SetActorNotDormantOnConnectionCS) == 0x000008, "Wrong size on B1NetReplicationGraphConnection_SetActorNotDormantOnConnectionCS");
static_assert(offsetof(B1NetReplicationGraphConnection_SetActorNotDormantOnConnectionCS, InActor) == 0x000000, "Member 'B1NetReplicationGraphConnection_SetActorNotDormantOnConnectionCS::InActor' has a wrong offset!");

// Function b1.B1ReplicationGraph.AddBGUCharacterToAlwaysRelevantNodeCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_AddBGUCharacterToAlwaysRelevantNodeCS final
{
public:
	class ABGUCharacter*                          Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_AddBGUCharacterToAlwaysRelevantNodeCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_AddBGUCharacterToAlwaysRelevantNodeCS");
static_assert(sizeof(B1ReplicationGraph_AddBGUCharacterToAlwaysRelevantNodeCS) == 0x000008, "Wrong size on B1ReplicationGraph_AddBGUCharacterToAlwaysRelevantNodeCS");
static_assert(offsetof(B1ReplicationGraph_AddBGUCharacterToAlwaysRelevantNodeCS, Actor) == 0x000000, "Member 'B1ReplicationGraph_AddBGUCharacterToAlwaysRelevantNodeCS::Actor' has a wrong offset!");

// Function b1.B1ReplicationGraph.AddConnectionGraphNodeCS
// 0x0010 (0x0010 - 0x0000)
struct B1ReplicationGraph_AddConnectionGraphNodeCS final
{
public:
	class UReplicationGraphNode*                  GraphNode;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetReplicationGraphConnection*         ConnectionManager;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_AddConnectionGraphNodeCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_AddConnectionGraphNodeCS");
static_assert(sizeof(B1ReplicationGraph_AddConnectionGraphNodeCS) == 0x000010, "Wrong size on B1ReplicationGraph_AddConnectionGraphNodeCS");
static_assert(offsetof(B1ReplicationGraph_AddConnectionGraphNodeCS, GraphNode) == 0x000000, "Member 'B1ReplicationGraph_AddConnectionGraphNodeCS::GraphNode' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_AddConnectionGraphNodeCS, ConnectionManager) == 0x000008, "Member 'B1ReplicationGraph_AddConnectionGraphNodeCS::ConnectionManager' has a wrong offset!");

// Function b1.B1ReplicationGraph.AddNetworkActorCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_AddNetworkActorCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_AddNetworkActorCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_AddNetworkActorCS");
static_assert(sizeof(B1ReplicationGraph_AddNetworkActorCS) == 0x000008, "Wrong size on B1ReplicationGraph_AddNetworkActorCS");
static_assert(offsetof(B1ReplicationGraph_AddNetworkActorCS, Actor) == 0x000000, "Member 'B1ReplicationGraph_AddNetworkActorCS::Actor' has a wrong offset!");

// Function b1.B1ReplicationGraph.ClienResetActorChannelCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_ClienResetActorChannelCS final
{
public:
	class ABGUCharacter*                          Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_ClienResetActorChannelCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_ClienResetActorChannelCS");
static_assert(sizeof(B1ReplicationGraph_ClienResetActorChannelCS) == 0x000008, "Wrong size on B1ReplicationGraph_ClienResetActorChannelCS");
static_assert(offsetof(B1ReplicationGraph_ClienResetActorChannelCS, Actor) == 0x000000, "Member 'B1ReplicationGraph_ClienResetActorChannelCS::Actor' has a wrong offset!");

// Function b1.B1ReplicationGraph.GetConnectionByIndexCS
// 0x0010 (0x0010 - 0x0000)
struct B1ReplicationGraph_GetConnectionByIndexCS final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNetReplicationGraphConnection*         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_GetConnectionByIndexCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_GetConnectionByIndexCS");
static_assert(sizeof(B1ReplicationGraph_GetConnectionByIndexCS) == 0x000010, "Wrong size on B1ReplicationGraph_GetConnectionByIndexCS");
static_assert(offsetof(B1ReplicationGraph_GetConnectionByIndexCS, Idx) == 0x000000, "Member 'B1ReplicationGraph_GetConnectionByIndexCS::Idx' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_GetConnectionByIndexCS, ReturnValue) == 0x000008, "Member 'B1ReplicationGraph_GetConnectionByIndexCS::ReturnValue' has a wrong offset!");

// Function b1.B1ReplicationGraph.GetReplicationGraphConnectionByPC
// 0x0010 (0x0010 - 0x0000)
struct B1ReplicationGraph_GetReplicationGraphConnectionByPC final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UB1NetReplicationGraphConnection*       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_GetReplicationGraphConnectionByPC) == 0x000008, "Wrong alignment on B1ReplicationGraph_GetReplicationGraphConnectionByPC");
static_assert(sizeof(B1ReplicationGraph_GetReplicationGraphConnectionByPC) == 0x000010, "Wrong size on B1ReplicationGraph_GetReplicationGraphConnectionByPC");
static_assert(offsetof(B1ReplicationGraph_GetReplicationGraphConnectionByPC, PlayerController) == 0x000000, "Member 'B1ReplicationGraph_GetReplicationGraphConnectionByPC::PlayerController' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_GetReplicationGraphConnectionByPC, ReturnValue) == 0x000008, "Member 'B1ReplicationGraph_GetReplicationGraphConnectionByPC::ReturnValue' has a wrong offset!");

// Function b1.B1ReplicationGraph.GetServerConnectionCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_GetServerConnectionCS final
{
public:
	class UNetConnection*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_GetServerConnectionCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_GetServerConnectionCS");
static_assert(sizeof(B1ReplicationGraph_GetServerConnectionCS) == 0x000008, "Wrong size on B1ReplicationGraph_GetServerConnectionCS");
static_assert(offsetof(B1ReplicationGraph_GetServerConnectionCS, ReturnValue) == 0x000000, "Member 'B1ReplicationGraph_GetServerConnectionCS::ReturnValue' has a wrong offset!");

// Function b1.B1ReplicationGraph.GetWorldCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_GetWorldCS final
{
public:
	class UWorld*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_GetWorldCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_GetWorldCS");
static_assert(sizeof(B1ReplicationGraph_GetWorldCS) == 0x000008, "Wrong size on B1ReplicationGraph_GetWorldCS");
static_assert(offsetof(B1ReplicationGraph_GetWorldCS, ReturnValue) == 0x000000, "Member 'B1ReplicationGraph_GetWorldCS::ReturnValue' has a wrong offset!");

// Function b1.B1ReplicationGraph.GSNetworkRemapPathCS
// 0x0028 (0x0028 - 0x0000)
struct B1ReplicationGraph_GSNetworkRemapPathCS final
{
public:
	const class UObject*                          Outer_0;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginName;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_GSNetworkRemapPathCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_GSNetworkRemapPathCS");
static_assert(sizeof(B1ReplicationGraph_GSNetworkRemapPathCS) == 0x000028, "Wrong size on B1ReplicationGraph_GSNetworkRemapPathCS");
static_assert(offsetof(B1ReplicationGraph_GSNetworkRemapPathCS, Outer_0) == 0x000000, "Member 'B1ReplicationGraph_GSNetworkRemapPathCS::Outer_0' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_GSNetworkRemapPathCS, OriginName) == 0x000008, "Member 'B1ReplicationGraph_GSNetworkRemapPathCS::OriginName' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_GSNetworkRemapPathCS, Name_0) == 0x000018, "Member 'B1ReplicationGraph_GSNetworkRemapPathCS::Name_0' has a wrong offset!");

// Function b1.B1ReplicationGraph.InitConnectionGraphNodesCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_InitConnectionGraphNodesCS final
{
public:
	class UNetReplicationGraphConnection*         RepGraphConnection;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_InitConnectionGraphNodesCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_InitConnectionGraphNodesCS");
static_assert(sizeof(B1ReplicationGraph_InitConnectionGraphNodesCS) == 0x000008, "Wrong size on B1ReplicationGraph_InitConnectionGraphNodesCS");
static_assert(offsetof(B1ReplicationGraph_InitConnectionGraphNodesCS, RepGraphConnection) == 0x000000, "Member 'B1ReplicationGraph_InitConnectionGraphNodesCS::RepGraphConnection' has a wrong offset!");

// Function b1.B1ReplicationGraph.InitNodeCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_InitNodeCS final
{
public:
	class UB1ReplicationGraphNode_CSBase*         CSNode;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_InitNodeCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_InitNodeCS");
static_assert(sizeof(B1ReplicationGraph_InitNodeCS) == 0x000008, "Wrong size on B1ReplicationGraph_InitNodeCS");
static_assert(offsetof(B1ReplicationGraph_InitNodeCS, CSNode) == 0x000000, "Member 'B1ReplicationGraph_InitNodeCS::CSNode' has a wrong offset!");

// Function b1.B1ReplicationGraph.RemoveBGUCharacterFromAlwaysRelevantNodeCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_RemoveBGUCharacterFromAlwaysRelevantNodeCS final
{
public:
	class ABGUCharacter*                          Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_RemoveBGUCharacterFromAlwaysRelevantNodeCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_RemoveBGUCharacterFromAlwaysRelevantNodeCS");
static_assert(sizeof(B1ReplicationGraph_RemoveBGUCharacterFromAlwaysRelevantNodeCS) == 0x000008, "Wrong size on B1ReplicationGraph_RemoveBGUCharacterFromAlwaysRelevantNodeCS");
static_assert(offsetof(B1ReplicationGraph_RemoveBGUCharacterFromAlwaysRelevantNodeCS, Actor) == 0x000000, "Member 'B1ReplicationGraph_RemoveBGUCharacterFromAlwaysRelevantNodeCS::Actor' has a wrong offset!");

// Function b1.B1ReplicationGraph.RemoveConnectionGraphNodeCS
// 0x0010 (0x0010 - 0x0000)
struct B1ReplicationGraph_RemoveConnectionGraphNodeCS final
{
public:
	class UReplicationGraphNode*                  GraphNode;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNetReplicationGraphConnection*         ConnectionManager;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_RemoveConnectionGraphNodeCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_RemoveConnectionGraphNodeCS");
static_assert(sizeof(B1ReplicationGraph_RemoveConnectionGraphNodeCS) == 0x000010, "Wrong size on B1ReplicationGraph_RemoveConnectionGraphNodeCS");
static_assert(offsetof(B1ReplicationGraph_RemoveConnectionGraphNodeCS, GraphNode) == 0x000000, "Member 'B1ReplicationGraph_RemoveConnectionGraphNodeCS::GraphNode' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_RemoveConnectionGraphNodeCS, ConnectionManager) == 0x000008, "Member 'B1ReplicationGraph_RemoveConnectionGraphNodeCS::ConnectionManager' has a wrong offset!");

// Function b1.B1ReplicationGraph.RemoveNetworkActorCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_RemoveNetworkActorCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_RemoveNetworkActorCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_RemoveNetworkActorCS");
static_assert(sizeof(B1ReplicationGraph_RemoveNetworkActorCS) == 0x000008, "Wrong size on B1ReplicationGraph_RemoveNetworkActorCS");
static_assert(offsetof(B1ReplicationGraph_RemoveNetworkActorCS, Actor) == 0x000000, "Member 'B1ReplicationGraph_RemoveNetworkActorCS::Actor' has a wrong offset!");

// Function b1.B1ReplicationGraph.RouteAddNetworkActorToNodesCS
// 0x0020 (0x0020 - 0x0000)
struct B1ReplicationGraph_RouteAddNetworkActorToNodesCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_RouteAddNetworkActorToNodesCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_RouteAddNetworkActorToNodesCS");
static_assert(sizeof(B1ReplicationGraph_RouteAddNetworkActorToNodesCS) == 0x000020, "Wrong size on B1ReplicationGraph_RouteAddNetworkActorToNodesCS");
static_assert(offsetof(B1ReplicationGraph_RouteAddNetworkActorToNodesCS, Actor) == 0x000000, "Member 'B1ReplicationGraph_RouteAddNetworkActorToNodesCS::Actor' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_RouteAddNetworkActorToNodesCS, WorldLocation) == 0x000008, "Member 'B1ReplicationGraph_RouteAddNetworkActorToNodesCS::WorldLocation' has a wrong offset!");

// Function b1.B1ReplicationGraph.RouteRemoveNetworkActorToNodesCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_RouteRemoveNetworkActorToNodesCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_RouteRemoveNetworkActorToNodesCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_RouteRemoveNetworkActorToNodesCS");
static_assert(sizeof(B1ReplicationGraph_RouteRemoveNetworkActorToNodesCS) == 0x000008, "Wrong size on B1ReplicationGraph_RouteRemoveNetworkActorToNodesCS");
static_assert(offsetof(B1ReplicationGraph_RouteRemoveNetworkActorToNodesCS, Actor) == 0x000000, "Member 'B1ReplicationGraph_RouteRemoveNetworkActorToNodesCS::Actor' has a wrong offset!");

// Function b1.B1ReplicationGraph.SetAlwaysRelevantNodeCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraph_SetAlwaysRelevantNodeCS final
{
public:
	class UB1ReplicationGraphNode_CSBase*         AlwaysRelevantNodeCS;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_SetAlwaysRelevantNodeCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_SetAlwaysRelevantNodeCS");
static_assert(sizeof(B1ReplicationGraph_SetAlwaysRelevantNodeCS) == 0x000008, "Wrong size on B1ReplicationGraph_SetAlwaysRelevantNodeCS");
static_assert(offsetof(B1ReplicationGraph_SetAlwaysRelevantNodeCS, AlwaysRelevantNodeCS) == 0x000000, "Member 'B1ReplicationGraph_SetAlwaysRelevantNodeCS::AlwaysRelevantNodeCS' has a wrong offset!");

// Function b1.B1ReplicationGraph.SetGlobalReplicationClassInfo
// 0x0010 (0x0010 - 0x0000)
struct B1ReplicationGraph_SetGlobalReplicationClassInfo final
{
public:
	class UClass*                                 ReplicatedClass;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistanceSquared;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplicationPeriodFrame;                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraph_SetGlobalReplicationClassInfo) == 0x000008, "Wrong alignment on B1ReplicationGraph_SetGlobalReplicationClassInfo");
static_assert(sizeof(B1ReplicationGraph_SetGlobalReplicationClassInfo) == 0x000010, "Wrong size on B1ReplicationGraph_SetGlobalReplicationClassInfo");
static_assert(offsetof(B1ReplicationGraph_SetGlobalReplicationClassInfo, ReplicatedClass) == 0x000000, "Member 'B1ReplicationGraph_SetGlobalReplicationClassInfo::ReplicatedClass' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_SetGlobalReplicationClassInfo, CullDistanceSquared) == 0x000008, "Member 'B1ReplicationGraph_SetGlobalReplicationClassInfo::CullDistanceSquared' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_SetGlobalReplicationClassInfo, ReplicationPeriodFrame) == 0x00000C, "Member 'B1ReplicationGraph_SetGlobalReplicationClassInfo::ReplicationPeriodFrame' has a wrong offset!");

// Function b1.B1ReplicationGraph.SetRoleSwapOnReplicateCS
// 0x0010 (0x0010 - 0x0000)
struct B1ReplicationGraph_SetRoleSwapOnReplicateCS final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Swap;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1ReplicationGraph_SetRoleSwapOnReplicateCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_SetRoleSwapOnReplicateCS");
static_assert(sizeof(B1ReplicationGraph_SetRoleSwapOnReplicateCS) == 0x000010, "Wrong size on B1ReplicationGraph_SetRoleSwapOnReplicateCS");
static_assert(offsetof(B1ReplicationGraph_SetRoleSwapOnReplicateCS, Actor) == 0x000000, "Member 'B1ReplicationGraph_SetRoleSwapOnReplicateCS::Actor' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_SetRoleSwapOnReplicateCS, Swap) == 0x000008, "Member 'B1ReplicationGraph_SetRoleSwapOnReplicateCS::Swap' has a wrong offset!");

// Function b1.B1ReplicationGraph.ShouldServerMultiCastRPCForPlayerCS
// 0x0020 (0x0020 - 0x0000)
struct B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS final
{
public:
	class APlayerController*                      Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         FuncAddr;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS) == 0x000008, "Wrong alignment on B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS");
static_assert(sizeof(B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS) == 0x000020, "Wrong size on B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS");
static_assert(offsetof(B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS, Controller) == 0x000000, "Member 'B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS::Controller' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS, Actor) == 0x000008, "Member 'B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS::Actor' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS, FuncAddr) == 0x000010, "Member 'B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS::FuncAddr' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS, ReturnValue) == 0x000018, "Member 'B1ReplicationGraph_ShouldServerMultiCastRPCForPlayerCS::ReturnValue' has a wrong offset!");

// Function b1.B1ReplicationGraphNode_CSBase.GatherActorListsForConnectionCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraphNode_CSBase_GatherActorListsForConnectionCS final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraphNode_CSBase_GatherActorListsForConnectionCS) == 0x000008, "Wrong alignment on B1ReplicationGraphNode_CSBase_GatherActorListsForConnectionCS");
static_assert(sizeof(B1ReplicationGraphNode_CSBase_GatherActorListsForConnectionCS) == 0x000008, "Wrong size on B1ReplicationGraphNode_CSBase_GatherActorListsForConnectionCS");
static_assert(offsetof(B1ReplicationGraphNode_CSBase_GatherActorListsForConnectionCS, PlayerController) == 0x000000, "Member 'B1ReplicationGraphNode_CSBase_GatherActorListsForConnectionCS::PlayerController' has a wrong offset!");

// Function b1.B1ReplicationGraphNode_CSBase.NotifyAddNetworkActorCS
// 0x0008 (0x0008 - 0x0000)
struct B1ReplicationGraphNode_CSBase_NotifyAddNetworkActorCS final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraphNode_CSBase_NotifyAddNetworkActorCS) == 0x000008, "Wrong alignment on B1ReplicationGraphNode_CSBase_NotifyAddNetworkActorCS");
static_assert(sizeof(B1ReplicationGraphNode_CSBase_NotifyAddNetworkActorCS) == 0x000008, "Wrong size on B1ReplicationGraphNode_CSBase_NotifyAddNetworkActorCS");
static_assert(offsetof(B1ReplicationGraphNode_CSBase_NotifyAddNetworkActorCS, Actor) == 0x000000, "Member 'B1ReplicationGraphNode_CSBase_NotifyAddNetworkActorCS::Actor' has a wrong offset!");

// Function b1.B1ReplicationGraphNode_CSBase.NotifyRemoveNetworkActorCS
// 0x0010 (0x0010 - 0x0000)
struct B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnIfNotFound;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS) == 0x000008, "Wrong alignment on B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS");
static_assert(sizeof(B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS) == 0x000010, "Wrong size on B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS");
static_assert(offsetof(B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS, Actor) == 0x000000, "Member 'B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS::Actor' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS, bWarnIfNotFound) == 0x000008, "Member 'B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS::bWarnIfNotFound' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS, ReturnValue) == 0x000009, "Member 'B1ReplicationGraphNode_CSBase_NotifyRemoveNetworkActorCS::ReturnValue' has a wrong offset!");

// Function b1.B1ReplicationGraphNode_CSBase.LogNodeCS
// 0x0018 (0x0018 - 0x0000)
struct B1ReplicationGraphNode_CSBase_LogNodeCS final
{
public:
	int32                                         Flag;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NodeName;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1ReplicationGraphNode_CSBase_LogNodeCS) == 0x000008, "Wrong alignment on B1ReplicationGraphNode_CSBase_LogNodeCS");
static_assert(sizeof(B1ReplicationGraphNode_CSBase_LogNodeCS) == 0x000018, "Wrong size on B1ReplicationGraphNode_CSBase_LogNodeCS");
static_assert(offsetof(B1ReplicationGraphNode_CSBase_LogNodeCS, Flag) == 0x000000, "Member 'B1ReplicationGraphNode_CSBase_LogNodeCS::Flag' has a wrong offset!");
static_assert(offsetof(B1ReplicationGraphNode_CSBase_LogNodeCS, NodeName) == 0x000008, "Member 'B1ReplicationGraphNode_CSBase_LogNodeCS::NodeName' has a wrong offset!");

// Function b1.B1Util.CheckIsSimulationPlayMode
// 0x0001 (0x0001 - 0x0000)
struct B1Util_CheckIsSimulationPlayMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_CheckIsSimulationPlayMode) == 0x000001, "Wrong alignment on B1Util_CheckIsSimulationPlayMode");
static_assert(sizeof(B1Util_CheckIsSimulationPlayMode) == 0x000001, "Wrong size on B1Util_CheckIsSimulationPlayMode");
static_assert(offsetof(B1Util_CheckIsSimulationPlayMode, ReturnValue) == 0x000000, "Member 'B1Util_CheckIsSimulationPlayMode::ReturnValue' has a wrong offset!");

// Function b1.B1Util.CopyStringToClipboard
// 0x0010 (0x0010 - 0x0000)
struct B1Util_CopyStringToClipboard final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_CopyStringToClipboard) == 0x000008, "Wrong alignment on B1Util_CopyStringToClipboard");
static_assert(sizeof(B1Util_CopyStringToClipboard) == 0x000010, "Wrong size on B1Util_CopyStringToClipboard");
static_assert(offsetof(B1Util_CopyStringToClipboard, Text) == 0x000000, "Member 'B1Util_CopyStringToClipboard::Text' has a wrong offset!");

// Function b1.B1Util.GetAgreementReaded
// 0x0004 (0x0004 - 0x0000)
struct B1Util_GetAgreementReaded final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_GetAgreementReaded) == 0x000004, "Wrong alignment on B1Util_GetAgreementReaded");
static_assert(sizeof(B1Util_GetAgreementReaded) == 0x000004, "Wrong size on B1Util_GetAgreementReaded");
static_assert(offsetof(B1Util_GetAgreementReaded, ReturnValue) == 0x000000, "Member 'B1Util_GetAgreementReaded::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetArchiveMarkFinish
// 0x0001 (0x0001 - 0x0000)
struct B1Util_GetArchiveMarkFinish final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_GetArchiveMarkFinish) == 0x000001, "Wrong alignment on B1Util_GetArchiveMarkFinish");
static_assert(sizeof(B1Util_GetArchiveMarkFinish) == 0x000001, "Wrong size on B1Util_GetArchiveMarkFinish");
static_assert(offsetof(B1Util_GetArchiveMarkFinish, ReturnValue) == 0x000000, "Member 'B1Util_GetArchiveMarkFinish::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetAvailableMaps
// 0x0018 (0x0018 - 0x0000)
struct B1Util_GetAvailableMaps final
{
public:
	TArray<class FString>                         OutAvailableMaps;                                  // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1Util_GetAvailableMaps) == 0x000008, "Wrong alignment on B1Util_GetAvailableMaps");
static_assert(sizeof(B1Util_GetAvailableMaps) == 0x000018, "Wrong size on B1Util_GetAvailableMaps");
static_assert(offsetof(B1Util_GetAvailableMaps, OutAvailableMaps) == 0x000000, "Member 'B1Util_GetAvailableMaps::OutAvailableMaps' has a wrong offset!");
static_assert(offsetof(B1Util_GetAvailableMaps, ReturnValue) == 0x000010, "Member 'B1Util_GetAvailableMaps::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetFirstSettingFinish
// 0x0001 (0x0001 - 0x0000)
struct B1Util_GetFirstSettingFinish final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_GetFirstSettingFinish) == 0x000001, "Wrong alignment on B1Util_GetFirstSettingFinish");
static_assert(sizeof(B1Util_GetFirstSettingFinish) == 0x000001, "Wrong size on B1Util_GetFirstSettingFinish");
static_assert(offsetof(B1Util_GetFirstSettingFinish, ReturnValue) == 0x000000, "Member 'B1Util_GetFirstSettingFinish::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetGMCommandList
// 0x0058 (0x0058 - 0x0000)
struct B1Util_GetGMCommandList final
{
public:
	TMap<uint8, class FString>                    OutGMCommandList;                                  // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1Util_GetGMCommandList) == 0x000008, "Wrong alignment on B1Util_GetGMCommandList");
static_assert(sizeof(B1Util_GetGMCommandList) == 0x000058, "Wrong size on B1Util_GetGMCommandList");
static_assert(offsetof(B1Util_GetGMCommandList, OutGMCommandList) == 0x000000, "Member 'B1Util_GetGMCommandList::OutGMCommandList' has a wrong offset!");
static_assert(offsetof(B1Util_GetGMCommandList, ReturnValue) == 0x000050, "Member 'B1Util_GetGMCommandList::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetPrivacyAgreement
// 0x0004 (0x0004 - 0x0000)
struct B1Util_GetPrivacyAgreement final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_GetPrivacyAgreement) == 0x000004, "Wrong alignment on B1Util_GetPrivacyAgreement");
static_assert(sizeof(B1Util_GetPrivacyAgreement) == 0x000004, "Wrong size on B1Util_GetPrivacyAgreement");
static_assert(offsetof(B1Util_GetPrivacyAgreement, ReturnValue) == 0x000000, "Member 'B1Util_GetPrivacyAgreement::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetRandomNumberFloat
// 0x000C (0x000C - 0x0000)
struct B1Util_GetRandomNumberFloat final
{
public:
	float                                         LeftNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightNum;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_GetRandomNumberFloat) == 0x000004, "Wrong alignment on B1Util_GetRandomNumberFloat");
static_assert(sizeof(B1Util_GetRandomNumberFloat) == 0x00000C, "Wrong size on B1Util_GetRandomNumberFloat");
static_assert(offsetof(B1Util_GetRandomNumberFloat, LeftNum) == 0x000000, "Member 'B1Util_GetRandomNumberFloat::LeftNum' has a wrong offset!");
static_assert(offsetof(B1Util_GetRandomNumberFloat, RightNum) == 0x000004, "Member 'B1Util_GetRandomNumberFloat::RightNum' has a wrong offset!");
static_assert(offsetof(B1Util_GetRandomNumberFloat, ReturnValue) == 0x000008, "Member 'B1Util_GetRandomNumberFloat::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetRandomNumberInt
// 0x000C (0x000C - 0x0000)
struct B1Util_GetRandomNumberInt final
{
public:
	int32                                         LeftNum;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightNum;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_GetRandomNumberInt) == 0x000004, "Wrong alignment on B1Util_GetRandomNumberInt");
static_assert(sizeof(B1Util_GetRandomNumberInt) == 0x00000C, "Wrong size on B1Util_GetRandomNumberInt");
static_assert(offsetof(B1Util_GetRandomNumberInt, LeftNum) == 0x000000, "Member 'B1Util_GetRandomNumberInt::LeftNum' has a wrong offset!");
static_assert(offsetof(B1Util_GetRandomNumberInt, RightNum) == 0x000004, "Member 'B1Util_GetRandomNumberInt::RightNum' has a wrong offset!");
static_assert(offsetof(B1Util_GetRandomNumberInt, ReturnValue) == 0x000008, "Member 'B1Util_GetRandomNumberInt::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetStartCommandList
// 0x0018 (0x0018 - 0x0000)
struct B1Util_GetStartCommandList final
{
public:
	TArray<class FString>                         OutStartCommandList;                               // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1Util_GetStartCommandList) == 0x000008, "Wrong alignment on B1Util_GetStartCommandList");
static_assert(sizeof(B1Util_GetStartCommandList) == 0x000018, "Wrong size on B1Util_GetStartCommandList");
static_assert(offsetof(B1Util_GetStartCommandList, OutStartCommandList) == 0x000000, "Member 'B1Util_GetStartCommandList::OutStartCommandList' has a wrong offset!");
static_assert(offsetof(B1Util_GetStartCommandList, ReturnValue) == 0x000010, "Member 'B1Util_GetStartCommandList::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetStartLevelName
// 0x0010 (0x0010 - 0x0000)
struct B1Util_GetStartLevelName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_GetStartLevelName) == 0x000008, "Wrong alignment on B1Util_GetStartLevelName");
static_assert(sizeof(B1Util_GetStartLevelName) == 0x000010, "Wrong size on B1Util_GetStartLevelName");
static_assert(offsetof(B1Util_GetStartLevelName, ReturnValue) == 0x000000, "Member 'B1Util_GetStartLevelName::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetUISettingCustomData
// 0x0058 (0x0058 - 0x0000)
struct B1Util_GetUISettingCustomData final
{
public:
	TMap<class FString, class FString>            OutDetailSettingData;                              // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1Util_GetUISettingCustomData) == 0x000008, "Wrong alignment on B1Util_GetUISettingCustomData");
static_assert(sizeof(B1Util_GetUISettingCustomData) == 0x000058, "Wrong size on B1Util_GetUISettingCustomData");
static_assert(offsetof(B1Util_GetUISettingCustomData, OutDetailSettingData) == 0x000000, "Member 'B1Util_GetUISettingCustomData::OutDetailSettingData' has a wrong offset!");
static_assert(offsetof(B1Util_GetUISettingCustomData, ReturnValue) == 0x000050, "Member 'B1Util_GetUISettingCustomData::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetUISettingData
// 0x0058 (0x0058 - 0x0000)
struct B1Util_GetUISettingData final
{
public:
	TMap<class FString, class FString>            OutUISettingData;                                  // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(B1Util_GetUISettingData) == 0x000008, "Wrong alignment on B1Util_GetUISettingData");
static_assert(sizeof(B1Util_GetUISettingData) == 0x000058, "Wrong size on B1Util_GetUISettingData");
static_assert(offsetof(B1Util_GetUISettingData, OutUISettingData) == 0x000000, "Member 'B1Util_GetUISettingData::OutUISettingData' has a wrong offset!");
static_assert(offsetof(B1Util_GetUISettingData, ReturnValue) == 0x000050, "Member 'B1Util_GetUISettingData::ReturnValue' has a wrong offset!");

// Function b1.B1Util.GetUISettingPbTag
// 0x0004 (0x0004 - 0x0000)
struct B1Util_GetUISettingPbTag final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_GetUISettingPbTag) == 0x000004, "Wrong alignment on B1Util_GetUISettingPbTag");
static_assert(sizeof(B1Util_GetUISettingPbTag) == 0x000004, "Wrong size on B1Util_GetUISettingPbTag");
static_assert(offsetof(B1Util_GetUISettingPbTag, ReturnValue) == 0x000000, "Member 'B1Util_GetUISettingPbTag::ReturnValue' has a wrong offset!");

// Function b1.B1Util.IsNeverShowStartupUI
// 0x0001 (0x0001 - 0x0000)
struct B1Util_IsNeverShowStartupUI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_IsNeverShowStartupUI) == 0x000001, "Wrong alignment on B1Util_IsNeverShowStartupUI");
static_assert(sizeof(B1Util_IsNeverShowStartupUI) == 0x000001, "Wrong size on B1Util_IsNeverShowStartupUI");
static_assert(offsetof(B1Util_IsNeverShowStartupUI, ReturnValue) == 0x000000, "Member 'B1Util_IsNeverShowStartupUI::ReturnValue' has a wrong offset!");

// Function b1.B1Util.IsStartupConfigEnable
// 0x0001 (0x0001 - 0x0000)
struct B1Util_IsStartupConfigEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_IsStartupConfigEnable) == 0x000001, "Wrong alignment on B1Util_IsStartupConfigEnable");
static_assert(sizeof(B1Util_IsStartupConfigEnable) == 0x000001, "Wrong size on B1Util_IsStartupConfigEnable");
static_assert(offsetof(B1Util_IsStartupConfigEnable, ReturnValue) == 0x000000, "Member 'B1Util_IsStartupConfigEnable::ReturnValue' has a wrong offset!");

// Function b1.B1Util.OpenFileBrowser
// 0x0010 (0x0010 - 0x0000)
struct B1Util_OpenFileBrowser final
{
public:
	class FString                                 FolderPath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_OpenFileBrowser) == 0x000008, "Wrong alignment on B1Util_OpenFileBrowser");
static_assert(sizeof(B1Util_OpenFileBrowser) == 0x000010, "Wrong size on B1Util_OpenFileBrowser");
static_assert(offsetof(B1Util_OpenFileBrowser, FolderPath) == 0x000000, "Member 'B1Util_OpenFileBrowser::FolderPath' has a wrong offset!");

// Function b1.B1Util.SetAgreementReaded
// 0x0004 (0x0004 - 0x0000)
struct B1Util_SetAgreementReaded final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetAgreementReaded) == 0x000004, "Wrong alignment on B1Util_SetAgreementReaded");
static_assert(sizeof(B1Util_SetAgreementReaded) == 0x000004, "Wrong size on B1Util_SetAgreementReaded");
static_assert(offsetof(B1Util_SetAgreementReaded, NewValue) == 0x000000, "Member 'B1Util_SetAgreementReaded::NewValue' has a wrong offset!");

// Function b1.B1Util.SetArchiveMarkFinish
// 0x0001 (0x0001 - 0x0000)
struct B1Util_SetArchiveMarkFinish final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetArchiveMarkFinish) == 0x000001, "Wrong alignment on B1Util_SetArchiveMarkFinish");
static_assert(sizeof(B1Util_SetArchiveMarkFinish) == 0x000001, "Wrong size on B1Util_SetArchiveMarkFinish");
static_assert(offsetof(B1Util_SetArchiveMarkFinish, NewValue) == 0x000000, "Member 'B1Util_SetArchiveMarkFinish::NewValue' has a wrong offset!");

// Function b1.B1Util.SetFirstSettingFinish
// 0x0001 (0x0001 - 0x0000)
struct B1Util_SetFirstSettingFinish final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetFirstSettingFinish) == 0x000001, "Wrong alignment on B1Util_SetFirstSettingFinish");
static_assert(sizeof(B1Util_SetFirstSettingFinish) == 0x000001, "Wrong size on B1Util_SetFirstSettingFinish");
static_assert(offsetof(B1Util_SetFirstSettingFinish, NewValue) == 0x000000, "Member 'B1Util_SetFirstSettingFinish::NewValue' has a wrong offset!");

// Function b1.B1Util.SetGMCommandList
// 0x0050 (0x0050 - 0x0000)
struct B1Util_SetGMCommandList final
{
public:
	TMap<uint8, class FString>                    InGMCommandList;                                   // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetGMCommandList) == 0x000008, "Wrong alignment on B1Util_SetGMCommandList");
static_assert(sizeof(B1Util_SetGMCommandList) == 0x000050, "Wrong size on B1Util_SetGMCommandList");
static_assert(offsetof(B1Util_SetGMCommandList, InGMCommandList) == 0x000000, "Member 'B1Util_SetGMCommandList::InGMCommandList' has a wrong offset!");

// Function b1.B1Util.SetMainMonitorID
// 0x0010 (0x0010 - 0x0000)
struct B1Util_SetMainMonitorID final
{
public:
	class FString                                 MonitorID;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetMainMonitorID) == 0x000008, "Wrong alignment on B1Util_SetMainMonitorID");
static_assert(sizeof(B1Util_SetMainMonitorID) == 0x000010, "Wrong size on B1Util_SetMainMonitorID");
static_assert(offsetof(B1Util_SetMainMonitorID, MonitorID) == 0x000000, "Member 'B1Util_SetMainMonitorID::MonitorID' has a wrong offset!");

// Function b1.B1Util.SetNeverShowStartupUI
// 0x0001 (0x0001 - 0x0000)
struct B1Util_SetNeverShowStartupUI final
{
public:
	bool                                          bInNeverShowStartupUI;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetNeverShowStartupUI) == 0x000001, "Wrong alignment on B1Util_SetNeverShowStartupUI");
static_assert(sizeof(B1Util_SetNeverShowStartupUI) == 0x000001, "Wrong size on B1Util_SetNeverShowStartupUI");
static_assert(offsetof(B1Util_SetNeverShowStartupUI, bInNeverShowStartupUI) == 0x000000, "Member 'B1Util_SetNeverShowStartupUI::bInNeverShowStartupUI' has a wrong offset!");

// Function b1.B1Util.SetPrivacyAgreement
// 0x0004 (0x0004 - 0x0000)
struct B1Util_SetPrivacyAgreement final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetPrivacyAgreement) == 0x000004, "Wrong alignment on B1Util_SetPrivacyAgreement");
static_assert(sizeof(B1Util_SetPrivacyAgreement) == 0x000004, "Wrong size on B1Util_SetPrivacyAgreement");
static_assert(offsetof(B1Util_SetPrivacyAgreement, NewValue) == 0x000000, "Member 'B1Util_SetPrivacyAgreement::NewValue' has a wrong offset!");

// Function b1.B1Util.SetStartCommandList
// 0x0010 (0x0010 - 0x0000)
struct B1Util_SetStartCommandList final
{
public:
	TArray<class FString>                         InStartCommandList;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetStartCommandList) == 0x000008, "Wrong alignment on B1Util_SetStartCommandList");
static_assert(sizeof(B1Util_SetStartCommandList) == 0x000010, "Wrong size on B1Util_SetStartCommandList");
static_assert(offsetof(B1Util_SetStartCommandList, InStartCommandList) == 0x000000, "Member 'B1Util_SetStartCommandList::InStartCommandList' has a wrong offset!");

// Function b1.B1Util.SetStartLevelName
// 0x0010 (0x0010 - 0x0000)
struct B1Util_SetStartLevelName final
{
public:
	class FString                                 InStartLevelName;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetStartLevelName) == 0x000008, "Wrong alignment on B1Util_SetStartLevelName");
static_assert(sizeof(B1Util_SetStartLevelName) == 0x000010, "Wrong size on B1Util_SetStartLevelName");
static_assert(offsetof(B1Util_SetStartLevelName, InStartLevelName) == 0x000000, "Member 'B1Util_SetStartLevelName::InStartLevelName' has a wrong offset!");

// Function b1.B1Util.SetStartupConfigEnable
// 0x0001 (0x0001 - 0x0000)
struct B1Util_SetStartupConfigEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetStartupConfigEnable) == 0x000001, "Wrong alignment on B1Util_SetStartupConfigEnable");
static_assert(sizeof(B1Util_SetStartupConfigEnable) == 0x000001, "Wrong size on B1Util_SetStartupConfigEnable");
static_assert(offsetof(B1Util_SetStartupConfigEnable, bEnable) == 0x000000, "Member 'B1Util_SetStartupConfigEnable::bEnable' has a wrong offset!");

// Function b1.B1Util.SetUISettingCustomData
// 0x0050 (0x0050 - 0x0000)
struct B1Util_SetUISettingCustomData final
{
public:
	TMap<class FString, class FString>            DetailSettingData;                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetUISettingCustomData) == 0x000008, "Wrong alignment on B1Util_SetUISettingCustomData");
static_assert(sizeof(B1Util_SetUISettingCustomData) == 0x000050, "Wrong size on B1Util_SetUISettingCustomData");
static_assert(offsetof(B1Util_SetUISettingCustomData, DetailSettingData) == 0x000000, "Member 'B1Util_SetUISettingCustomData::DetailSettingData' has a wrong offset!");

// Function b1.B1Util.SetUISettingData
// 0x0050 (0x0050 - 0x0000)
struct B1Util_SetUISettingData final
{
public:
	TMap<class FString, class FString>            SetUISettingData_0;                                // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetUISettingData) == 0x000008, "Wrong alignment on B1Util_SetUISettingData");
static_assert(sizeof(B1Util_SetUISettingData) == 0x000050, "Wrong size on B1Util_SetUISettingData");
static_assert(offsetof(B1Util_SetUISettingData, SetUISettingData_0) == 0x000000, "Member 'B1Util_SetUISettingData::SetUISettingData_0' has a wrong offset!");

// Function b1.B1Util.SetUISettingPbTag
// 0x0004 (0x0004 - 0x0000)
struct B1Util_SetUISettingPbTag final
{
public:
	int32                                         TagId;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(B1Util_SetUISettingPbTag) == 0x000004, "Wrong alignment on B1Util_SetUISettingPbTag");
static_assert(sizeof(B1Util_SetUISettingPbTag) == 0x000004, "Wrong size on B1Util_SetUISettingPbTag");
static_assert(offsetof(B1Util_SetUISettingPbTag, TagId) == 0x000000, "Member 'B1Util_SetUISettingPbTag::TagId' has a wrong offset!");

// Function b1.SmartActorGuidObj.CanManageStates
// 0x0001 (0x0001 - 0x0000)
struct SmartActorGuidObj_CanManageStates final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartActorGuidObj_CanManageStates) == 0x000001, "Wrong alignment on SmartActorGuidObj_CanManageStates");
static_assert(sizeof(SmartActorGuidObj_CanManageStates) == 0x000001, "Wrong size on SmartActorGuidObj_CanManageStates");
static_assert(offsetof(SmartActorGuidObj_CanManageStates, ReturnValue) == 0x000000, "Member 'SmartActorGuidObj_CanManageStates::ReturnValue' has a wrong offset!");

// Function b1.SmartActorGuidObj.GetActorGuid
// 0x0020 (0x0020 - 0x0000)
struct SmartActorGuidObj_GetActorGuid final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutActorGuid;                                      // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SmartActorGuidObj_GetActorGuid) == 0x000008, "Wrong alignment on SmartActorGuidObj_GetActorGuid");
static_assert(sizeof(SmartActorGuidObj_GetActorGuid) == 0x000020, "Wrong size on SmartActorGuidObj_GetActorGuid");
static_assert(offsetof(SmartActorGuidObj_GetActorGuid, InActor) == 0x000000, "Member 'SmartActorGuidObj_GetActorGuid::InActor' has a wrong offset!");
static_assert(offsetof(SmartActorGuidObj_GetActorGuid, OutActorGuid) == 0x000008, "Member 'SmartActorGuidObj_GetActorGuid::OutActorGuid' has a wrong offset!");
static_assert(offsetof(SmartActorGuidObj_GetActorGuid, ReturnValue) == 0x000018, "Member 'SmartActorGuidObj_GetActorGuid::ReturnValue' has a wrong offset!");

// Function b1.SmartActorGuidObj.GetActorGuidOptions
// 0x0028 (0x0028 - 0x0000)
struct SmartActorGuidObj_GetActorGuidOptions final
{
public:
	class FString                                 PropertyName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActorGuidOption>               OutOptions;                                        // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SmartActorGuidObj_GetActorGuidOptions) == 0x000008, "Wrong alignment on SmartActorGuidObj_GetActorGuidOptions");
static_assert(sizeof(SmartActorGuidObj_GetActorGuidOptions) == 0x000028, "Wrong size on SmartActorGuidObj_GetActorGuidOptions");
static_assert(offsetof(SmartActorGuidObj_GetActorGuidOptions, PropertyName) == 0x000000, "Member 'SmartActorGuidObj_GetActorGuidOptions::PropertyName' has a wrong offset!");
static_assert(offsetof(SmartActorGuidObj_GetActorGuidOptions, OutOptions) == 0x000010, "Member 'SmartActorGuidObj_GetActorGuidOptions::OutOptions' has a wrong offset!");
static_assert(offsetof(SmartActorGuidObj_GetActorGuidOptions, ReturnValue) == 0x000020, "Member 'SmartActorGuidObj_GetActorGuidOptions::ReturnValue' has a wrong offset!");

// Function b1.BaseActorComp.ApplyWorldOffsetCS
// 0x0020 (0x0020 - 0x0000)
struct BaseActorComp_ApplyWorldOffsetCS final
{
public:
	struct FVector                                InOffset;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldShift;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BaseActorComp_ApplyWorldOffsetCS) == 0x000008, "Wrong alignment on BaseActorComp_ApplyWorldOffsetCS");
static_assert(sizeof(BaseActorComp_ApplyWorldOffsetCS) == 0x000020, "Wrong size on BaseActorComp_ApplyWorldOffsetCS");
static_assert(offsetof(BaseActorComp_ApplyWorldOffsetCS, InOffset) == 0x000000, "Member 'BaseActorComp_ApplyWorldOffsetCS::InOffset' has a wrong offset!");
static_assert(offsetof(BaseActorComp_ApplyWorldOffsetCS, bWorldShift) == 0x000018, "Member 'BaseActorComp_ApplyWorldOffsetCS::bWorldShift' has a wrong offset!");

// Function b1.BaseActorComp.EndPlayInCS
// 0x0001 (0x0001 - 0x0000)
struct BaseActorComp_EndPlayInCS final
{
public:
	EEndPlayReason                                EndPlayReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseActorComp_EndPlayInCS) == 0x000001, "Wrong alignment on BaseActorComp_EndPlayInCS");
static_assert(sizeof(BaseActorComp_EndPlayInCS) == 0x000001, "Wrong size on BaseActorComp_EndPlayInCS");
static_assert(offsetof(BaseActorComp_EndPlayInCS, EndPlayReason) == 0x000000, "Member 'BaseActorComp_EndPlayInCS::EndPlayReason' has a wrong offset!");

// Function b1.BaseActorComp.GetDebugID
// 0x0004 (0x0004 - 0x0000)
struct BaseActorComp_GetDebugID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseActorComp_GetDebugID) == 0x000004, "Wrong alignment on BaseActorComp_GetDebugID");
static_assert(sizeof(BaseActorComp_GetDebugID) == 0x000004, "Wrong size on BaseActorComp_GetDebugID");
static_assert(offsetof(BaseActorComp_GetDebugID, ReturnValue) == 0x000000, "Member 'BaseActorComp_GetDebugID::ReturnValue' has a wrong offset!");

// Function b1.BaseActorComp.GetLogLvl
// 0x0004 (0x0004 - 0x0000)
struct BaseActorComp_GetLogLvl final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseActorComp_GetLogLvl) == 0x000004, "Wrong alignment on BaseActorComp_GetLogLvl");
static_assert(sizeof(BaseActorComp_GetLogLvl) == 0x000004, "Wrong size on BaseActorComp_GetLogLvl");
static_assert(offsetof(BaseActorComp_GetLogLvl, ReturnValue) == 0x000000, "Member 'BaseActorComp_GetLogLvl::ReturnValue' has a wrong offset!");

// Function b1.BaseActorCompTickable.TickComponentInCS
// 0x0004 (0x0004 - 0x0000)
struct BaseActorCompTickable_TickComponentInCS final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseActorCompTickable_TickComponentInCS) == 0x000004, "Wrong alignment on BaseActorCompTickable_TickComponentInCS");
static_assert(sizeof(BaseActorCompTickable_TickComponentInCS) == 0x000004, "Wrong size on BaseActorCompTickable_TickComponentInCS");
static_assert(offsetof(BaseActorCompTickable_TickComponentInCS, DeltaTime) == 0x000000, "Member 'BaseActorCompTickable_TickComponentInCS::DeltaTime' has a wrong offset!");

// Function b1.BaseEditorTickableActorComp.OnPropertyChanged
// 0x0020 (0x0020 - 0x0000)
struct BaseEditorTickableActorComp_OnPropertyChanged final
{
public:
	class FString                                 MemberName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseEditorTickableActorComp_OnPropertyChanged) == 0x000008, "Wrong alignment on BaseEditorTickableActorComp_OnPropertyChanged");
static_assert(sizeof(BaseEditorTickableActorComp_OnPropertyChanged) == 0x000020, "Wrong size on BaseEditorTickableActorComp_OnPropertyChanged");
static_assert(offsetof(BaseEditorTickableActorComp_OnPropertyChanged, MemberName) == 0x000000, "Member 'BaseEditorTickableActorComp_OnPropertyChanged::MemberName' has a wrong offset!");
static_assert(offsetof(BaseEditorTickableActorComp_OnPropertyChanged, PropertyName) == 0x000010, "Member 'BaseEditorTickableActorComp_OnPropertyChanged::PropertyName' has a wrong offset!");

// Function b1.SceneComponentTickable.EndPlayGS
// 0x0001 (0x0001 - 0x0000)
struct SceneComponentTickable_EndPlayGS final
{
public:
	EEndPlayReason                                EndPlayReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponentTickable_EndPlayGS) == 0x000001, "Wrong alignment on SceneComponentTickable_EndPlayGS");
static_assert(sizeof(SceneComponentTickable_EndPlayGS) == 0x000001, "Wrong size on SceneComponentTickable_EndPlayGS");
static_assert(offsetof(SceneComponentTickable_EndPlayGS, EndPlayReason) == 0x000000, "Member 'SceneComponentTickable_EndPlayGS::EndPlayReason' has a wrong offset!");

// Function b1.SceneComponentTickable.TickComponentGS
// 0x0004 (0x0004 - 0x0000)
struct SceneComponentTickable_TickComponentGS final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponentTickable_TickComponentGS) == 0x000004, "Wrong alignment on SceneComponentTickable_TickComponentGS");
static_assert(sizeof(SceneComponentTickable_TickComponentGS) == 0x000004, "Wrong size on SceneComponentTickable_TickComponentGS");
static_assert(offsetof(SceneComponentTickable_TickComponentGS, DeltaTime) == 0x000000, "Member 'SceneComponentTickable_TickComponentGS::DeltaTime' has a wrong offset!");

// Function b1.EditorOnlyCompBase.GetParamDisplayNameCS
// 0x0030 (0x0030 - 0x0000)
struct EditorOnlyCompBase_GetParamDisplayNameCS final
{
public:
	class FString                                 PropertyName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCalliopeGuid                          ConfigGuid;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EditorOnlyCompBase_GetParamDisplayNameCS) == 0x000008, "Wrong alignment on EditorOnlyCompBase_GetParamDisplayNameCS");
static_assert(sizeof(EditorOnlyCompBase_GetParamDisplayNameCS) == 0x000030, "Wrong size on EditorOnlyCompBase_GetParamDisplayNameCS");
static_assert(offsetof(EditorOnlyCompBase_GetParamDisplayNameCS, PropertyName) == 0x000000, "Member 'EditorOnlyCompBase_GetParamDisplayNameCS::PropertyName' has a wrong offset!");
static_assert(offsetof(EditorOnlyCompBase_GetParamDisplayNameCS, ConfigGuid) == 0x000010, "Member 'EditorOnlyCompBase_GetParamDisplayNameCS::ConfigGuid' has a wrong offset!");
static_assert(offsetof(EditorOnlyCompBase_GetParamDisplayNameCS, ReturnValue) == 0x000020, "Member 'EditorOnlyCompBase_GetParamDisplayNameCS::ReturnValue' has a wrong offset!");

// Function b1.EditorOnlyCompBase.GetPossibleParamsCS
// 0x0030 (0x0030 - 0x0000)
struct EditorOnlyCompBase_GetPossibleParamsCS final
{
public:
	class FString                                 ParentPropertyName;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCalliopeGuid>                  OutParamArray;                                     // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(EditorOnlyCompBase_GetPossibleParamsCS) == 0x000008, "Wrong alignment on EditorOnlyCompBase_GetPossibleParamsCS");
static_assert(sizeof(EditorOnlyCompBase_GetPossibleParamsCS) == 0x000030, "Wrong size on EditorOnlyCompBase_GetPossibleParamsCS");
static_assert(offsetof(EditorOnlyCompBase_GetPossibleParamsCS, ParentPropertyName) == 0x000000, "Member 'EditorOnlyCompBase_GetPossibleParamsCS::ParentPropertyName' has a wrong offset!");
static_assert(offsetof(EditorOnlyCompBase_GetPossibleParamsCS, PropertyName) == 0x000010, "Member 'EditorOnlyCompBase_GetPossibleParamsCS::PropertyName' has a wrong offset!");
static_assert(offsetof(EditorOnlyCompBase_GetPossibleParamsCS, OutParamArray) == 0x000020, "Member 'EditorOnlyCompBase_GetPossibleParamsCS::OutParamArray' has a wrong offset!");

// Function b1.BGPPlayerCameraManager.OnViewTargetChangedCS
// 0x0018 (0x0018 - 0x0000)
struct BGPPlayerCameraManager_OnViewTargetChangedCS final
{
public:
	class APlayerController*                      PC;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OldViewTarget;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NewViewTarget;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerCameraManager_OnViewTargetChangedCS) == 0x000008, "Wrong alignment on BGPPlayerCameraManager_OnViewTargetChangedCS");
static_assert(sizeof(BGPPlayerCameraManager_OnViewTargetChangedCS) == 0x000018, "Wrong size on BGPPlayerCameraManager_OnViewTargetChangedCS");
static_assert(offsetof(BGPPlayerCameraManager_OnViewTargetChangedCS, PC) == 0x000000, "Member 'BGPPlayerCameraManager_OnViewTargetChangedCS::PC' has a wrong offset!");
static_assert(offsetof(BGPPlayerCameraManager_OnViewTargetChangedCS, OldViewTarget) == 0x000008, "Member 'BGPPlayerCameraManager_OnViewTargetChangedCS::OldViewTarget' has a wrong offset!");
static_assert(offsetof(BGPPlayerCameraManager_OnViewTargetChangedCS, NewViewTarget) == 0x000010, "Member 'BGPPlayerCameraManager_OnViewTargetChangedCS::NewViewTarget' has a wrong offset!");

// Function b1.BGPPlayerCameraManager.SetViewTargetCS
// 0x0018 (0x0018 - 0x0000)
struct BGPPlayerCameraManager_SetViewTargetCS final
{
public:
	class AActor*                                 NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0008(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerCameraManager_SetViewTargetCS) == 0x000008, "Wrong alignment on BGPPlayerCameraManager_SetViewTargetCS");
static_assert(sizeof(BGPPlayerCameraManager_SetViewTargetCS) == 0x000018, "Wrong size on BGPPlayerCameraManager_SetViewTargetCS");
static_assert(offsetof(BGPPlayerCameraManager_SetViewTargetCS, NewViewTarget) == 0x000000, "Member 'BGPPlayerCameraManager_SetViewTargetCS::NewViewTarget' has a wrong offset!");
static_assert(offsetof(BGPPlayerCameraManager_SetViewTargetCS, TransitionParams) == 0x000008, "Member 'BGPPlayerCameraManager_SetViewTargetCS::TransitionParams' has a wrong offset!");

// Function b1.BGPPlayerCameraManager.UpdateCameraCS
// 0x0004 (0x0004 - 0x0000)
struct BGPPlayerCameraManager_UpdateCameraCS final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerCameraManager_UpdateCameraCS) == 0x000004, "Wrong alignment on BGPPlayerCameraManager_UpdateCameraCS");
static_assert(sizeof(BGPPlayerCameraManager_UpdateCameraCS) == 0x000004, "Wrong size on BGPPlayerCameraManager_UpdateCameraCS");
static_assert(offsetof(BGPPlayerCameraManager_UpdateCameraCS, DeltaTime) == 0x000000, "Member 'BGPPlayerCameraManager_UpdateCameraCS::DeltaTime' has a wrong offset!");

// Function b1.BGPPlayerCameraManager.GetPendingViewTargetCS
// 0x0008 (0x0008 - 0x0000)
struct BGPPlayerCameraManager_GetPendingViewTargetCS final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerCameraManager_GetPendingViewTargetCS) == 0x000008, "Wrong alignment on BGPPlayerCameraManager_GetPendingViewTargetCS");
static_assert(sizeof(BGPPlayerCameraManager_GetPendingViewTargetCS) == 0x000008, "Wrong size on BGPPlayerCameraManager_GetPendingViewTargetCS");
static_assert(offsetof(BGPPlayerCameraManager_GetPendingViewTargetCS, ReturnValue) == 0x000000, "Member 'BGPPlayerCameraManager_GetPendingViewTargetCS::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerCameraManager.GetViewTargetCS
// 0x0008 (0x0008 - 0x0000)
struct BGPPlayerCameraManager_GetViewTargetCS final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerCameraManager_GetViewTargetCS) == 0x000008, "Wrong alignment on BGPPlayerCameraManager_GetViewTargetCS");
static_assert(sizeof(BGPPlayerCameraManager_GetViewTargetCS) == 0x000008, "Wrong size on BGPPlayerCameraManager_GetViewTargetCS");
static_assert(offsetof(BGPPlayerCameraManager_GetViewTargetCS, ReturnValue) == 0x000000, "Member 'BGPPlayerCameraManager_GetViewTargetCS::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerController.GetCachedConsoleCommandCS
// 0x0010 (0x0010 - 0x0000)
struct BGPPlayerController_GetCachedConsoleCommandCS final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetCachedConsoleCommandCS) == 0x000008, "Wrong alignment on BGPPlayerController_GetCachedConsoleCommandCS");
static_assert(sizeof(BGPPlayerController_GetCachedConsoleCommandCS) == 0x000010, "Wrong size on BGPPlayerController_GetCachedConsoleCommandCS");
static_assert(offsetof(BGPPlayerController_GetCachedConsoleCommandCS, ReturnValue) == 0x000000, "Member 'BGPPlayerController_GetCachedConsoleCommandCS::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerController.GetCachedConsoleWorldContext
// 0x0008 (0x0008 - 0x0000)
struct BGPPlayerController_GetCachedConsoleWorldContext final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetCachedConsoleWorldContext) == 0x000008, "Wrong alignment on BGPPlayerController_GetCachedConsoleWorldContext");
static_assert(sizeof(BGPPlayerController_GetCachedConsoleWorldContext) == 0x000008, "Wrong size on BGPPlayerController_GetCachedConsoleWorldContext");
static_assert(offsetof(BGPPlayerController_GetCachedConsoleWorldContext, ReturnValue) == 0x000000, "Member 'BGPPlayerController_GetCachedConsoleWorldContext::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerController.ConsoleCommandCS
// 0x0010 (0x0010 - 0x0000)
struct BGPPlayerController_ConsoleCommandCS final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_ConsoleCommandCS) == 0x000008, "Wrong alignment on BGPPlayerController_ConsoleCommandCS");
static_assert(sizeof(BGPPlayerController_ConsoleCommandCS) == 0x000010, "Wrong size on BGPPlayerController_ConsoleCommandCS");
static_assert(offsetof(BGPPlayerController_ConsoleCommandCS, Command) == 0x000000, "Member 'BGPPlayerController_ConsoleCommandCS::Command' has a wrong offset!");

// Function b1.BGPPlayerController.GetCameraBlendTimeToGo
// 0x0004 (0x0004 - 0x0000)
struct BGPPlayerController_GetCameraBlendTimeToGo final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetCameraBlendTimeToGo) == 0x000004, "Wrong alignment on BGPPlayerController_GetCameraBlendTimeToGo");
static_assert(sizeof(BGPPlayerController_GetCameraBlendTimeToGo) == 0x000004, "Wrong size on BGPPlayerController_GetCameraBlendTimeToGo");
static_assert(offsetof(BGPPlayerController_GetCameraBlendTimeToGo, ReturnValue) == 0x000000, "Member 'BGPPlayerController_GetCameraBlendTimeToGo::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerController.GetIsShouldPerformFullTickWhenPaused
// 0x0001 (0x0001 - 0x0000)
struct BGPPlayerController_GetIsShouldPerformFullTickWhenPaused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetIsShouldPerformFullTickWhenPaused) == 0x000001, "Wrong alignment on BGPPlayerController_GetIsShouldPerformFullTickWhenPaused");
static_assert(sizeof(BGPPlayerController_GetIsShouldPerformFullTickWhenPaused) == 0x000001, "Wrong size on BGPPlayerController_GetIsShouldPerformFullTickWhenPaused");
static_assert(offsetof(BGPPlayerController_GetIsShouldPerformFullTickWhenPaused, ReturnValue) == 0x000000, "Member 'BGPPlayerController_GetIsShouldPerformFullTickWhenPaused::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerController.GetNetConnectionCS
// 0x0008 (0x0008 - 0x0000)
struct BGPPlayerController_GetNetConnectionCS final
{
public:
	class UNetConnection*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetNetConnectionCS) == 0x000008, "Wrong alignment on BGPPlayerController_GetNetConnectionCS");
static_assert(sizeof(BGPPlayerController_GetNetConnectionCS) == 0x000008, "Wrong size on BGPPlayerController_GetNetConnectionCS");
static_assert(offsetof(BGPPlayerController_GetNetConnectionCS, ReturnValue) == 0x000000, "Member 'BGPPlayerController_GetNetConnectionCS::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerController.GetPendingViewTarget
// 0x0008 (0x0008 - 0x0000)
struct BGPPlayerController_GetPendingViewTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetPendingViewTarget) == 0x000008, "Wrong alignment on BGPPlayerController_GetPendingViewTarget");
static_assert(sizeof(BGPPlayerController_GetPendingViewTarget) == 0x000008, "Wrong size on BGPPlayerController_GetPendingViewTarget");
static_assert(offsetof(BGPPlayerController_GetPendingViewTarget, ReturnValue) == 0x000000, "Member 'BGPPlayerController_GetPendingViewTarget::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerController.GetSeamlessTravelActorListCS
// 0x0018 (0x0018 - 0x0000)
struct BGPPlayerController_GetSeamlessTravelActorListCS final
{
public:
	bool                                          bToEntry;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorList;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetSeamlessTravelActorListCS) == 0x000008, "Wrong alignment on BGPPlayerController_GetSeamlessTravelActorListCS");
static_assert(sizeof(BGPPlayerController_GetSeamlessTravelActorListCS) == 0x000018, "Wrong size on BGPPlayerController_GetSeamlessTravelActorListCS");
static_assert(offsetof(BGPPlayerController_GetSeamlessTravelActorListCS, bToEntry) == 0x000000, "Member 'BGPPlayerController_GetSeamlessTravelActorListCS::bToEntry' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_GetSeamlessTravelActorListCS, ActorList) == 0x000008, "Member 'BGPPlayerController_GetSeamlessTravelActorListCS::ActorList' has a wrong offset!");

// Function b1.BGPPlayerController.GetSpawnLocationCS
// 0x0018 (0x0018 - 0x0000)
struct BGPPlayerController_GetSpawnLocationCS final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetSpawnLocationCS) == 0x000008, "Wrong alignment on BGPPlayerController_GetSpawnLocationCS");
static_assert(sizeof(BGPPlayerController_GetSpawnLocationCS) == 0x000018, "Wrong size on BGPPlayerController_GetSpawnLocationCS");
static_assert(offsetof(BGPPlayerController_GetSpawnLocationCS, ReturnValue) == 0x000000, "Member 'BGPPlayerController_GetSpawnLocationCS::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerController.OnPossessWithViewTargetBlend
// 0x0018 (0x0018 - 0x0000)
struct BGPPlayerController_OnPossessWithViewTargetBlend final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunc;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOutgoing;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableBlendViewTarget;                             // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGPPlayerController_OnPossessWithViewTargetBlend) == 0x000008, "Wrong alignment on BGPPlayerController_OnPossessWithViewTargetBlend");
static_assert(sizeof(BGPPlayerController_OnPossessWithViewTargetBlend) == 0x000018, "Wrong size on BGPPlayerController_OnPossessWithViewTargetBlend");
static_assert(offsetof(BGPPlayerController_OnPossessWithViewTargetBlend, InPawn) == 0x000000, "Member 'BGPPlayerController_OnPossessWithViewTargetBlend::InPawn' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_OnPossessWithViewTargetBlend, BlendTime) == 0x000008, "Member 'BGPPlayerController_OnPossessWithViewTargetBlend::BlendTime' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_OnPossessWithViewTargetBlend, BlendFunc) == 0x00000C, "Member 'BGPPlayerController_OnPossessWithViewTargetBlend::BlendFunc' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_OnPossessWithViewTargetBlend, BlendExp) == 0x000010, "Member 'BGPPlayerController_OnPossessWithViewTargetBlend::BlendExp' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_OnPossessWithViewTargetBlend, bLockOutgoing) == 0x000014, "Member 'BGPPlayerController_OnPossessWithViewTargetBlend::bLockOutgoing' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_OnPossessWithViewTargetBlend, EnableBlendViewTarget) == 0x000015, "Member 'BGPPlayerController_OnPossessWithViewTargetBlend::EnableBlendViewTarget' has a wrong offset!");

// Function b1.BGPPlayerController.SetIsShouldPerformFullTickWhenPaused
// 0x0001 (0x0001 - 0x0000)
struct BGPPlayerController_SetIsShouldPerformFullTickWhenPaused final
{
public:
	bool                                          IsShould;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_SetIsShouldPerformFullTickWhenPaused) == 0x000001, "Wrong alignment on BGPPlayerController_SetIsShouldPerformFullTickWhenPaused");
static_assert(sizeof(BGPPlayerController_SetIsShouldPerformFullTickWhenPaused) == 0x000001, "Wrong size on BGPPlayerController_SetIsShouldPerformFullTickWhenPaused");
static_assert(offsetof(BGPPlayerController_SetIsShouldPerformFullTickWhenPaused, IsShould) == 0x000000, "Member 'BGPPlayerController_SetIsShouldPerformFullTickWhenPaused::IsShould' has a wrong offset!");

// Function b1.BGPPlayerController.SetSpawnLocationCS
// 0x0018 (0x0018 - 0x0000)
struct BGPPlayerController_SetSpawnLocationCS final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_SetSpawnLocationCS) == 0x000008, "Wrong alignment on BGPPlayerController_SetSpawnLocationCS");
static_assert(sizeof(BGPPlayerController_SetSpawnLocationCS) == 0x000018, "Wrong size on BGPPlayerController_SetSpawnLocationCS");
static_assert(offsetof(BGPPlayerController_SetSpawnLocationCS, NewLocation) == 0x000000, "Member 'BGPPlayerController_SetSpawnLocationCS::NewLocation' has a wrong offset!");

// Function b1.BGPPlayerController.GetAudioListenerPositionCS
// 0x0048 (0x0048 - 0x0000)
struct BGPPlayerController_GetAudioListenerPositionCS final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutFrontDir;                                       // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutRightDir;                                       // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetAudioListenerPositionCS) == 0x000008, "Wrong alignment on BGPPlayerController_GetAudioListenerPositionCS");
static_assert(sizeof(BGPPlayerController_GetAudioListenerPositionCS) == 0x000048, "Wrong size on BGPPlayerController_GetAudioListenerPositionCS");
static_assert(offsetof(BGPPlayerController_GetAudioListenerPositionCS, OutLocation) == 0x000000, "Member 'BGPPlayerController_GetAudioListenerPositionCS::OutLocation' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_GetAudioListenerPositionCS, OutFrontDir) == 0x000018, "Member 'BGPPlayerController_GetAudioListenerPositionCS::OutFrontDir' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_GetAudioListenerPositionCS, OutRightDir) == 0x000030, "Member 'BGPPlayerController_GetAudioListenerPositionCS::OutRightDir' has a wrong offset!");

// Function b1.BGPPlayerController.GetAudioListenerRotationCS
// 0x0018 (0x0018 - 0x0000)
struct BGPPlayerController_GetAudioListenerRotationCS final
{
public:
	struct FRotator                               OutRotation;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerController_GetAudioListenerRotationCS) == 0x000008, "Wrong alignment on BGPPlayerController_GetAudioListenerRotationCS");
static_assert(sizeof(BGPPlayerController_GetAudioListenerRotationCS) == 0x000018, "Wrong size on BGPPlayerController_GetAudioListenerRotationCS");
static_assert(offsetof(BGPPlayerController_GetAudioListenerRotationCS, OutRotation) == 0x000000, "Member 'BGPPlayerController_GetAudioListenerRotationCS::OutRotation' has a wrong offset!");

// Function b1.BGPPlayerController.GetPlayerViewPointCS
// 0x0038 (0x0038 - 0x0000)
struct BGPPlayerController_GetPlayerViewPointCS final
{
public:
	struct FVector                                Out_Location;                                      // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Out_Rotation;                                      // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGPPlayerController_GetPlayerViewPointCS) == 0x000008, "Wrong alignment on BGPPlayerController_GetPlayerViewPointCS");
static_assert(sizeof(BGPPlayerController_GetPlayerViewPointCS) == 0x000038, "Wrong size on BGPPlayerController_GetPlayerViewPointCS");
static_assert(offsetof(BGPPlayerController_GetPlayerViewPointCS, Out_Location) == 0x000000, "Member 'BGPPlayerController_GetPlayerViewPointCS::Out_Location' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_GetPlayerViewPointCS, Out_Rotation) == 0x000018, "Member 'BGPPlayerController_GetPlayerViewPointCS::Out_Rotation' has a wrong offset!");
static_assert(offsetof(BGPPlayerController_GetPlayerViewPointCS, ReturnValue) == 0x000030, "Member 'BGPPlayerController_GetPlayerViewPointCS::ReturnValue' has a wrong offset!");

// Function b1.BGPPlayerReverseReplicator.SetOwnerBGUChr
// 0x0008 (0x0008 - 0x0000)
struct BGPPlayerReverseReplicator_SetOwnerBGUChr final
{
public:
	class ABGUCharacter*                          BGUOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGPPlayerReverseReplicator_SetOwnerBGUChr) == 0x000008, "Wrong alignment on BGPPlayerReverseReplicator_SetOwnerBGUChr");
static_assert(sizeof(BGPPlayerReverseReplicator_SetOwnerBGUChr) == 0x000008, "Wrong size on BGPPlayerReverseReplicator_SetOwnerBGUChr");
static_assert(offsetof(BGPPlayerReverseReplicator_SetOwnerBGUChr, BGUOwner) == 0x000000, "Member 'BGPPlayerReverseReplicator_SetOwnerBGUChr::BGUOwner' has a wrong offset!");

// Function b1.BGUActorBase.ApplyWorldOffsetCS
// 0x0020 (0x0020 - 0x0000)
struct BGUActorBase_ApplyWorldOffsetCS final
{
public:
	struct FVector                                InOffset;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldShift;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUActorBase_ApplyWorldOffsetCS) == 0x000008, "Wrong alignment on BGUActorBase_ApplyWorldOffsetCS");
static_assert(sizeof(BGUActorBase_ApplyWorldOffsetCS) == 0x000020, "Wrong size on BGUActorBase_ApplyWorldOffsetCS");
static_assert(offsetof(BGUActorBase_ApplyWorldOffsetCS, InOffset) == 0x000000, "Member 'BGUActorBase_ApplyWorldOffsetCS::InOffset' has a wrong offset!");
static_assert(offsetof(BGUActorBase_ApplyWorldOffsetCS, bWorldShift) == 0x000018, "Member 'BGUActorBase_ApplyWorldOffsetCS::bWorldShift' has a wrong offset!");

// Function b1.BGUActorBase.AttachBaseActorComp
// 0x0008 (0x0008 - 0x0000)
struct BGUActorBase_AttachBaseActorComp final
{
public:
	class UBaseActorComp*                         Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_AttachBaseActorComp) == 0x000008, "Wrong alignment on BGUActorBase_AttachBaseActorComp");
static_assert(sizeof(BGUActorBase_AttachBaseActorComp) == 0x000008, "Wrong size on BGUActorBase_AttachBaseActorComp");
static_assert(offsetof(BGUActorBase_AttachBaseActorComp, Comp) == 0x000000, "Member 'BGUActorBase_AttachBaseActorComp::Comp' has a wrong offset!");

// Function b1.BGUActorBase.GetBUSEventCollection
// 0x0008 (0x0008 - 0x0000)
struct BGUActorBase_GetBUSEventCollection final
{
public:
	class UBUS_EventCollection*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_GetBUSEventCollection) == 0x000008, "Wrong alignment on BGUActorBase_GetBUSEventCollection");
static_assert(sizeof(BGUActorBase_GetBUSEventCollection) == 0x000008, "Wrong size on BGUActorBase_GetBUSEventCollection");
static_assert(offsetof(BGUActorBase_GetBUSEventCollection, ReturnValue) == 0x000000, "Member 'BGUActorBase_GetBUSEventCollection::ReturnValue' has a wrong offset!");

// Function b1.BGUActorBase.OnConstructionCS
// 0x0060 (0x0060 - 0x0000)
struct BGUActorBase_OnConstructionCS final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_OnConstructionCS) == 0x000010, "Wrong alignment on BGUActorBase_OnConstructionCS");
static_assert(sizeof(BGUActorBase_OnConstructionCS) == 0x000060, "Wrong size on BGUActorBase_OnConstructionCS");
static_assert(offsetof(BGUActorBase_OnConstructionCS, Transform) == 0x000000, "Member 'BGUActorBase_OnConstructionCS::Transform' has a wrong offset!");

// Function b1.BGUActorBase.OnPostEditMove
// 0x0001 (0x0001 - 0x0000)
struct BGUActorBase_OnPostEditMove final
{
public:
	bool                                          bFinish;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_OnPostEditMove) == 0x000001, "Wrong alignment on BGUActorBase_OnPostEditMove");
static_assert(sizeof(BGUActorBase_OnPostEditMove) == 0x000001, "Wrong size on BGUActorBase_OnPostEditMove");
static_assert(offsetof(BGUActorBase_OnPostEditMove, bFinish) == 0x000000, "Member 'BGUActorBase_OnPostEditMove::bFinish' has a wrong offset!");

// Function b1.BGUActorBase.OnPropertyChanged
// 0x0020 (0x0020 - 0x0000)
struct BGUActorBase_OnPropertyChanged final
{
public:
	class FString                                 MemberName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_OnPropertyChanged) == 0x000008, "Wrong alignment on BGUActorBase_OnPropertyChanged");
static_assert(sizeof(BGUActorBase_OnPropertyChanged) == 0x000020, "Wrong size on BGUActorBase_OnPropertyChanged");
static_assert(offsetof(BGUActorBase_OnPropertyChanged, MemberName) == 0x000000, "Member 'BGUActorBase_OnPropertyChanged::MemberName' has a wrong offset!");
static_assert(offsetof(BGUActorBase_OnPropertyChanged, PropertyName) == 0x000010, "Member 'BGUActorBase_OnPropertyChanged::PropertyName' has a wrong offset!");

// Function b1.BGUActorBase.SetCompCanEverAffectNavigation
// 0x0010 (0x0010 - 0x0000)
struct BGUActorBase_SetCompCanEverAffectNavigation final
{
public:
	class UActorComponent*                        ActorComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelevant;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUActorBase_SetCompCanEverAffectNavigation) == 0x000008, "Wrong alignment on BGUActorBase_SetCompCanEverAffectNavigation");
static_assert(sizeof(BGUActorBase_SetCompCanEverAffectNavigation) == 0x000010, "Wrong size on BGUActorBase_SetCompCanEverAffectNavigation");
static_assert(offsetof(BGUActorBase_SetCompCanEverAffectNavigation, ActorComponent) == 0x000000, "Member 'BGUActorBase_SetCompCanEverAffectNavigation::ActorComponent' has a wrong offset!");
static_assert(offsetof(BGUActorBase_SetCompCanEverAffectNavigation, bRelevant) == 0x000008, "Member 'BGUActorBase_SetCompCanEverAffectNavigation::bRelevant' has a wrong offset!");

// Function b1.BGUActorBase.SetRootComponentCS
// 0x0008 (0x0008 - 0x0000)
struct BGUActorBase_SetRootComponentCS final
{
public:
	class USceneComponent*                        NewRootComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_SetRootComponentCS) == 0x000008, "Wrong alignment on BGUActorBase_SetRootComponentCS");
static_assert(sizeof(BGUActorBase_SetRootComponentCS) == 0x000008, "Wrong size on BGUActorBase_SetRootComponentCS");
static_assert(offsetof(BGUActorBase_SetRootComponentCS, NewRootComponent) == 0x000000, "Member 'BGUActorBase_SetRootComponentCS::NewRootComponent' has a wrong offset!");

// Function b1.BGUActorBase.SetTeamID
// 0x0004 (0x0004 - 0x0000)
struct BGUActorBase_SetTeamID final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_SetTeamID) == 0x000004, "Wrong alignment on BGUActorBase_SetTeamID");
static_assert(sizeof(BGUActorBase_SetTeamID) == 0x000004, "Wrong size on BGUActorBase_SetTeamID");
static_assert(offsetof(BGUActorBase_SetTeamID, ID) == 0x000000, "Member 'BGUActorBase_SetTeamID::ID' has a wrong offset!");

// Function b1.BGUActorBase.GetActorGuid
// 0x0018 (0x0018 - 0x0000)
struct BGUActorBase_GetActorGuid final
{
public:
	class FString                                 OutActorGuid;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUActorBase_GetActorGuid) == 0x000008, "Wrong alignment on BGUActorBase_GetActorGuid");
static_assert(sizeof(BGUActorBase_GetActorGuid) == 0x000018, "Wrong size on BGUActorBase_GetActorGuid");
static_assert(offsetof(BGUActorBase_GetActorGuid, OutActorGuid) == 0x000000, "Member 'BGUActorBase_GetActorGuid::OutActorGuid' has a wrong offset!");
static_assert(offsetof(BGUActorBase_GetActorGuid, ReturnValue) == 0x000010, "Member 'BGUActorBase_GetActorGuid::ReturnValue' has a wrong offset!");

// Function b1.BGUActorBase.GetActorGuidCS
// 0x0018 (0x0018 - 0x0000)
struct BGUActorBase_GetActorGuidCS final
{
public:
	class FString                                 OutActorGuid;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUActorBase_GetActorGuidCS) == 0x000008, "Wrong alignment on BGUActorBase_GetActorGuidCS");
static_assert(sizeof(BGUActorBase_GetActorGuidCS) == 0x000018, "Wrong size on BGUActorBase_GetActorGuidCS");
static_assert(offsetof(BGUActorBase_GetActorGuidCS, OutActorGuid) == 0x000000, "Member 'BGUActorBase_GetActorGuidCS::OutActorGuid' has a wrong offset!");
static_assert(offsetof(BGUActorBase_GetActorGuidCS, ReturnValue) == 0x000010, "Member 'BGUActorBase_GetActorGuidCS::ReturnValue' has a wrong offset!");

// Function b1.BGUActorBase.GetTeamID
// 0x0004 (0x0004 - 0x0000)
struct BGUActorBase_GetTeamID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_GetTeamID) == 0x000004, "Wrong alignment on BGUActorBase_GetTeamID");
static_assert(sizeof(BGUActorBase_GetTeamID) == 0x000004, "Wrong size on BGUActorBase_GetTeamID");
static_assert(offsetof(BGUActorBase_GetTeamID, ReturnValue) == 0x000000, "Member 'BGUActorBase_GetTeamID::ReturnValue' has a wrong offset!");

// Function b1.BGUActorBase.GetTeamIDCS
// 0x0004 (0x0004 - 0x0000)
struct BGUActorBase_GetTeamIDCS final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUActorBase_GetTeamIDCS) == 0x000004, "Wrong alignment on BGUActorBase_GetTeamIDCS");
static_assert(sizeof(BGUActorBase_GetTeamIDCS) == 0x000004, "Wrong size on BGUActorBase_GetTeamIDCS");
static_assert(offsetof(BGUActorBase_GetTeamIDCS, ReturnValue) == 0x000000, "Member 'BGUActorBase_GetTeamIDCS::ReturnValue' has a wrong offset!");

// Function b1.BGUAnimationSyncComponent.OnBeginSyncAnimationOnGuest
// 0x0040 (0x0040 - 0x0000)
struct BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest final
{
public:
	class UAnimMontage*                           InGuestMontage;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InTargetSyncPointOnHost;                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSelfSyncPointOnGuest;                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebugDraw;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NotifyBeginTime;                                   // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 DummyMesh;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InGuestActor;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendInTime;                                     // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSceneCollision;                             // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest) == 0x000008, "Wrong alignment on BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest");
static_assert(sizeof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest) == 0x000040, "Wrong size on BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, InGuestMontage) == 0x000000, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::InGuestMontage' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, InTargetSyncPointOnHost) == 0x000008, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::InTargetSyncPointOnHost' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, InSelfSyncPointOnGuest) == 0x000010, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::InSelfSyncPointOnGuest' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, bEnableDebugDraw) == 0x000018, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::bEnableDebugDraw' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, NotifyBeginTime) == 0x00001C, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::NotifyBeginTime' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, DummyMesh) == 0x000020, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::DummyMesh' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, InGuestActor) == 0x000028, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::InGuestActor' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, InBlendInTime) == 0x000030, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::InBlendInTime' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, PlayRate) == 0x000034, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::PlayRate' has a wrong offset!");
static_assert(offsetof(BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest, bIgnoreSceneCollision) == 0x000038, "Member 'BGUAnimationSyncComponent_OnBeginSyncAnimationOnGuest::bIgnoreSceneCollision' has a wrong offset!");

// Function b1.BGUAnimationSyncComponent.OnEndSyncAnimationOnGuest
// 0x0001 (0x0001 - 0x0000)
struct BGUAnimationSyncComponent_OnEndSyncAnimationOnGuest final
{
public:
	bool                                          bStopGuestMontage;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUAnimationSyncComponent_OnEndSyncAnimationOnGuest) == 0x000001, "Wrong alignment on BGUAnimationSyncComponent_OnEndSyncAnimationOnGuest");
static_assert(sizeof(BGUAnimationSyncComponent_OnEndSyncAnimationOnGuest) == 0x000001, "Wrong size on BGUAnimationSyncComponent_OnEndSyncAnimationOnGuest");
static_assert(offsetof(BGUAnimationSyncComponent_OnEndSyncAnimationOnGuest, bStopGuestMontage) == 0x000000, "Member 'BGUAnimationSyncComponent_OnEndSyncAnimationOnGuest::bStopGuestMontage' has a wrong offset!");

// Function b1.BGUAnimationSyncComponent.OnRespectCollisionInASS
// 0x0001 (0x0001 - 0x0000)
struct BGUAnimationSyncComponent_OnRespectCollisionInASS final
{
public:
	bool                                          bRespect;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUAnimationSyncComponent_OnRespectCollisionInASS) == 0x000001, "Wrong alignment on BGUAnimationSyncComponent_OnRespectCollisionInASS");
static_assert(sizeof(BGUAnimationSyncComponent_OnRespectCollisionInASS) == 0x000001, "Wrong size on BGUAnimationSyncComponent_OnRespectCollisionInASS");
static_assert(offsetof(BGUAnimationSyncComponent_OnRespectCollisionInASS, bRespect) == 0x000000, "Member 'BGUAnimationSyncComponent_OnRespectCollisionInASS::bRespect' has a wrong offset!");

// Function b1.BGUAnimationSyncComponent.OnSwitchSyncGuestTarget
// 0x0008 (0x0008 - 0x0000)
struct BGUAnimationSyncComponent_OnSwitchSyncGuestTarget final
{
public:
	class AActor*                                 NewGuest;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUAnimationSyncComponent_OnSwitchSyncGuestTarget) == 0x000008, "Wrong alignment on BGUAnimationSyncComponent_OnSwitchSyncGuestTarget");
static_assert(sizeof(BGUAnimationSyncComponent_OnSwitchSyncGuestTarget) == 0x000008, "Wrong size on BGUAnimationSyncComponent_OnSwitchSyncGuestTarget");
static_assert(offsetof(BGUAnimationSyncComponent_OnSwitchSyncGuestTarget, NewGuest) == 0x000000, "Member 'BGUAnimationSyncComponent_OnSwitchSyncGuestTarget::NewGuest' has a wrong offset!");

// Function b1.BGUBounceCheckObject.BindBounceEvent
// 0x0008 (0x0008 - 0x0000)
struct BGUBounceCheckObject_BindBounceEvent final
{
public:
	class UProjectileMovementComponent*           ProjectileMovementComp;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUBounceCheckObject_BindBounceEvent) == 0x000008, "Wrong alignment on BGUBounceCheckObject_BindBounceEvent");
static_assert(sizeof(BGUBounceCheckObject_BindBounceEvent) == 0x000008, "Wrong size on BGUBounceCheckObject_BindBounceEvent");
static_assert(offsetof(BGUBounceCheckObject_BindBounceEvent, ProjectileMovementComp) == 0x000000, "Member 'BGUBounceCheckObject_BindBounceEvent::ProjectileMovementComp' has a wrong offset!");

// Function b1.BGUBounceCheckObject.OnBounceCheck
// 0x0100 (0x0100 - 0x0000)
struct BGUBounceCheckObject_OnBounceCheck final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                OldVelocity;                                       // 0x00E8(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUBounceCheckObject_OnBounceCheck) == 0x000008, "Wrong alignment on BGUBounceCheckObject_OnBounceCheck");
static_assert(sizeof(BGUBounceCheckObject_OnBounceCheck) == 0x000100, "Wrong size on BGUBounceCheckObject_OnBounceCheck");
static_assert(offsetof(BGUBounceCheckObject_OnBounceCheck, Hit) == 0x000000, "Member 'BGUBounceCheckObject_OnBounceCheck::Hit' has a wrong offset!");
static_assert(offsetof(BGUBounceCheckObject_OnBounceCheck, OldVelocity) == 0x0000E8, "Member 'BGUBounceCheckObject_OnBounceCheck::OldVelocity' has a wrong offset!");

// Function b1.BGUCharacter.AttachBaseActorComp
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_AttachBaseActorComp final
{
public:
	class UBaseActorComp*                         Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_AttachBaseActorComp) == 0x000008, "Wrong alignment on BGUCharacter_AttachBaseActorComp");
static_assert(sizeof(BGUCharacter_AttachBaseActorComp) == 0x000008, "Wrong size on BGUCharacter_AttachBaseActorComp");
static_assert(offsetof(BGUCharacter_AttachBaseActorComp, Comp) == 0x000000, "Member 'BGUCharacter_AttachBaseActorComp::Comp' has a wrong offset!");

// Function b1.BGUCharacter.GetBUSEventCollection
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_GetBUSEventCollection final
{
public:
	class UBUS_EventCollection*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_GetBUSEventCollection) == 0x000008, "Wrong alignment on BGUCharacter_GetBUSEventCollection");
static_assert(sizeof(BGUCharacter_GetBUSEventCollection) == 0x000008, "Wrong size on BGUCharacter_GetBUSEventCollection");
static_assert(offsetof(BGUCharacter_GetBUSEventCollection, ReturnValue) == 0x000000, "Member 'BGUCharacter_GetBUSEventCollection::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.GetGSAuthorityPlayerCS
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_GetGSAuthorityPlayerCS final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_GetGSAuthorityPlayerCS) == 0x000008, "Wrong alignment on BGUCharacter_GetGSAuthorityPlayerCS");
static_assert(sizeof(BGUCharacter_GetGSAuthorityPlayerCS) == 0x000008, "Wrong size on BGUCharacter_GetGSAuthorityPlayerCS");
static_assert(offsetof(BGUCharacter_GetGSAuthorityPlayerCS, ReturnValue) == 0x000000, "Member 'BGUCharacter_GetGSAuthorityPlayerCS::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.GetHostSyncMontageSyncStartTime
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacter_GetHostSyncMontageSyncStartTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_GetHostSyncMontageSyncStartTime) == 0x000004, "Wrong alignment on BGUCharacter_GetHostSyncMontageSyncStartTime");
static_assert(sizeof(BGUCharacter_GetHostSyncMontageSyncStartTime) == 0x000004, "Wrong size on BGUCharacter_GetHostSyncMontageSyncStartTime");
static_assert(offsetof(BGUCharacter_GetHostSyncMontageSyncStartTime, ReturnValue) == 0x000000, "Member 'BGUCharacter_GetHostSyncMontageSyncStartTime::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.GSSwapNetRoleCS
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacter_GSSwapNetRoleCS final
{
public:
	bool                                          HasAuthority_0;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_GSSwapNetRoleCS) == 0x000001, "Wrong alignment on BGUCharacter_GSSwapNetRoleCS");
static_assert(sizeof(BGUCharacter_GSSwapNetRoleCS) == 0x000001, "Wrong size on BGUCharacter_GSSwapNetRoleCS");
static_assert(offsetof(BGUCharacter_GSSwapNetRoleCS, HasAuthority_0) == 0x000000, "Member 'BGUCharacter_GSSwapNetRoleCS::HasAuthority_0' has a wrong offset!");

// Function b1.BGUCharacter.IsInGuestSyncMontage
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacter_IsInGuestSyncMontage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_IsInGuestSyncMontage) == 0x000001, "Wrong alignment on BGUCharacter_IsInGuestSyncMontage");
static_assert(sizeof(BGUCharacter_IsInGuestSyncMontage) == 0x000001, "Wrong size on BGUCharacter_IsInGuestSyncMontage");
static_assert(offsetof(BGUCharacter_IsInGuestSyncMontage, ReturnValue) == 0x000000, "Member 'BGUCharacter_IsInGuestSyncMontage::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.IsPlayerCharacterCS
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacter_IsPlayerCharacterCS final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_IsPlayerCharacterCS) == 0x000001, "Wrong alignment on BGUCharacter_IsPlayerCharacterCS");
static_assert(sizeof(BGUCharacter_IsPlayerCharacterCS) == 0x000001, "Wrong size on BGUCharacter_IsPlayerCharacterCS");
static_assert(offsetof(BGUCharacter_IsPlayerCharacterCS, ReturnValue) == 0x000000, "Member 'BGUCharacter_IsPlayerCharacterCS::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.OnActorChannelOpen
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_OnActorChannelOpen final
{
public:
	class UNetConnection*                         Connection;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_OnActorChannelOpen) == 0x000008, "Wrong alignment on BGUCharacter_OnActorChannelOpen");
static_assert(sizeof(BGUCharacter_OnActorChannelOpen) == 0x000008, "Wrong size on BGUCharacter_OnActorChannelOpen");
static_assert(offsetof(BGUCharacter_OnActorChannelOpen, Connection) == 0x000000, "Member 'BGUCharacter_OnActorChannelOpen::Connection' has a wrong offset!");

// Function b1.BGUCharacter.OnConstructionCS
// 0x0060 (0x0060 - 0x0000)
struct BGUCharacter_OnConstructionCS final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_OnConstructionCS) == 0x000010, "Wrong alignment on BGUCharacter_OnConstructionCS");
static_assert(sizeof(BGUCharacter_OnConstructionCS) == 0x000060, "Wrong size on BGUCharacter_OnConstructionCS");
static_assert(offsetof(BGUCharacter_OnConstructionCS, Transform) == 0x000000, "Member 'BGUCharacter_OnConstructionCS::Transform' has a wrong offset!");

// Function b1.BGUCharacter.OnGuestSyncMontage
// 0x0010 (0x0010 - 0x0000)
struct BGUCharacter_OnGuestSyncMontage final
{
public:
	class UAnimMontage*                           _HostSyncMontage;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HostSyncMontageStartTime;                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUCharacter_OnGuestSyncMontage) == 0x000008, "Wrong alignment on BGUCharacter_OnGuestSyncMontage");
static_assert(sizeof(BGUCharacter_OnGuestSyncMontage) == 0x000010, "Wrong size on BGUCharacter_OnGuestSyncMontage");
static_assert(offsetof(BGUCharacter_OnGuestSyncMontage, _HostSyncMontage) == 0x000000, "Member 'BGUCharacter_OnGuestSyncMontage::_HostSyncMontage' has a wrong offset!");
static_assert(offsetof(BGUCharacter_OnGuestSyncMontage, _HostSyncMontageStartTime) == 0x000008, "Member 'BGUCharacter_OnGuestSyncMontage::_HostSyncMontageStartTime' has a wrong offset!");

// Function b1.BGUCharacter.OnMovementModeChangedCS
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacter_OnMovementModeChangedCS final
{
public:
	EMovementMode                                 PrevMovementMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 NewMovementMode;                                   // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PrevCustomMode;                                    // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewCustomMode;                                     // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_OnMovementModeChangedCS) == 0x000001, "Wrong alignment on BGUCharacter_OnMovementModeChangedCS");
static_assert(sizeof(BGUCharacter_OnMovementModeChangedCS) == 0x000004, "Wrong size on BGUCharacter_OnMovementModeChangedCS");
static_assert(offsetof(BGUCharacter_OnMovementModeChangedCS, PrevMovementMode) == 0x000000, "Member 'BGUCharacter_OnMovementModeChangedCS::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(BGUCharacter_OnMovementModeChangedCS, NewMovementMode) == 0x000001, "Member 'BGUCharacter_OnMovementModeChangedCS::NewMovementMode' has a wrong offset!");
static_assert(offsetof(BGUCharacter_OnMovementModeChangedCS, PrevCustomMode) == 0x000002, "Member 'BGUCharacter_OnMovementModeChangedCS::PrevCustomMode' has a wrong offset!");
static_assert(offsetof(BGUCharacter_OnMovementModeChangedCS, NewCustomMode) == 0x000003, "Member 'BGUCharacter_OnMovementModeChangedCS::NewCustomMode' has a wrong offset!");

// Function b1.BGUCharacter.OnPossessedCS
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_OnPossessedCS final
{
public:
	class AController*                            NewController;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_OnPossessedCS) == 0x000008, "Wrong alignment on BGUCharacter_OnPossessedCS");
static_assert(sizeof(BGUCharacter_OnPossessedCS) == 0x000008, "Wrong size on BGUCharacter_OnPossessedCS");
static_assert(offsetof(BGUCharacter_OnPossessedCS, NewController) == 0x000000, "Member 'BGUCharacter_OnPossessedCS::NewController' has a wrong offset!");

// Function b1.BGUCharacter.SetPreferActorRotToControlRot
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacter_SetPreferActorRotToControlRot final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_SetPreferActorRotToControlRot) == 0x000001, "Wrong alignment on BGUCharacter_SetPreferActorRotToControlRot");
static_assert(sizeof(BGUCharacter_SetPreferActorRotToControlRot) == 0x000001, "Wrong size on BGUCharacter_SetPreferActorRotToControlRot");
static_assert(offsetof(BGUCharacter_SetPreferActorRotToControlRot, bValue) == 0x000000, "Member 'BGUCharacter_SetPreferActorRotToControlRot::bValue' has a wrong offset!");

// Function b1.BGUCharacter.SetTamerOwner
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_SetTamerOwner final
{
public:
	class ABGUTamerBase*                          NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_SetTamerOwner) == 0x000008, "Wrong alignment on BGUCharacter_SetTamerOwner");
static_assert(sizeof(BGUCharacter_SetTamerOwner) == 0x000008, "Wrong size on BGUCharacter_SetTamerOwner");
static_assert(offsetof(BGUCharacter_SetTamerOwner, NewOwner) == 0x000000, "Member 'BGUCharacter_SetTamerOwner::NewOwner' has a wrong offset!");

// Function b1.BGUCharacter.SetTeamID
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacter_SetTeamID final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_SetTeamID) == 0x000004, "Wrong alignment on BGUCharacter_SetTeamID");
static_assert(sizeof(BGUCharacter_SetTeamID) == 0x000004, "Wrong size on BGUCharacter_SetTeamID");
static_assert(offsetof(BGUCharacter_SetTeamID, ID) == 0x000000, "Member 'BGUCharacter_SetTeamID::ID' has a wrong offset!");

// Function b1.BGUCharacter.SetupPlayerInputComponentCS
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_SetupPlayerInputComponentCS final
{
public:
	class UInputComponent*                        PlayerInputComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_SetupPlayerInputComponentCS) == 0x000008, "Wrong alignment on BGUCharacter_SetupPlayerInputComponentCS");
static_assert(sizeof(BGUCharacter_SetupPlayerInputComponentCS) == 0x000008, "Wrong size on BGUCharacter_SetupPlayerInputComponentCS");
static_assert(offsetof(BGUCharacter_SetupPlayerInputComponentCS, PlayerInputComponent) == 0x000000, "Member 'BGUCharacter_SetupPlayerInputComponentCS::PlayerInputComponent' has a wrong offset!");

// Function b1.BGUCharacter.SetViewRotationYawOffset
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacter_SetViewRotationYawOffset final
{
public:
	float                                         NewOffset;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_SetViewRotationYawOffset) == 0x000004, "Wrong alignment on BGUCharacter_SetViewRotationYawOffset");
static_assert(sizeof(BGUCharacter_SetViewRotationYawOffset) == 0x000004, "Wrong size on BGUCharacter_SetViewRotationYawOffset");
static_assert(offsetof(BGUCharacter_SetViewRotationYawOffset, NewOffset) == 0x000000, "Member 'BGUCharacter_SetViewRotationYawOffset::NewOffset' has a wrong offset!");

// Function b1.BGUCharacter.SwitchNetRoleOnly
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacter_SwitchNetRoleOnly final
{
public:
	bool                                          HasAuthority_0;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_SwitchNetRoleOnly) == 0x000001, "Wrong alignment on BGUCharacter_SwitchNetRoleOnly");
static_assert(sizeof(BGUCharacter_SwitchNetRoleOnly) == 0x000001, "Wrong size on BGUCharacter_SwitchNetRoleOnly");
static_assert(offsetof(BGUCharacter_SwitchNetRoleOnly, HasAuthority_0) == 0x000000, "Member 'BGUCharacter_SwitchNetRoleOnly::HasAuthority_0' has a wrong offset!");

// Function b1.BGUCharacter.TryGetComponentByName
// 0x0010 (0x0010 - 0x0000)
struct BGUCharacter_TryGetComponentByName final
{
public:
	class FName                                   CompName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_TryGetComponentByName) == 0x000008, "Wrong alignment on BGUCharacter_TryGetComponentByName");
static_assert(sizeof(BGUCharacter_TryGetComponentByName) == 0x000010, "Wrong size on BGUCharacter_TryGetComponentByName");
static_assert(offsetof(BGUCharacter_TryGetComponentByName, CompName) == 0x000000, "Member 'BGUCharacter_TryGetComponentByName::CompName' has a wrong offset!");
static_assert(offsetof(BGUCharacter_TryGetComponentByName, ReturnValue) == 0x000008, "Member 'BGUCharacter_TryGetComponentByName::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.TryGetHostSyncMontage
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_TryGetHostSyncMontage final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_TryGetHostSyncMontage) == 0x000008, "Wrong alignment on BGUCharacter_TryGetHostSyncMontage");
static_assert(sizeof(BGUCharacter_TryGetHostSyncMontage) == 0x000008, "Wrong size on BGUCharacter_TryGetHostSyncMontage");
static_assert(offsetof(BGUCharacter_TryGetHostSyncMontage, ReturnValue) == 0x000000, "Member 'BGUCharacter_TryGetHostSyncMontage::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.GetActorGuid
// 0x0018 (0x0018 - 0x0000)
struct BGUCharacter_GetActorGuid final
{
public:
	class FString                                 OutActorGuid;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUCharacter_GetActorGuid) == 0x000008, "Wrong alignment on BGUCharacter_GetActorGuid");
static_assert(sizeof(BGUCharacter_GetActorGuid) == 0x000018, "Wrong size on BGUCharacter_GetActorGuid");
static_assert(offsetof(BGUCharacter_GetActorGuid, OutActorGuid) == 0x000000, "Member 'BGUCharacter_GetActorGuid::OutActorGuid' has a wrong offset!");
static_assert(offsetof(BGUCharacter_GetActorGuid, ReturnValue) == 0x000010, "Member 'BGUCharacter_GetActorGuid::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.GetActorGuidCS
// 0x0018 (0x0018 - 0x0000)
struct BGUCharacter_GetActorGuidCS final
{
public:
	class FString                                 OutActorGuid;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUCharacter_GetActorGuidCS) == 0x000008, "Wrong alignment on BGUCharacter_GetActorGuidCS");
static_assert(sizeof(BGUCharacter_GetActorGuidCS) == 0x000018, "Wrong size on BGUCharacter_GetActorGuidCS");
static_assert(offsetof(BGUCharacter_GetActorGuidCS, OutActorGuid) == 0x000000, "Member 'BGUCharacter_GetActorGuidCS::OutActorGuid' has a wrong offset!");
static_assert(offsetof(BGUCharacter_GetActorGuidCS, ReturnValue) == 0x000010, "Member 'BGUCharacter_GetActorGuidCS::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.GetTamerOwner
// 0x0008 (0x0008 - 0x0000)
struct BGUCharacter_GetTamerOwner final
{
public:
	class ABGUTamerBase*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_GetTamerOwner) == 0x000008, "Wrong alignment on BGUCharacter_GetTamerOwner");
static_assert(sizeof(BGUCharacter_GetTamerOwner) == 0x000008, "Wrong size on BGUCharacter_GetTamerOwner");
static_assert(offsetof(BGUCharacter_GetTamerOwner, ReturnValue) == 0x000000, "Member 'BGUCharacter_GetTamerOwner::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.GetTeamID
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacter_GetTeamID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_GetTeamID) == 0x000004, "Wrong alignment on BGUCharacter_GetTeamID");
static_assert(sizeof(BGUCharacter_GetTeamID) == 0x000004, "Wrong size on BGUCharacter_GetTeamID");
static_assert(offsetof(BGUCharacter_GetTeamID, ReturnValue) == 0x000000, "Member 'BGUCharacter_GetTeamID::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacter.GetViewRotationYawOffset
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacter_GetViewRotationYawOffset final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacter_GetViewRotationYawOffset) == 0x000004, "Wrong alignment on BGUCharacter_GetViewRotationYawOffset");
static_assert(sizeof(BGUCharacter_GetViewRotationYawOffset) == 0x000004, "Wrong size on BGUCharacter_GetViewRotationYawOffset");
static_assert(offsetof(BGUCharacter_GetViewRotationYawOffset, ReturnValue) == 0x000000, "Member 'BGUCharacter_GetViewRotationYawOffset::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.CanGetNormalAndSurfaceTypeInfoFromMovement
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_CanGetNormalAndSurfaceTypeInfoFromMovement final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_CanGetNormalAndSurfaceTypeInfoFromMovement) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_CanGetNormalAndSurfaceTypeInfoFromMovement");
static_assert(sizeof(BGUCharacterMovementComponent_CanGetNormalAndSurfaceTypeInfoFromMovement) == 0x000001, "Wrong size on BGUCharacterMovementComponent_CanGetNormalAndSurfaceTypeInfoFromMovement");
static_assert(offsetof(BGUCharacterMovementComponent_CanGetNormalAndSurfaceTypeInfoFromMovement, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_CanGetNormalAndSurfaceTypeInfoFromMovement::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.GetTopZInFalling
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacterMovementComponent_GetTopZInFalling final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_GetTopZInFalling) == 0x000004, "Wrong alignment on BGUCharacterMovementComponent_GetTopZInFalling");
static_assert(sizeof(BGUCharacterMovementComponent_GetTopZInFalling) == 0x000004, "Wrong size on BGUCharacterMovementComponent_GetTopZInFalling");
static_assert(offsetof(BGUCharacterMovementComponent_GetTopZInFalling, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_GetTopZInFalling::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.HasAnimRootMotion_CS
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_HasAnimRootMotion_CS final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_HasAnimRootMotion_CS) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_HasAnimRootMotion_CS");
static_assert(sizeof(BGUCharacterMovementComponent_HasAnimRootMotion_CS) == 0x000001, "Wrong size on BGUCharacterMovementComponent_HasAnimRootMotion_CS");
static_assert(offsetof(BGUCharacterMovementComponent_HasAnimRootMotion_CS, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_HasAnimRootMotion_CS::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.IsUseSeparateBrakingFriction
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_IsUseSeparateBrakingFriction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_IsUseSeparateBrakingFriction) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_IsUseSeparateBrakingFriction");
static_assert(sizeof(BGUCharacterMovementComponent_IsUseSeparateBrakingFriction) == 0x000001, "Wrong size on BGUCharacterMovementComponent_IsUseSeparateBrakingFriction");
static_assert(offsetof(BGUCharacterMovementComponent_IsUseSeparateBrakingFriction, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_IsUseSeparateBrakingFriction::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.LaunchVelocityZ
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacterMovementComponent_LaunchVelocityZ final
{
public:
	float                                         VelocityZ;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_LaunchVelocityZ) == 0x000004, "Wrong alignment on BGUCharacterMovementComponent_LaunchVelocityZ");
static_assert(sizeof(BGUCharacterMovementComponent_LaunchVelocityZ) == 0x000004, "Wrong size on BGUCharacterMovementComponent_LaunchVelocityZ");
static_assert(offsetof(BGUCharacterMovementComponent_LaunchVelocityZ, VelocityZ) == 0x000000, "Member 'BGUCharacterMovementComponent_LaunchVelocityZ::VelocityZ' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.MoveUpdateHitMove
// 0x0018 (0x0018 - 0x0000)
struct BGUCharacterMovementComponent_MoveUpdateHitMove final
{
public:
	struct FVector                                Delta;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_MoveUpdateHitMove) == 0x000008, "Wrong alignment on BGUCharacterMovementComponent_MoveUpdateHitMove");
static_assert(sizeof(BGUCharacterMovementComponent_MoveUpdateHitMove) == 0x000018, "Wrong size on BGUCharacterMovementComponent_MoveUpdateHitMove");
static_assert(offsetof(BGUCharacterMovementComponent_MoveUpdateHitMove, Delta) == 0x000000, "Member 'BGUCharacterMovementComponent_MoveUpdateHitMove::Delta' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetCustomJumpVelocityIncrement
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacterMovementComponent_SetCustomJumpVelocityIncrement final
{
public:
	float                                         VelocityIncrement;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetCustomJumpVelocityIncrement) == 0x000004, "Wrong alignment on BGUCharacterMovementComponent_SetCustomJumpVelocityIncrement");
static_assert(sizeof(BGUCharacterMovementComponent_SetCustomJumpVelocityIncrement) == 0x000004, "Wrong size on BGUCharacterMovementComponent_SetCustomJumpVelocityIncrement");
static_assert(offsetof(BGUCharacterMovementComponent_SetCustomJumpVelocityIncrement, VelocityIncrement) == 0x000000, "Member 'BGUCharacterMovementComponent_SetCustomJumpVelocityIncrement::VelocityIncrement' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetDisableNavWalkOptByWhiteList
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_SetDisableNavWalkOptByWhiteList final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetDisableNavWalkOptByWhiteList) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_SetDisableNavWalkOptByWhiteList");
static_assert(sizeof(BGUCharacterMovementComponent_SetDisableNavWalkOptByWhiteList) == 0x000001, "Wrong size on BGUCharacterMovementComponent_SetDisableNavWalkOptByWhiteList");
static_assert(offsetof(BGUCharacterMovementComponent_SetDisableNavWalkOptByWhiteList, bDisable) == 0x000000, "Member 'BGUCharacterMovementComponent_SetDisableNavWalkOptByWhiteList::bDisable' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetEnableSimplePhysWalkCollision
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_SetEnableSimplePhysWalkCollision final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetEnableSimplePhysWalkCollision) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_SetEnableSimplePhysWalkCollision");
static_assert(sizeof(BGUCharacterMovementComponent_SetEnableSimplePhysWalkCollision) == 0x000001, "Wrong size on BGUCharacterMovementComponent_SetEnableSimplePhysWalkCollision");
static_assert(offsetof(BGUCharacterMovementComponent_SetEnableSimplePhysWalkCollision, bEnable) == 0x000000, "Member 'BGUCharacterMovementComponent_SetEnableSimplePhysWalkCollision::bEnable' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetNavWalkOptLevel
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacterMovementComponent_SetNavWalkOptLevel final
{
public:
	int32                                         NewLevel;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetNavWalkOptLevel) == 0x000004, "Wrong alignment on BGUCharacterMovementComponent_SetNavWalkOptLevel");
static_assert(sizeof(BGUCharacterMovementComponent_SetNavWalkOptLevel) == 0x000004, "Wrong size on BGUCharacterMovementComponent_SetNavWalkOptLevel");
static_assert(offsetof(BGUCharacterMovementComponent_SetNavWalkOptLevel, NewLevel) == 0x000000, "Member 'BGUCharacterMovementComponent_SetNavWalkOptLevel::NewLevel' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetNavWalkOptMassiveMode
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_SetNavWalkOptMassiveMode final
{
public:
	bool                                          bMassiveOpt;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetNavWalkOptMassiveMode) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_SetNavWalkOptMassiveMode");
static_assert(sizeof(BGUCharacterMovementComponent_SetNavWalkOptMassiveMode) == 0x000001, "Wrong size on BGUCharacterMovementComponent_SetNavWalkOptMassiveMode");
static_assert(offsetof(BGUCharacterMovementComponent_SetNavWalkOptMassiveMode, bMassiveOpt) == 0x000000, "Member 'BGUCharacterMovementComponent_SetNavWalkOptMassiveMode::bMassiveOpt' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetOnMovingPlatform
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_SetOnMovingPlatform final
{
public:
	bool                                          bIsOnMovingPlatform;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetOnMovingPlatform) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_SetOnMovingPlatform");
static_assert(sizeof(BGUCharacterMovementComponent_SetOnMovingPlatform) == 0x000001, "Wrong size on BGUCharacterMovementComponent_SetOnMovingPlatform");
static_assert(offsetof(BGUCharacterMovementComponent_SetOnMovingPlatform, bIsOnMovingPlatform) == 0x000000, "Member 'BGUCharacterMovementComponent_SetOnMovingPlatform::bIsOnMovingPlatform' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetSwitchToNavWalkCumulateTime
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacterMovementComponent_SetSwitchToNavWalkCumulateTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetSwitchToNavWalkCumulateTime) == 0x000004, "Wrong alignment on BGUCharacterMovementComponent_SetSwitchToNavWalkCumulateTime");
static_assert(sizeof(BGUCharacterMovementComponent_SetSwitchToNavWalkCumulateTime) == 0x000004, "Wrong size on BGUCharacterMovementComponent_SetSwitchToNavWalkCumulateTime");
static_assert(offsetof(BGUCharacterMovementComponent_SetSwitchToNavWalkCumulateTime, Time) == 0x000000, "Member 'BGUCharacterMovementComponent_SetSwitchToNavWalkCumulateTime::Time' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetUseSeparateBrakingFriction
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_SetUseSeparateBrakingFriction final
{
public:
	bool                                          bUse;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetUseSeparateBrakingFriction) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_SetUseSeparateBrakingFriction");
static_assert(sizeof(BGUCharacterMovementComponent_SetUseSeparateBrakingFriction) == 0x000001, "Wrong size on BGUCharacterMovementComponent_SetUseSeparateBrakingFriction");
static_assert(offsetof(BGUCharacterMovementComponent_SetUseSeparateBrakingFriction, bUse) == 0x000000, "Member 'BGUCharacterMovementComponent_SetUseSeparateBrakingFriction::bUse' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.TryGetCurHitPointFromMovement
// 0x0018 (0x0018 - 0x0000)
struct BGUCharacterMovementComponent_TryGetCurHitPointFromMovement final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_TryGetCurHitPointFromMovement) == 0x000008, "Wrong alignment on BGUCharacterMovementComponent_TryGetCurHitPointFromMovement");
static_assert(sizeof(BGUCharacterMovementComponent_TryGetCurHitPointFromMovement) == 0x000018, "Wrong size on BGUCharacterMovementComponent_TryGetCurHitPointFromMovement");
static_assert(offsetof(BGUCharacterMovementComponent_TryGetCurHitPointFromMovement, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_TryGetCurHitPointFromMovement::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.TryGetCurNormalFromMovement
// 0x0018 (0x0018 - 0x0000)
struct BGUCharacterMovementComponent_TryGetCurNormalFromMovement final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_TryGetCurNormalFromMovement) == 0x000008, "Wrong alignment on BGUCharacterMovementComponent_TryGetCurNormalFromMovement");
static_assert(sizeof(BGUCharacterMovementComponent_TryGetCurNormalFromMovement) == 0x000018, "Wrong size on BGUCharacterMovementComponent_TryGetCurNormalFromMovement");
static_assert(offsetof(BGUCharacterMovementComponent_TryGetCurNormalFromMovement, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_TryGetCurNormalFromMovement::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.TryGetCurSurfaceTypeFromMovement
// 0x0004 (0x0004 - 0x0000)
struct BGUCharacterMovementComponent_TryGetCurSurfaceTypeFromMovement final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_TryGetCurSurfaceTypeFromMovement) == 0x000004, "Wrong alignment on BGUCharacterMovementComponent_TryGetCurSurfaceTypeFromMovement");
static_assert(sizeof(BGUCharacterMovementComponent_TryGetCurSurfaceTypeFromMovement) == 0x000004, "Wrong size on BGUCharacterMovementComponent_TryGetCurSurfaceTypeFromMovement");
static_assert(offsetof(BGUCharacterMovementComponent_TryGetCurSurfaceTypeFromMovement, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_TryGetCurSurfaceTypeFromMovement::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.IsInJumpOffAdjust
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_IsInJumpOffAdjust final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_IsInJumpOffAdjust) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_IsInJumpOffAdjust");
static_assert(sizeof(BGUCharacterMovementComponent_IsInJumpOffAdjust) == 0x000001, "Wrong size on BGUCharacterMovementComponent_IsInJumpOffAdjust");
static_assert(offsetof(BGUCharacterMovementComponent_IsInJumpOffAdjust, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_IsInJumpOffAdjust::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.IsInNavWalkOptMode
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_IsInNavWalkOptMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_IsInNavWalkOptMode) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_IsInNavWalkOptMode");
static_assert(sizeof(BGUCharacterMovementComponent_IsInNavWalkOptMode) == 0x000001, "Wrong size on BGUCharacterMovementComponent_IsInNavWalkOptMode");
static_assert(offsetof(BGUCharacterMovementComponent_IsInNavWalkOptMode, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_IsInNavWalkOptMode::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.IsWalkOnDitch
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_IsWalkOnDitch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_IsWalkOnDitch) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_IsWalkOnDitch");
static_assert(sizeof(BGUCharacterMovementComponent_IsWalkOnDitch) == 0x000001, "Wrong size on BGUCharacterMovementComponent_IsWalkOnDitch");
static_assert(offsetof(BGUCharacterMovementComponent_IsWalkOnDitch, ReturnValue) == 0x000000, "Member 'BGUCharacterMovementComponent_IsWalkOnDitch::ReturnValue' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetJumpOffState
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_SetJumpOffState final
{
public:
	bool                                          JumpOff;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetJumpOffState) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_SetJumpOffState");
static_assert(sizeof(BGUCharacterMovementComponent_SetJumpOffState) == 0x000001, "Wrong size on BGUCharacterMovementComponent_SetJumpOffState");
static_assert(offsetof(BGUCharacterMovementComponent_SetJumpOffState, JumpOff) == 0x000000, "Member 'BGUCharacterMovementComponent_SetJumpOffState::JumpOff' has a wrong offset!");

// Function b1.BGUCharacterMovementComponent.SetWalkOnDitch
// 0x0001 (0x0001 - 0x0000)
struct BGUCharacterMovementComponent_SetWalkOnDitch final
{
public:
	bool                                          bDitch;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUCharacterMovementComponent_SetWalkOnDitch) == 0x000001, "Wrong alignment on BGUCharacterMovementComponent_SetWalkOnDitch");
static_assert(sizeof(BGUCharacterMovementComponent_SetWalkOnDitch) == 0x000001, "Wrong size on BGUCharacterMovementComponent_SetWalkOnDitch");
static_assert(offsetof(BGUCharacterMovementComponent_SetWalkOnDitch, bDitch) == 0x000000, "Member 'BGUCharacterMovementComponent_SetWalkOnDitch::bDitch' has a wrong offset!");

// Function b1.BGUFuncLibCSSystem.CSGetDataByClass
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibCSSystem_CSGetDataByClass final
{
public:
	class UBaseActorComp*                         Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Cls;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSSystem_CSGetDataByClass) == 0x000008, "Wrong alignment on BGUFuncLibCSSystem_CSGetDataByClass");
static_assert(sizeof(BGUFuncLibCSSystem_CSGetDataByClass) == 0x000018, "Wrong size on BGUFuncLibCSSystem_CSGetDataByClass");
static_assert(offsetof(BGUFuncLibCSSystem_CSGetDataByClass, Comp) == 0x000000, "Member 'BGUFuncLibCSSystem_CSGetDataByClass::Comp' has a wrong offset!");
static_assert(offsetof(BGUFuncLibCSSystem_CSGetDataByClass, Cls) == 0x000008, "Member 'BGUFuncLibCSSystem_CSGetDataByClass::Cls' has a wrong offset!");
static_assert(offsetof(BGUFuncLibCSSystem_CSGetDataByClass, ReturnValue) == 0x000010, "Member 'BGUFuncLibCSSystem_CSGetDataByClass::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibCSSystem.CSGetReadOnlyData
// 0x0018 (0x0018 - 0x0000)
struct BGUFuncLibCSSystem_CSGetReadOnlyData final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Cls;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSSystem_CSGetReadOnlyData) == 0x000008, "Wrong alignment on BGUFuncLibCSSystem_CSGetReadOnlyData");
static_assert(sizeof(BGUFuncLibCSSystem_CSGetReadOnlyData) == 0x000018, "Wrong size on BGUFuncLibCSSystem_CSGetReadOnlyData");
static_assert(offsetof(BGUFuncLibCSSystem_CSGetReadOnlyData, OwnerActor) == 0x000000, "Member 'BGUFuncLibCSSystem_CSGetReadOnlyData::OwnerActor' has a wrong offset!");
static_assert(offsetof(BGUFuncLibCSSystem_CSGetReadOnlyData, Cls) == 0x000008, "Member 'BGUFuncLibCSSystem_CSGetReadOnlyData::Cls' has a wrong offset!");
static_assert(offsetof(BGUFuncLibCSSystem_CSGetReadOnlyData, ReturnValue) == 0x000010, "Member 'BGUFuncLibCSSystem_CSGetReadOnlyData::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.AddLevelStreaming
// 0x0050 (0x0050 - 0x0000)
struct BGUFunctionLibrary_AddLevelStreaming final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockOnLoad;                                // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0044(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_AddLevelStreaming) == 0x000008, "Wrong alignment on BGUFunctionLibrary_AddLevelStreaming");
static_assert(sizeof(BGUFunctionLibrary_AddLevelStreaming) == 0x000050, "Wrong size on BGUFunctionLibrary_AddLevelStreaming");
static_assert(offsetof(BGUFunctionLibrary_AddLevelStreaming, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_AddLevelStreaming::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_AddLevelStreaming, LevelName) == 0x000008, "Member 'BGUFunctionLibrary_AddLevelStreaming::LevelName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_AddLevelStreaming, Location) == 0x000010, "Member 'BGUFunctionLibrary_AddLevelStreaming::Location' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_AddLevelStreaming, Rotation) == 0x000028, "Member 'BGUFunctionLibrary_AddLevelStreaming::Rotation' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_AddLevelStreaming, bShouldBlockOnLoad) == 0x000040, "Member 'BGUFunctionLibrary_AddLevelStreaming::bShouldBlockOnLoad' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_AddLevelStreaming, ReturnValue) == 0x000044, "Member 'BGUFunctionLibrary_AddLevelStreaming::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.ApplyLevelTransform
// 0x0070 (0x0070 - 0x0000)
struct BGUFunctionLibrary_ApplyLevelTransform final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             LevelTransform;                                    // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_ApplyLevelTransform) == 0x000010, "Wrong alignment on BGUFunctionLibrary_ApplyLevelTransform");
static_assert(sizeof(BGUFunctionLibrary_ApplyLevelTransform) == 0x000070, "Wrong size on BGUFunctionLibrary_ApplyLevelTransform");
static_assert(offsetof(BGUFunctionLibrary_ApplyLevelTransform, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_ApplyLevelTransform::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_ApplyLevelTransform, LevelName) == 0x000008, "Member 'BGUFunctionLibrary_ApplyLevelTransform::LevelName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_ApplyLevelTransform, LevelTransform) == 0x000010, "Member 'BGUFunctionLibrary_ApplyLevelTransform::LevelTransform' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUActorUpdateAllTFXComp
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibrary_BGUActorUpdateAllTFXComp final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUActorUpdateAllTFXComp) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUActorUpdateAllTFXComp");
static_assert(sizeof(BGUFunctionLibrary_BGUActorUpdateAllTFXComp) == 0x000008, "Wrong size on BGUFunctionLibrary_BGUActorUpdateAllTFXComp");
static_assert(offsetof(BGUFunctionLibrary_BGUActorUpdateAllTFXComp, Actor) == 0x000000, "Member 'BGUFunctionLibrary_BGUActorUpdateAllTFXComp::Actor' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUBeginDeferredActorSpawnFromClass
// 0x0090 (0x0090 - 0x0000)
struct BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingOverride;                         // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0078(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass) == 0x000010, "Wrong alignment on BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass");
static_assert(sizeof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass) == 0x000090, "Wrong size on BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass, ActorClass) == 0x000008, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass::ActorClass' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass, SpawnTransform) == 0x000010, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass::SpawnTransform' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass, CollisionHandlingOverride) == 0x000070, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass::CollisionHandlingOverride' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass, Owner) == 0x000078, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass::Owner' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass, ReturnValue) == 0x000080, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClass::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUBeginDeferredActorSpawnFromClassWithName
// 0x00A0 (0x00A0 - 0x0000)
struct BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingOverride;                         // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0078(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 OverrideLevel;                                     // 0x0088(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName) == 0x000010, "Wrong alignment on BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName");
static_assert(sizeof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName) == 0x0000A0, "Wrong size on BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName, ActorClass) == 0x000008, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName::ActorClass' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName, SpawnTransform) == 0x000010, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName::SpawnTransform' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName, CollisionHandlingOverride) == 0x000070, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName::CollisionHandlingOverride' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName, Owner) == 0x000078, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName::Owner' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName, ActorName) == 0x000080, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName::ActorName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName, OverrideLevel) == 0x000088, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName::OverrideLevel' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName, ReturnValue) == 0x000090, "Member 'BGUFunctionLibrary_BGUBeginDeferredActorSpawnFromClassWithName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUCalcBounds
// 0x0040 (0x0040 - 0x0000)
struct BGUFunctionLibrary_BGUCalcBounds final
{
public:
	class UPrimitiveComponent*                    StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUCalcBounds) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUCalcBounds");
static_assert(sizeof(BGUFunctionLibrary_BGUCalcBounds) == 0x000040, "Wrong size on BGUFunctionLibrary_BGUCalcBounds");
static_assert(offsetof(BGUFunctionLibrary_BGUCalcBounds, StaticMesh) == 0x000000, "Member 'BGUFunctionLibrary_BGUCalcBounds::StaticMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUCalcBounds, Origin) == 0x000008, "Member 'BGUFunctionLibrary_BGUCalcBounds::Origin' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUCalcBounds, BoxExtent) == 0x000020, "Member 'BGUFunctionLibrary_BGUCalcBounds::BoxExtent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUCalcBounds, SphereRadius) == 0x000038, "Member 'BGUFunctionLibrary_BGUCalcBounds::SphereRadius' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUFindFirstActorWithTag
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUFindFirstActorWithTag final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUFindFirstActorWithTag) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUFindFirstActorWithTag");
static_assert(sizeof(BGUFunctionLibrary_BGUFindFirstActorWithTag) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUFindFirstActorWithTag");
static_assert(offsetof(BGUFunctionLibrary_BGUFindFirstActorWithTag, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUFindFirstActorWithTag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUFindFirstActorWithTag, TagName) == 0x000008, "Member 'BGUFunctionLibrary_BGUFindFirstActorWithTag::TagName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUFindFirstActorWithTag, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_BGUFindFirstActorWithTag::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUFinishSpawningActor
// 0x0080 (0x0080 - 0x0000)
struct BGUFunctionLibrary_BGUFinishSpawningActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0070(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUFinishSpawningActor) == 0x000010, "Wrong alignment on BGUFunctionLibrary_BGUFinishSpawningActor");
static_assert(sizeof(BGUFunctionLibrary_BGUFinishSpawningActor) == 0x000080, "Wrong size on BGUFunctionLibrary_BGUFinishSpawningActor");
static_assert(offsetof(BGUFunctionLibrary_BGUFinishSpawningActor, Actor) == 0x000000, "Member 'BGUFunctionLibrary_BGUFinishSpawningActor::Actor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUFinishSpawningActor, SpawnTransform) == 0x000010, "Member 'BGUFunctionLibrary_BGUFinishSpawningActor::SpawnTransform' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUFinishSpawningActor, ReturnValue) == 0x000070, "Member 'BGUFunctionLibrary_BGUFinishSpawningActor::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUFlushLevelStreamingOnlyVisibility
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibrary_BGUFlushLevelStreamingOnlyVisibility final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUFlushLevelStreamingOnlyVisibility) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUFlushLevelStreamingOnlyVisibility");
static_assert(sizeof(BGUFunctionLibrary_BGUFlushLevelStreamingOnlyVisibility) == 0x000008, "Wrong size on BGUFunctionLibrary_BGUFlushLevelStreamingOnlyVisibility");
static_assert(offsetof(BGUFunctionLibrary_BGUFlushLevelStreamingOnlyVisibility, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUFlushLevelStreamingOnlyVisibility::WorldContextObject' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGenComponent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUGenComponent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ActorComponentClass;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUGenComponent) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGenComponent");
static_assert(sizeof(BGUFunctionLibrary_BGUGenComponent) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUGenComponent");
static_assert(offsetof(BGUFunctionLibrary_BGUGenComponent, Actor) == 0x000000, "Member 'BGUFunctionLibrary_BGUGenComponent::Actor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGenComponent, ActorComponentClass) == 0x000008, "Member 'BGUFunctionLibrary_BGUGenComponent::ActorComponentClass' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGenComponent, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_BGUGenComponent::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGenComponentAndAdd
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUGenComponentAndAdd final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ActorComponentClass;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUGenComponentAndAdd) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGenComponentAndAdd");
static_assert(sizeof(BGUFunctionLibrary_BGUGenComponentAndAdd) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUGenComponentAndAdd");
static_assert(offsetof(BGUFunctionLibrary_BGUGenComponentAndAdd, Actor) == 0x000000, "Member 'BGUFunctionLibrary_BGUGenComponentAndAdd::Actor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGenComponentAndAdd, ActorComponentClass) == 0x000008, "Member 'BGUFunctionLibrary_BGUGenComponentAndAdd::ActorComponentClass' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGenComponentAndAdd, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_BGUGenComponentAndAdd::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGenProceduralLevel
// 0x0090 (0x0090 - 0x0000)
struct BGUFunctionLibrary_BGUGenProceduralLevel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WorldAssetName;                                    // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InLevelName;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InLevelTransform;                                  // 0x0020(0x0060)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUGenProceduralLevel) == 0x000010, "Wrong alignment on BGUFunctionLibrary_BGUGenProceduralLevel");
static_assert(sizeof(BGUFunctionLibrary_BGUGenProceduralLevel) == 0x000090, "Wrong size on BGUFunctionLibrary_BGUGenProceduralLevel");
static_assert(offsetof(BGUFunctionLibrary_BGUGenProceduralLevel, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUGenProceduralLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGenProceduralLevel, WorldAssetName) == 0x000008, "Member 'BGUFunctionLibrary_BGUGenProceduralLevel::WorldAssetName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGenProceduralLevel, InLevelName) == 0x000010, "Member 'BGUFunctionLibrary_BGUGenProceduralLevel::InLevelName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGenProceduralLevel, InLevelTransform) == 0x000020, "Member 'BGUFunctionLibrary_BGUGenProceduralLevel::InLevelTransform' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGenProceduralLevel, ReturnValue) == 0x000080, "Member 'BGUFunctionLibrary_BGUGenProceduralLevel::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetActiveMontagePosition
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUGetActiveMontagePosition final
{
public:
	const class ABGUCharacter*                    Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUGetActiveMontagePosition) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetActiveMontagePosition");
static_assert(sizeof(BGUFunctionLibrary_BGUGetActiveMontagePosition) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUGetActiveMontagePosition");
static_assert(offsetof(BGUFunctionLibrary_BGUGetActiveMontagePosition, Actor) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetActiveMontagePosition::Actor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetActiveMontagePosition, Montage) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetActiveMontagePosition::Montage' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetActiveMontagePosition, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_BGUGetActiveMontagePosition::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetAllActorsWithTagInRangeSorted
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted final
{
public:
	class AActor*                                 CenterActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         OutActors;                                         // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted");
static_assert(sizeof(BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted) == 0x000030, "Wrong size on BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted");
static_assert(offsetof(BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted, CenterActor) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted::CenterActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted, TagName) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted::TagName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted, Range) == 0x000010, "Member 'BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted::Range' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted, OutActors) == 0x000018, "Member 'BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted::OutActors' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted, ReturnValue) == 0x000028, "Member 'BGUFunctionLibrary_BGUGetAllActorsWithTagInRangeSorted::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetHitResultActor
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_BGUGetHitResultActor final
{
public:
	struct FActorInstanceHandle                   ActorInstanceHandle;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUGetHitResultActor) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetHitResultActor");
static_assert(sizeof(BGUFunctionLibrary_BGUGetHitResultActor) == 0x000020, "Wrong size on BGUFunctionLibrary_BGUGetHitResultActor");
static_assert(offsetof(BGUFunctionLibrary_BGUGetHitResultActor, ActorInstanceHandle) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetHitResultActor::ActorInstanceHandle' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetHitResultActor, ReturnValue) == 0x000018, "Member 'BGUFunctionLibrary_BGUGetHitResultActor::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetMontageSectionLengthByIndex
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex");
static_assert(sizeof(BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex, Unit) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex::Unit' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex, AnimMontage) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex::AnimMontage' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex, Index_0) == 0x000010, "Member 'BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex, ReturnValue) == 0x000014, "Member 'BGUFunctionLibrary_BGUGetMontageSectionLengthByIndex::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetMontageSectionLengthByName
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_BGUGetMontageSectionLengthByName final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUGetMontageSectionLengthByName) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetMontageSectionLengthByName");
static_assert(sizeof(BGUFunctionLibrary_BGUGetMontageSectionLengthByName) == 0x000020, "Wrong size on BGUFunctionLibrary_BGUGetMontageSectionLengthByName");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionLengthByName, Unit) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetMontageSectionLengthByName::Unit' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionLengthByName, AnimMontage) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetMontageSectionLengthByName::AnimMontage' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionLengthByName, SectionName) == 0x000010, "Member 'BGUFunctionLibrary_BGUGetMontageSectionLengthByName::SectionName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionLengthByName, ReturnValue) == 0x000018, "Member 'BGUFunctionLibrary_BGUGetMontageSectionLengthByName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetMontageSectionStartAndEndTime
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutStartTime;                                      // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutEndTime;                                        // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime");
static_assert(sizeof(BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime) == 0x000020, "Wrong size on BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime, AnimMontage) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime::AnimMontage' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime, SectionName) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime::SectionName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime, OutStartTime) == 0x000010, "Member 'BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime::OutStartTime' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime, OutEndTime) == 0x000014, "Member 'BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime::OutEndTime' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime, ReturnValue) == 0x000018, "Member 'BGUFunctionLibrary_BGUGetMontageSectionStartAndEndTime::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetMontageSectionTimeLeftFromPos
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos");
static_assert(sizeof(BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos, Unit) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos::Unit' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos, AnimMontage) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos::AnimMontage' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos, Position) == 0x000010, "Member 'BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos::Position' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos, ReturnValue) == 0x000014, "Member 'BGUFunctionLibrary_BGUGetMontageSectionTimeLeftFromPos::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetSkeletalMeshSimulatedBodiesBelowNum
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum final
{
public:
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum");
static_assert(sizeof(BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum");
static_assert(offsetof(BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum, SkeletalMesh) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum, BoneName) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum::BoneName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum, bIncludeSelf) == 0x000010, "Member 'BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum::bIncludeSelf' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum, ReturnValue) == 0x000014, "Member 'BGUFunctionLibrary_BGUGetSkeletalMeshSimulatedBodiesBelowNum::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetTeamID
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_BGUGetTeamID final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUGetTeamID) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetTeamID");
static_assert(sizeof(BGUFunctionLibrary_BGUGetTeamID) == 0x000010, "Wrong size on BGUFunctionLibrary_BGUGetTeamID");
static_assert(offsetof(BGUFunctionLibrary_BGUGetTeamID, Unit) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetTeamID::Unit' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetTeamID, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetTeamID::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUGetWindParameters_GameThread
// 0x0048 (0x0048 - 0x0000)
struct BGUFunctionLibrary_BGUGetWindParameters_GameThread final
{
public:
	class AActor*                                 WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutDirection;                                      // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutSpeed;                                          // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutMinGustAmt;                                     // 0x003C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutMaxGustAmt;                                     // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUGetWindParameters_GameThread) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUGetWindParameters_GameThread");
static_assert(sizeof(BGUFunctionLibrary_BGUGetWindParameters_GameThread) == 0x000048, "Wrong size on BGUFunctionLibrary_BGUGetWindParameters_GameThread");
static_assert(offsetof(BGUFunctionLibrary_BGUGetWindParameters_GameThread, WorldContext) == 0x000000, "Member 'BGUFunctionLibrary_BGUGetWindParameters_GameThread::WorldContext' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetWindParameters_GameThread, Position) == 0x000008, "Member 'BGUFunctionLibrary_BGUGetWindParameters_GameThread::Position' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetWindParameters_GameThread, OutDirection) == 0x000020, "Member 'BGUFunctionLibrary_BGUGetWindParameters_GameThread::OutDirection' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetWindParameters_GameThread, OutSpeed) == 0x000038, "Member 'BGUFunctionLibrary_BGUGetWindParameters_GameThread::OutSpeed' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetWindParameters_GameThread, OutMinGustAmt) == 0x00003C, "Member 'BGUFunctionLibrary_BGUGetWindParameters_GameThread::OutMinGustAmt' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUGetWindParameters_GameThread, OutMaxGustAmt) == 0x000040, "Member 'BGUFunctionLibrary_BGUGetWindParameters_GameThread::OutMaxGustAmt' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUHasFuncName
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_BGUHasFuncName final
{
public:
	class FName                                   FuncName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 StopAtClass;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUHasFuncName) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUHasFuncName");
static_assert(sizeof(BGUFunctionLibrary_BGUHasFuncName) == 0x000020, "Wrong size on BGUFunctionLibrary_BGUHasFuncName");
static_assert(offsetof(BGUFunctionLibrary_BGUHasFuncName, FuncName) == 0x000000, "Member 'BGUFunctionLibrary_BGUHasFuncName::FuncName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUHasFuncName, Object) == 0x000008, "Member 'BGUFunctionLibrary_BGUHasFuncName::Object' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUHasFuncName, StopAtClass) == 0x000010, "Member 'BGUFunctionLibrary_BGUHasFuncName::StopAtClass' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUHasFuncName, ReturnValue) == 0x000018, "Member 'BGUFunctionLibrary_BGUHasFuncName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUIsExistFile
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUIsExistFile final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUIsExistFile) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUIsExistFile");
static_assert(sizeof(BGUFunctionLibrary_BGUIsExistFile) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUIsExistFile");
static_assert(offsetof(BGUFunctionLibrary_BGUIsExistFile, Path) == 0x000000, "Member 'BGUFunctionLibrary_BGUIsExistFile::Path' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUIsExistFile, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_BGUIsExistFile::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGULoadStreamLevel
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibrary_BGULoadStreamLevel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeVisibleAfterLoad;                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockOnLoad;                                // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CallbackTarget;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CallbackFunc;                                      // 0x0020(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionID;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Linkage;                                           // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGULoadStreamLevel) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGULoadStreamLevel");
static_assert(sizeof(BGUFunctionLibrary_BGULoadStreamLevel) == 0x000030, "Wrong size on BGUFunctionLibrary_BGULoadStreamLevel");
static_assert(offsetof(BGUFunctionLibrary_BGULoadStreamLevel, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGULoadStreamLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGULoadStreamLevel, LevelName) == 0x000008, "Member 'BGUFunctionLibrary_BGULoadStreamLevel::LevelName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGULoadStreamLevel, bMakeVisibleAfterLoad) == 0x000010, "Member 'BGUFunctionLibrary_BGULoadStreamLevel::bMakeVisibleAfterLoad' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGULoadStreamLevel, bShouldBlockOnLoad) == 0x000011, "Member 'BGUFunctionLibrary_BGULoadStreamLevel::bShouldBlockOnLoad' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGULoadStreamLevel, CallbackTarget) == 0x000018, "Member 'BGUFunctionLibrary_BGULoadStreamLevel::CallbackTarget' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGULoadStreamLevel, CallbackFunc) == 0x000020, "Member 'BGUFunctionLibrary_BGULoadStreamLevel::CallbackFunc' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGULoadStreamLevel, ActionID) == 0x000028, "Member 'BGUFunctionLibrary_BGULoadStreamLevel::ActionID' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGULoadStreamLevel, Linkage) == 0x00002C, "Member 'BGUFunctionLibrary_BGULoadStreamLevel::Linkage' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUMergeSkeletalMesh
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_BGUMergeSkeletalMesh final
{
public:
	class USkeletalMesh*                          InMergeMesh;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  InSrcMeshList;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         StripTopLODS;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshBufferAccess                             MeshBufferAccess;                                  // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUMergeSkeletalMesh) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUMergeSkeletalMesh");
static_assert(sizeof(BGUFunctionLibrary_BGUMergeSkeletalMesh) == 0x000020, "Wrong size on BGUFunctionLibrary_BGUMergeSkeletalMesh");
static_assert(offsetof(BGUFunctionLibrary_BGUMergeSkeletalMesh, InMergeMesh) == 0x000000, "Member 'BGUFunctionLibrary_BGUMergeSkeletalMesh::InMergeMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUMergeSkeletalMesh, InSrcMeshList) == 0x000008, "Member 'BGUFunctionLibrary_BGUMergeSkeletalMesh::InSrcMeshList' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUMergeSkeletalMesh, StripTopLODS) == 0x000018, "Member 'BGUFunctionLibrary_BGUMergeSkeletalMesh::StripTopLODS' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUMergeSkeletalMesh, MeshBufferAccess) == 0x00001C, "Member 'BGUFunctionLibrary_BGUMergeSkeletalMesh::MeshBufferAccess' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUMergeSkeletalMesh, ReturnValue) == 0x00001D, "Member 'BGUFunctionLibrary_BGUMergeSkeletalMesh::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUNavigationCalPathCost
// 0x0048 (0x0048 - 0x0000)
struct BGUFunctionLibrary_BGUNavigationCalPathCost final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathStart;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathEnd;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathCost;                                          // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            Querier;                                           // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUNavigationCalPathCost) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUNavigationCalPathCost");
static_assert(sizeof(BGUFunctionLibrary_BGUNavigationCalPathCost) == 0x000048, "Wrong size on BGUFunctionLibrary_BGUNavigationCalPathCost");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationCalPathCost, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUNavigationCalPathCost::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationCalPathCost, PathStart) == 0x000008, "Member 'BGUFunctionLibrary_BGUNavigationCalPathCost::PathStart' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationCalPathCost, PathEnd) == 0x000020, "Member 'BGUFunctionLibrary_BGUNavigationCalPathCost::PathEnd' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationCalPathCost, PathCost) == 0x000038, "Member 'BGUFunctionLibrary_BGUNavigationCalPathCost::PathCost' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationCalPathCost, Querier) == 0x000040, "Member 'BGUFunctionLibrary_BGUNavigationCalPathCost::Querier' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUNavigationRaycast
// 0x0068 (0x0068 - 0x0000)
struct BGUFunctionLibrary_BGUNavigationRaycast final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayStart;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayEnd;                                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Querier;                                           // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUNavigationRaycast) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUNavigationRaycast");
static_assert(sizeof(BGUFunctionLibrary_BGUNavigationRaycast) == 0x000068, "Wrong size on BGUFunctionLibrary_BGUNavigationRaycast");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationRaycast, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUNavigationRaycast::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationRaycast, RayStart) == 0x000008, "Member 'BGUFunctionLibrary_BGUNavigationRaycast::RayStart' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationRaycast, RayEnd) == 0x000020, "Member 'BGUFunctionLibrary_BGUNavigationRaycast::RayEnd' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationRaycast, HitLocation) == 0x000038, "Member 'BGUFunctionLibrary_BGUNavigationRaycast::HitLocation' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationRaycast, FilterClass) == 0x000050, "Member 'BGUFunctionLibrary_BGUNavigationRaycast::FilterClass' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationRaycast, Querier) == 0x000058, "Member 'BGUFunctionLibrary_BGUNavigationRaycast::Querier' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUNavigationRaycast, ReturnValue) == 0x000060, "Member 'BGUFunctionLibrary_BGUNavigationRaycast::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUPerlinNoise1D
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibrary_BGUPerlinNoise1D final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUPerlinNoise1D) == 0x000004, "Wrong alignment on BGUFunctionLibrary_BGUPerlinNoise1D");
static_assert(sizeof(BGUFunctionLibrary_BGUPerlinNoise1D) == 0x000008, "Wrong size on BGUFunctionLibrary_BGUPerlinNoise1D");
static_assert(offsetof(BGUFunctionLibrary_BGUPerlinNoise1D, Value) == 0x000000, "Member 'BGUFunctionLibrary_BGUPerlinNoise1D::Value' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUPerlinNoise1D, ReturnValue) == 0x000004, "Member 'BGUFunctionLibrary_BGUPerlinNoise1D::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUPlayerCtrlerGetViewPoint
// 0x0038 (0x0038 - 0x0000)
struct BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint final
{
public:
	class APlayerController*                      PlayerCtrler;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Out_Location;                                      // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Out_Rotation;                                      // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint");
static_assert(sizeof(BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint) == 0x000038, "Wrong size on BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint");
static_assert(offsetof(BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint, PlayerCtrler) == 0x000000, "Member 'BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint::PlayerCtrler' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint, Out_Location) == 0x000008, "Member 'BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint::Out_Location' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint, Out_Rotation) == 0x000020, "Member 'BGUFunctionLibrary_BGUPlayerCtrlerGetViewPoint::Out_Rotation' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUProcessLatentActions
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUProcessLatentActions final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUProcessLatentActions) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUProcessLatentActions");
static_assert(sizeof(BGUFunctionLibrary_BGUProcessLatentActions) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUProcessLatentActions");
static_assert(offsetof(BGUFunctionLibrary_BGUProcessLatentActions, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUProcessLatentActions::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUProcessLatentActions, InObject) == 0x000008, "Member 'BGUFunctionLibrary_BGUProcessLatentActions::InObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUProcessLatentActions, DeltaTime) == 0x000010, "Member 'BGUFunctionLibrary_BGUProcessLatentActions::DeltaTime' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUProjectPointToNavigation
// 0x0068 (0x0068 - 0x0000)
struct BGUFunctionLibrary_BGUProjectPointToNavigation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProjectedLocation;                                 // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavigationData*                        NavData;                                           // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QueryExtent;                                       // 0x0048(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUProjectPointToNavigation) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUProjectPointToNavigation");
static_assert(sizeof(BGUFunctionLibrary_BGUProjectPointToNavigation) == 0x000068, "Wrong size on BGUFunctionLibrary_BGUProjectPointToNavigation");
static_assert(offsetof(BGUFunctionLibrary_BGUProjectPointToNavigation, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUProjectPointToNavigation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUProjectPointToNavigation, Point) == 0x000008, "Member 'BGUFunctionLibrary_BGUProjectPointToNavigation::Point' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUProjectPointToNavigation, ProjectedLocation) == 0x000020, "Member 'BGUFunctionLibrary_BGUProjectPointToNavigation::ProjectedLocation' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUProjectPointToNavigation, NavData) == 0x000038, "Member 'BGUFunctionLibrary_BGUProjectPointToNavigation::NavData' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUProjectPointToNavigation, FilterClass) == 0x000040, "Member 'BGUFunctionLibrary_BGUProjectPointToNavigation::FilterClass' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUProjectPointToNavigation, QueryExtent) == 0x000048, "Member 'BGUFunctionLibrary_BGUProjectPointToNavigation::QueryExtent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUProjectPointToNavigation, ReturnValue) == 0x000060, "Member 'BGUFunctionLibrary_BGUProjectPointToNavigation::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGURenameActorComponent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGURenameActorComponent final
{
public:
	class UActorComponent*                        Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewName;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGURenameActorComponent) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGURenameActorComponent");
static_assert(sizeof(BGUFunctionLibrary_BGURenameActorComponent) == 0x000018, "Wrong size on BGUFunctionLibrary_BGURenameActorComponent");
static_assert(offsetof(BGUFunctionLibrary_BGURenameActorComponent, Comp) == 0x000000, "Member 'BGUFunctionLibrary_BGURenameActorComponent::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGURenameActorComponent, NewName) == 0x000008, "Member 'BGUFunctionLibrary_BGURenameActorComponent::NewName' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUResetActorVelocity
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibrary_BGUResetActorVelocity final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUResetActorVelocity) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUResetActorVelocity");
static_assert(sizeof(BGUFunctionLibrary_BGUResetActorVelocity) == 0x000008, "Wrong size on BGUFunctionLibrary_BGUResetActorVelocity");
static_assert(offsetof(BGUFunctionLibrary_BGUResetActorVelocity, Actor) == 0x000000, "Member 'BGUFunctionLibrary_BGUResetActorVelocity::Actor' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUResetGeometryCollectionComponent
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibrary_BGUResetGeometryCollectionComponent final
{
public:
	class UGeometryCollectionComponent*           GeometryCollectionComponent;                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUResetGeometryCollectionComponent) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUResetGeometryCollectionComponent");
static_assert(sizeof(BGUFunctionLibrary_BGUResetGeometryCollectionComponent) == 0x000008, "Wrong size on BGUFunctionLibrary_BGUResetGeometryCollectionComponent");
static_assert(offsetof(BGUFunctionLibrary_BGUResetGeometryCollectionComponent, GeometryCollectionComponent) == 0x000000, "Member 'BGUFunctionLibrary_BGUResetGeometryCollectionComponent::GeometryCollectionComponent' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUResetToDefaultBoomCameraLagSpeed
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibrary_BGUResetToDefaultBoomCameraLagSpeed final
{
public:
	class AActor*                                 PlayerCharacter;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUResetToDefaultBoomCameraLagSpeed) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUResetToDefaultBoomCameraLagSpeed");
static_assert(sizeof(BGUFunctionLibrary_BGUResetToDefaultBoomCameraLagSpeed) == 0x000008, "Wrong size on BGUFunctionLibrary_BGUResetToDefaultBoomCameraLagSpeed");
static_assert(offsetof(BGUFunctionLibrary_BGUResetToDefaultBoomCameraLagSpeed, PlayerCharacter) == 0x000000, "Member 'BGUFunctionLibrary_BGUResetToDefaultBoomCameraLagSpeed::PlayerCharacter' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSaveUnitAttrToFile
// 0x0028 (0x0028 - 0x0000)
struct BGUFunctionLibrary_BGUSaveUnitAttrToFile final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Overwrite;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUSaveUnitAttrToFile) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSaveUnitAttrToFile");
static_assert(sizeof(BGUFunctionLibrary_BGUSaveUnitAttrToFile) == 0x000028, "Wrong size on BGUFunctionLibrary_BGUSaveUnitAttrToFile");
static_assert(offsetof(BGUFunctionLibrary_BGUSaveUnitAttrToFile, Name_0) == 0x000000, "Member 'BGUFunctionLibrary_BGUSaveUnitAttrToFile::Name_0' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSaveUnitAttrToFile, Text) == 0x000010, "Member 'BGUFunctionLibrary_BGUSaveUnitAttrToFile::Text' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSaveUnitAttrToFile, Overwrite) == 0x000020, "Member 'BGUFunctionLibrary_BGUSaveUnitAttrToFile::Overwrite' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSeparatingAxisPointCheck
// 0x0048 (0x0048 - 0x0000)
struct BGUFunctionLibrary_BGUSeparatingAxisPointCheck final
{
public:
	TArray<struct FVector>                        InPolyVertices;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                InBoxCenter;                                       // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InBoxExtent;                                       // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCalcLeastPenetration;                           // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0041(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUSeparatingAxisPointCheck) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSeparatingAxisPointCheck");
static_assert(sizeof(BGUFunctionLibrary_BGUSeparatingAxisPointCheck) == 0x000048, "Wrong size on BGUFunctionLibrary_BGUSeparatingAxisPointCheck");
static_assert(offsetof(BGUFunctionLibrary_BGUSeparatingAxisPointCheck, InPolyVertices) == 0x000000, "Member 'BGUFunctionLibrary_BGUSeparatingAxisPointCheck::InPolyVertices' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSeparatingAxisPointCheck, InBoxCenter) == 0x000010, "Member 'BGUFunctionLibrary_BGUSeparatingAxisPointCheck::InBoxCenter' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSeparatingAxisPointCheck, InBoxExtent) == 0x000028, "Member 'BGUFunctionLibrary_BGUSeparatingAxisPointCheck::InBoxExtent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSeparatingAxisPointCheck, bInCalcLeastPenetration) == 0x000040, "Member 'BGUFunctionLibrary_BGUSeparatingAxisPointCheck::bInCalcLeastPenetration' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSeparatingAxisPointCheck, ReturnValue) == 0x000041, "Member 'BGUFunctionLibrary_BGUSeparatingAxisPointCheck::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSetActiveMontagePosition
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUSetActiveMontagePosition final
{
public:
	const class ABGUCharacter*                    Character;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUSetActiveMontagePosition) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSetActiveMontagePosition");
static_assert(sizeof(BGUFunctionLibrary_BGUSetActiveMontagePosition) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUSetActiveMontagePosition");
static_assert(offsetof(BGUFunctionLibrary_BGUSetActiveMontagePosition, Character) == 0x000000, "Member 'BGUFunctionLibrary_BGUSetActiveMontagePosition::Character' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetActiveMontagePosition, Montage) == 0x000008, "Member 'BGUFunctionLibrary_BGUSetActiveMontagePosition::Montage' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetActiveMontagePosition, Position) == 0x000010, "Member 'BGUFunctionLibrary_BGUSetActiveMontagePosition::Position' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetActiveMontagePosition, ReturnValue) == 0x000014, "Member 'BGUFunctionLibrary_BGUSetActiveMontagePosition::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSetEnableGravity
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_BGUSetEnableGravity final
{
public:
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUSetEnableGravity) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSetEnableGravity");
static_assert(sizeof(BGUFunctionLibrary_BGUSetEnableGravity) == 0x000010, "Wrong size on BGUFunctionLibrary_BGUSetEnableGravity");
static_assert(offsetof(BGUFunctionLibrary_BGUSetEnableGravity, TargetMesh) == 0x000000, "Member 'BGUFunctionLibrary_BGUSetEnableGravity::TargetMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetEnableGravity, bEnableGravity) == 0x000008, "Member 'BGUFunctionLibrary_BGUSetEnableGravity::bEnableGravity' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSetLinearColorParameterValueToMesh
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh final
{
public:
	class UMeshComponent*                         MeshInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LinearColorParameterValue;                         // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh");
static_assert(sizeof(BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh) == 0x000020, "Wrong size on BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh");
static_assert(offsetof(BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh, MeshInst) == 0x000000, "Member 'BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh::MeshInst' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh, ParameterName) == 0x000008, "Member 'BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh::ParameterName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh, LinearColorParameterValue) == 0x000010, "Member 'BGUFunctionLibrary_BGUSetLinearColorParameterValueToMesh::LinearColorParameterValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSetTressFXAssetAndMaterial
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial final
{
public:
	class UTressFXComponent*                      TFXComp;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTressFXAsset*                          Asset;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      Material;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial");
static_assert(sizeof(BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial");
static_assert(offsetof(BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial, TFXComp) == 0x000000, "Member 'BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial::TFXComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial, Asset) == 0x000008, "Member 'BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial::Asset' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial, Material) == 0x000010, "Member 'BGUFunctionLibrary_BGUSetTressFXAssetAndMaterial::Material' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSetValueToCurveFloat
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUSetValueToCurveFloat final
{
public:
	class UCurveFloat*                            CurveFloat;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Key;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveInterpMode                          InterpMode;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUSetValueToCurveFloat) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSetValueToCurveFloat");
static_assert(sizeof(BGUFunctionLibrary_BGUSetValueToCurveFloat) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUSetValueToCurveFloat");
static_assert(offsetof(BGUFunctionLibrary_BGUSetValueToCurveFloat, CurveFloat) == 0x000000, "Member 'BGUFunctionLibrary_BGUSetValueToCurveFloat::CurveFloat' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetValueToCurveFloat, Key) == 0x000008, "Member 'BGUFunctionLibrary_BGUSetValueToCurveFloat::Key' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetValueToCurveFloat, Value) == 0x00000C, "Member 'BGUFunctionLibrary_BGUSetValueToCurveFloat::Value' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetValueToCurveFloat, InterpMode) == 0x000010, "Member 'BGUFunctionLibrary_BGUSetValueToCurveFloat::InterpMode' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSetValueToCurveVector
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibrary_BGUSetValueToCurveVector final
{
public:
	class UCurveVector*                           CurveVector;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Key;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Value;                                             // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERichCurveInterpMode                          InterpMode;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUSetValueToCurveVector) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSetValueToCurveVector");
static_assert(sizeof(BGUFunctionLibrary_BGUSetValueToCurveVector) == 0x000030, "Wrong size on BGUFunctionLibrary_BGUSetValueToCurveVector");
static_assert(offsetof(BGUFunctionLibrary_BGUSetValueToCurveVector, CurveVector) == 0x000000, "Member 'BGUFunctionLibrary_BGUSetValueToCurveVector::CurveVector' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetValueToCurveVector, Key) == 0x000008, "Member 'BGUFunctionLibrary_BGUSetValueToCurveVector::Key' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetValueToCurveVector, Value) == 0x000010, "Member 'BGUFunctionLibrary_BGUSetValueToCurveVector::Value' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSetValueToCurveVector, InterpMode) == 0x000028, "Member 'BGUFunctionLibrary_BGUSetValueToCurveVector::InterpMode' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUShapeSweepMultiByObjectType
// 0x0068 (0x0068 - 0x0000)
struct BGUFunctionLibrary_BGUShapeSweepMultiByObjectType final
{
public:
	const class UShapeComponent*                  ShapeComp;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0061(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUShapeSweepMultiByObjectType");
static_assert(sizeof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType) == 0x000068, "Wrong size on BGUFunctionLibrary_BGUShapeSweepMultiByObjectType");
static_assert(offsetof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType, ShapeComp) == 0x000000, "Member 'BGUFunctionLibrary_BGUShapeSweepMultiByObjectType::ShapeComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType, Start) == 0x000008, "Member 'BGUFunctionLibrary_BGUShapeSweepMultiByObjectType::Start' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType, End) == 0x000020, "Member 'BGUFunctionLibrary_BGUShapeSweepMultiByObjectType::End' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType, ObjectTypes) == 0x000038, "Member 'BGUFunctionLibrary_BGUShapeSweepMultiByObjectType::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType, bTraceComplex) == 0x000048, "Member 'BGUFunctionLibrary_BGUShapeSweepMultiByObjectType::bTraceComplex' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType, OutHits) == 0x000050, "Member 'BGUFunctionLibrary_BGUShapeSweepMultiByObjectType::OutHits' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType, bIgnoreSelf) == 0x000060, "Member 'BGUFunctionLibrary_BGUShapeSweepMultiByObjectType::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUShapeSweepMultiByObjectType, ReturnValue) == 0x000061, "Member 'BGUFunctionLibrary_BGUShapeSweepMultiByObjectType::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUSKMeshContainSocket
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUSKMeshContainSocket final
{
public:
	class USkeletalMeshComponent*                 SkMeshComp;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUSKMeshContainSocket) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUSKMeshContainSocket");
static_assert(sizeof(BGUFunctionLibrary_BGUSKMeshContainSocket) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUSKMeshContainSocket");
static_assert(offsetof(BGUFunctionLibrary_BGUSKMeshContainSocket, SkMeshComp) == 0x000000, "Member 'BGUFunctionLibrary_BGUSKMeshContainSocket::SkMeshComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSKMeshContainSocket, SocketName) == 0x000008, "Member 'BGUFunctionLibrary_BGUSKMeshContainSocket::SocketName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUSKMeshContainSocket, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_BGUSKMeshContainSocket::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUUnloadStreamLevel
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibrary_BGUUnloadStreamLevel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockOnUnload;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CallbackTarget;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CallbackFunc;                                      // 0x0020(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionID;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Linkage;                                           // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUUnloadStreamLevel) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUUnloadStreamLevel");
static_assert(sizeof(BGUFunctionLibrary_BGUUnloadStreamLevel) == 0x000030, "Wrong size on BGUFunctionLibrary_BGUUnloadStreamLevel");
static_assert(offsetof(BGUFunctionLibrary_BGUUnloadStreamLevel, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_BGUUnloadStreamLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUUnloadStreamLevel, LevelName) == 0x000008, "Member 'BGUFunctionLibrary_BGUUnloadStreamLevel::LevelName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUUnloadStreamLevel, bShouldBlockOnUnload) == 0x000010, "Member 'BGUFunctionLibrary_BGUUnloadStreamLevel::bShouldBlockOnUnload' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUUnloadStreamLevel, CallbackTarget) == 0x000018, "Member 'BGUFunctionLibrary_BGUUnloadStreamLevel::CallbackTarget' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUUnloadStreamLevel, CallbackFunc) == 0x000020, "Member 'BGUFunctionLibrary_BGUUnloadStreamLevel::CallbackFunc' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUUnloadStreamLevel, ActionID) == 0x000028, "Member 'BGUFunctionLibrary_BGUUnloadStreamLevel::ActionID' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUUnloadStreamLevel, Linkage) == 0x00002C, "Member 'BGUFunctionLibrary_BGUUnloadStreamLevel::Linkage' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUUpdateLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibrary_BGUUpdateLevelStreaming final
{
public:
	class UWorld*                                 CurWorld;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BGUUpdateLevelStreaming) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUUpdateLevelStreaming");
static_assert(sizeof(BGUFunctionLibrary_BGUUpdateLevelStreaming) == 0x000008, "Wrong size on BGUFunctionLibrary_BGUUpdateLevelStreaming");
static_assert(offsetof(BGUFunctionLibrary_BGUUpdateLevelStreaming, CurWorld) == 0x000000, "Member 'BGUFunctionLibrary_BGUUpdateLevelStreaming::CurWorld' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BGUWoodTestCharacter
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_BGUWoodTestCharacter final
{
public:
	class AActor*                                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRate;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_BGUWoodTestCharacter) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BGUWoodTestCharacter");
static_assert(sizeof(BGUFunctionLibrary_BGUWoodTestCharacter) == 0x000018, "Wrong size on BGUFunctionLibrary_BGUWoodTestCharacter");
static_assert(offsetof(BGUFunctionLibrary_BGUWoodTestCharacter, Character) == 0x000000, "Member 'BGUFunctionLibrary_BGUWoodTestCharacter::Character' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUWoodTestCharacter, Montage) == 0x000008, "Member 'BGUFunctionLibrary_BGUWoodTestCharacter::Montage' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BGUWoodTestCharacter, ScaleRate) == 0x000010, "Member 'BGUFunctionLibrary_BGUWoodTestCharacter::ScaleRate' has a wrong offset!");

// Function b1.BGUFunctionLibrary.BonesSphereMask
// 0x0038 (0x0038 - 0x0000)
struct BGUFunctionLibrary_BonesSphereMask final
{
public:
	class USkeletalMeshComponent*                 TargetSkeletalMesh;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldPosition;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_BonesSphereMask) == 0x000008, "Wrong alignment on BGUFunctionLibrary_BonesSphereMask");
static_assert(sizeof(BGUFunctionLibrary_BonesSphereMask) == 0x000038, "Wrong size on BGUFunctionLibrary_BonesSphereMask");
static_assert(offsetof(BGUFunctionLibrary_BonesSphereMask, TargetSkeletalMesh) == 0x000000, "Member 'BGUFunctionLibrary_BonesSphereMask::TargetSkeletalMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BonesSphereMask, Radius) == 0x000008, "Member 'BGUFunctionLibrary_BonesSphereMask::Radius' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BonesSphereMask, WorldPosition) == 0x000010, "Member 'BGUFunctionLibrary_BonesSphereMask::WorldPosition' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_BonesSphereMask, ReturnValue) == 0x000028, "Member 'BGUFunctionLibrary_BonesSphereMask::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.CalculateMontageCostValue
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_CalculateMontageCostValue final
{
public:
	TArray<class UAnimMontage*>                   MontageList;                                       // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneNameList;                                      // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_CalculateMontageCostValue) == 0x000008, "Wrong alignment on BGUFunctionLibrary_CalculateMontageCostValue");
static_assert(sizeof(BGUFunctionLibrary_CalculateMontageCostValue) == 0x000020, "Wrong size on BGUFunctionLibrary_CalculateMontageCostValue");
static_assert(offsetof(BGUFunctionLibrary_CalculateMontageCostValue, MontageList) == 0x000000, "Member 'BGUFunctionLibrary_CalculateMontageCostValue::MontageList' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_CalculateMontageCostValue, BoneNameList) == 0x000010, "Member 'BGUFunctionLibrary_CalculateMontageCostValue::BoneNameList' has a wrong offset!");

// Function b1.BGUFunctionLibrary.DrawDebugString
// 0x0050 (0x0050 - 0x0000)
struct BGUFunctionLibrary_DrawDebugString final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TextLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TestBaseActor;                                     // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor;                                         // 0x0038(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_DrawDebugString) == 0x000008, "Wrong alignment on BGUFunctionLibrary_DrawDebugString");
static_assert(sizeof(BGUFunctionLibrary_DrawDebugString) == 0x000050, "Wrong size on BGUFunctionLibrary_DrawDebugString");
static_assert(offsetof(BGUFunctionLibrary_DrawDebugString, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_DrawDebugString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_DrawDebugString, TextLocation) == 0x000008, "Member 'BGUFunctionLibrary_DrawDebugString::TextLocation' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_DrawDebugString, Text) == 0x000020, "Member 'BGUFunctionLibrary_DrawDebugString::Text' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_DrawDebugString, TestBaseActor) == 0x000030, "Member 'BGUFunctionLibrary_DrawDebugString::TestBaseActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_DrawDebugString, TextColor) == 0x000038, "Member 'BGUFunctionLibrary_DrawDebugString::TextColor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_DrawDebugString, Duration) == 0x000048, "Member 'BGUFunctionLibrary_DrawDebugString::Duration' has a wrong offset!");

// Function b1.BGUFunctionLibrary.ForceLoadTileLOD
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_ForceLoadTileLOD final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TileName;                                          // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SwitchOn;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_ForceLoadTileLOD) == 0x000008, "Wrong alignment on BGUFunctionLibrary_ForceLoadTileLOD");
static_assert(sizeof(BGUFunctionLibrary_ForceLoadTileLOD) == 0x000020, "Wrong size on BGUFunctionLibrary_ForceLoadTileLOD");
static_assert(offsetof(BGUFunctionLibrary_ForceLoadTileLOD, WorldContext) == 0x000000, "Member 'BGUFunctionLibrary_ForceLoadTileLOD::WorldContext' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_ForceLoadTileLOD, TileName) == 0x000008, "Member 'BGUFunctionLibrary_ForceLoadTileLOD::TileName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_ForceLoadTileLOD, SwitchOn) == 0x000018, "Member 'BGUFunctionLibrary_ForceLoadTileLOD::SwitchOn' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetAllActorsInLevel
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_GetAllActorsInLevel final
{
public:
	class ULevel*                                 Level;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetAllActorsInLevel) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetAllActorsInLevel");
static_assert(sizeof(BGUFunctionLibrary_GetAllActorsInLevel) == 0x000018, "Wrong size on BGUFunctionLibrary_GetAllActorsInLevel");
static_assert(offsetof(BGUFunctionLibrary_GetAllActorsInLevel, Level) == 0x000000, "Member 'BGUFunctionLibrary_GetAllActorsInLevel::Level' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetAllActorsInLevel, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_GetAllActorsInLevel::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetAllActorsInWorld
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_GetAllActorsInWorld final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetAllActorsInWorld) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetAllActorsInWorld");
static_assert(sizeof(BGUFunctionLibrary_GetAllActorsInWorld) == 0x000018, "Wrong size on BGUFunctionLibrary_GetAllActorsInWorld");
static_assert(offsetof(BGUFunctionLibrary_GetAllActorsInWorld, World) == 0x000000, "Member 'BGUFunctionLibrary_GetAllActorsInWorld::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetAllActorsInWorld, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_GetAllActorsInWorld::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetAllAssetDependencies
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_GetAllAssetDependencies final
{
public:
	class FName                                   SelectedPackageName;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetAllAssetDependencies) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetAllAssetDependencies");
static_assert(sizeof(BGUFunctionLibrary_GetAllAssetDependencies) == 0x000018, "Wrong size on BGUFunctionLibrary_GetAllAssetDependencies");
static_assert(offsetof(BGUFunctionLibrary_GetAllAssetDependencies, SelectedPackageName) == 0x000000, "Member 'BGUFunctionLibrary_GetAllAssetDependencies::SelectedPackageName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetAllAssetDependencies, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_GetAllAssetDependencies::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetAllAssetReference
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_GetAllAssetReference final
{
public:
	class FName                                   SelectedPackageName;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetAllAssetReference) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetAllAssetReference");
static_assert(sizeof(BGUFunctionLibrary_GetAllAssetReference) == 0x000018, "Wrong size on BGUFunctionLibrary_GetAllAssetReference");
static_assert(offsetof(BGUFunctionLibrary_GetAllAssetReference, SelectedPackageName) == 0x000000, "Member 'BGUFunctionLibrary_GetAllAssetReference::SelectedPackageName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetAllAssetReference, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_GetAllAssetReference::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetAssetLongPackageName
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibrary_GetAssetLongPackageName final
{
public:
	class FName                                   ClassName;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetName;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetAssetLongPackageName) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetAssetLongPackageName");
static_assert(sizeof(BGUFunctionLibrary_GetAssetLongPackageName) == 0x000020, "Wrong size on BGUFunctionLibrary_GetAssetLongPackageName");
static_assert(offsetof(BGUFunctionLibrary_GetAssetLongPackageName, ClassName) == 0x000000, "Member 'BGUFunctionLibrary_GetAssetLongPackageName::ClassName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetAssetLongPackageName, AssetName) == 0x000008, "Member 'BGUFunctionLibrary_GetAssetLongPackageName::AssetName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetAssetLongPackageName, ReturnValue) == 0x000018, "Member 'BGUFunctionLibrary_GetAssetLongPackageName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetLevelStreaming
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_GetLevelStreaming final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULevelStreaming*>                ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetLevelStreaming) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetLevelStreaming");
static_assert(sizeof(BGUFunctionLibrary_GetLevelStreaming) == 0x000018, "Wrong size on BGUFunctionLibrary_GetLevelStreaming");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreaming, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_GetLevelStreaming::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreaming, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_GetLevelStreaming::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetLevelStreamingFromWorld
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_GetLevelStreamingFromWorld final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULevelStreaming*>                ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetLevelStreamingFromWorld) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetLevelStreamingFromWorld");
static_assert(sizeof(BGUFunctionLibrary_GetLevelStreamingFromWorld) == 0x000018, "Wrong size on BGUFunctionLibrary_GetLevelStreamingFromWorld");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreamingFromWorld, World) == 0x000000, "Member 'BGUFunctionLibrary_GetLevelStreamingFromWorld::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreamingFromWorld, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_GetLevelStreamingFromWorld::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetLevelStreamingLevelTransformByName
// 0x0070 (0x0070 - 0x0000)
struct BGUFunctionLibrary_GetLevelStreamingLevelTransformByName final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetLevelStreamingLevelTransformByName) == 0x000010, "Wrong alignment on BGUFunctionLibrary_GetLevelStreamingLevelTransformByName");
static_assert(sizeof(BGUFunctionLibrary_GetLevelStreamingLevelTransformByName) == 0x000070, "Wrong size on BGUFunctionLibrary_GetLevelStreamingLevelTransformByName");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreamingLevelTransformByName, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_GetLevelStreamingLevelTransformByName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreamingLevelTransformByName, LevelName) == 0x000008, "Member 'BGUFunctionLibrary_GetLevelStreamingLevelTransformByName::LevelName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreamingLevelTransformByName, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_GetLevelStreamingLevelTransformByName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetLevelStreamingState
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_GetLevelStreamingState final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_GetLevelStreamingState) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetLevelStreamingState");
static_assert(sizeof(BGUFunctionLibrary_GetLevelStreamingState) == 0x000018, "Wrong size on BGUFunctionLibrary_GetLevelStreamingState");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreamingState, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_GetLevelStreamingState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreamingState, LevelName) == 0x000008, "Member 'BGUFunctionLibrary_GetLevelStreamingState::LevelName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetLevelStreamingState, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_GetLevelStreamingState::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetNearestBoneName
// 0x0038 (0x0038 - 0x0000)
struct BGUFunctionLibrary_GetNearestBoneName final
{
public:
	class USkeletalMeshComponent*                 TargetSkeletalMesh;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OptionalWhiteList;                                 // 0x0020(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetNearestBoneName) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetNearestBoneName");
static_assert(sizeof(BGUFunctionLibrary_GetNearestBoneName) == 0x000038, "Wrong size on BGUFunctionLibrary_GetNearestBoneName");
static_assert(offsetof(BGUFunctionLibrary_GetNearestBoneName, TargetSkeletalMesh) == 0x000000, "Member 'BGUFunctionLibrary_GetNearestBoneName::TargetSkeletalMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetNearestBoneName, WorldPosition) == 0x000008, "Member 'BGUFunctionLibrary_GetNearestBoneName::WorldPosition' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetNearestBoneName, OptionalWhiteList) == 0x000020, "Member 'BGUFunctionLibrary_GetNearestBoneName::OptionalWhiteList' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetNearestBoneName, ReturnValue) == 0x000030, "Member 'BGUFunctionLibrary_GetNearestBoneName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetPlayerCharacter
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_GetPlayerCharacter final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetPlayerCharacter) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetPlayerCharacter");
static_assert(sizeof(BGUFunctionLibrary_GetPlayerCharacter) == 0x000010, "Wrong size on BGUFunctionLibrary_GetPlayerCharacter");
static_assert(offsetof(BGUFunctionLibrary_GetPlayerCharacter, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_GetPlayerCharacter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetPlayerCharacter, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_GetPlayerCharacter::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.GetStreamingVolumeBounds
// 0x0040 (0x0040 - 0x0000)
struct BGUFunctionLibrary_GetStreamingVolumeBounds final
{
public:
	class ULevelStreaming*                        LevelStreaming;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ReturnValue;                                       // 0x0008(0x0038)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_GetStreamingVolumeBounds) == 0x000008, "Wrong alignment on BGUFunctionLibrary_GetStreamingVolumeBounds");
static_assert(sizeof(BGUFunctionLibrary_GetStreamingVolumeBounds) == 0x000040, "Wrong size on BGUFunctionLibrary_GetStreamingVolumeBounds");
static_assert(offsetof(BGUFunctionLibrary_GetStreamingVolumeBounds, LevelStreaming) == 0x000000, "Member 'BGUFunctionLibrary_GetStreamingVolumeBounds::LevelStreaming' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_GetStreamingVolumeBounds, ReturnValue) == 0x000008, "Member 'BGUFunctionLibrary_GetStreamingVolumeBounds::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.MoveLevel
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibrary_MoveLevel final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InWorldOffset;                                     // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActorOnly;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_MoveLevel) == 0x000008, "Wrong alignment on BGUFunctionLibrary_MoveLevel");
static_assert(sizeof(BGUFunctionLibrary_MoveLevel) == 0x000030, "Wrong size on BGUFunctionLibrary_MoveLevel");
static_assert(offsetof(BGUFunctionLibrary_MoveLevel, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_MoveLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_MoveLevel, LevelName) == 0x000008, "Member 'BGUFunctionLibrary_MoveLevel::LevelName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_MoveLevel, InWorldOffset) == 0x000010, "Member 'BGUFunctionLibrary_MoveLevel::InWorldOffset' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_MoveLevel, bActorOnly) == 0x000028, "Member 'BGUFunctionLibrary_MoveLevel::bActorOnly' has a wrong offset!");

// Function b1.BGUFunctionLibrary.RemoveActorComponentFromLevelActor
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_RemoveActorComponentFromLevelActor final
{
public:
	class AActor*                                 TargetLevelActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        InActorComponent;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_RemoveActorComponentFromLevelActor) == 0x000008, "Wrong alignment on BGUFunctionLibrary_RemoveActorComponentFromLevelActor");
static_assert(sizeof(BGUFunctionLibrary_RemoveActorComponentFromLevelActor) == 0x000010, "Wrong size on BGUFunctionLibrary_RemoveActorComponentFromLevelActor");
static_assert(offsetof(BGUFunctionLibrary_RemoveActorComponentFromLevelActor, TargetLevelActor) == 0x000000, "Member 'BGUFunctionLibrary_RemoveActorComponentFromLevelActor::TargetLevelActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_RemoveActorComponentFromLevelActor, InActorComponent) == 0x000008, "Member 'BGUFunctionLibrary_RemoveActorComponentFromLevelActor::InActorComponent' has a wrong offset!");

// Function b1.BGUFunctionLibrary.RemoveLevelStreaming
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_RemoveLevelStreaming final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_RemoveLevelStreaming) == 0x000008, "Wrong alignment on BGUFunctionLibrary_RemoveLevelStreaming");
static_assert(sizeof(BGUFunctionLibrary_RemoveLevelStreaming) == 0x000010, "Wrong size on BGUFunctionLibrary_RemoveLevelStreaming");
static_assert(offsetof(BGUFunctionLibrary_RemoveLevelStreaming, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibrary_RemoveLevelStreaming::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_RemoveLevelStreaming, LevelName) == 0x000008, "Member 'BGUFunctionLibrary_RemoveLevelStreaming::LevelName' has a wrong offset!");

// Function b1.BGUFunctionLibrary.SerializeActorComponentToLevelActor
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_SerializeActorComponentToLevelActor final
{
public:
	class AActor*                                 TargetLevelActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        InActorComponent;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_SerializeActorComponentToLevelActor) == 0x000008, "Wrong alignment on BGUFunctionLibrary_SerializeActorComponentToLevelActor");
static_assert(sizeof(BGUFunctionLibrary_SerializeActorComponentToLevelActor) == 0x000010, "Wrong size on BGUFunctionLibrary_SerializeActorComponentToLevelActor");
static_assert(offsetof(BGUFunctionLibrary_SerializeActorComponentToLevelActor, TargetLevelActor) == 0x000000, "Member 'BGUFunctionLibrary_SerializeActorComponentToLevelActor::TargetLevelActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SerializeActorComponentToLevelActor, InActorComponent) == 0x000008, "Member 'BGUFunctionLibrary_SerializeActorComponentToLevelActor::InActorComponent' has a wrong offset!");

// Function b1.BGUFunctionLibrary.SetAllBodiesBelowSimulatePhysics
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics final
{
public:
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InBoneName;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewSimulate;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCustomPhysicsType;                            // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics) == 0x000008, "Wrong alignment on BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics");
static_assert(sizeof(BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics) == 0x000018, "Wrong size on BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics");
static_assert(offsetof(BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics, TargetMesh) == 0x000000, "Member 'BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics::TargetMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics, InBoneName) == 0x000008, "Member 'BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics::InBoneName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics, bNewSimulate) == 0x000010, "Member 'BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics::bNewSimulate' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics, bIncludeSelf) == 0x000011, "Member 'BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics::bIncludeSelf' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics, bSkipCustomPhysicsType) == 0x000012, "Member 'BGUFunctionLibrary_SetAllBodiesBelowSimulatePhysics::bSkipCustomPhysicsType' has a wrong offset!");

// Function b1.BGUFunctionLibrary.SetBodyBonePhysic
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_SetBodyBonePhysic final
{
public:
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewBool;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_SetBodyBonePhysic) == 0x000008, "Wrong alignment on BGUFunctionLibrary_SetBodyBonePhysic");
static_assert(sizeof(BGUFunctionLibrary_SetBodyBonePhysic) == 0x000018, "Wrong size on BGUFunctionLibrary_SetBodyBonePhysic");
static_assert(offsetof(BGUFunctionLibrary_SetBodyBonePhysic, TargetMesh) == 0x000000, "Member 'BGUFunctionLibrary_SetBodyBonePhysic::TargetMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SetBodyBonePhysic, BoneName) == 0x000008, "Member 'BGUFunctionLibrary_SetBodyBonePhysic::BoneName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SetBodyBonePhysic, NewBool) == 0x000010, "Member 'BGUFunctionLibrary_SetBodyBonePhysic::NewBool' has a wrong offset!");

// Function b1.BGUFunctionLibrary.SetIKValid
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_SetIKValid final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValid;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_SetIKValid) == 0x000008, "Wrong alignment on BGUFunctionLibrary_SetIKValid");
static_assert(sizeof(BGUFunctionLibrary_SetIKValid) == 0x000010, "Wrong size on BGUFunctionLibrary_SetIKValid");
static_assert(offsetof(BGUFunctionLibrary_SetIKValid, Character) == 0x000000, "Member 'BGUFunctionLibrary_SetIKValid::Character' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SetIKValid, NewValid) == 0x000008, "Member 'BGUFunctionLibrary_SetIKValid::NewValid' has a wrong offset!");

// Function b1.BGUFunctionLibrary.SetLocalKinematics
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_SetLocalKinematics final
{
public:
	class USkeletalMeshComponent*                 TargetMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewBool;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_SetLocalKinematics) == 0x000008, "Wrong alignment on BGUFunctionLibrary_SetLocalKinematics");
static_assert(sizeof(BGUFunctionLibrary_SetLocalKinematics) == 0x000010, "Wrong size on BGUFunctionLibrary_SetLocalKinematics");
static_assert(offsetof(BGUFunctionLibrary_SetLocalKinematics, TargetMesh) == 0x000000, "Member 'BGUFunctionLibrary_SetLocalKinematics::TargetMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SetLocalKinematics, NewBool) == 0x000008, "Member 'BGUFunctionLibrary_SetLocalKinematics::NewBool' has a wrong offset!");

// Function b1.BGUFunctionLibrary.SphereComponentInitRadius
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibrary_SphereComponentInitRadius final
{
public:
	class USphereComponent*                       SphereComp;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_SphereComponentInitRadius) == 0x000008, "Wrong alignment on BGUFunctionLibrary_SphereComponentInitRadius");
static_assert(sizeof(BGUFunctionLibrary_SphereComponentInitRadius) == 0x000010, "Wrong size on BGUFunctionLibrary_SphereComponentInitRadius");
static_assert(offsetof(BGUFunctionLibrary_SphereComponentInitRadius, SphereComp) == 0x000000, "Member 'BGUFunctionLibrary_SphereComponentInitRadius::SphereComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_SphereComponentInitRadius, Radius) == 0x000008, "Member 'BGUFunctionLibrary_SphereComponentInitRadius::Radius' has a wrong offset!");

// Function b1.BGUFunctionLibrary.VolumeEncompassPoint
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibrary_VolumeEncompassPoint final
{
public:
	class AVolume*                                Volume;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutDistanceToPoint;                                // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibrary_VolumeEncompassPoint) == 0x000008, "Wrong alignment on BGUFunctionLibrary_VolumeEncompassPoint");
static_assert(sizeof(BGUFunctionLibrary_VolumeEncompassPoint) == 0x000030, "Wrong size on BGUFunctionLibrary_VolumeEncompassPoint");
static_assert(offsetof(BGUFunctionLibrary_VolumeEncompassPoint, Volume) == 0x000000, "Member 'BGUFunctionLibrary_VolumeEncompassPoint::Volume' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_VolumeEncompassPoint, Point) == 0x000008, "Member 'BGUFunctionLibrary_VolumeEncompassPoint::Point' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_VolumeEncompassPoint, SphereRadius) == 0x000020, "Member 'BGUFunctionLibrary_VolumeEncompassPoint::SphereRadius' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_VolumeEncompassPoint, OutDistanceToPoint) == 0x000024, "Member 'BGUFunctionLibrary_VolumeEncompassPoint::OutDistanceToPoint' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_VolumeEncompassPoint, ReturnValue) == 0x000028, "Member 'BGUFunctionLibrary_VolumeEncompassPoint::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.WrapHitResult
// 0x0160 (0x0160 - 0x0000)
struct BGUFunctionLibrary_WrapHitResult final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FUStGSHitResult                        ReturnValue;                                       // 0x00E8(0x0078)(Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_WrapHitResult) == 0x000008, "Wrong alignment on BGUFunctionLibrary_WrapHitResult");
static_assert(sizeof(BGUFunctionLibrary_WrapHitResult) == 0x000160, "Wrong size on BGUFunctionLibrary_WrapHitResult");
static_assert(offsetof(BGUFunctionLibrary_WrapHitResult, HitResult) == 0x000000, "Member 'BGUFunctionLibrary_WrapHitResult::HitResult' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_WrapHitResult, ReturnValue) == 0x0000E8, "Member 'BGUFunctionLibrary_WrapHitResult::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibrary.MakeUniqueTamerMonsterName
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibrary_MakeUniqueTamerMonsterName final
{
public:
	class ULevel*                                 SpawnLevel;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InBaseName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibrary_MakeUniqueTamerMonsterName) == 0x000008, "Wrong alignment on BGUFunctionLibrary_MakeUniqueTamerMonsterName");
static_assert(sizeof(BGUFunctionLibrary_MakeUniqueTamerMonsterName) == 0x000018, "Wrong size on BGUFunctionLibrary_MakeUniqueTamerMonsterName");
static_assert(offsetof(BGUFunctionLibrary_MakeUniqueTamerMonsterName, SpawnLevel) == 0x000000, "Member 'BGUFunctionLibrary_MakeUniqueTamerMonsterName::SpawnLevel' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_MakeUniqueTamerMonsterName, InBaseName) == 0x000008, "Member 'BGUFunctionLibrary_MakeUniqueTamerMonsterName::InBaseName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibrary_MakeUniqueTamerMonsterName, ReturnValue) == 0x000010, "Member 'BGUFunctionLibrary_MakeUniqueTamerMonsterName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.AddNotifyPreloadedAsset
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_AddNotifyPreloadedAsset final
{
public:
	class UObject*                                Notify;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Asset;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_AddNotifyPreloadedAsset) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_AddNotifyPreloadedAsset");
static_assert(sizeof(BGUFunctionLibraryForCS_AddNotifyPreloadedAsset) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_AddNotifyPreloadedAsset");
static_assert(offsetof(BGUFunctionLibraryForCS_AddNotifyPreloadedAsset, Notify) == 0x000000, "Member 'BGUFunctionLibraryForCS_AddNotifyPreloadedAsset::Notify' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_AddNotifyPreloadedAsset, Asset) == 0x000008, "Member 'BGUFunctionLibraryForCS_AddNotifyPreloadedAsset::Asset' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUBindOnActorBeginOverlapEvent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent, Actor) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent::Actor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent, Obj) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent, FuncName) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUBindOnActorBeginOverlapEvent::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUBindOnActorEndOverlapEvent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent, Actor) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent::Actor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent, Obj) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent, FuncName) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUBindOnActorEndOverlapEvent::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUBindOnAllSetLevelsStateFinished
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished, Obj) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished, FuncName) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUBindOnAllSetLevelsStateFinished::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUBindOnComponentBeginOverlapEvent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent, Comp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent, Obj) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent, FuncName) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentBeginOverlapEvent::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUBindOnComponentEndOverlapEvent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent, Comp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent, Obj) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent, FuncName) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentEndOverlapEvent::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUBindOnComponentHitEvent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Func_0;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent, Comp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent, Obj) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent, Func_0) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUBindOnComponentHitEvent::Func_0' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUBindOnSetLevelsStateFinished
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished, Obj) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished, FuncName) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUBindOnSetLevelsStateFinished::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUComputeActorHitMovePenetration
// 0x0058 (0x0058 - 0x0000)
struct BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHitMoveOverlapOtherActorCollisionsInfo*> OverlappedOtherActorInfos;                         // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SelfWeight;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlaneNormalVector;                                 // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxComputeRound;                                   // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Epsilon;                                           // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration) == 0x000058, "Wrong size on BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration, SelfActor) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration::SelfActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration, OverlappedOtherActorInfos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration::OverlappedOtherActorInfos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration, SelfWeight) == 0x000018, "Member 'BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration::SelfWeight' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration, PlaneNormalVector) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration::PlaneNormalVector' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration, MaxComputeRound) == 0x000038, "Member 'BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration::MaxComputeRound' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration, Epsilon) == 0x00003C, "Member 'BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration::Epsilon' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration, ReturnValue) == 0x000040, "Member 'BGUFunctionLibraryForCS_BGUComputeActorHitMovePenetration::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUCreateLandscapeHeightMap
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap final
{
public:
	class ALandscape*                             Landscape;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PackageName;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetName;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap) == 0x000030, "Wrong size on BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap, Landscape) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap::Landscape' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap, PackageName) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap::PackageName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap, AssetName) == 0x000018, "Member 'BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap::AssetName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap, ReturnValue) == 0x000028, "Member 'BGUFunctionLibraryForCS_BGUCreateLandscapeHeightMap::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawDebugAnnularSector
// 0x0058 (0x0058 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfAngle;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector) == 0x000058, "Wrong size on BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, CenterPos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::CenterPos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, Direction) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::Direction' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, InnerRadius) == 0x000038, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::InnerRadius' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, OuterRadius) == 0x00003C, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::OuterRadius' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, HalfAngle) == 0x000040, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::HalfAngle' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, Color) == 0x000044, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::Color' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, Duration) == 0x000048, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::Duration' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, Thickness) == 0x00004C, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::Thickness' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector, Segments) == 0x000050, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugAnnularSector::Segments' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawDebugCircle
// 0x0028 (0x0028 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawDebugCircle final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Raidus;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawDebugCircle) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawDebugCircle");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawDebugCircle) == 0x000028, "Wrong size on BGUFunctionLibraryForCS_BGUDrawDebugCircle");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugCircle, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugCircle::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugCircle, CenterPos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugCircle::CenterPos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugCircle, Raidus) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugCircle::Raidus' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawDebugCircleEx
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawDebugCircleEx final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Raidus;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepTime;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawDebugCircleEx) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawDebugCircleEx");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawDebugCircleEx) == 0x000030, "Wrong size on BGUFunctionLibraryForCS_BGUDrawDebugCircleEx");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugCircleEx, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugCircleEx::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugCircleEx, CenterPos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugCircleEx::CenterPos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugCircleEx, Raidus) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugCircleEx::Raidus' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugCircleEx, KeepTime) == 0x000024, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugCircleEx::KeepTime' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugCircleEx, Color) == 0x000028, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugCircleEx::Color' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawDebugRect
// 0x0040 (0x0040 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawDebugRect final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawDebugRect) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawDebugRect");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawDebugRect) == 0x000040, "Wrong size on BGUFunctionLibraryForCS_BGUDrawDebugRect");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugRect, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugRect::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugRect, CenterPos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugRect::CenterPos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugRect, Direction) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugRect::Direction' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugRect, Width) == 0x000038, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugRect::Width' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugRect, Length) == 0x00003C, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugRect::Length' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawDebugSphere
// 0x0028 (0x0028 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawDebugSphere final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Raidus;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawDebugSphere) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawDebugSphere");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawDebugSphere) == 0x000028, "Wrong size on BGUFunctionLibraryForCS_BGUDrawDebugSphere");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugSphere, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugSphere::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugSphere, CenterPos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugSphere::CenterPos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugSphere, Raidus) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugSphere::Raidus' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawDebugSphereEx
// 0x0030 (0x0030 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawDebugSphereEx final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Raidus;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepTime;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawDebugSphereEx) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawDebugSphereEx");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawDebugSphereEx) == 0x000030, "Wrong size on BGUFunctionLibraryForCS_BGUDrawDebugSphereEx");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugSphereEx, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugSphereEx::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugSphereEx, CenterPos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugSphereEx::CenterPos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugSphereEx, Raidus) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugSphereEx::Raidus' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugSphereEx, KeepTime) == 0x000024, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugSphereEx::KeepTime' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawDebugSphereEx, Color) == 0x000028, "Member 'BGUFunctionLibraryForCS_BGUDrawDebugSphereEx::Color' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawLineArrow
// 0x0040 (0x0040 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawLineArrow final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowSize;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawLineArrow) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawLineArrow");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawLineArrow) == 0x000040, "Wrong size on BGUFunctionLibraryForCS_BGUDrawLineArrow");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrow, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrow::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrow, LineStart) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrow::LineStart' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrow, LineEnd) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrow::LineEnd' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrow, ArrowSize) == 0x000038, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrow::ArrowSize' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawLineArrowEx
// 0x0048 (0x0048 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawLineArrowEx final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowSize;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPersistentLines;                                 // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawLineArrowEx");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx) == 0x000048, "Wrong size on BGUFunctionLibraryForCS_BGUDrawLineArrowEx");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrowEx::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx, LineStart) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrowEx::LineStart' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx, LineEnd) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrowEx::LineEnd' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx, ArrowSize) == 0x000038, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrowEx::ArrowSize' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx, Color) == 0x00003C, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrowEx::Color' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx, IsPersistentLines) == 0x000040, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrowEx::IsPersistentLines' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawLineArrowEx, LifeTime) == 0x000044, "Member 'BGUFunctionLibraryForCS_BGUDrawLineArrowEx::LifeTime' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawSphereSweep
// 0x00E0 (0x00E0 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawSphereSweep final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Start;                                             // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             End;                                               // 0x0070(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00D0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0xC];                                       // 0x00D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawSphereSweep) == 0x000010, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawSphereSweep");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawSphereSweep) == 0x0000E0, "Wrong size on BGUFunctionLibraryForCS_BGUDrawSphereSweep");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawSphereSweep, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawSphereSweep::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawSphereSweep, Start) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUDrawSphereSweep::Start' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawSphereSweep, End) == 0x000070, "Member 'BGUFunctionLibraryForCS_BGUDrawSphereSweep::End' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawSphereSweep, Radius) == 0x0000D0, "Member 'BGUFunctionLibraryForCS_BGUDrawSphereSweep::Radius' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BguDrawSphereSweepWithColor
// 0x00E0 (0x00E0 - 0x0000)
struct BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Start;                                             // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             End;                                               // 0x0070(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00D0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x00D4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor) == 0x000010, "Wrong alignment on BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor");
static_assert(sizeof(BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor) == 0x0000E0, "Wrong size on BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor, Start) == 0x000010, "Member 'BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor::Start' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor, End) == 0x000070, "Member 'BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor::End' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor, Radius) == 0x0000D0, "Member 'BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor::Radius' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor, Color) == 0x0000D4, "Member 'BGUFunctionLibraryForCS_BguDrawSphereSweepWithColor::Color' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUDrawSweepCheckShape
// 0x0070 (0x0070 - 0x0000)
struct BGUFunctionLibraryForCS_BGUDrawSweepCheckShape final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rot;                                               // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGSSweepCheckShapeInfo                 SweepCheckShapeInfo;                               // 0x0040(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUDrawSweepCheckShape) == 0x000010, "Wrong alignment on BGUFunctionLibraryForCS_BGUDrawSweepCheckShape");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUDrawSweepCheckShape) == 0x000070, "Wrong size on BGUFunctionLibraryForCS_BGUDrawSweepCheckShape");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawSweepCheckShape, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUDrawSweepCheckShape::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawSweepCheckShape, CenterPos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUDrawSweepCheckShape::CenterPos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawSweepCheckShape, Rot) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUDrawSweepCheckShape::Rot' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUDrawSweepCheckShape, SweepCheckShapeInfo) == 0x000040, "Member 'BGUFunctionLibraryForCS_BGUDrawSweepCheckShape::SweepCheckShapeInfo' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BguDrawSweepCheckShapeWithColor
// 0x0070 (0x0070 - 0x0000)
struct BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rot;                                               // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGSSweepCheckShapeInfo                 SweepCheckShapeInfo;                               // 0x0040(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0068(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor) == 0x000010, "Wrong alignment on BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor");
static_assert(sizeof(BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor) == 0x000070, "Wrong size on BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor, World) == 0x000000, "Member 'BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor::World' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor, CenterPos) == 0x000008, "Member 'BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor::CenterPos' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor, Rot) == 0x000020, "Member 'BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor::Rot' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor, SweepCheckShapeInfo) == 0x000040, "Member 'BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor::SweepCheckShapeInfo' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor, Color) == 0x000068, "Member 'BGUFunctionLibraryForCS_BguDrawSweepCheckShapeWithColor::Color' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUEnableActorTick
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUEnableActorTick final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUEnableActorTick) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUEnableActorTick");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUEnableActorTick) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUEnableActorTick");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUEnableActorTick, Actor) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUEnableActorTick::Actor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUEnableActorTick, bEnable) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUEnableActorTick::bEnable' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUExceutePyCode
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUExceutePyCode final
{
public:
	class FString                                 PyPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUExceutePyCode) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUExceutePyCode");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUExceutePyCode) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUExceutePyCode");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUExceutePyCode, PyPath) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUExceutePyCode::PyPath' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetActorLevelName
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetActorLevelName final
{
public:
	class AActor*                                 Unit;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetActorLevelName) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetActorLevelName");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetActorLevelName) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUGetActorLevelName");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetActorLevelName, Unit) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetActorLevelName::Unit' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetActorLevelName, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetActorLevelName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetAIStimulusWasSuccessfullySensed
// 0x0060 (0x0060 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed final
{
public:
	struct FAIStimulus                            Stimulus;                                          // 0x0000(0x0058)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed) == 0x000060, "Wrong size on BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed, Stimulus) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed::Stimulus' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed, ReturnValue) == 0x000058, "Member 'BGUFunctionLibraryForCS_BGUGetAIStimulusWasSuccessfullySensed::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetAllActorsFromGroupActor
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor final
{
public:
	class AActor*                                 GroupActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecurse;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor) == 0x000020, "Wrong size on BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor, GroupActor) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor::GroupActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor, bRecurse) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor::bRecurse' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor, ReturnValue) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUGetAllActorsFromGroupActor::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetBodyRadius
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetBodyRadius final
{
public:
	class USkeletalMeshComponent*                 SkMeshComp;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetWelded;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetBodyRadius) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetBodyRadius");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetBodyRadius) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUGetBodyRadius");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetBodyRadius, SkMeshComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetBodyRadius::SkMeshComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetBodyRadius, BoneName) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetBodyRadius::BoneName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetBodyRadius, bGetWelded) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUGetBodyRadius::bGetWelded' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetBodyRadius, ReturnValue) == 0x000014, "Member 'BGUFunctionLibraryForCS_BGUGetBodyRadius::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetBounds
// 0x0038 (0x0038 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetBounds final
{
public:
	class UPrimitiveComponent*                    PrimComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetBounds) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetBounds");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetBounds) == 0x000038, "Wrong size on BGUFunctionLibraryForCS_BGUGetBounds");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetBounds, PrimComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetBounds::PrimComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetBounds, Origin) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetBounds::Origin' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetBounds, BoxExtent) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUGetBounds::BoxExtent' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetCurActiveMontageInstID
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID, AnimInstance) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID::AnimInstance' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetCurActiveMontageInstID::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetCurrentTime
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetCurrentTime final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetCurrentTime) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetCurrentTime");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetCurrentTime) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetCurrentTime");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetCurrentTime, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetCurrentTime::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetCurrentTime, IsValid) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetCurrentTime::IsValid' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetCurrentTime, ReturnValue) == 0x00000C, "Member 'BGUFunctionLibraryForCS_BGUGetCurrentTime::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetFloatValueTableRow
// 0x0038 (0x0038 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetFloatValueTableRow final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGSFloatValueTableRow                  Result;                                            // 0x0010(0x0010)(Parm, OutParm, NativeAccessSpecifierPublic)
	class FString                                 ContextString;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnIfRowMissing;                                 // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0031(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetFloatValueTableRow) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetFloatValueTableRow");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetFloatValueTableRow) == 0x000038, "Wrong size on BGUFunctionLibraryForCS_BGUGetFloatValueTableRow");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetFloatValueTableRow, DataTable) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetFloatValueTableRow::DataTable' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetFloatValueTableRow, RowName) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetFloatValueTableRow::RowName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetFloatValueTableRow, Result) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUGetFloatValueTableRow::Result' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetFloatValueTableRow, ContextString) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUGetFloatValueTableRow::ContextString' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetFloatValueTableRow, bWarnIfRowMissing) == 0x000030, "Member 'BGUFunctionLibraryForCS_BGUGetFloatValueTableRow::bWarnIfRowMissing' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetFloatValueTableRow, ReturnValue) == 0x000031, "Member 'BGUFunctionLibraryForCS_BGUGetFloatValueTableRow::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetIsBuildShipping
// 0x0001 (0x0001 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetIsBuildShipping final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetIsBuildShipping) == 0x000001, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetIsBuildShipping");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetIsBuildShipping) == 0x000001, "Wrong size on BGUFunctionLibraryForCS_BGUGetIsBuildShipping");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetIsBuildShipping, ReturnValue) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetIsBuildShipping::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetIsEditor
// 0x0001 (0x0001 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetIsEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetIsEditor) == 0x000001, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetIsEditor");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetIsEditor) == 0x000001, "Wrong size on BGUFunctionLibraryForCS_BGUGetIsEditor");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetIsEditor, ReturnValue) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetIsEditor::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetIsInEditorPreview
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetIsInEditorPreview final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetIsInEditorPreview) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetIsInEditorPreview");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetIsInEditorPreview) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetIsInEditorPreview");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetIsInEditorPreview, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetIsInEditorPreview::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetIsInEditorPreview, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetIsInEditorPreview::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetIsInGameWorld
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetIsInGameWorld final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetIsInGameWorld) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetIsInGameWorld");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetIsInGameWorld) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetIsInGameWorld");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetIsInGameWorld, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetIsInGameWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetIsInGameWorld, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetIsInGameWorld::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetIsRuntionShowCollision
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetIsRuntionShowCollision::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetLandscapeExtent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetLandscapeExtent final
{
public:
	class ALandscape*                             Landscape;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinX;                                              // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinY;                                              // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxX;                                              // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxY;                                              // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetLandscapeExtent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetLandscapeExtent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetLandscapeExtent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUGetLandscapeExtent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLandscapeExtent, Landscape) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetLandscapeExtent::Landscape' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLandscapeExtent, MinX) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetLandscapeExtent::MinX' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLandscapeExtent, MinY) == 0x00000C, "Member 'BGUFunctionLibraryForCS_BGUGetLandscapeExtent::MinY' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLandscapeExtent, MaxX) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUGetLandscapeExtent::MaxX' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLandscapeExtent, MaxY) == 0x000014, "Member 'BGUFunctionLibraryForCS_BGUGetLandscapeExtent::MaxY' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetLevelSequenceCurTime
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime final
{
public:
	class ULevelSequencePlayer*                   LeveleSequencePlayer;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime, LeveleSequencePlayer) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime::LeveleSequencePlayer' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetLevelSequenceCurTime::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetLevelSequenceLength
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetLevelSequenceLength final
{
public:
	class ULevelSequencePlayer*                   LeveleSequencePlayer;                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetLevelSequenceLength) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetLevelSequenceLength");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetLevelSequenceLength) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetLevelSequenceLength");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLevelSequenceLength, LeveleSequencePlayer) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetLevelSequenceLength::LeveleSequencePlayer' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetLevelSequenceLength, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetLevelSequenceLength::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetMeshPredictedLODLevel
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel, MeshComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel::MeshComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetMeshPredictedLODLevel::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetPaperSpriteSize
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetPaperSpriteSize final
{
public:
	class UPaperSprite*                           PaperSprite;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetPaperSpriteSize) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetPaperSpriteSize");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetPaperSpriteSize) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUGetPaperSpriteSize");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetPaperSpriteSize, PaperSprite) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetPaperSpriteSize::PaperSprite' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetPaperSpriteSize, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetPaperSpriteSize::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetPARadiusByBoneName
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName final
{
public:
	class UPhysicsAsset*                          PA;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyRadius;                                        // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName, PA) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName::PA' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName, BoneName) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName::BoneName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName, BodyRadius) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName::BodyRadius' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName, ReturnValue) == 0x000014, "Member 'BGUFunctionLibraryForCS_BGUGetPARadiusByBoneName::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetParticleSystemIsLooping
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping final
{
public:
	const class UParticleSystem*                  ParticleForPlay;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping, ParticleForPlay) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping::ParticleForPlay' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetParticleSystemIsLooping::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetSectionFromProceduralMesh
// 0x0060 (0x0060 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh final
{
public:
	class UProceduralMeshComponent*               InProcMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Vertices;                                          // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Triangles;                                         // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Normals;                                           // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      UVs;                                               // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FProcMeshTangent>               Tangents;                                          // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh) == 0x000060, "Wrong size on BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh, InProcMesh) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh::InProcMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh, SectionIndex) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh::SectionIndex' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh, Vertices) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh::Vertices' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh, Triangles) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh::Triangles' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh, Normals) == 0x000030, "Member 'BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh::Normals' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh, UVs) == 0x000040, "Member 'BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh::UVs' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh, Tangents) == 0x000050, "Member 'BGUFunctionLibraryForCS_BGUGetSectionFromProceduralMesh::Tangents' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUGetUWorld
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUGetUWorld final
{
public:
	class UObject*                                InnerObject;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUGetUWorld) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUGetUWorld");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUGetUWorld) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUGetUWorld");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetUWorld, InnerObject) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUGetUWorld::InnerObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUGetUWorld, ReturnValue) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUGetUWorld::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUIsBlackBoardKeyTypeMatch
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch final
{
public:
	class UBlackboardKeyType*                     BBKey;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBBKeyType                                    BBKeyType;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch, BBKey) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch::BBKey' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch, BBKeyType) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch::BBKeyType' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch, ReturnValue) == 0x000009, "Member 'BGUFunctionLibraryForCS_BGUIsBlackBoardKeyTypeMatch::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUMovementComponentHandleImpact
// 0x0110 (0x0110 - 0x0000)
struct BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact final
{
public:
	class UMovementComponent*                     MoveComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TimeSlice;                                         // 0x00F0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoveDelta;                                         // 0x00F8(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact) == 0x000110, "Wrong size on BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact, MoveComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact::MoveComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact, Hit) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact::Hit' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact, TimeSlice) == 0x0000F0, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact::TimeSlice' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact, MoveDelta) == 0x0000F8, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentHandleImpact::MoveDelta' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUMovementComponentSlideAlongSurface
// 0x0220 (0x0220 - 0x0000)
struct BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface final
{
public:
	class UMovementComponent*                     MoveComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Delta;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Normal;                                            // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             InHit;                                             // 0x0040(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHandleImpact;                                     // 0x0128(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0130(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0218(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface) == 0x000220, "Wrong size on BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface, MoveComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface::MoveComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface, Delta) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface::Delta' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface, Time) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface::Time' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface, Normal) == 0x000028, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface::Normal' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface, InHit) == 0x000040, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface::InHit' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface, bHandleImpact) == 0x000128, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface::bHandleImpact' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface, OutHit) == 0x000130, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface::OutHit' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface, ReturnValue) == 0x000218, "Member 'BGUFunctionLibraryForCS_BGUMovementComponentSlideAlongSurface::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGURegistComp
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGURegistComp final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ActorComp;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGURegistComp) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGURegistComp");
static_assert(sizeof(BGUFunctionLibraryForCS_BGURegistComp) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGURegistComp");
static_assert(offsetof(BGUFunctionLibraryForCS_BGURegistComp, WorldContextObject) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGURegistComp::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGURegistComp, ActorComp) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGURegistComp::ActorComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGURegistComp, ReturnValue) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGURegistComp::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGURestartBT
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibraryForCS_BGURestartBT final
{
public:
	class ABGUAIController*                       AIController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGURestartBT) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGURestartBT");
static_assert(sizeof(BGUFunctionLibraryForCS_BGURestartBT) == 0x000008, "Wrong size on BGUFunctionLibraryForCS_BGURestartBT");
static_assert(offsetof(BGUFunctionLibraryForCS_BGURestartBT, AIController) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGURestartBT::AIController' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUSetDecalSize
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibraryForCS_BGUSetDecalSize final
{
public:
	class UDecalComponent*                        DecalComp;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUSetDecalSize) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUSetDecalSize");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUSetDecalSize) == 0x000020, "Wrong size on BGUFunctionLibraryForCS_BGUSetDecalSize");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSetDecalSize, DecalComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUSetDecalSize::DecalComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSetDecalSize, Size) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUSetDecalSize::Size' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUSetIKComponentValid
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUSetIKComponentValid final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewValid;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUSetIKComponentValid) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUSetIKComponentValid");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUSetIKComponentValid) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUSetIKComponentValid");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSetIKComponentValid, Character) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUSetIKComponentValid::Character' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSetIKComponentValid, NewValid) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUSetIKComponentValid::NewValid' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUSetParticleSysCompPoolingMethod
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod final
{
public:
	class UParticleSystemComponent*               ParticleComp;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPSCPoolMethod                                PoolMethod;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod, ParticleComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod::ParticleComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod, PoolMethod) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUSetParticleSysCompPoolingMethod::PoolMethod' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUSetParticleSysSortPriority
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority final
{
public:
	class UParticleSystemComponent*               ParticleSystemComp;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority, ParticleSystemComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority::ParticleSystemComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority, SortPriority) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUSetParticleSysSortPriority::SortPriority' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUSliceProceduralMesh
// 0x0058 (0x0058 - 0x0000)
struct BGUFunctionLibraryForCS_BGUSliceProceduralMesh final
{
public:
	class UProceduralMeshComponent*               InProcMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlanePosition;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateOtherHalf;                                  // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralMeshComponent*               OutOtherHalfProcMesh;                              // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProcMeshSliceCapOption                       CapOption;                                         // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     CapMaterial;                                       // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUSliceProceduralMesh");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh) == 0x000058, "Wrong size on BGUFunctionLibraryForCS_BGUSliceProceduralMesh");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh, InProcMesh) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUSliceProceduralMesh::InProcMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh, PlanePosition) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUSliceProceduralMesh::PlanePosition' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh, PlaneNormal) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUSliceProceduralMesh::PlaneNormal' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh, bCreateOtherHalf) == 0x000038, "Member 'BGUFunctionLibraryForCS_BGUSliceProceduralMesh::bCreateOtherHalf' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh, OutOtherHalfProcMesh) == 0x000040, "Member 'BGUFunctionLibraryForCS_BGUSliceProceduralMesh::OutOtherHalfProcMesh' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh, CapOption) == 0x000048, "Member 'BGUFunctionLibraryForCS_BGUSliceProceduralMesh::CapOption' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSliceProceduralMesh, CapMaterial) == 0x000050, "Member 'BGUFunctionLibraryForCS_BGUSliceProceduralMesh::CapMaterial' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUSpawnDecalAttached
// 0x0070 (0x0070 - 0x0000)
struct BGUFunctionLibraryForCS_BGUSpawnDecalAttached final
{
public:
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeSpan;                                          // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        ReturnValue;                                       // 0x0068(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUSpawnDecalAttached");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached) == 0x000070, "Wrong size on BGUFunctionLibraryForCS_BGUSpawnDecalAttached");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, DecalMaterial) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::DecalMaterial' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, DecalSize) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::DecalSize' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, AttachToComponent) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, AttachPointName) == 0x000028, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, Location) == 0x000030, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::Location' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, Rotation) == 0x000048, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::Rotation' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, LocationType) == 0x000060, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::LocationType' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, LifeSpan) == 0x000064, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::LifeSpan' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUSpawnDecalAttached, ReturnValue) == 0x000068, "Member 'BGUFunctionLibraryForCS_BGUSpawnDecalAttached::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUTeleportTo
// 0x0040 (0x0040 - 0x0000)
struct BGUFunctionLibraryForCS_BGUTeleportTo final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DestRotation;                                      // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsATest;                                          // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCheck;                                          // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUTeleportTo) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUTeleportTo");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUTeleportTo) == 0x000040, "Wrong size on BGUFunctionLibraryForCS_BGUTeleportTo");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUTeleportTo, Owner) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUTeleportTo::Owner' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUTeleportTo, DestLocation) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUTeleportTo::DestLocation' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUTeleportTo, DestRotation) == 0x000020, "Member 'BGUFunctionLibraryForCS_BGUTeleportTo::DestRotation' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUTeleportTo, bIsATest) == 0x000038, "Member 'BGUFunctionLibraryForCS_BGUTeleportTo::bIsATest' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUTeleportTo, bNoCheck) == 0x000039, "Member 'BGUFunctionLibraryForCS_BGUTeleportTo::bNoCheck' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUTeleportTo, ReturnValue) == 0x00003A, "Member 'BGUFunctionLibraryForCS_BGUTeleportTo::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUUnBindOnAllSetLevelsStateFinished
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished, Obj) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished, FuncName) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnAllSetLevelsStateFinished::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUUnBindOnComponentBeginOverlapEvent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent, Comp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent, Obj) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent, FuncName) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentBeginOverlapEvent::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUUnBindOnComponentEndOverlapEvent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent, Comp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent, Obj) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent, FuncName) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentEndOverlapEvent::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUUnBindOnComponentHitEvent
// 0x0018 (0x0018 - 0x0000)
struct BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Obj;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Func_0;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent) == 0x000018, "Wrong size on BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent, Comp) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent, Obj) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent, Func_0) == 0x000010, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnComponentHitEvent::Func_0' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.BGUUnBindOnSetLevelsStateFinished
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished");
static_assert(sizeof(BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished, Obj) == 0x000000, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished::Obj' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished, FuncName) == 0x000008, "Member 'BGUFunctionLibraryForCS_BGUUnBindOnSetLevelsStateFinished::FuncName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.CallSectionManuallyChangeOnCrossSectionNotifies
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies final
{
public:
	class ABGUCharacter*                          OwnerChar;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewSectionName;                                    // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies");
static_assert(sizeof(BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies");
static_assert(offsetof(BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies, OwnerChar) == 0x000000, "Member 'BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies::OwnerChar' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies, NewSectionName) == 0x000008, "Member 'BGUFunctionLibraryForCS_CallSectionManuallyChangeOnCrossSectionNotifies::NewSectionName' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.CompForceUpdateOverlaps
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_CompForceUpdateOverlaps final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotifies;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_CompForceUpdateOverlaps) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_CompForceUpdateOverlaps");
static_assert(sizeof(BGUFunctionLibraryForCS_CompForceUpdateOverlaps) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_CompForceUpdateOverlaps");
static_assert(offsetof(BGUFunctionLibraryForCS_CompForceUpdateOverlaps, Comp) == 0x000000, "Member 'BGUFunctionLibraryForCS_CompForceUpdateOverlaps::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_CompForceUpdateOverlaps, bDoNotifies) == 0x000008, "Member 'BGUFunctionLibraryForCS_CompForceUpdateOverlaps::bDoNotifies' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_CompForceUpdateOverlaps, ReturnValue) == 0x000009, "Member 'BGUFunctionLibraryForCS_CompForceUpdateOverlaps::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.ConvertObjectTypeToCollisionChannel
// 0x0002 (0x0002 - 0x0000)
struct BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel final
{
public:
	EObjectTypeQuery                              ObjectType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel) == 0x000001, "Wrong alignment on BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel");
static_assert(sizeof(BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel) == 0x000002, "Wrong size on BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel");
static_assert(offsetof(BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel, ObjectType) == 0x000000, "Member 'BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel::ObjectType' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel, ReturnValue) == 0x000001, "Member 'BGUFunctionLibraryForCS_ConvertObjectTypeToCollisionChannel::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.ConvertToObjectType
// 0x0002 (0x0002 - 0x0000)
struct BGUFunctionLibraryForCS_ConvertToObjectType final
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectTypeQuery                              ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_ConvertToObjectType) == 0x000001, "Wrong alignment on BGUFunctionLibraryForCS_ConvertToObjectType");
static_assert(sizeof(BGUFunctionLibraryForCS_ConvertToObjectType) == 0x000002, "Wrong size on BGUFunctionLibraryForCS_ConvertToObjectType");
static_assert(offsetof(BGUFunctionLibraryForCS_ConvertToObjectType, CollisionChannel) == 0x000000, "Member 'BGUFunctionLibraryForCS_ConvertToObjectType::CollisionChannel' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_ConvertToObjectType, ReturnValue) == 0x000001, "Member 'BGUFunctionLibraryForCS_ConvertToObjectType::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.ConvertToTraceType
// 0x0002 (0x0002 - 0x0000)
struct BGUFunctionLibraryForCS_ConvertToTraceType final
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_ConvertToTraceType) == 0x000001, "Wrong alignment on BGUFunctionLibraryForCS_ConvertToTraceType");
static_assert(sizeof(BGUFunctionLibraryForCS_ConvertToTraceType) == 0x000002, "Wrong size on BGUFunctionLibraryForCS_ConvertToTraceType");
static_assert(offsetof(BGUFunctionLibraryForCS_ConvertToTraceType, CollisionChannel) == 0x000000, "Member 'BGUFunctionLibraryForCS_ConvertToTraceType::CollisionChannel' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_ConvertToTraceType, ReturnValue) == 0x000001, "Member 'BGUFunctionLibraryForCS_ConvertToTraceType::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.ConvertTraceTypeToCollisionChannel
// 0x0002 (0x0002 - 0x0000)
struct BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel final
{
public:
	ETraceTypeQuery                               TraceType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel) == 0x000001, "Wrong alignment on BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel");
static_assert(sizeof(BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel) == 0x000002, "Wrong size on BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel");
static_assert(offsetof(BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel, TraceType) == 0x000000, "Member 'BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel::TraceType' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel, ReturnValue) == 0x000001, "Member 'BGUFunctionLibraryForCS_ConvertTraceTypeToCollisionChannel::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.CopyProceduralMeshFromStaticMeshComponent
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralMeshComponent*               ProcMeshComponent;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateCollision;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent");
static_assert(sizeof(BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent) == 0x000020, "Wrong size on BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent");
static_assert(offsetof(BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent, StaticMeshComponent) == 0x000000, "Member 'BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent, LODIndex) == 0x000008, "Member 'BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent::LODIndex' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent, ProcMeshComponent) == 0x000010, "Member 'BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent::ProcMeshComponent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent, bCreateCollision) == 0x000018, "Member 'BGUFunctionLibraryForCS_CopyProceduralMeshFromStaticMeshComponent::bCreateCollision' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.RemoveAllQueriesByQuerier
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibraryForCS_RemoveAllQueriesByQuerier final
{
public:
	class UObject*                                Querier;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_RemoveAllQueriesByQuerier) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_RemoveAllQueriesByQuerier");
static_assert(sizeof(BGUFunctionLibraryForCS_RemoveAllQueriesByQuerier) == 0x000008, "Wrong size on BGUFunctionLibraryForCS_RemoveAllQueriesByQuerier");
static_assert(offsetof(BGUFunctionLibraryForCS_RemoveAllQueriesByQuerier, Querier) == 0x000000, "Member 'BGUFunctionLibraryForCS_RemoveAllQueriesByQuerier::Querier' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.RequestGameplayTag
// 0x0014 (0x0014 - 0x0000)
struct BGUFunctionLibraryForCS_RequestGameplayTag final
{
public:
	class FName                                   TagName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ErrorIfNotFound;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_RequestGameplayTag) == 0x000004, "Wrong alignment on BGUFunctionLibraryForCS_RequestGameplayTag");
static_assert(sizeof(BGUFunctionLibraryForCS_RequestGameplayTag) == 0x000014, "Wrong size on BGUFunctionLibraryForCS_RequestGameplayTag");
static_assert(offsetof(BGUFunctionLibraryForCS_RequestGameplayTag, TagName) == 0x000000, "Member 'BGUFunctionLibraryForCS_RequestGameplayTag::TagName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_RequestGameplayTag, ErrorIfNotFound) == 0x000008, "Member 'BGUFunctionLibraryForCS_RequestGameplayTag::ErrorIfNotFound' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_RequestGameplayTag, ReturnValue) == 0x00000C, "Member 'BGUFunctionLibraryForCS_RequestGameplayTag::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.ValidateMontagesForCrossSectionNS
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_ValidateMontagesForCrossSectionNS final
{
public:
	class FString                                 ResourcePath;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_ValidateMontagesForCrossSectionNS) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_ValidateMontagesForCrossSectionNS");
static_assert(sizeof(BGUFunctionLibraryForCS_ValidateMontagesForCrossSectionNS) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_ValidateMontagesForCrossSectionNS");
static_assert(offsetof(BGUFunctionLibraryForCS_ValidateMontagesForCrossSectionNS, ResourcePath) == 0x000000, "Member 'BGUFunctionLibraryForCS_ValidateMontagesForCrossSectionNS::ResourcePath' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.OnActorBeginOverlapPlaceholder
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder final
{
public:
	class AActor*                                 OverlapActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder");
static_assert(sizeof(BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder");
static_assert(offsetof(BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder, OverlapActor) == 0x000000, "Member 'BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder::OverlapActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder, OtherActor) == 0x000008, "Member 'BGUFunctionLibraryForCS_OnActorBeginOverlapPlaceholder::OtherActor' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.OnActorEndOverlapPlaceholder
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder final
{
public:
	class AActor*                                 OverlapActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder");
static_assert(sizeof(BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder) == 0x000010, "Wrong size on BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder");
static_assert(offsetof(BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder, OverlapActor) == 0x000000, "Member 'BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder::OverlapActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder, OtherActor) == 0x000008, "Member 'BGUFunctionLibraryForCS_OnActorEndOverlapPlaceholder::OtherActor' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.OnComponentBeginOverlapPlaceholder
// 0x0108 (0x0108 - 0x0000)
struct BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder");
static_assert(sizeof(BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder) == 0x000108, "Wrong size on BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder, OverlappedComponent) == 0x000000, "Member 'BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder, OtherActor) == 0x000008, "Member 'BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder::OtherActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder, OtherComp) == 0x000010, "Member 'BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder::OtherComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder, OtherBodyIndex) == 0x000018, "Member 'BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder, bFromSweep) == 0x00001C, "Member 'BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder::bFromSweep' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder, SweepResult) == 0x000020, "Member 'BGUFunctionLibraryForCS_OnComponentBeginOverlapPlaceholder::SweepResult' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.OnComponentEndOverlapPlaceholder
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder");
static_assert(sizeof(BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder) == 0x000020, "Wrong size on BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder, OverlappedComponent) == 0x000000, "Member 'BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder, OtherActor) == 0x000008, "Member 'BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder::OtherActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder, OtherComp) == 0x000010, "Member 'BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder::OtherComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder, OtherBodyIndex) == 0x000018, "Member 'BGUFunctionLibraryForCS_OnComponentEndOverlapPlaceholder::OtherBodyIndex' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.OnComponentHitPlaceholder
// 0x0118 (0x0118 - 0x0000)
struct BGUFunctionLibraryForCS_OnComponentHitPlaceholder final
{
public:
	class UPrimitiveComponent*                    HitComp;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitImpule;                                         // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibraryForCS_OnComponentHitPlaceholder) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_OnComponentHitPlaceholder");
static_assert(sizeof(BGUFunctionLibraryForCS_OnComponentHitPlaceholder) == 0x000118, "Wrong size on BGUFunctionLibraryForCS_OnComponentHitPlaceholder");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentHitPlaceholder, HitComp) == 0x000000, "Member 'BGUFunctionLibraryForCS_OnComponentHitPlaceholder::HitComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentHitPlaceholder, OtherActor) == 0x000008, "Member 'BGUFunctionLibraryForCS_OnComponentHitPlaceholder::OtherActor' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentHitPlaceholder, OtherComp) == 0x000010, "Member 'BGUFunctionLibraryForCS_OnComponentHitPlaceholder::OtherComp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentHitPlaceholder, HitImpule) == 0x000018, "Member 'BGUFunctionLibraryForCS_OnComponentHitPlaceholder::HitImpule' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnComponentHitPlaceholder, Hit) == 0x000030, "Member 'BGUFunctionLibraryForCS_OnComponentHitPlaceholder::Hit' has a wrong offset!");

// Function b1.BGUFunctionLibraryForCS.OnSetLevelsStateFinishedPlaceHolder
// 0x0028 (0x0028 - 0x0000)
struct BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder final
{
public:
	class FString                                 InTargetLevelsKeyword;                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTargetLevelState;                                // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InOperationID;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder) == 0x000008, "Wrong alignment on BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder");
static_assert(sizeof(BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder) == 0x000028, "Wrong size on BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder");
static_assert(offsetof(BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder, InTargetLevelsKeyword) == 0x000000, "Member 'BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder::InTargetLevelsKeyword' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder, InTargetLevelState) == 0x000010, "Member 'BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder::InTargetLevelState' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder, InOperationID) == 0x000020, "Member 'BGUFunctionLibraryForCS_OnSetLevelsStateFinishedPlaceHolder::InOperationID' has a wrong offset!");

// Function b1.BGUFunctionLibAK.AkEventPinInGarbageCollector
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibAK_AkEventPinInGarbageCollector final
{
public:
	class UAkAudioEvent*                          Event;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibAK_AkEventPinInGarbageCollector) == 0x000008, "Wrong alignment on BGUFunctionLibAK_AkEventPinInGarbageCollector");
static_assert(sizeof(BGUFunctionLibAK_AkEventPinInGarbageCollector) == 0x000010, "Wrong size on BGUFunctionLibAK_AkEventPinInGarbageCollector");
static_assert(offsetof(BGUFunctionLibAK_AkEventPinInGarbageCollector, Event) == 0x000000, "Member 'BGUFunctionLibAK_AkEventPinInGarbageCollector::Event' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_AkEventPinInGarbageCollector, PlayingID) == 0x000008, "Member 'BGUFunctionLibAK_AkEventPinInGarbageCollector::PlayingID' has a wrong offset!");

// Function b1.BGUFunctionLibAK.BGUAKStopPlayingID
// 0x000C (0x000C - 0x0000)
struct BGUFunctionLibAK_BGUAKStopPlayingID final
{
public:
	int32                                         PlayingID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeOutTimeMs;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeOutCurveType;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibAK_BGUAKStopPlayingID) == 0x000004, "Wrong alignment on BGUFunctionLibAK_BGUAKStopPlayingID");
static_assert(sizeof(BGUFunctionLibAK_BGUAKStopPlayingID) == 0x00000C, "Wrong size on BGUFunctionLibAK_BGUAKStopPlayingID");
static_assert(offsetof(BGUFunctionLibAK_BGUAKStopPlayingID, PlayingID) == 0x000000, "Member 'BGUFunctionLibAK_BGUAKStopPlayingID::PlayingID' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_BGUAKStopPlayingID, FadeOutTimeMs) == 0x000004, "Member 'BGUFunctionLibAK_BGUAKStopPlayingID::FadeOutTimeMs' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_BGUAKStopPlayingID, FadeOutCurveType) == 0x000008, "Member 'BGUFunctionLibAK_BGUAKStopPlayingID::FadeOutCurveType' has a wrong offset!");

// Function b1.BGUFunctionLibAK.ExecuteActionOnPlayingID
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibAK_ExecuteActionOnPlayingID final
{
public:
	int32                                         ActionType;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeOutTimeMs;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeOutCurveType;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibAK_ExecuteActionOnPlayingID) == 0x000004, "Wrong alignment on BGUFunctionLibAK_ExecuteActionOnPlayingID");
static_assert(sizeof(BGUFunctionLibAK_ExecuteActionOnPlayingID) == 0x000010, "Wrong size on BGUFunctionLibAK_ExecuteActionOnPlayingID");
static_assert(offsetof(BGUFunctionLibAK_ExecuteActionOnPlayingID, ActionType) == 0x000000, "Member 'BGUFunctionLibAK_ExecuteActionOnPlayingID::ActionType' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_ExecuteActionOnPlayingID, PlayingID) == 0x000004, "Member 'BGUFunctionLibAK_ExecuteActionOnPlayingID::PlayingID' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_ExecuteActionOnPlayingID, FadeOutTimeMs) == 0x000008, "Member 'BGUFunctionLibAK_ExecuteActionOnPlayingID::FadeOutTimeMs' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_ExecuteActionOnPlayingID, FadeOutCurveType) == 0x00000C, "Member 'BGUFunctionLibAK_ExecuteActionOnPlayingID::FadeOutCurveType' has a wrong offset!");

// Function b1.BGUFunctionLibAK.GetSourcePlayPosition
// 0x0008 (0x0008 - 0x0000)
struct BGUFunctionLibAK_GetSourcePlayPosition final
{
public:
	int32                                         PlayingID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibAK_GetSourcePlayPosition) == 0x000004, "Wrong alignment on BGUFunctionLibAK_GetSourcePlayPosition");
static_assert(sizeof(BGUFunctionLibAK_GetSourcePlayPosition) == 0x000008, "Wrong size on BGUFunctionLibAK_GetSourcePlayPosition");
static_assert(offsetof(BGUFunctionLibAK_GetSourcePlayPosition, PlayingID) == 0x000000, "Member 'BGUFunctionLibAK_GetSourcePlayPosition::PlayingID' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_GetSourcePlayPosition, ReturnValue) == 0x000004, "Member 'BGUFunctionLibAK_GetSourcePlayPosition::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibAK.LoadBank
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibAK_LoadBank final
{
public:
	class FString                                 BankName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibAK_LoadBank) == 0x000008, "Wrong alignment on BGUFunctionLibAK_LoadBank");
static_assert(sizeof(BGUFunctionLibAK_LoadBank) == 0x000010, "Wrong size on BGUFunctionLibAK_LoadBank");
static_assert(offsetof(BGUFunctionLibAK_LoadBank, BankName) == 0x000000, "Member 'BGUFunctionLibAK_LoadBank::BankName' has a wrong offset!");

// Function b1.BGUFunctionLibAK.PostAkEventOnDummyActor
// 0x0020 (0x0020 - 0x0000)
struct BGUFunctionLibAK_PostAkEventOnDummyActor final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Event;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibAK_PostAkEventOnDummyActor) == 0x000008, "Wrong alignment on BGUFunctionLibAK_PostAkEventOnDummyActor");
static_assert(sizeof(BGUFunctionLibAK_PostAkEventOnDummyActor) == 0x000020, "Wrong size on BGUFunctionLibAK_PostAkEventOnDummyActor");
static_assert(offsetof(BGUFunctionLibAK_PostAkEventOnDummyActor, EventName) == 0x000000, "Member 'BGUFunctionLibAK_PostAkEventOnDummyActor::EventName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_PostAkEventOnDummyActor, Event) == 0x000010, "Member 'BGUFunctionLibAK_PostAkEventOnDummyActor::Event' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_PostAkEventOnDummyActor, ReturnValue) == 0x000018, "Member 'BGUFunctionLibAK_PostAkEventOnDummyActor::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibAK.SeekOnEvent
// 0x0028 (0x0028 - 0x0000)
struct BGUFunctionLibAK_SeekOnEvent final
{
public:
	class FString                                 InEventName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkComponent*                           InComponent;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPercent;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSeekToNearestMarker;                            // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InPlayingID;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkResult                                     ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibAK_SeekOnEvent) == 0x000008, "Wrong alignment on BGUFunctionLibAK_SeekOnEvent");
static_assert(sizeof(BGUFunctionLibAK_SeekOnEvent) == 0x000028, "Wrong size on BGUFunctionLibAK_SeekOnEvent");
static_assert(offsetof(BGUFunctionLibAK_SeekOnEvent, InEventName) == 0x000000, "Member 'BGUFunctionLibAK_SeekOnEvent::InEventName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_SeekOnEvent, InComponent) == 0x000010, "Member 'BGUFunctionLibAK_SeekOnEvent::InComponent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_SeekOnEvent, InPercent) == 0x000018, "Member 'BGUFunctionLibAK_SeekOnEvent::InPercent' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_SeekOnEvent, bInSeekToNearestMarker) == 0x00001C, "Member 'BGUFunctionLibAK_SeekOnEvent::bInSeekToNearestMarker' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_SeekOnEvent, InPlayingID) == 0x000020, "Member 'BGUFunctionLibAK_SeekOnEvent::InPlayingID' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_SeekOnEvent, ReturnValue) == 0x000024, "Member 'BGUFunctionLibAK_SeekOnEvent::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibAK.SetUnrealGlobalSwitch
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibAK_SetUnrealGlobalSwitch final
{
public:
	class FName                                   SwitchGroup;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SwitchState;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibAK_SetUnrealGlobalSwitch) == 0x000004, "Wrong alignment on BGUFunctionLibAK_SetUnrealGlobalSwitch");
static_assert(sizeof(BGUFunctionLibAK_SetUnrealGlobalSwitch) == 0x000010, "Wrong size on BGUFunctionLibAK_SetUnrealGlobalSwitch");
static_assert(offsetof(BGUFunctionLibAK_SetUnrealGlobalSwitch, SwitchGroup) == 0x000000, "Member 'BGUFunctionLibAK_SetUnrealGlobalSwitch::SwitchGroup' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibAK_SetUnrealGlobalSwitch, SwitchState) == 0x000008, "Member 'BGUFunctionLibAK_SetUnrealGlobalSwitch::SwitchState' has a wrong offset!");

// Function b1.BGUFunctionLibAK.UnLoadBank
// 0x0010 (0x0010 - 0x0000)
struct BGUFunctionLibAK_UnLoadBank final
{
public:
	class FString                                 BankName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibAK_UnLoadBank) == 0x000008, "Wrong alignment on BGUFunctionLibAK_UnLoadBank");
static_assert(sizeof(BGUFunctionLibAK_UnLoadBank) == 0x000010, "Wrong size on BGUFunctionLibAK_UnLoadBank");
static_assert(offsetof(BGUFunctionLibAK_UnLoadBank, BankName) == 0x000000, "Member 'BGUFunctionLibAK_UnLoadBank::BankName' has a wrong offset!");

// Function b1.BGUFunctionLibCollisionChannel.BGUGetCollisionResponseToChannels
// 0x0060 (0x0060 - 0x0000)
struct BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels final
{
public:
	const class UPrimitiveComponent*              Comp;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECollisionChannel, ECollisionResponse>   OutResponseToChannels;                             // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels) == 0x000008, "Wrong alignment on BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels");
static_assert(sizeof(BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels) == 0x000060, "Wrong size on BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels");
static_assert(offsetof(BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels, Comp) == 0x000000, "Member 'BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels, OutResponseToChannels) == 0x000008, "Member 'BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels::OutResponseToChannels' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels, ReturnValue) == 0x000058, "Member 'BGUFunctionLibCollisionChannel_BGUGetCollisionResponseToChannels::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibCollisionChannel.BGUSetCollisionResponseToChannels
// 0x0058 (0x0058 - 0x0000)
struct BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels final
{
public:
	class UPrimitiveComponent*                    Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECollisionChannel, ECollisionResponse>   ResponseToChannels;                                // 0x0008(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels) == 0x000008, "Wrong alignment on BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels");
static_assert(sizeof(BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels) == 0x000058, "Wrong size on BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels");
static_assert(offsetof(BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels, Comp) == 0x000000, "Member 'BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels, ResponseToChannels) == 0x000008, "Member 'BGUFunctionLibCollisionChannel_BGUSetCollisionResponseToChannels::ResponseToChannels' has a wrong offset!");

// Function b1.BGUFunctionLibCollisionChannel.ConvertToCollisionChannelByObjectType
// 0x0002 (0x0002 - 0x0000)
struct BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType final
{
public:
	EObjectTypeQuery                              ObjectType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType) == 0x000001, "Wrong alignment on BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType");
static_assert(sizeof(BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType) == 0x000002, "Wrong size on BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType");
static_assert(offsetof(BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType, ObjectType) == 0x000000, "Member 'BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType::ObjectType' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType, ReturnValue) == 0x000001, "Member 'BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByObjectType::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibCollisionChannel.ConvertToCollisionChannelByTraceType
// 0x0002 (0x0002 - 0x0000)
struct BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType final
{
public:
	ETraceTypeQuery                               TraceType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType) == 0x000001, "Wrong alignment on BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType");
static_assert(sizeof(BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType) == 0x000002, "Wrong size on BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType");
static_assert(offsetof(BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType, TraceType) == 0x000000, "Member 'BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType::TraceType' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType, ReturnValue) == 0x000001, "Member 'BGUFunctionLibCollisionChannel_ConvertToCollisionChannelByTraceType::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibCollisionChannel.ConvertToObjectType
// 0x0002 (0x0002 - 0x0000)
struct BGUFunctionLibCollisionChannel_ConvertToObjectType final
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectTypeQuery                              ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibCollisionChannel_ConvertToObjectType) == 0x000001, "Wrong alignment on BGUFunctionLibCollisionChannel_ConvertToObjectType");
static_assert(sizeof(BGUFunctionLibCollisionChannel_ConvertToObjectType) == 0x000002, "Wrong size on BGUFunctionLibCollisionChannel_ConvertToObjectType");
static_assert(offsetof(BGUFunctionLibCollisionChannel_ConvertToObjectType, CollisionChannel) == 0x000000, "Member 'BGUFunctionLibCollisionChannel_ConvertToObjectType::CollisionChannel' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_ConvertToObjectType, ReturnValue) == 0x000001, "Member 'BGUFunctionLibCollisionChannel_ConvertToObjectType::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibCollisionChannel.ConvertToTraceType
// 0x0002 (0x0002 - 0x0000)
struct BGUFunctionLibCollisionChannel_ConvertToTraceType final
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFunctionLibCollisionChannel_ConvertToTraceType) == 0x000001, "Wrong alignment on BGUFunctionLibCollisionChannel_ConvertToTraceType");
static_assert(sizeof(BGUFunctionLibCollisionChannel_ConvertToTraceType) == 0x000002, "Wrong size on BGUFunctionLibCollisionChannel_ConvertToTraceType");
static_assert(offsetof(BGUFunctionLibCollisionChannel_ConvertToTraceType, CollisionChannel) == 0x000000, "Member 'BGUFunctionLibCollisionChannel_ConvertToTraceType::CollisionChannel' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_ConvertToTraceType, ReturnValue) == 0x000001, "Member 'BGUFunctionLibCollisionChannel_ConvertToTraceType::ReturnValue' has a wrong offset!");

// Function b1.BGUFunctionLibCollisionChannel.GetCollisionProfileData
// 0x0070 (0x0070 - 0x0000)
struct BGUFunctionLibCollisionChannel_GetCollisionProfileData final
{
public:
	const class UPrimitiveComponent*              Comp;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             OutCollisionEnabled;                               // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             OutObjectType;                                     // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECollisionChannel, ECollisionResponse>   OutResponseToChannels;                             // 0x0018(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUFunctionLibCollisionChannel_GetCollisionProfileData) == 0x000008, "Wrong alignment on BGUFunctionLibCollisionChannel_GetCollisionProfileData");
static_assert(sizeof(BGUFunctionLibCollisionChannel_GetCollisionProfileData) == 0x000070, "Wrong size on BGUFunctionLibCollisionChannel_GetCollisionProfileData");
static_assert(offsetof(BGUFunctionLibCollisionChannel_GetCollisionProfileData, Comp) == 0x000000, "Member 'BGUFunctionLibCollisionChannel_GetCollisionProfileData::Comp' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_GetCollisionProfileData, ProfileName) == 0x000008, "Member 'BGUFunctionLibCollisionChannel_GetCollisionProfileData::ProfileName' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_GetCollisionProfileData, OutCollisionEnabled) == 0x000010, "Member 'BGUFunctionLibCollisionChannel_GetCollisionProfileData::OutCollisionEnabled' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_GetCollisionProfileData, OutObjectType) == 0x000011, "Member 'BGUFunctionLibCollisionChannel_GetCollisionProfileData::OutObjectType' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_GetCollisionProfileData, OutResponseToChannels) == 0x000018, "Member 'BGUFunctionLibCollisionChannel_GetCollisionProfileData::OutResponseToChannels' has a wrong offset!");
static_assert(offsetof(BGUFunctionLibCollisionChannel_GetCollisionProfileData, ReturnValue) == 0x000068, "Member 'BGUFunctionLibCollisionChannel_GetCollisionProfileData::ReturnValue' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_BTDecoratorCheckCondition
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_BTDecoratorCheckCondition final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_BTDecoratorCheckCondition) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_BTDecoratorCheckCondition");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_BTDecoratorCheckCondition) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_BTDecoratorCheckCondition");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_BTDecoratorCheckCondition, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_BTDecoratorCheckCondition::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_BTServiceActivation
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_BTServiceActivation final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_BTServiceActivation) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_BTServiceActivation");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_BTServiceActivation) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_BTServiceActivation");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_BTServiceActivation, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_BTServiceActivation::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_BTServiceDeactivation
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_BTServiceDeactivation final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_BTServiceDeactivation) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_BTServiceDeactivation");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_BTServiceDeactivation) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_BTServiceDeactivation");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_BTServiceDeactivation, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_BTServiceDeactivation::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_BTServiceSearchStart
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_BTServiceSearchStart final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_BTServiceSearchStart) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_BTServiceSearchStart");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_BTServiceSearchStart) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_BTServiceSearchStart");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_BTServiceSearchStart, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_BTServiceSearchStart::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_BTServiceTick
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_BTServiceTick final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_BTServiceTick) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_BTServiceTick");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_BTServiceTick) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_BTServiceTick");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_BTServiceTick, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_BTServiceTick::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_BTTaskAbort
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_BTTaskAbort final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_BTTaskAbort) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_BTTaskAbort");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_BTTaskAbort) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_BTTaskAbort");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_BTTaskAbort, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_BTTaskAbort::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_BTTaskExecute
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_BTTaskExecute final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_BTTaskExecute) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_BTTaskExecute");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_BTTaskExecute) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_BTTaskExecute");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_BTTaskExecute, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_BTTaskExecute::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_BTTaskTick
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_BTTaskTick final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_BTTaskTick) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_BTTaskTick");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_BTTaskTick) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_BTTaskTick");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_BTTaskTick, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_BTTaskTick::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_ResetProperty
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_ResetProperty final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_ResetProperty) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_ResetProperty");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_ResetProperty) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_ResetProperty");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_ResetProperty, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_ResetProperty::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_SetCollisionResponseProperty
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_SetCollisionResponseProperty final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_SetCollisionResponseProperty) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_SetCollisionResponseProperty");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_SetCollisionResponseProperty) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_SetCollisionResponseProperty");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_SetCollisionResponseProperty, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_SetCollisionResponseProperty::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_SetEnumProperty
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_SetEnumProperty final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_SetEnumProperty) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_SetEnumProperty");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_SetEnumProperty) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_SetEnumProperty");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_SetEnumProperty, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_SetEnumProperty::FuncPtr' has a wrong offset!");

// Function b1.BGUFuncLibCSDelegateRegister.Register_SetFloatProperty
// 0x0008 (0x0008 - 0x0000)
struct BGUFuncLibCSDelegateRegister_Register_SetFloatProperty final
{
public:
	struct FIntPtr                                FuncPtr;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUFuncLibCSDelegateRegister_Register_SetFloatProperty) == 0x000004, "Wrong alignment on BGUFuncLibCSDelegateRegister_Register_SetFloatProperty");
static_assert(sizeof(BGUFuncLibCSDelegateRegister_Register_SetFloatProperty) == 0x000008, "Wrong size on BGUFuncLibCSDelegateRegister_Register_SetFloatProperty");
static_assert(offsetof(BGUFuncLibCSDelegateRegister_Register_SetFloatProperty, FuncPtr) == 0x000000, "Member 'BGUFuncLibCSDelegateRegister_Register_SetFloatProperty::FuncPtr' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.CacheWorldCompositionLevelNames
// 0x0008 (0x0008 - 0x0000)
struct BGUWCStreamingFuncLib_CacheWorldCompositionLevelNames final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_CacheWorldCompositionLevelNames) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_CacheWorldCompositionLevelNames");
static_assert(sizeof(BGUWCStreamingFuncLib_CacheWorldCompositionLevelNames) == 0x000008, "Wrong size on BGUWCStreamingFuncLib_CacheWorldCompositionLevelNames");
static_assert(offsetof(BGUWCStreamingFuncLib_CacheWorldCompositionLevelNames, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_CacheWorldCompositionLevelNames::InWorldContext' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.CacheWorldCompositionStreamingLayers
// 0x0008 (0x0008 - 0x0000)
struct BGUWCStreamingFuncLib_CacheWorldCompositionStreamingLayers final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_CacheWorldCompositionStreamingLayers) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_CacheWorldCompositionStreamingLayers");
static_assert(sizeof(BGUWCStreamingFuncLib_CacheWorldCompositionStreamingLayers) == 0x000008, "Wrong size on BGUWCStreamingFuncLib_CacheWorldCompositionStreamingLayers");
static_assert(offsetof(BGUWCStreamingFuncLib_CacheWorldCompositionStreamingLayers, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_CacheWorldCompositionStreamingLayers::InWorldContext' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.CheckLevelState
// 0x0018 (0x0018 - 0x0000)
struct BGUWCStreamingFuncLib_CheckLevelState final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTargetLevelName;                                 // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_CheckLevelState) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_CheckLevelState");
static_assert(sizeof(BGUWCStreamingFuncLib_CheckLevelState) == 0x000018, "Wrong size on BGUWCStreamingFuncLib_CheckLevelState");
static_assert(offsetof(BGUWCStreamingFuncLib_CheckLevelState, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_CheckLevelState::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_CheckLevelState, InTargetLevelName) == 0x000008, "Member 'BGUWCStreamingFuncLib_CheckLevelState::InTargetLevelName' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.DestroyGSWCWorldStreamingSources
// 0x0008 (0x0008 - 0x0000)
struct BGUWCStreamingFuncLib_DestroyGSWCWorldStreamingSources final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_DestroyGSWCWorldStreamingSources) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_DestroyGSWCWorldStreamingSources");
static_assert(sizeof(BGUWCStreamingFuncLib_DestroyGSWCWorldStreamingSources) == 0x000008, "Wrong size on BGUWCStreamingFuncLib_DestroyGSWCWorldStreamingSources");
static_assert(offsetof(BGUWCStreamingFuncLib_DestroyGSWCWorldStreamingSources, WorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_DestroyGSWCWorldStreamingSources::WorldContext' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.DisableStreamingSource
// 0x0008 (0x0008 - 0x0000)
struct BGUWCStreamingFuncLib_DisableStreamingSource final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_DisableStreamingSource) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_DisableStreamingSource");
static_assert(sizeof(BGUWCStreamingFuncLib_DisableStreamingSource) == 0x000008, "Wrong size on BGUWCStreamingFuncLib_DisableStreamingSource");
static_assert(offsetof(BGUWCStreamingFuncLib_DisableStreamingSource, InActor) == 0x000000, "Member 'BGUWCStreamingFuncLib_DisableStreamingSource::InActor' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.EnableStreamingSource
// 0x0008 (0x0008 - 0x0000)
struct BGUWCStreamingFuncLib_EnableStreamingSource final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_EnableStreamingSource) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_EnableStreamingSource");
static_assert(sizeof(BGUWCStreamingFuncLib_EnableStreamingSource) == 0x000008, "Wrong size on BGUWCStreamingFuncLib_EnableStreamingSource");
static_assert(offsetof(BGUWCStreamingFuncLib_EnableStreamingSource, InActor) == 0x000000, "Member 'BGUWCStreamingFuncLib_EnableStreamingSource::InActor' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.FlushAllLevelState
// 0x0018 (0x0018 - 0x0000)
struct BGUWCStreamingFuncLib_FlushAllLevelState final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         InExcludedLevelKeywords;                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_FlushAllLevelState) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_FlushAllLevelState");
static_assert(sizeof(BGUWCStreamingFuncLib_FlushAllLevelState) == 0x000018, "Wrong size on BGUWCStreamingFuncLib_FlushAllLevelState");
static_assert(offsetof(BGUWCStreamingFuncLib_FlushAllLevelState, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_FlushAllLevelState::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_FlushAllLevelState, InExcludedLevelKeywords) == 0x000008, "Member 'BGUWCStreamingFuncLib_FlushAllLevelState::InExcludedLevelKeywords' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.ForceLoadAllStreamingLevels
// 0x0008 (0x0008 - 0x0000)
struct BGUWCStreamingFuncLib_ForceLoadAllStreamingLevels final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_ForceLoadAllStreamingLevels) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_ForceLoadAllStreamingLevels");
static_assert(sizeof(BGUWCStreamingFuncLib_ForceLoadAllStreamingLevels) == 0x000008, "Wrong size on BGUWCStreamingFuncLib_ForceLoadAllStreamingLevels");
static_assert(offsetof(BGUWCStreamingFuncLib_ForceLoadAllStreamingLevels, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_ForceLoadAllStreamingLevels::InWorldContext' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.GetAllLevelCurrentState
// 0x0060 (0x0060 - 0x0000)
struct BGUWCStreamingFuncLib_GetAllLevelCurrentState final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, uint8>                    OutLevelStreamingList;                             // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          bIgnoreWCTile;                                     // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x005C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_GetAllLevelCurrentState) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_GetAllLevelCurrentState");
static_assert(sizeof(BGUWCStreamingFuncLib_GetAllLevelCurrentState) == 0x000060, "Wrong size on BGUWCStreamingFuncLib_GetAllLevelCurrentState");
static_assert(offsetof(BGUWCStreamingFuncLib_GetAllLevelCurrentState, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_GetAllLevelCurrentState::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetAllLevelCurrentState, OutLevelStreamingList) == 0x000008, "Member 'BGUWCStreamingFuncLib_GetAllLevelCurrentState::OutLevelStreamingList' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetAllLevelCurrentState, bIgnoreWCTile) == 0x000058, "Member 'BGUWCStreamingFuncLib_GetAllLevelCurrentState::bIgnoreWCTile' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetAllLevelCurrentState, ReturnValue) == 0x00005C, "Member 'BGUWCStreamingFuncLib_GetAllLevelCurrentState::ReturnValue' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.GetLevelCurrentStateAndIsConsideredUpdate
// 0x00B8 (0x00B8 - 0x0000)
struct BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LevelNames;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<class FString, uint8>                    OutLevelStreamingList;                             // 0x0018(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TSet<class FString>                           OutCosideredUpdateSet;                             // 0x0068(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate");
static_assert(sizeof(BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate) == 0x0000B8, "Wrong size on BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate, LevelNames) == 0x000008, "Member 'BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate::LevelNames' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate, OutLevelStreamingList) == 0x000018, "Member 'BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate::OutLevelStreamingList' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate, OutCosideredUpdateSet) == 0x000068, "Member 'BGUWCStreamingFuncLib_GetLevelCurrentStateAndIsConsideredUpdate::OutCosideredUpdateSet' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.GetLevelNames
// 0x0020 (0x0020 - 0x0000)
struct BGUWCStreamingFuncLib_GetLevelNames final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutLevelNames;                                     // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUWCStreamingFuncLib_GetLevelNames) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_GetLevelNames");
static_assert(sizeof(BGUWCStreamingFuncLib_GetLevelNames) == 0x000020, "Wrong size on BGUWCStreamingFuncLib_GetLevelNames");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelNames, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_GetLevelNames::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelNames, OutLevelNames) == 0x000008, "Member 'BGUWCStreamingFuncLib_GetLevelNames::OutLevelNames' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelNames, ReturnValue) == 0x000018, "Member 'BGUWCStreamingFuncLib_GetLevelNames::ReturnValue' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.GetLevelNamesByKeyword
// 0x0028 (0x0028 - 0x0000)
struct BGUWCStreamingFuncLib_GetLevelNamesByKeyword final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InLevelNameKeyword;                                // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_GetLevelNamesByKeyword) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_GetLevelNamesByKeyword");
static_assert(sizeof(BGUWCStreamingFuncLib_GetLevelNamesByKeyword) == 0x000028, "Wrong size on BGUWCStreamingFuncLib_GetLevelNamesByKeyword");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelNamesByKeyword, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_GetLevelNamesByKeyword::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelNamesByKeyword, InLevelNameKeyword) == 0x000008, "Member 'BGUWCStreamingFuncLib_GetLevelNamesByKeyword::InLevelNameKeyword' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetLevelNamesByKeyword, ReturnValue) == 0x000018, "Member 'BGUWCStreamingFuncLib_GetLevelNamesByKeyword::ReturnValue' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.GetProcessingStreamingLevelNum
// 0x0010 (0x0010 - 0x0000)
struct BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum");
static_assert(sizeof(BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum) == 0x000010, "Wrong size on BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum");
static_assert(offsetof(BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum, ReturnValue) == 0x000008, "Member 'BGUWCStreamingFuncLib_GetProcessingStreamingLevelNum::ReturnValue' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.IsLevelStreamable
// 0x0020 (0x0020 - 0x0000)
struct BGUWCStreamingFuncLib_IsLevelStreamable final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTargetLevelName;                                 // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUWCStreamingFuncLib_IsLevelStreamable) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_IsLevelStreamable");
static_assert(sizeof(BGUWCStreamingFuncLib_IsLevelStreamable) == 0x000020, "Wrong size on BGUWCStreamingFuncLib_IsLevelStreamable");
static_assert(offsetof(BGUWCStreamingFuncLib_IsLevelStreamable, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_IsLevelStreamable::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_IsLevelStreamable, InTargetLevelName) == 0x000008, "Member 'BGUWCStreamingFuncLib_IsLevelStreamable::InTargetLevelName' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_IsLevelStreamable, ReturnValue) == 0x000018, "Member 'BGUWCStreamingFuncLib_IsLevelStreamable::ReturnValue' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.ModifyStreamingDistanceScaleByStreamingLayer
// 0x0028 (0x0028 - 0x0000)
struct BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTargetLayerName;                                 // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InTargetLODIndex;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTargetScaleFactor;                               // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockTillStreamingCompleted;                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer");
static_assert(sizeof(BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer) == 0x000028, "Wrong size on BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer");
static_assert(offsetof(BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer, InTargetLayerName) == 0x000008, "Member 'BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer::InTargetLayerName' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer, InTargetLODIndex) == 0x000018, "Member 'BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer::InTargetLODIndex' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer, InTargetScaleFactor) == 0x00001C, "Member 'BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer::InTargetScaleFactor' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer, bBlockTillStreamingCompleted) == 0x000020, "Member 'BGUWCStreamingFuncLib_ModifyStreamingDistanceScaleByStreamingLayer::bBlockTillStreamingCompleted' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.PauseDistanceStreaming
// 0x0018 (0x0018 - 0x0000)
struct BGUWCStreamingFuncLib_PauseDistanceStreaming final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         InExcludedLevelKeywords;                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_PauseDistanceStreaming) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_PauseDistanceStreaming");
static_assert(sizeof(BGUWCStreamingFuncLib_PauseDistanceStreaming) == 0x000018, "Wrong size on BGUWCStreamingFuncLib_PauseDistanceStreaming");
static_assert(offsetof(BGUWCStreamingFuncLib_PauseDistanceStreaming, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_PauseDistanceStreaming::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_PauseDistanceStreaming, InExcludedLevelKeywords) == 0x000008, "Member 'BGUWCStreamingFuncLib_PauseDistanceStreaming::InExcludedLevelKeywords' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.QueryProcessingStreamingLevels
// 0x0058 (0x0058 - 0x0000)
struct BGUWCStreamingFuncLib_QueryProcessingStreamingLevels final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            ReturnValue;                                       // 0x0008(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_QueryProcessingStreamingLevels) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_QueryProcessingStreamingLevels");
static_assert(sizeof(BGUWCStreamingFuncLib_QueryProcessingStreamingLevels) == 0x000058, "Wrong size on BGUWCStreamingFuncLib_QueryProcessingStreamingLevels");
static_assert(offsetof(BGUWCStreamingFuncLib_QueryProcessingStreamingLevels, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_QueryProcessingStreamingLevels::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_QueryProcessingStreamingLevels, ReturnValue) == 0x000008, "Member 'BGUWCStreamingFuncLib_QueryProcessingStreamingLevels::ReturnValue' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.RegisterAsStreamingSource
// 0x0008 (0x0008 - 0x0000)
struct BGUWCStreamingFuncLib_RegisterAsStreamingSource final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_RegisterAsStreamingSource) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_RegisterAsStreamingSource");
static_assert(sizeof(BGUWCStreamingFuncLib_RegisterAsStreamingSource) == 0x000008, "Wrong size on BGUWCStreamingFuncLib_RegisterAsStreamingSource");
static_assert(offsetof(BGUWCStreamingFuncLib_RegisterAsStreamingSource, InActor) == 0x000000, "Member 'BGUWCStreamingFuncLib_RegisterAsStreamingSource::InActor' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.SetLevelsState
// 0x0038 (0x0038 - 0x0000)
struct BGUWCStreamingFuncLib_SetLevelsState final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTargetLevelNameOrKeyword;                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSLevelState                                 InTargetState;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InOperationID;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeywordMatch;                                     // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockOnLoad;                                      // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGSSetLevelStateFailedInfo>     ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_SetLevelsState) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_SetLevelsState");
static_assert(sizeof(BGUWCStreamingFuncLib_SetLevelsState) == 0x000038, "Wrong size on BGUWCStreamingFuncLib_SetLevelsState");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsState, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_SetLevelsState::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsState, InTargetLevelNameOrKeyword) == 0x000008, "Member 'BGUWCStreamingFuncLib_SetLevelsState::InTargetLevelNameOrKeyword' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsState, InTargetState) == 0x000018, "Member 'BGUWCStreamingFuncLib_SetLevelsState::InTargetState' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsState, InOperationID) == 0x00001C, "Member 'BGUWCStreamingFuncLib_SetLevelsState::InOperationID' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsState, bKeywordMatch) == 0x000020, "Member 'BGUWCStreamingFuncLib_SetLevelsState::bKeywordMatch' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsState, bBlockOnLoad) == 0x000021, "Member 'BGUWCStreamingFuncLib_SetLevelsState::bBlockOnLoad' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsState, ReturnValue) == 0x000028, "Member 'BGUWCStreamingFuncLib_SetLevelsState::ReturnValue' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.SetLevelsStateByNames
// 0x0038 (0x0038 - 0x0000)
struct BGUWCStreamingFuncLib_SetLevelsStateByNames final
{
public:
	class UObject*                                InWorldContext;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         InTargetLevelNames;                                // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EGSLevelState                                 InTargetState;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InOperationID;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockOnLoad;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGSSetLevelStateFailedInfo>     ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_SetLevelsStateByNames) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_SetLevelsStateByNames");
static_assert(sizeof(BGUWCStreamingFuncLib_SetLevelsStateByNames) == 0x000038, "Wrong size on BGUWCStreamingFuncLib_SetLevelsStateByNames");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsStateByNames, InWorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_SetLevelsStateByNames::InWorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsStateByNames, InTargetLevelNames) == 0x000008, "Member 'BGUWCStreamingFuncLib_SetLevelsStateByNames::InTargetLevelNames' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsStateByNames, InTargetState) == 0x000018, "Member 'BGUWCStreamingFuncLib_SetLevelsStateByNames::InTargetState' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsStateByNames, InOperationID) == 0x00001C, "Member 'BGUWCStreamingFuncLib_SetLevelsStateByNames::InOperationID' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsStateByNames, bBlockOnLoad) == 0x000020, "Member 'BGUWCStreamingFuncLib_SetLevelsStateByNames::bBlockOnLoad' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetLevelsStateByNames, ReturnValue) == 0x000028, "Member 'BGUWCStreamingFuncLib_SetLevelsStateByNames::ReturnValue' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.SetStreamingManagerViewSource
// 0x0020 (0x0020 - 0x0000)
struct BGUWCStreamingFuncLib_SetStreamingManagerViewSource final
{
public:
	struct FVector                                ViewLocation;                                      // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUWCStreamingFuncLib_SetStreamingManagerViewSource) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_SetStreamingManagerViewSource");
static_assert(sizeof(BGUWCStreamingFuncLib_SetStreamingManagerViewSource) == 0x000020, "Wrong size on BGUWCStreamingFuncLib_SetStreamingManagerViewSource");
static_assert(offsetof(BGUWCStreamingFuncLib_SetStreamingManagerViewSource, ViewLocation) == 0x000000, "Member 'BGUWCStreamingFuncLib_SetStreamingManagerViewSource::ViewLocation' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SetStreamingManagerViewSource, Duration) == 0x000018, "Member 'BGUWCStreamingFuncLib_SetStreamingManagerViewSource::Duration' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.SpawnStreamingSource
// 0x0020 (0x0020 - 0x0000)
struct BGUWCStreamingFuncLib_SpawnStreamingSource final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_SpawnStreamingSource) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_SpawnStreamingSource");
static_assert(sizeof(BGUWCStreamingFuncLib_SpawnStreamingSource) == 0x000020, "Wrong size on BGUWCStreamingFuncLib_SpawnStreamingSource");
static_assert(offsetof(BGUWCStreamingFuncLib_SpawnStreamingSource, WorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_SpawnStreamingSource::WorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_SpawnStreamingSource, SpawnLocation) == 0x000008, "Member 'BGUWCStreamingFuncLib_SpawnStreamingSource::SpawnLocation' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.UnregisterFromStreamingSource
// 0x0008 (0x0008 - 0x0000)
struct BGUWCStreamingFuncLib_UnregisterFromStreamingSource final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUWCStreamingFuncLib_UnregisterFromStreamingSource) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_UnregisterFromStreamingSource");
static_assert(sizeof(BGUWCStreamingFuncLib_UnregisterFromStreamingSource) == 0x000008, "Wrong size on BGUWCStreamingFuncLib_UnregisterFromStreamingSource");
static_assert(offsetof(BGUWCStreamingFuncLib_UnregisterFromStreamingSource, InActor) == 0x000000, "Member 'BGUWCStreamingFuncLib_UnregisterFromStreamingSource::InActor' has a wrong offset!");

// Function b1.BGUWCStreamingFuncLib.UpdateStreamingState
// 0x0010 (0x0010 - 0x0000)
struct BGUWCStreamingFuncLib_UpdateStreamingState final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockTillComplete;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUWCStreamingFuncLib_UpdateStreamingState) == 0x000008, "Wrong alignment on BGUWCStreamingFuncLib_UpdateStreamingState");
static_assert(sizeof(BGUWCStreamingFuncLib_UpdateStreamingState) == 0x000010, "Wrong size on BGUWCStreamingFuncLib_UpdateStreamingState");
static_assert(offsetof(BGUWCStreamingFuncLib_UpdateStreamingState, WorldContext) == 0x000000, "Member 'BGUWCStreamingFuncLib_UpdateStreamingState::WorldContext' has a wrong offset!");
static_assert(offsetof(BGUWCStreamingFuncLib_UpdateStreamingState, bBlockTillComplete) == 0x000008, "Member 'BGUWCStreamingFuncLib_UpdateStreamingState::bBlockTillComplete' has a wrong offset!");

// Function b1.BGULocalFluid2DComponent.GetPressureDivergenceTexture
// 0x0008 (0x0008 - 0x0000)
struct BGULocalFluid2DComponent_GetPressureDivergenceTexture final
{
public:
	class UTextureRenderTarget2D*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGULocalFluid2DComponent_GetPressureDivergenceTexture) == 0x000008, "Wrong alignment on BGULocalFluid2DComponent_GetPressureDivergenceTexture");
static_assert(sizeof(BGULocalFluid2DComponent_GetPressureDivergenceTexture) == 0x000008, "Wrong size on BGULocalFluid2DComponent_GetPressureDivergenceTexture");
static_assert(offsetof(BGULocalFluid2DComponent_GetPressureDivergenceTexture, ReturnValue) == 0x000000, "Member 'BGULocalFluid2DComponent_GetPressureDivergenceTexture::ReturnValue' has a wrong offset!");

// Function b1.BGULocalFluid2DComponent.GetVeloDensityTexture
// 0x0008 (0x0008 - 0x0000)
struct BGULocalFluid2DComponent_GetVeloDensityTexture final
{
public:
	class UTextureRenderTarget2D*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGULocalFluid2DComponent_GetVeloDensityTexture) == 0x000008, "Wrong alignment on BGULocalFluid2DComponent_GetVeloDensityTexture");
static_assert(sizeof(BGULocalFluid2DComponent_GetVeloDensityTexture) == 0x000008, "Wrong size on BGULocalFluid2DComponent_GetVeloDensityTexture");
static_assert(offsetof(BGULocalFluid2DComponent_GetVeloDensityTexture, ReturnValue) == 0x000000, "Member 'BGULocalFluid2DComponent_GetVeloDensityTexture::ReturnValue' has a wrong offset!");

// Function b1.BGUPerformerActor.SetOptimizeEnabled
// 0x0001 (0x0001 - 0x0000)
struct BGUPerformerActor_SetOptimizeEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUPerformerActor_SetOptimizeEnabled) == 0x000001, "Wrong alignment on BGUPerformerActor_SetOptimizeEnabled");
static_assert(sizeof(BGUPerformerActor_SetOptimizeEnabled) == 0x000001, "Wrong size on BGUPerformerActor_SetOptimizeEnabled");
static_assert(offsetof(BGUPerformerActor_SetOptimizeEnabled, bEnable) == 0x000000, "Member 'BGUPerformerActor_SetOptimizeEnabled::bEnable' has a wrong offset!");

// Function b1.BGUPlacedEditorUtilityBase.GetActorReference
// 0x0018 (0x0018 - 0x0000)
struct BGUPlacedEditorUtilityBase_GetActorReference final
{
public:
	class FString                                 PathToActor;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUPlacedEditorUtilityBase_GetActorReference) == 0x000008, "Wrong alignment on BGUPlacedEditorUtilityBase_GetActorReference");
static_assert(sizeof(BGUPlacedEditorUtilityBase_GetActorReference) == 0x000018, "Wrong size on BGUPlacedEditorUtilityBase_GetActorReference");
static_assert(offsetof(BGUPlacedEditorUtilityBase_GetActorReference, PathToActor) == 0x000000, "Member 'BGUPlacedEditorUtilityBase_GetActorReference::PathToActor' has a wrong offset!");
static_assert(offsetof(BGUPlacedEditorUtilityBase_GetActorReference, ReturnValue) == 0x000010, "Member 'BGUPlacedEditorUtilityBase_GetActorReference::ReturnValue' has a wrong offset!");

// Function b1.BGUPlacedEditorUtilityBase.GetLevelViewportCameraInfo
// 0x0038 (0x0038 - 0x0000)
struct BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo final
{
public:
	struct FVector                                CameraLocation;                                    // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation;                                    // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo) == 0x000008, "Wrong alignment on BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo");
static_assert(sizeof(BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo) == 0x000038, "Wrong size on BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo");
static_assert(offsetof(BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo, CameraLocation) == 0x000000, "Member 'BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo::CameraLocation' has a wrong offset!");
static_assert(offsetof(BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo, CameraRotation) == 0x000018, "Member 'BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo::CameraRotation' has a wrong offset!");
static_assert(offsetof(BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo, ReturnValue) == 0x000030, "Member 'BGUPlacedEditorUtilityBase_GetLevelViewportCameraInfo::ReturnValue' has a wrong offset!");

// Function b1.BGUPlacedEditorUtilityBase.GetSelectionSet
// 0x0010 (0x0010 - 0x0000)
struct BGUPlacedEditorUtilityBase_GetSelectionSet final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUPlacedEditorUtilityBase_GetSelectionSet) == 0x000008, "Wrong alignment on BGUPlacedEditorUtilityBase_GetSelectionSet");
static_assert(sizeof(BGUPlacedEditorUtilityBase_GetSelectionSet) == 0x000010, "Wrong size on BGUPlacedEditorUtilityBase_GetSelectionSet");
static_assert(offsetof(BGUPlacedEditorUtilityBase_GetSelectionSet, ReturnValue) == 0x000000, "Member 'BGUPlacedEditorUtilityBase_GetSelectionSet::ReturnValue' has a wrong offset!");

// Function b1.BGUPlacedEditorUtilityBase.OnWorldCleanup
// 0x0010 (0x0010 - 0x0000)
struct BGUPlacedEditorUtilityBase_OnWorldCleanup final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SessionEnded;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CleanupResources;                                  // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUPlacedEditorUtilityBase_OnWorldCleanup) == 0x000008, "Wrong alignment on BGUPlacedEditorUtilityBase_OnWorldCleanup");
static_assert(sizeof(BGUPlacedEditorUtilityBase_OnWorldCleanup) == 0x000010, "Wrong size on BGUPlacedEditorUtilityBase_OnWorldCleanup");
static_assert(offsetof(BGUPlacedEditorUtilityBase_OnWorldCleanup, World) == 0x000000, "Member 'BGUPlacedEditorUtilityBase_OnWorldCleanup::World' has a wrong offset!");
static_assert(offsetof(BGUPlacedEditorUtilityBase_OnWorldCleanup, SessionEnded) == 0x000008, "Member 'BGUPlacedEditorUtilityBase_OnWorldCleanup::SessionEnded' has a wrong offset!");
static_assert(offsetof(BGUPlacedEditorUtilityBase_OnWorldCleanup, CleanupResources) == 0x000009, "Member 'BGUPlacedEditorUtilityBase_OnWorldCleanup::CleanupResources' has a wrong offset!");

// Function b1.BGUPlacedEditorUtilityBase.SetActorSelectionState
// 0x0010 (0x0010 - 0x0000)
struct BGUPlacedEditorUtilityBase_SetActorSelectionState final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBeSelected;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUPlacedEditorUtilityBase_SetActorSelectionState) == 0x000008, "Wrong alignment on BGUPlacedEditorUtilityBase_SetActorSelectionState");
static_assert(sizeof(BGUPlacedEditorUtilityBase_SetActorSelectionState) == 0x000010, "Wrong size on BGUPlacedEditorUtilityBase_SetActorSelectionState");
static_assert(offsetof(BGUPlacedEditorUtilityBase_SetActorSelectionState, Actor) == 0x000000, "Member 'BGUPlacedEditorUtilityBase_SetActorSelectionState::Actor' has a wrong offset!");
static_assert(offsetof(BGUPlacedEditorUtilityBase_SetActorSelectionState, bShouldBeSelected) == 0x000008, "Member 'BGUPlacedEditorUtilityBase_SetActorSelectionState::bShouldBeSelected' has a wrong offset!");

// Function b1.BGUPlacedEditorUtilityBase.SetLevelViewportCameraInfo
// 0x0030 (0x0030 - 0x0000)
struct BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo final
{
public:
	struct FVector                                CameraLocation;                                    // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation;                                    // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo) == 0x000008, "Wrong alignment on BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo");
static_assert(sizeof(BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo) == 0x000030, "Wrong size on BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo");
static_assert(offsetof(BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo, CameraLocation) == 0x000000, "Member 'BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo::CameraLocation' has a wrong offset!");
static_assert(offsetof(BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo, CameraRotation) == 0x000018, "Member 'BGUPlacedEditorUtilityBase_SetLevelViewportCameraInfo::CameraRotation' has a wrong offset!");

// Function b1.BGUPlayMontageCallbackProxy.CreateProxyObjectForPlayMontage
// 0x0018 (0x0018 - 0x0000)
struct BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage final
{
public:
	int32                                         ReqIdx;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageToPlay;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGUPlayMontageCallbackProxy*           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage) == 0x000008, "Wrong alignment on BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage");
static_assert(sizeof(BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage) == 0x000018, "Wrong size on BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage");
static_assert(offsetof(BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage, ReqIdx) == 0x000000, "Member 'BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage::ReqIdx' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage, MontageToPlay) == 0x000008, "Member 'BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage::MontageToPlay' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage, ReturnValue) == 0x000010, "Member 'BGUPlayMontageCallbackProxy_CreateProxyObjectForPlayMontage::ReturnValue' has a wrong offset!");

// Function b1.BGUPlayMontageCallbackProxy.OnMontageBlendingOut
// 0x0010 (0x0010 - 0x0000)
struct BGUPlayMontageCallbackProxy_OnMontageBlendingOut final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUPlayMontageCallbackProxy_OnMontageBlendingOut) == 0x000008, "Wrong alignment on BGUPlayMontageCallbackProxy_OnMontageBlendingOut");
static_assert(sizeof(BGUPlayMontageCallbackProxy_OnMontageBlendingOut) == 0x000010, "Wrong size on BGUPlayMontageCallbackProxy_OnMontageBlendingOut");
static_assert(offsetof(BGUPlayMontageCallbackProxy_OnMontageBlendingOut, Montage) == 0x000000, "Member 'BGUPlayMontageCallbackProxy_OnMontageBlendingOut::Montage' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_OnMontageBlendingOut, bInterrupted) == 0x000008, "Member 'BGUPlayMontageCallbackProxy_OnMontageBlendingOut::bInterrupted' has a wrong offset!");

// Function b1.BGUPlayMontageCallbackProxy.OnMontageEnded
// 0x0010 (0x0010 - 0x0000)
struct BGUPlayMontageCallbackProxy_OnMontageEnded final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupted;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUPlayMontageCallbackProxy_OnMontageEnded) == 0x000008, "Wrong alignment on BGUPlayMontageCallbackProxy_OnMontageEnded");
static_assert(sizeof(BGUPlayMontageCallbackProxy_OnMontageEnded) == 0x000010, "Wrong size on BGUPlayMontageCallbackProxy_OnMontageEnded");
static_assert(offsetof(BGUPlayMontageCallbackProxy_OnMontageEnded, Montage) == 0x000000, "Member 'BGUPlayMontageCallbackProxy_OnMontageEnded::Montage' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_OnMontageEnded, bInterrupted) == 0x000008, "Member 'BGUPlayMontageCallbackProxy_OnMontageEnded::bInterrupted' has a wrong offset!");

// Function b1.BGUPlayMontageCallbackProxy.OnNotifyBeginReceived
// 0x0028 (0x0028 - 0x0000)
struct BGUPlayMontageCallbackProxy_OnNotifyBeginReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUPlayMontageCallbackProxy_OnNotifyBeginReceived) == 0x000008, "Wrong alignment on BGUPlayMontageCallbackProxy_OnNotifyBeginReceived");
static_assert(sizeof(BGUPlayMontageCallbackProxy_OnNotifyBeginReceived) == 0x000028, "Wrong size on BGUPlayMontageCallbackProxy_OnNotifyBeginReceived");
static_assert(offsetof(BGUPlayMontageCallbackProxy_OnNotifyBeginReceived, NotifyName) == 0x000000, "Member 'BGUPlayMontageCallbackProxy_OnNotifyBeginReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_OnNotifyBeginReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'BGUPlayMontageCallbackProxy_OnNotifyBeginReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function b1.BGUPlayMontageCallbackProxy.OnNotifyEndReceived
// 0x0028 (0x0028 - 0x0000)
struct BGUPlayMontageCallbackProxy_OnNotifyEndReceived final
{
public:
	class FName                                   NotifyName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBranchingPointNotifyPayload           BranchingPointNotifyPayload;                       // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUPlayMontageCallbackProxy_OnNotifyEndReceived) == 0x000008, "Wrong alignment on BGUPlayMontageCallbackProxy_OnNotifyEndReceived");
static_assert(sizeof(BGUPlayMontageCallbackProxy_OnNotifyEndReceived) == 0x000028, "Wrong size on BGUPlayMontageCallbackProxy_OnNotifyEndReceived");
static_assert(offsetof(BGUPlayMontageCallbackProxy_OnNotifyEndReceived, NotifyName) == 0x000000, "Member 'BGUPlayMontageCallbackProxy_OnNotifyEndReceived::NotifyName' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_OnNotifyEndReceived, BranchingPointNotifyPayload) == 0x000008, "Member 'BGUPlayMontageCallbackProxy_OnNotifyEndReceived::BranchingPointNotifyPayload' has a wrong offset!");

// Function b1.BGUPlayMontageCallbackProxy.PlayMontage
// 0x0030 (0x0030 - 0x0000)
struct BGUPlayMontageCallbackProxy_PlayMontage final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingPosition;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapShot;                                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartingSection;                                   // 0x001C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExceptAdditiveSlot;                                // 0x0024(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUPlayMontageCallbackProxy_PlayMontage) == 0x000008, "Wrong alignment on BGUPlayMontageCallbackProxy_PlayMontage");
static_assert(sizeof(BGUPlayMontageCallbackProxy_PlayMontage) == 0x000030, "Wrong size on BGUPlayMontageCallbackProxy_PlayMontage");
static_assert(offsetof(BGUPlayMontageCallbackProxy_PlayMontage, InSkeletalMeshComponent) == 0x000000, "Member 'BGUPlayMontageCallbackProxy_PlayMontage::InSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_PlayMontage, MontageToPlay) == 0x000008, "Member 'BGUPlayMontageCallbackProxy_PlayMontage::MontageToPlay' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_PlayMontage, PlayRate) == 0x000010, "Member 'BGUPlayMontageCallbackProxy_PlayMontage::PlayRate' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_PlayMontage, StartingPosition) == 0x000014, "Member 'BGUPlayMontageCallbackProxy_PlayMontage::StartingPosition' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_PlayMontage, bSnapShot) == 0x000018, "Member 'BGUPlayMontageCallbackProxy_PlayMontage::bSnapShot' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_PlayMontage, StartingSection) == 0x00001C, "Member 'BGUPlayMontageCallbackProxy_PlayMontage::StartingSection' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_PlayMontage, ExceptAdditiveSlot) == 0x000024, "Member 'BGUPlayMontageCallbackProxy_PlayMontage::ExceptAdditiveSlot' has a wrong offset!");
static_assert(offsetof(BGUPlayMontageCallbackProxy_PlayMontage, ReturnValue) == 0x00002C, "Member 'BGUPlayMontageCallbackProxy_PlayMontage::ReturnValue' has a wrong offset!");

// Function b1.BGURootMotionFollowMovementComponent.GetMasterMoveComp
// 0x0008 (0x0008 - 0x0000)
struct BGURootMotionFollowMovementComponent_GetMasterMoveComp final
{
public:
	class UBGUCharacterMovementComponent*         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGURootMotionFollowMovementComponent_GetMasterMoveComp) == 0x000008, "Wrong alignment on BGURootMotionFollowMovementComponent_GetMasterMoveComp");
static_assert(sizeof(BGURootMotionFollowMovementComponent_GetMasterMoveComp) == 0x000008, "Wrong size on BGURootMotionFollowMovementComponent_GetMasterMoveComp");
static_assert(offsetof(BGURootMotionFollowMovementComponent_GetMasterMoveComp, ReturnValue) == 0x000000, "Member 'BGURootMotionFollowMovementComponent_GetMasterMoveComp::ReturnValue' has a wrong offset!");

// Function b1.BGURootMotionSourceObject_Base.Init
// 0x0010 (0x0010 - 0x0000)
struct BGURootMotionSourceObject_Base_Init final
{
public:
	class UCharacterMovementComponent*            MoveComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InInstanceName;                                    // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGURootMotionSourceObject_Base_Init) == 0x000008, "Wrong alignment on BGURootMotionSourceObject_Base_Init");
static_assert(sizeof(BGURootMotionSourceObject_Base_Init) == 0x000010, "Wrong size on BGURootMotionSourceObject_Base_Init");
static_assert(offsetof(BGURootMotionSourceObject_Base_Init, MoveComp) == 0x000000, "Member 'BGURootMotionSourceObject_Base_Init::MoveComp' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_Base_Init, InInstanceName) == 0x000008, "Member 'BGURootMotionSourceObject_Base_Init::InInstanceName' has a wrong offset!");

// Function b1.BGURootMotionSourceObject_ConstantForce.ApplyRootMotionSource
// 0x0058 (0x0058 - 0x0000)
struct BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource final
{
public:
	struct FVector                                WorldDirection;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdditive;                                       // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionFinishVelocityMode                 FinishVelocityMode;                                // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FinishSetVelocity;                                 // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishClampVelocity;                               // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGravity;                                    // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0055(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource) == 0x000008, "Wrong alignment on BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource");
static_assert(sizeof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource) == 0x000058, "Wrong size on BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, WorldDirection) == 0x000000, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::WorldDirection' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, Strength) == 0x000018, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::Strength' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, Duration) == 0x00001C, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::Duration' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, bIsAdditive) == 0x000020, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::bIsAdditive' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, StrengthOverTime) == 0x000028, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::StrengthOverTime' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, FinishVelocityMode) == 0x000030, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::FinishVelocityMode' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, FinishSetVelocity) == 0x000038, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::FinishSetVelocity' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, FinishClampVelocity) == 0x000050, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::FinishClampVelocity' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, bEnableGravity) == 0x000054, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::bEnableGravity' has a wrong offset!");
static_assert(offsetof(BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource, ReturnValue) == 0x000055, "Member 'BGURootMotionSourceObject_ConstantForce_ApplyRootMotionSource::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.BoxOverlapBGUCharacters
// 0x0050 (0x0050 - 0x0000)
struct BGUSelectUtil_BoxOverlapBGUCharacters final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxPos;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABGUCharacter*>                  OutArray;                                          // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	ECollisionChannel                             QueryChannel;                                      // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x004C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSelectUtil_BoxOverlapBGUCharacters) == 0x000008, "Wrong alignment on BGUSelectUtil_BoxOverlapBGUCharacters");
static_assert(sizeof(BGUSelectUtil_BoxOverlapBGUCharacters) == 0x000050, "Wrong size on BGUSelectUtil_BoxOverlapBGUCharacters");
static_assert(offsetof(BGUSelectUtil_BoxOverlapBGUCharacters, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_BoxOverlapBGUCharacters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapBGUCharacters, BoxPos) == 0x000008, "Member 'BGUSelectUtil_BoxOverlapBGUCharacters::BoxPos' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapBGUCharacters, BoxExtent) == 0x000020, "Member 'BGUSelectUtil_BoxOverlapBGUCharacters::BoxExtent' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapBGUCharacters, OutArray) == 0x000038, "Member 'BGUSelectUtil_BoxOverlapBGUCharacters::OutArray' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapBGUCharacters, QueryChannel) == 0x000048, "Member 'BGUSelectUtil_BoxOverlapBGUCharacters::QueryChannel' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapBGUCharacters, ReturnValue) == 0x00004C, "Member 'BGUSelectUtil_BoxOverlapBGUCharacters::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.BoxOverlapV2BGUCharacters
// 0x0070 (0x0070 - 0x0000)
struct BGUSelectUtil_BoxOverlapV2BGUCharacters final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxPos;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rot;                                               // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0040(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABGUCharacter*>                  OutArray;                                          // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0068(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_BoxOverlapV2BGUCharacters) == 0x000010, "Wrong alignment on BGUSelectUtil_BoxOverlapV2BGUCharacters");
static_assert(sizeof(BGUSelectUtil_BoxOverlapV2BGUCharacters) == 0x000070, "Wrong size on BGUSelectUtil_BoxOverlapV2BGUCharacters");
static_assert(offsetof(BGUSelectUtil_BoxOverlapV2BGUCharacters, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_BoxOverlapV2BGUCharacters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapV2BGUCharacters, BoxPos) == 0x000008, "Member 'BGUSelectUtil_BoxOverlapV2BGUCharacters::BoxPos' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapV2BGUCharacters, Rot) == 0x000020, "Member 'BGUSelectUtil_BoxOverlapV2BGUCharacters::Rot' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapV2BGUCharacters, BoxExtent) == 0x000040, "Member 'BGUSelectUtil_BoxOverlapV2BGUCharacters::BoxExtent' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapV2BGUCharacters, OutArray) == 0x000058, "Member 'BGUSelectUtil_BoxOverlapV2BGUCharacters::OutArray' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_BoxOverlapV2BGUCharacters, ReturnValue) == 0x000068, "Member 'BGUSelectUtil_BoxOverlapV2BGUCharacters::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.GetHitUnderCursor
// 0x0060 (0x0060 - 0x0000)
struct BGUSelectUtil_GetHitUnderCursor final
{
public:
	class APlayerController*                      PlayerCtrl;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               QueryChnl;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResultSimple                       HitResult;                                         // 0x0010(0x0048)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_GetHitUnderCursor) == 0x000008, "Wrong alignment on BGUSelectUtil_GetHitUnderCursor");
static_assert(sizeof(BGUSelectUtil_GetHitUnderCursor) == 0x000060, "Wrong size on BGUSelectUtil_GetHitUnderCursor");
static_assert(offsetof(BGUSelectUtil_GetHitUnderCursor, PlayerCtrl) == 0x000000, "Member 'BGUSelectUtil_GetHitUnderCursor::PlayerCtrl' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_GetHitUnderCursor, QueryChnl) == 0x000008, "Member 'BGUSelectUtil_GetHitUnderCursor::QueryChnl' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_GetHitUnderCursor, bTraceComplex) == 0x000009, "Member 'BGUSelectUtil_GetHitUnderCursor::bTraceComplex' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_GetHitUnderCursor, HitResult) == 0x000010, "Member 'BGUSelectUtil_GetHitUnderCursor::HitResult' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_GetHitUnderCursor, ReturnValue) == 0x000058, "Member 'BGUSelectUtil_GetHitUnderCursor::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.LineTraceForObjects
// 0x00A0 (0x00A0 - 0x0000)
struct BGUSelectUtil_LineTraceForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTrace;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResultSimple                       HitResult;                                         // 0x0050(0x0048)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0098(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_LineTraceForObjects) == 0x000008, "Wrong alignment on BGUSelectUtil_LineTraceForObjects");
static_assert(sizeof(BGUSelectUtil_LineTraceForObjects) == 0x0000A0, "Wrong size on BGUSelectUtil_LineTraceForObjects");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjects, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_LineTraceForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjects, StartTrace) == 0x000008, "Member 'BGUSelectUtil_LineTraceForObjects::StartTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjects, EndTrace) == 0x000020, "Member 'BGUSelectUtil_LineTraceForObjects::EndTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjects, ObjectTypes) == 0x000038, "Member 'BGUSelectUtil_LineTraceForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjects, bDebug) == 0x000048, "Member 'BGUSelectUtil_LineTraceForObjects::bDebug' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjects, HitResult) == 0x000050, "Member 'BGUSelectUtil_LineTraceForObjects::HitResult' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjects, ReturnValue) == 0x000098, "Member 'BGUSelectUtil_LineTraceForObjects::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.LineTraceForObjectsTypeSimple
// 0x00A0 (0x00A0 - 0x0000)
struct BGUSelectUtil_LineTraceForObjectsTypeSimple final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTrace;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResultSimple                       HitResult;                                         // 0x0050(0x0048)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x009C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSelectUtil_LineTraceForObjectsTypeSimple) == 0x000008, "Wrong alignment on BGUSelectUtil_LineTraceForObjectsTypeSimple");
static_assert(sizeof(BGUSelectUtil_LineTraceForObjectsTypeSimple) == 0x0000A0, "Wrong size on BGUSelectUtil_LineTraceForObjectsTypeSimple");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjectsTypeSimple, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_LineTraceForObjectsTypeSimple::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjectsTypeSimple, StartTrace) == 0x000008, "Member 'BGUSelectUtil_LineTraceForObjectsTypeSimple::StartTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjectsTypeSimple, EndTrace) == 0x000020, "Member 'BGUSelectUtil_LineTraceForObjectsTypeSimple::EndTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjectsTypeSimple, ObjectTypes) == 0x000038, "Member 'BGUSelectUtil_LineTraceForObjectsTypeSimple::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjectsTypeSimple, bDebug) == 0x000048, "Member 'BGUSelectUtil_LineTraceForObjectsTypeSimple::bDebug' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjectsTypeSimple, HitResult) == 0x000050, "Member 'BGUSelectUtil_LineTraceForObjectsTypeSimple::HitResult' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjectsTypeSimple, bTraceComplex) == 0x000098, "Member 'BGUSelectUtil_LineTraceForObjectsTypeSimple::bTraceComplex' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceForObjectsTypeSimple, ReturnValue) == 0x00009C, "Member 'BGUSelectUtil_LineTraceForObjectsTypeSimple::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.LineTraceMultiByObjType
// 0x0068 (0x0068 - 0x0000)
struct BGUSelectUtil_LineTraceMultiByObjType final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTrace;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResultSimple>               HitResultList;                                     // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0060(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_LineTraceMultiByObjType) == 0x000008, "Wrong alignment on BGUSelectUtil_LineTraceMultiByObjType");
static_assert(sizeof(BGUSelectUtil_LineTraceMultiByObjType) == 0x000068, "Wrong size on BGUSelectUtil_LineTraceMultiByObjType");
static_assert(offsetof(BGUSelectUtil_LineTraceMultiByObjType, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_LineTraceMultiByObjType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceMultiByObjType, StartTrace) == 0x000008, "Member 'BGUSelectUtil_LineTraceMultiByObjType::StartTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceMultiByObjType, EndTrace) == 0x000020, "Member 'BGUSelectUtil_LineTraceMultiByObjType::EndTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceMultiByObjType, ObjectTypes) == 0x000038, "Member 'BGUSelectUtil_LineTraceMultiByObjType::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceMultiByObjType, bDebug) == 0x000048, "Member 'BGUSelectUtil_LineTraceMultiByObjType::bDebug' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceMultiByObjType, HitResultList) == 0x000050, "Member 'BGUSelectUtil_LineTraceMultiByObjType::HitResultList' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceMultiByObjType, ReturnValue) == 0x000060, "Member 'BGUSelectUtil_LineTraceMultiByObjType::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.LineTraceOnlyCheck
// 0x00A0 (0x00A0 - 0x0000)
struct BGUSelectUtil_LineTraceOnlyCheck final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTrace;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               QueryChnl;                                         // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResultSimple                       HitResult;                                         // 0x0040(0x0048)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Ingnores;                                          // 0x0088(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x009C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSelectUtil_LineTraceOnlyCheck) == 0x000008, "Wrong alignment on BGUSelectUtil_LineTraceOnlyCheck");
static_assert(sizeof(BGUSelectUtil_LineTraceOnlyCheck) == 0x0000A0, "Wrong size on BGUSelectUtil_LineTraceOnlyCheck");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_LineTraceOnlyCheck::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, StartTrace) == 0x000008, "Member 'BGUSelectUtil_LineTraceOnlyCheck::StartTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, EndTrace) == 0x000020, "Member 'BGUSelectUtil_LineTraceOnlyCheck::EndTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, QueryChnl) == 0x000038, "Member 'BGUSelectUtil_LineTraceOnlyCheck::QueryChnl' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, bDebug) == 0x000039, "Member 'BGUSelectUtil_LineTraceOnlyCheck::bDebug' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, HitResult) == 0x000040, "Member 'BGUSelectUtil_LineTraceOnlyCheck::HitResult' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, Ingnores) == 0x000088, "Member 'BGUSelectUtil_LineTraceOnlyCheck::Ingnores' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, bTraceComplex) == 0x000098, "Member 'BGUSelectUtil_LineTraceOnlyCheck::bTraceComplex' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceOnlyCheck, ReturnValue) == 0x00009C, "Member 'BGUSelectUtil_LineTraceOnlyCheck::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.LineTraceSimple
// 0x00A0 (0x00A0 - 0x0000)
struct BGUSelectUtil_LineTraceSimple final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTrace;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               QueryChnl;                                         // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResultSimple                       HitResult;                                         // 0x0040(0x0048)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Ingnores;                                          // 0x0088(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x009C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSelectUtil_LineTraceSimple) == 0x000008, "Wrong alignment on BGUSelectUtil_LineTraceSimple");
static_assert(sizeof(BGUSelectUtil_LineTraceSimple) == 0x0000A0, "Wrong size on BGUSelectUtil_LineTraceSimple");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_LineTraceSimple::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, StartTrace) == 0x000008, "Member 'BGUSelectUtil_LineTraceSimple::StartTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, EndTrace) == 0x000020, "Member 'BGUSelectUtil_LineTraceSimple::EndTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, QueryChnl) == 0x000038, "Member 'BGUSelectUtil_LineTraceSimple::QueryChnl' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, bDebug) == 0x000039, "Member 'BGUSelectUtil_LineTraceSimple::bDebug' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, HitResult) == 0x000040, "Member 'BGUSelectUtil_LineTraceSimple::HitResult' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, Ingnores) == 0x000088, "Member 'BGUSelectUtil_LineTraceSimple::Ingnores' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, bTraceComplex) == 0x000098, "Member 'BGUSelectUtil_LineTraceSimple::bTraceComplex' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSimple, ReturnValue) == 0x00009C, "Member 'BGUSelectUtil_LineTraceSimple::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.LineTraceSingleForObjects
// 0x0180 (0x0180 - 0x0000)
struct BGUSelectUtil_LineTraceSingleForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0068(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0150(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x0154(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0164(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0174(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0178(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_LineTraceSingleForObjects) == 0x000008, "Wrong alignment on BGUSelectUtil_LineTraceSingleForObjects");
static_assert(sizeof(BGUSelectUtil_LineTraceSingleForObjects) == 0x000180, "Wrong size on BGUSelectUtil_LineTraceSingleForObjects");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_LineTraceSingleForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, Start) == 0x000008, "Member 'BGUSelectUtil_LineTraceSingleForObjects::Start' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, End) == 0x000020, "Member 'BGUSelectUtil_LineTraceSingleForObjects::End' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, ObjectTypes) == 0x000038, "Member 'BGUSelectUtil_LineTraceSingleForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, bTraceComplex) == 0x000048, "Member 'BGUSelectUtil_LineTraceSingleForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, ActorsToIgnore) == 0x000050, "Member 'BGUSelectUtil_LineTraceSingleForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, DrawDebugType) == 0x000060, "Member 'BGUSelectUtil_LineTraceSingleForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, OutHit) == 0x000068, "Member 'BGUSelectUtil_LineTraceSingleForObjects::OutHit' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, bIgnoreSelf) == 0x000150, "Member 'BGUSelectUtil_LineTraceSingleForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, TraceColor) == 0x000154, "Member 'BGUSelectUtil_LineTraceSingleForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, TraceHitColor) == 0x000164, "Member 'BGUSelectUtil_LineTraceSingleForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, DrawTime) == 0x000174, "Member 'BGUSelectUtil_LineTraceSingleForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_LineTraceSingleForObjects, ReturnValue) == 0x000178, "Member 'BGUSelectUtil_LineTraceSingleForObjects::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.MultiSphereTraceForObjects
// 0x0070 (0x0070 - 0x0000)
struct BGUSelectUtil_MultiSphereTraceForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTrace;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTrace;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0040(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResultSimple>               HitResultList;                                     // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0068(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_MultiSphereTraceForObjects) == 0x000008, "Wrong alignment on BGUSelectUtil_MultiSphereTraceForObjects");
static_assert(sizeof(BGUSelectUtil_MultiSphereTraceForObjects) == 0x000070, "Wrong size on BGUSelectUtil_MultiSphereTraceForObjects");
static_assert(offsetof(BGUSelectUtil_MultiSphereTraceForObjects, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_MultiSphereTraceForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_MultiSphereTraceForObjects, StartTrace) == 0x000008, "Member 'BGUSelectUtil_MultiSphereTraceForObjects::StartTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_MultiSphereTraceForObjects, EndTrace) == 0x000020, "Member 'BGUSelectUtil_MultiSphereTraceForObjects::EndTrace' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_MultiSphereTraceForObjects, Radius) == 0x000038, "Member 'BGUSelectUtil_MultiSphereTraceForObjects::Radius' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_MultiSphereTraceForObjects, ObjectTypes) == 0x000040, "Member 'BGUSelectUtil_MultiSphereTraceForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_MultiSphereTraceForObjects, bDebug) == 0x000050, "Member 'BGUSelectUtil_MultiSphereTraceForObjects::bDebug' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_MultiSphereTraceForObjects, HitResultList) == 0x000058, "Member 'BGUSelectUtil_MultiSphereTraceForObjects::HitResultList' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_MultiSphereTraceForObjects, ReturnValue) == 0x000068, "Member 'BGUSelectUtil_MultiSphereTraceForObjects::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.SelectBGUCharactersInCircle
// 0x0040 (0x0040 - 0x0000)
struct BGUSelectUtil_SelectBGUCharactersInCircle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetBase;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCount;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetFilter;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Params_0;                                          // 0x0028(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_SelectBGUCharactersInCircle) == 0x000008, "Wrong alignment on BGUSelectUtil_SelectBGUCharactersInCircle");
static_assert(sizeof(BGUSelectUtil_SelectBGUCharactersInCircle) == 0x000040, "Wrong size on BGUSelectUtil_SelectBGUCharactersInCircle");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCircle, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_SelectBGUCharactersInCircle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCircle, OutActors) == 0x000008, "Member 'BGUSelectUtil_SelectBGUCharactersInCircle::OutActors' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCircle, TargetBase) == 0x000018, "Member 'BGUSelectUtil_SelectBGUCharactersInCircle::TargetBase' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCircle, TargetCount) == 0x000020, "Member 'BGUSelectUtil_SelectBGUCharactersInCircle::TargetCount' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCircle, TargetFilter) == 0x000024, "Member 'BGUSelectUtil_SelectBGUCharactersInCircle::TargetFilter' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCircle, Params_0) == 0x000028, "Member 'BGUSelectUtil_SelectBGUCharactersInCircle::Params_0' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCircle, ReturnValue) == 0x000038, "Member 'BGUSelectUtil_SelectBGUCharactersInCircle::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.SelectBGUCharactersInCylinder
// 0x0040 (0x0040 - 0x0000)
struct BGUSelectUtil_SelectBGUCharactersInCylinder final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetBase;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCount;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetFilter;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Params_0;                                          // 0x0028(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_SelectBGUCharactersInCylinder) == 0x000008, "Wrong alignment on BGUSelectUtil_SelectBGUCharactersInCylinder");
static_assert(sizeof(BGUSelectUtil_SelectBGUCharactersInCylinder) == 0x000040, "Wrong size on BGUSelectUtil_SelectBGUCharactersInCylinder");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCylinder, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_SelectBGUCharactersInCylinder::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCylinder, OutActors) == 0x000008, "Member 'BGUSelectUtil_SelectBGUCharactersInCylinder::OutActors' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCylinder, TargetBase) == 0x000018, "Member 'BGUSelectUtil_SelectBGUCharactersInCylinder::TargetBase' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCylinder, TargetCount) == 0x000020, "Member 'BGUSelectUtil_SelectBGUCharactersInCylinder::TargetCount' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCylinder, TargetFilter) == 0x000024, "Member 'BGUSelectUtil_SelectBGUCharactersInCylinder::TargetFilter' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCylinder, Params_0) == 0x000028, "Member 'BGUSelectUtil_SelectBGUCharactersInCylinder::Params_0' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInCylinder, ReturnValue) == 0x000038, "Member 'BGUSelectUtil_SelectBGUCharactersInCylinder::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.SelectBGUCharactersInRect
// 0x0040 (0x0040 - 0x0000)
struct BGUSelectUtil_SelectBGUCharactersInRect final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetBase;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCount;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetFilter;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Params_0;                                          // 0x0028(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUSelectUtil_SelectBGUCharactersInRect) == 0x000008, "Wrong alignment on BGUSelectUtil_SelectBGUCharactersInRect");
static_assert(sizeof(BGUSelectUtil_SelectBGUCharactersInRect) == 0x000040, "Wrong size on BGUSelectUtil_SelectBGUCharactersInRect");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInRect, WorldContextObject) == 0x000000, "Member 'BGUSelectUtil_SelectBGUCharactersInRect::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInRect, OutActors) == 0x000008, "Member 'BGUSelectUtil_SelectBGUCharactersInRect::OutActors' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInRect, TargetBase) == 0x000018, "Member 'BGUSelectUtil_SelectBGUCharactersInRect::TargetBase' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInRect, TargetCount) == 0x000020, "Member 'BGUSelectUtil_SelectBGUCharactersInRect::TargetCount' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInRect, TargetFilter) == 0x000024, "Member 'BGUSelectUtil_SelectBGUCharactersInRect::TargetFilter' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInRect, Params_0) == 0x000028, "Member 'BGUSelectUtil_SelectBGUCharactersInRect::Params_0' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SelectBGUCharactersInRect, ReturnValue) == 0x000038, "Member 'BGUSelectUtil_SelectBGUCharactersInRect::ReturnValue' has a wrong offset!");

// Function b1.BGUSelectUtil.SphereOverlapBGUCharacters
// 0x0040 (0x0040 - 0x0000)
struct BGUSelectUtil_SphereOverlapBGUCharacters final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SphereCenter;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABGUCharacter*>                  OutArray;                                          // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	ECollisionChannel                             QueryChannel;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x003C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSelectUtil_SphereOverlapBGUCharacters) == 0x000008, "Wrong alignment on BGUSelectUtil_SphereOverlapBGUCharacters");
static_assert(sizeof(BGUSelectUtil_SphereOverlapBGUCharacters) == 0x000040, "Wrong size on BGUSelectUtil_SphereOverlapBGUCharacters");
static_assert(offsetof(BGUSelectUtil_SphereOverlapBGUCharacters, WorldContext) == 0x000000, "Member 'BGUSelectUtil_SphereOverlapBGUCharacters::WorldContext' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SphereOverlapBGUCharacters, SphereCenter) == 0x000008, "Member 'BGUSelectUtil_SphereOverlapBGUCharacters::SphereCenter' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SphereOverlapBGUCharacters, Radius) == 0x000020, "Member 'BGUSelectUtil_SphereOverlapBGUCharacters::Radius' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SphereOverlapBGUCharacters, OutArray) == 0x000028, "Member 'BGUSelectUtil_SphereOverlapBGUCharacters::OutArray' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SphereOverlapBGUCharacters, QueryChannel) == 0x000038, "Member 'BGUSelectUtil_SphereOverlapBGUCharacters::QueryChannel' has a wrong offset!");
static_assert(offsetof(BGUSelectUtil_SphereOverlapBGUCharacters, ReturnValue) == 0x00003C, "Member 'BGUSelectUtil_SphereOverlapBGUCharacters::ReturnValue' has a wrong offset!");

// Function b1.BGUSpringArmComponent.BlendLocationsInCS
// 0x0138 (0x0138 - 0x0000)
struct BGUSpringArmComponent_BlendLocationsInCS final
{
public:
	struct FVector                                OriginArmLocation;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredArmLocation;                                // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0030(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0118(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0120(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSpringArmComponent_BlendLocationsInCS) == 0x000008, "Wrong alignment on BGUSpringArmComponent_BlendLocationsInCS");
static_assert(sizeof(BGUSpringArmComponent_BlendLocationsInCS) == 0x000138, "Wrong size on BGUSpringArmComponent_BlendLocationsInCS");
static_assert(offsetof(BGUSpringArmComponent_BlendLocationsInCS, OriginArmLocation) == 0x000000, "Member 'BGUSpringArmComponent_BlendLocationsInCS::OriginArmLocation' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_BlendLocationsInCS, DesiredArmLocation) == 0x000018, "Member 'BGUSpringArmComponent_BlendLocationsInCS::DesiredArmLocation' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_BlendLocationsInCS, HitResult) == 0x000030, "Member 'BGUSpringArmComponent_BlendLocationsInCS::HitResult' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_BlendLocationsInCS, DeltaTime) == 0x000118, "Member 'BGUSpringArmComponent_BlendLocationsInCS::DeltaTime' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_BlendLocationsInCS, ReturnValue) == 0x000120, "Member 'BGUSpringArmComponent_BlendLocationsInCS::ReturnValue' has a wrong offset!");

// Function b1.BGUSpringArmComponent.CalcSmoothLocation
// 0x0068 (0x0068 - 0x0000)
struct BGUSpringArmComponent_CalcSmoothLocation final
{
public:
	struct FVector                                Current;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SmoothSpeed;                                       // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0050(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSpringArmComponent_CalcSmoothLocation) == 0x000008, "Wrong alignment on BGUSpringArmComponent_CalcSmoothLocation");
static_assert(sizeof(BGUSpringArmComponent_CalcSmoothLocation) == 0x000068, "Wrong size on BGUSpringArmComponent_CalcSmoothLocation");
static_assert(offsetof(BGUSpringArmComponent_CalcSmoothLocation, Current) == 0x000000, "Member 'BGUSpringArmComponent_CalcSmoothLocation::Current' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_CalcSmoothLocation, Target) == 0x000018, "Member 'BGUSpringArmComponent_CalcSmoothLocation::Target' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_CalcSmoothLocation, DeltaTime) == 0x000030, "Member 'BGUSpringArmComponent_CalcSmoothLocation::DeltaTime' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_CalcSmoothLocation, SmoothSpeed) == 0x000038, "Member 'BGUSpringArmComponent_CalcSmoothLocation::SmoothSpeed' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_CalcSmoothLocation, ReturnValue) == 0x000050, "Member 'BGUSpringArmComponent_CalcSmoothLocation::ReturnValue' has a wrong offset!");

// Function b1.BGUSpringArmComponent.GetPreviousValues
// 0x0048 (0x0048 - 0x0000)
struct BGUSpringArmComponent_GetPreviousValues final
{
public:
	struct FVector                                OutPreviousDesiredLoc;                             // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutPreviousArmOrigin;                              // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutPreviousDesiredRot;                             // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSpringArmComponent_GetPreviousValues) == 0x000008, "Wrong alignment on BGUSpringArmComponent_GetPreviousValues");
static_assert(sizeof(BGUSpringArmComponent_GetPreviousValues) == 0x000048, "Wrong size on BGUSpringArmComponent_GetPreviousValues");
static_assert(offsetof(BGUSpringArmComponent_GetPreviousValues, OutPreviousDesiredLoc) == 0x000000, "Member 'BGUSpringArmComponent_GetPreviousValues::OutPreviousDesiredLoc' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_GetPreviousValues, OutPreviousArmOrigin) == 0x000018, "Member 'BGUSpringArmComponent_GetPreviousValues::OutPreviousArmOrigin' has a wrong offset!");
static_assert(offsetof(BGUSpringArmComponent_GetPreviousValues, OutPreviousDesiredRot) == 0x000030, "Member 'BGUSpringArmComponent_GetPreviousValues::OutPreviousDesiredRot' has a wrong offset!");

// Function b1.BGUTamerBase.ApplyWorldOffsetCS
// 0x0020 (0x0020 - 0x0000)
struct BGUTamerBase_ApplyWorldOffsetCS final
{
public:
	struct FVector                                InOffset;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldShift;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUTamerBase_ApplyWorldOffsetCS) == 0x000008, "Wrong alignment on BGUTamerBase_ApplyWorldOffsetCS");
static_assert(sizeof(BGUTamerBase_ApplyWorldOffsetCS) == 0x000020, "Wrong size on BGUTamerBase_ApplyWorldOffsetCS");
static_assert(offsetof(BGUTamerBase_ApplyWorldOffsetCS, InOffset) == 0x000000, "Member 'BGUTamerBase_ApplyWorldOffsetCS::InOffset' has a wrong offset!");
static_assert(offsetof(BGUTamerBase_ApplyWorldOffsetCS, bWorldShift) == 0x000018, "Member 'BGUTamerBase_ApplyWorldOffsetCS::bWorldShift' has a wrong offset!");

// Function b1.BGUTamerBase.GetHighLODMeshConfig
// 0x00E0 (0x00E0 - 0x0000)
struct BGUTamerBase_GetHighLODMeshConfig final
{
public:
	struct FTamerHighLODRootMeshConfig            OutMeshConfig;                                     // 0x0000(0x00D0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00D0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0xF];                                       // 0x00D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUTamerBase_GetHighLODMeshConfig) == 0x000010, "Wrong alignment on BGUTamerBase_GetHighLODMeshConfig");
static_assert(sizeof(BGUTamerBase_GetHighLODMeshConfig) == 0x0000E0, "Wrong size on BGUTamerBase_GetHighLODMeshConfig");
static_assert(offsetof(BGUTamerBase_GetHighLODMeshConfig, OutMeshConfig) == 0x000000, "Member 'BGUTamerBase_GetHighLODMeshConfig::OutMeshConfig' has a wrong offset!");
static_assert(offsetof(BGUTamerBase_GetHighLODMeshConfig, ReturnValue) == 0x0000D0, "Member 'BGUTamerBase_GetHighLODMeshConfig::ReturnValue' has a wrong offset!");

// Function b1.BGUTamerBase.OnConstructionCS
// 0x0060 (0x0060 - 0x0000)
struct BGUTamerBase_OnConstructionCS final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUTamerBase_OnConstructionCS) == 0x000010, "Wrong alignment on BGUTamerBase_OnConstructionCS");
static_assert(sizeof(BGUTamerBase_OnConstructionCS) == 0x000060, "Wrong size on BGUTamerBase_OnConstructionCS");
static_assert(offsetof(BGUTamerBase_OnConstructionCS, Transform) == 0x000000, "Member 'BGUTamerBase_OnConstructionCS::Transform' has a wrong offset!");

// Function b1.BGUTamerBase.OnPostEditMove
// 0x0001 (0x0001 - 0x0000)
struct BGUTamerBase_OnPostEditMove final
{
public:
	bool                                          bFisnish;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUTamerBase_OnPostEditMove) == 0x000001, "Wrong alignment on BGUTamerBase_OnPostEditMove");
static_assert(sizeof(BGUTamerBase_OnPostEditMove) == 0x000001, "Wrong size on BGUTamerBase_OnPostEditMove");
static_assert(offsetof(BGUTamerBase_OnPostEditMove, bFisnish) == 0x000000, "Member 'BGUTamerBase_OnPostEditMove::bFisnish' has a wrong offset!");

// Function b1.BGUTamerBase.OnPropertyChanged
// 0x0020 (0x0020 - 0x0000)
struct BGUTamerBase_OnPropertyChanged final
{
public:
	class FString                                 MemberName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUTamerBase_OnPropertyChanged) == 0x000008, "Wrong alignment on BGUTamerBase_OnPropertyChanged");
static_assert(sizeof(BGUTamerBase_OnPropertyChanged) == 0x000020, "Wrong size on BGUTamerBase_OnPropertyChanged");
static_assert(offsetof(BGUTamerBase_OnPropertyChanged, MemberName) == 0x000000, "Member 'BGUTamerBase_OnPropertyChanged::MemberName' has a wrong offset!");
static_assert(offsetof(BGUTamerBase_OnPropertyChanged, PropertyName) == 0x000010, "Member 'BGUTamerBase_OnPropertyChanged::PropertyName' has a wrong offset!");

// Function b1.BGUTamerBase.SetLODMeshVisible
// 0x0001 (0x0001 - 0x0000)
struct BGUTamerBase_SetLODMeshVisible final
{
public:
	bool                                          Invisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUTamerBase_SetLODMeshVisible) == 0x000001, "Wrong alignment on BGUTamerBase_SetLODMeshVisible");
static_assert(sizeof(BGUTamerBase_SetLODMeshVisible) == 0x000001, "Wrong size on BGUTamerBase_SetLODMeshVisible");
static_assert(offsetof(BGUTamerBase_SetLODMeshVisible, Invisible) == 0x000000, "Member 'BGUTamerBase_SetLODMeshVisible::Invisible' has a wrong offset!");

// Function b1.BGUTamerBase.GetActorGuid
// 0x0018 (0x0018 - 0x0000)
struct BGUTamerBase_GetActorGuid final
{
public:
	class FString                                 OutActorGuid;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUTamerBase_GetActorGuid) == 0x000008, "Wrong alignment on BGUTamerBase_GetActorGuid");
static_assert(sizeof(BGUTamerBase_GetActorGuid) == 0x000018, "Wrong size on BGUTamerBase_GetActorGuid");
static_assert(offsetof(BGUTamerBase_GetActorGuid, OutActorGuid) == 0x000000, "Member 'BGUTamerBase_GetActorGuid::OutActorGuid' has a wrong offset!");
static_assert(offsetof(BGUTamerBase_GetActorGuid, ReturnValue) == 0x000010, "Member 'BGUTamerBase_GetActorGuid::ReturnValue' has a wrong offset!");

// Function b1.BGUTamerBase.GetActorGuidCS
// 0x0018 (0x0018 - 0x0000)
struct BGUTamerBase_GetActorGuidCS final
{
public:
	class FString                                 OutActorGuid;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGUTamerBase_GetActorGuidCS) == 0x000008, "Wrong alignment on BGUTamerBase_GetActorGuidCS");
static_assert(sizeof(BGUTamerBase_GetActorGuidCS) == 0x000018, "Wrong size on BGUTamerBase_GetActorGuidCS");
static_assert(offsetof(BGUTamerBase_GetActorGuidCS, OutActorGuid) == 0x000000, "Member 'BGUTamerBase_GetActorGuidCS::OutActorGuid' has a wrong offset!");
static_assert(offsetof(BGUTamerBase_GetActorGuidCS, ReturnValue) == 0x000010, "Member 'BGUTamerBase_GetActorGuidCS::ReturnValue' has a wrong offset!");

// Function b1.BGUTeleportPoint.GetGSActorLablel
// 0x0010 (0x0010 - 0x0000)
struct BGUTeleportPoint_GetGSActorLablel final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUTeleportPoint_GetGSActorLablel) == 0x000008, "Wrong alignment on BGUTeleportPoint_GetGSActorLablel");
static_assert(sizeof(BGUTeleportPoint_GetGSActorLablel) == 0x000010, "Wrong size on BGUTeleportPoint_GetGSActorLablel");
static_assert(offsetof(BGUTeleportPoint_GetGSActorLablel, ReturnValue) == 0x000000, "Member 'BGUTeleportPoint_GetGSActorLablel::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoader.AsyncLoadClass
// 0x0028 (0x0028 - 0x0000)
struct BGWAssetLoader_AsyncLoadClass final
{
public:
	struct FSoftClassPath                         LoadPath;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWAssetLoaderRequest*                 Request;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWAssetLoader_AsyncLoadClass) == 0x000008, "Wrong alignment on BGWAssetLoader_AsyncLoadClass");
static_assert(sizeof(BGWAssetLoader_AsyncLoadClass) == 0x000028, "Wrong size on BGWAssetLoader_AsyncLoadClass");
static_assert(offsetof(BGWAssetLoader_AsyncLoadClass, LoadPath) == 0x000000, "Member 'BGWAssetLoader_AsyncLoadClass::LoadPath' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_AsyncLoadClass, Request) == 0x000018, "Member 'BGWAssetLoader_AsyncLoadClass::Request' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_AsyncLoadClass, Priority) == 0x000020, "Member 'BGWAssetLoader_AsyncLoadClass::Priority' has a wrong offset!");

// Function b1.BGWAssetLoader.AsyncLoadObject
// 0x0028 (0x0028 - 0x0000)
struct BGWAssetLoader_AsyncLoadObject final
{
public:
	struct FSoftObjectPath                        LoadPath;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWAssetLoaderRequest*                 Request;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWAssetLoader_AsyncLoadObject) == 0x000008, "Wrong alignment on BGWAssetLoader_AsyncLoadObject");
static_assert(sizeof(BGWAssetLoader_AsyncLoadObject) == 0x000028, "Wrong size on BGWAssetLoader_AsyncLoadObject");
static_assert(offsetof(BGWAssetLoader_AsyncLoadObject, LoadPath) == 0x000000, "Member 'BGWAssetLoader_AsyncLoadObject::LoadPath' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_AsyncLoadObject, Request) == 0x000018, "Member 'BGWAssetLoader_AsyncLoadObject::Request' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_AsyncLoadObject, Priority) == 0x000020, "Member 'BGWAssetLoader_AsyncLoadObject::Priority' has a wrong offset!");

// Function b1.BGWAssetLoader.AsyncLoadObjects
// 0x0020 (0x0020 - 0x0000)
struct BGWAssetLoader_AsyncLoadObjects final
{
public:
	TArray<struct FSoftObjectPath>                LoadList;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBGWAssetLoaderRequest*                 Request;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWAssetLoader_AsyncLoadObjects) == 0x000008, "Wrong alignment on BGWAssetLoader_AsyncLoadObjects");
static_assert(sizeof(BGWAssetLoader_AsyncLoadObjects) == 0x000020, "Wrong size on BGWAssetLoader_AsyncLoadObjects");
static_assert(offsetof(BGWAssetLoader_AsyncLoadObjects, LoadList) == 0x000000, "Member 'BGWAssetLoader_AsyncLoadObjects::LoadList' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_AsyncLoadObjects, Request) == 0x000010, "Member 'BGWAssetLoader_AsyncLoadObjects::Request' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_AsyncLoadObjects, Priority) == 0x000018, "Member 'BGWAssetLoader_AsyncLoadObjects::Priority' has a wrong offset!");

// Function b1.BGWAssetLoader.SyncLoadObject
// 0x0020 (0x0020 - 0x0000)
struct BGWAssetLoader_SyncLoadObject final
{
public:
	struct FSoftObjectPath                        Path;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoader_SyncLoadObject) == 0x000008, "Wrong alignment on BGWAssetLoader_SyncLoadObject");
static_assert(sizeof(BGWAssetLoader_SyncLoadObject) == 0x000020, "Wrong size on BGWAssetLoader_SyncLoadObject");
static_assert(offsetof(BGWAssetLoader_SyncLoadObject, Path) == 0x000000, "Member 'BGWAssetLoader_SyncLoadObject::Path' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_SyncLoadObject, ReturnValue) == 0x000018, "Member 'BGWAssetLoader_SyncLoadObject::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoader.SyncLoadObjects
// 0x0028 (0x0028 - 0x0000)
struct BGWAssetLoader_SyncLoadObjects final
{
public:
	TArray<struct FSoftObjectPath>                LoadList;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        OutObjList;                                        // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWAssetLoader_SyncLoadObjects) == 0x000008, "Wrong alignment on BGWAssetLoader_SyncLoadObjects");
static_assert(sizeof(BGWAssetLoader_SyncLoadObjects) == 0x000028, "Wrong size on BGWAssetLoader_SyncLoadObjects");
static_assert(offsetof(BGWAssetLoader_SyncLoadObjects, LoadList) == 0x000000, "Member 'BGWAssetLoader_SyncLoadObjects::LoadList' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_SyncLoadObjects, OutObjList) == 0x000010, "Member 'BGWAssetLoader_SyncLoadObjects::OutObjList' has a wrong offset!");
static_assert(offsetof(BGWAssetLoader_SyncLoadObjects, ReturnValue) == 0x000020, "Member 'BGWAssetLoader_SyncLoadObjects::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.Cancel
// 0x0001 (0x0001 - 0x0000)
struct BGWAssetLoaderRequest_Cancel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_Cancel) == 0x000001, "Wrong alignment on BGWAssetLoaderRequest_Cancel");
static_assert(sizeof(BGWAssetLoaderRequest_Cancel) == 0x000001, "Wrong size on BGWAssetLoaderRequest_Cancel");
static_assert(offsetof(BGWAssetLoaderRequest_Cancel, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_Cancel::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.WaitUntilComplete
// 0x0008 (0x0008 - 0x0000)
struct BGWAssetLoaderRequest_WaitUntilComplete final
{
public:
	float                                         Timeout;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartStalledHandles;                              // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWAssetLoaderRequest_WaitUntilComplete) == 0x000004, "Wrong alignment on BGWAssetLoaderRequest_WaitUntilComplete");
static_assert(sizeof(BGWAssetLoaderRequest_WaitUntilComplete) == 0x000008, "Wrong size on BGWAssetLoaderRequest_WaitUntilComplete");
static_assert(offsetof(BGWAssetLoaderRequest_WaitUntilComplete, Timeout) == 0x000000, "Member 'BGWAssetLoaderRequest_WaitUntilComplete::Timeout' has a wrong offset!");
static_assert(offsetof(BGWAssetLoaderRequest_WaitUntilComplete, bStartStalledHandles) == 0x000004, "Member 'BGWAssetLoaderRequest_WaitUntilComplete::bStartStalledHandles' has a wrong offset!");
static_assert(offsetof(BGWAssetLoaderRequest_WaitUntilComplete, ReturnValue) == 0x000005, "Member 'BGWAssetLoaderRequest_WaitUntilComplete::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.GetDebugName
// 0x0010 (0x0010 - 0x0000)
struct BGWAssetLoaderRequest_GetDebugName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_GetDebugName) == 0x000008, "Wrong alignment on BGWAssetLoaderRequest_GetDebugName");
static_assert(sizeof(BGWAssetLoaderRequest_GetDebugName) == 0x000010, "Wrong size on BGWAssetLoaderRequest_GetDebugName");
static_assert(offsetof(BGWAssetLoaderRequest_GetDebugName, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_GetDebugName::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.GetLoadedAssets
// 0x0010 (0x0010 - 0x0000)
struct BGWAssetLoaderRequest_GetLoadedAssets final
{
public:
	TArray<class UObject*>                        LoadedAssets;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_GetLoadedAssets) == 0x000008, "Wrong alignment on BGWAssetLoaderRequest_GetLoadedAssets");
static_assert(sizeof(BGWAssetLoaderRequest_GetLoadedAssets) == 0x000010, "Wrong size on BGWAssetLoaderRequest_GetLoadedAssets");
static_assert(offsetof(BGWAssetLoaderRequest_GetLoadedAssets, LoadedAssets) == 0x000000, "Member 'BGWAssetLoaderRequest_GetLoadedAssets::LoadedAssets' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.GetLoadedCount
// 0x0008 (0x0008 - 0x0000)
struct BGWAssetLoaderRequest_GetLoadedCount final
{
public:
	int32                                         LoadedCount;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequestedCount;                                    // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_GetLoadedCount) == 0x000004, "Wrong alignment on BGWAssetLoaderRequest_GetLoadedCount");
static_assert(sizeof(BGWAssetLoaderRequest_GetLoadedCount) == 0x000008, "Wrong size on BGWAssetLoaderRequest_GetLoadedCount");
static_assert(offsetof(BGWAssetLoaderRequest_GetLoadedCount, LoadedCount) == 0x000000, "Member 'BGWAssetLoaderRequest_GetLoadedCount::LoadedCount' has a wrong offset!");
static_assert(offsetof(BGWAssetLoaderRequest_GetLoadedCount, RequestedCount) == 0x000004, "Member 'BGWAssetLoaderRequest_GetLoadedCount::RequestedCount' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.GetPriority
// 0x0004 (0x0004 - 0x0000)
struct BGWAssetLoaderRequest_GetPriority final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_GetPriority) == 0x000004, "Wrong alignment on BGWAssetLoaderRequest_GetPriority");
static_assert(sizeof(BGWAssetLoaderRequest_GetPriority) == 0x000004, "Wrong size on BGWAssetLoaderRequest_GetPriority");
static_assert(offsetof(BGWAssetLoaderRequest_GetPriority, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_GetPriority::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.GetProgress
// 0x0004 (0x0004 - 0x0000)
struct BGWAssetLoaderRequest_GetProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_GetProgress) == 0x000004, "Wrong alignment on BGWAssetLoaderRequest_GetProgress");
static_assert(sizeof(BGWAssetLoaderRequest_GetProgress) == 0x000004, "Wrong size on BGWAssetLoaderRequest_GetProgress");
static_assert(offsetof(BGWAssetLoaderRequest_GetProgress, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_GetProgress::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.GetRequestedAssets
// 0x0010 (0x0010 - 0x0000)
struct BGWAssetLoaderRequest_GetRequestedAssets final
{
public:
	TArray<struct FSoftObjectPath>                AssetList;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_GetRequestedAssets) == 0x000008, "Wrong alignment on BGWAssetLoaderRequest_GetRequestedAssets");
static_assert(sizeof(BGWAssetLoaderRequest_GetRequestedAssets) == 0x000010, "Wrong size on BGWAssetLoaderRequest_GetRequestedAssets");
static_assert(offsetof(BGWAssetLoaderRequest_GetRequestedAssets, AssetList) == 0x000000, "Member 'BGWAssetLoaderRequest_GetRequestedAssets::AssetList' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.HasLoadCompleted
// 0x0001 (0x0001 - 0x0000)
struct BGWAssetLoaderRequest_HasLoadCompleted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_HasLoadCompleted) == 0x000001, "Wrong alignment on BGWAssetLoaderRequest_HasLoadCompleted");
static_assert(sizeof(BGWAssetLoaderRequest_HasLoadCompleted) == 0x000001, "Wrong size on BGWAssetLoaderRequest_HasLoadCompleted");
static_assert(offsetof(BGWAssetLoaderRequest_HasLoadCompleted, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_HasLoadCompleted::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.HasLoadCompletedOrStalled
// 0x0001 (0x0001 - 0x0000)
struct BGWAssetLoaderRequest_HasLoadCompletedOrStalled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_HasLoadCompletedOrStalled) == 0x000001, "Wrong alignment on BGWAssetLoaderRequest_HasLoadCompletedOrStalled");
static_assert(sizeof(BGWAssetLoaderRequest_HasLoadCompletedOrStalled) == 0x000001, "Wrong size on BGWAssetLoaderRequest_HasLoadCompletedOrStalled");
static_assert(offsetof(BGWAssetLoaderRequest_HasLoadCompletedOrStalled, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_HasLoadCompletedOrStalled::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.IsActive
// 0x0001 (0x0001 - 0x0000)
struct BGWAssetLoaderRequest_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_IsActive) == 0x000001, "Wrong alignment on BGWAssetLoaderRequest_IsActive");
static_assert(sizeof(BGWAssetLoaderRequest_IsActive) == 0x000001, "Wrong size on BGWAssetLoaderRequest_IsActive");
static_assert(offsetof(BGWAssetLoaderRequest_IsActive, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_IsActive::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.IsCombinedHandle
// 0x0001 (0x0001 - 0x0000)
struct BGWAssetLoaderRequest_IsCombinedHandle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_IsCombinedHandle) == 0x000001, "Wrong alignment on BGWAssetLoaderRequest_IsCombinedHandle");
static_assert(sizeof(BGWAssetLoaderRequest_IsCombinedHandle) == 0x000001, "Wrong size on BGWAssetLoaderRequest_IsCombinedHandle");
static_assert(offsetof(BGWAssetLoaderRequest_IsCombinedHandle, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_IsCombinedHandle::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.IsLoadingInProgress
// 0x0001 (0x0001 - 0x0000)
struct BGWAssetLoaderRequest_IsLoadingInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_IsLoadingInProgress) == 0x000001, "Wrong alignment on BGWAssetLoaderRequest_IsLoadingInProgress");
static_assert(sizeof(BGWAssetLoaderRequest_IsLoadingInProgress) == 0x000001, "Wrong size on BGWAssetLoaderRequest_IsLoadingInProgress");
static_assert(offsetof(BGWAssetLoaderRequest_IsLoadingInProgress, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_IsLoadingInProgress::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.IsStalled
// 0x0001 (0x0001 - 0x0000)
struct BGWAssetLoaderRequest_IsStalled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_IsStalled) == 0x000001, "Wrong alignment on BGWAssetLoaderRequest_IsStalled");
static_assert(sizeof(BGWAssetLoaderRequest_IsStalled) == 0x000001, "Wrong size on BGWAssetLoaderRequest_IsStalled");
static_assert(offsetof(BGWAssetLoaderRequest_IsStalled, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_IsStalled::ReturnValue' has a wrong offset!");

// Function b1.BGWAssetLoaderRequest.WasCanceled
// 0x0001 (0x0001 - 0x0000)
struct BGWAssetLoaderRequest_WasCanceled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWAssetLoaderRequest_WasCanceled) == 0x000001, "Wrong alignment on BGWAssetLoaderRequest_WasCanceled");
static_assert(sizeof(BGWAssetLoaderRequest_WasCanceled) == 0x000001, "Wrong size on BGWAssetLoaderRequest_WasCanceled");
static_assert(offsetof(BGWAssetLoaderRequest_WasCanceled, ReturnValue) == 0x000000, "Member 'BGWAssetLoaderRequest_WasCanceled::ReturnValue' has a wrong offset!");

// Function b1.BGWCameraGroupVolumeManager.Get
// 0x0010 (0x0010 - 0x0000)
struct BGWCameraGroupVolumeManager_Get final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWCameraGroupVolumeManager*           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWCameraGroupVolumeManager_Get) == 0x000008, "Wrong alignment on BGWCameraGroupVolumeManager_Get");
static_assert(sizeof(BGWCameraGroupVolumeManager_Get) == 0x000010, "Wrong size on BGWCameraGroupVolumeManager_Get");
static_assert(offsetof(BGWCameraGroupVolumeManager_Get, WorldContext) == 0x000000, "Member 'BGWCameraGroupVolumeManager_Get::WorldContext' has a wrong offset!");
static_assert(offsetof(BGWCameraGroupVolumeManager_Get, ReturnValue) == 0x000008, "Member 'BGWCameraGroupVolumeManager_Get::ReturnValue' has a wrong offset!");

// DelegateFunction b1.BGWCameraGroupVolumeManager.OnSwitchCameraGroupTo__DelegateSignature
// 0x000C (0x000C - 0x0000)
struct BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature final
{
public:
	int32                                         TargetCameraGroupId;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature) == 0x000004, "Wrong alignment on BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature");
static_assert(sizeof(BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature) == 0x00000C, "Wrong size on BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature");
static_assert(offsetof(BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature, TargetCameraGroupId) == 0x000000, "Member 'BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature::TargetCameraGroupId' has a wrong offset!");
static_assert(offsetof(BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature, Alpha) == 0x000004, "Member 'BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature::Alpha' has a wrong offset!");
static_assert(offsetof(BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature, BlendTime) == 0x000008, "Member 'BGWCameraGroupVolumeManager_OnSwitchCameraGroupTo__DelegateSignature::BlendTime' has a wrong offset!");

// Function b1.BGWCppExport.GetAllFuncAsMap
// 0x0050 (0x0050 - 0x0000)
struct BGWCppExport_GetAllFuncAsMap final
{
public:
	TMap<class FString, struct FIntPtr>           ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWCppExport_GetAllFuncAsMap) == 0x000008, "Wrong alignment on BGWCppExport_GetAllFuncAsMap");
static_assert(sizeof(BGWCppExport_GetAllFuncAsMap) == 0x000050, "Wrong size on BGWCppExport_GetAllFuncAsMap");
static_assert(offsetof(BGWCppExport_GetAllFuncAsMap, ReturnValue) == 0x000000, "Member 'BGWCppExport_GetAllFuncAsMap::ReturnValue' has a wrong offset!");

// Function b1.BGWSaveCheckDataAsset.SaveCheckCS
// 0x0028 (0x0028 - 0x0000)
struct BGWSaveCheckDataAsset_SaveCheckCS final
{
public:
	class FString                                 OutTitle;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutMessage;                                        // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWSaveCheckDataAsset_SaveCheckCS) == 0x000008, "Wrong alignment on BGWSaveCheckDataAsset_SaveCheckCS");
static_assert(sizeof(BGWSaveCheckDataAsset_SaveCheckCS) == 0x000028, "Wrong size on BGWSaveCheckDataAsset_SaveCheckCS");
static_assert(offsetof(BGWSaveCheckDataAsset_SaveCheckCS, OutTitle) == 0x000000, "Member 'BGWSaveCheckDataAsset_SaveCheckCS::OutTitle' has a wrong offset!");
static_assert(offsetof(BGWSaveCheckDataAsset_SaveCheckCS, OutMessage) == 0x000010, "Member 'BGWSaveCheckDataAsset_SaveCheckCS::OutMessage' has a wrong offset!");
static_assert(offsetof(BGWSaveCheckDataAsset_SaveCheckCS, ReturnValue) == 0x000020, "Member 'BGWSaveCheckDataAsset_SaveCheckCS::ReturnValue' has a wrong offset!");

// Function b1.BWC_DispLibLocalFogWrapper.SetLocalFogParameter
// 0x01F0 (0x01F0 - 0x0000)
struct BWC_DispLibLocalFogWrapper_SetLocalFogParameter final
{
public:
	struct FBWC_DispLibEnvSettings                InSettings;                                        // 0x0000(0x01E0)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              WindDir;                                           // 0x01E0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibLocalFogWrapper_SetLocalFogParameter) == 0x000010, "Wrong alignment on BWC_DispLibLocalFogWrapper_SetLocalFogParameter");
static_assert(sizeof(BWC_DispLibLocalFogWrapper_SetLocalFogParameter) == 0x0001F0, "Wrong size on BWC_DispLibLocalFogWrapper_SetLocalFogParameter");
static_assert(offsetof(BWC_DispLibLocalFogWrapper_SetLocalFogParameter, InSettings) == 0x000000, "Member 'BWC_DispLibLocalFogWrapper_SetLocalFogParameter::InSettings' has a wrong offset!");
static_assert(offsetof(BWC_DispLibLocalFogWrapper_SetLocalFogParameter, WindDir) == 0x0001E0, "Member 'BWC_DispLibLocalFogWrapper_SetLocalFogParameter::WindDir' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.IsWeatherAvailable
// 0x0028 (0x0028 - 0x0000)
struct BWC_DispLibDynamicEnvManager_IsWeatherAvailable final
{
public:
	EBGW_DispLibEnvWeather                        InWeather;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_IsWeatherAvailable) == 0x000008, "Wrong alignment on BWC_DispLibDynamicEnvManager_IsWeatherAvailable");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_IsWeatherAvailable) == 0x000028, "Wrong size on BWC_DispLibDynamicEnvManager_IsWeatherAvailable");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_IsWeatherAvailable, InWeather) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_IsWeatherAvailable::InWeather' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_IsWeatherAvailable, ViewLocation) == 0x000008, "Member 'BWC_DispLibDynamicEnvManager_IsWeatherAvailable::ViewLocation' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_IsWeatherAvailable, ReturnValue) == 0x000020, "Member 'BWC_DispLibDynamicEnvManager_IsWeatherAvailable::ReturnValue' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.OnApplyEnvSettings
// 0x0001 (0x0001 - 0x0000)
struct BWC_DispLibDynamicEnvManager_OnApplyEnvSettings final
{
public:
	bool                                          IsNight;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_OnApplyEnvSettings) == 0x000001, "Wrong alignment on BWC_DispLibDynamicEnvManager_OnApplyEnvSettings");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_OnApplyEnvSettings) == 0x000001, "Wrong size on BWC_DispLibDynamicEnvManager_OnApplyEnvSettings");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OnApplyEnvSettings, IsNight) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_OnApplyEnvSettings::IsNight' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.OnLerpEnvSettings
// 0x01F0 (0x01F0 - 0x0000)
struct BWC_DispLibDynamicEnvManager_OnLerpEnvSettings final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBWC_DispLibEnvSettings                Src;                                               // 0x0010(0x01E0)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_OnLerpEnvSettings) == 0x000010, "Wrong alignment on BWC_DispLibDynamicEnvManager_OnLerpEnvSettings");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_OnLerpEnvSettings) == 0x0001F0, "Wrong size on BWC_DispLibDynamicEnvManager_OnLerpEnvSettings");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OnLerpEnvSettings, Weight) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_OnLerpEnvSettings::Weight' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OnLerpEnvSettings, InTime) == 0x000004, "Member 'BWC_DispLibDynamicEnvManager_OnLerpEnvSettings::InTime' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OnLerpEnvSettings, Src) == 0x000010, "Member 'BWC_DispLibDynamicEnvManager_OnLerpEnvSettings::Src' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.OnTickEnvVolume
// 0x0200 (0x0200 - 0x0000)
struct BWC_DispLibDynamicEnvManager_OnTickEnvVolume final
{
public:
	struct FBWC_DispLibEnvSettings                EnvSettings;                                       // 0x0000(0x01E0)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x01E0(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime;                                            // 0x01F8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_OnTickEnvVolume) == 0x000010, "Wrong alignment on BWC_DispLibDynamicEnvManager_OnTickEnvVolume");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_OnTickEnvVolume) == 0x000200, "Wrong size on BWC_DispLibDynamicEnvManager_OnTickEnvVolume");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OnTickEnvVolume, EnvSettings) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_OnTickEnvVolume::EnvSettings' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OnTickEnvVolume, ViewLocation) == 0x0001E0, "Member 'BWC_DispLibDynamicEnvManager_OnTickEnvVolume::ViewLocation' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OnTickEnvVolume, InTime) == 0x0001F8, "Member 'BWC_DispLibDynamicEnvManager_OnTickEnvVolume::InTime' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.OnWeatherChanged
// 0x0018 (0x0018 - 0x0000)
struct BWC_DispLibDynamicEnvManager_OnWeatherChanged final
{
public:
	struct FVector                                CameraLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_OnWeatherChanged) == 0x000008, "Wrong alignment on BWC_DispLibDynamicEnvManager_OnWeatherChanged");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_OnWeatherChanged) == 0x000018, "Wrong size on BWC_DispLibDynamicEnvManager_OnWeatherChanged");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OnWeatherChanged, CameraLocation) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_OnWeatherChanged::CameraLocation' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.OverrideEnvSettings
// 0x03D0 (0x03D0 - 0x0000)
struct BWC_DispLibDynamicEnvManager_OverrideEnvSettings final
{
public:
	struct FBWC_DispLibEnvSettings                Src;                                               // 0x0000(0x01E0)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FBWC_DispLibEnvSettings                Dest;                                              // 0x01E0(0x01E0)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x03C0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0xC];                                      // 0x03C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_OverrideEnvSettings) == 0x000010, "Wrong alignment on BWC_DispLibDynamicEnvManager_OverrideEnvSettings");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_OverrideEnvSettings) == 0x0003D0, "Wrong size on BWC_DispLibDynamicEnvManager_OverrideEnvSettings");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OverrideEnvSettings, Src) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_OverrideEnvSettings::Src' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OverrideEnvSettings, Dest) == 0x0001E0, "Member 'BWC_DispLibDynamicEnvManager_OverrideEnvSettings::Dest' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_OverrideEnvSettings, Weight) == 0x0003C0, "Member 'BWC_DispLibDynamicEnvManager_OverrideEnvSettings::Weight' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.RandomWeather
// 0x0020 (0x0020 - 0x0000)
struct BWC_DispLibDynamicEnvManager_RandomWeather final
{
public:
	struct FVector                                ViewLocation;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGW_DispLibEnvWeather                        ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_RandomWeather) == 0x000008, "Wrong alignment on BWC_DispLibDynamicEnvManager_RandomWeather");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_RandomWeather) == 0x000020, "Wrong size on BWC_DispLibDynamicEnvManager_RandomWeather");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_RandomWeather, ViewLocation) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_RandomWeather::ViewLocation' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_RandomWeather, ReturnValue) == 0x000018, "Member 'BWC_DispLibDynamicEnvManager_RandomWeather::ReturnValue' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.SetEnvSettings
// 0x0020 (0x0020 - 0x0000)
struct BWC_DispLibDynamicEnvManager_SetEnvSettings final
{
public:
	bool                                          IsNight;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CameraLocation;                                    // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_SetEnvSettings) == 0x000008, "Wrong alignment on BWC_DispLibDynamicEnvManager_SetEnvSettings");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_SetEnvSettings) == 0x000020, "Wrong size on BWC_DispLibDynamicEnvManager_SetEnvSettings");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_SetEnvSettings, IsNight) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_SetEnvSettings::IsNight' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_SetEnvSettings, CameraLocation) == 0x000008, "Member 'BWC_DispLibDynamicEnvManager_SetEnvSettings::CameraLocation' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.SetWeather
// 0x0001 (0x0001 - 0x0000)
struct BWC_DispLibDynamicEnvManager_SetWeather final
{
public:
	EBGW_DispLibEnvWeather                        InWeather;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_SetWeather) == 0x000001, "Wrong alignment on BWC_DispLibDynamicEnvManager_SetWeather");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_SetWeather) == 0x000001, "Wrong size on BWC_DispLibDynamicEnvManager_SetWeather");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_SetWeather, InWeather) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_SetWeather::InWeather' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.SwithToNarrative
// 0x0008 (0x0008 - 0x0000)
struct BWC_DispLibDynamicEnvManager_SwithToNarrative final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeDuration;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_SwithToNarrative) == 0x000004, "Wrong alignment on BWC_DispLibDynamicEnvManager_SwithToNarrative");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_SwithToNarrative) == 0x000008, "Wrong size on BWC_DispLibDynamicEnvManager_SwithToNarrative");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_SwithToNarrative, Enable) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_SwithToNarrative::Enable' has a wrong offset!");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_SwithToNarrative, ChangeDuration) == 0x000004, "Member 'BWC_DispLibDynamicEnvManager_SwithToNarrative::ChangeDuration' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.UpdateEnvSystemConfig
// 0x0008 (0x0008 - 0x0000)
struct BWC_DispLibDynamicEnvManager_UpdateEnvSystemConfig final
{
public:
	class UBWS_DispLibEnvSystemConf*              SystemConf;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_UpdateEnvSystemConfig) == 0x000008, "Wrong alignment on BWC_DispLibDynamicEnvManager_UpdateEnvSystemConfig");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_UpdateEnvSystemConfig) == 0x000008, "Wrong size on BWC_DispLibDynamicEnvManager_UpdateEnvSystemConfig");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_UpdateEnvSystemConfig, SystemConf) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_UpdateEnvSystemConfig::SystemConf' has a wrong offset!");

// Function b1.BWC_DispLibDynamicEnvManager.UpdateSunAndMoonAngle
// 0x01E0 (0x01E0 - 0x0000)
struct BWC_DispLibDynamicEnvManager_UpdateSunAndMoonAngle final
{
public:
	struct FBWC_DispLibEnvSettings                Settings;                                          // 0x0000(0x01E0)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BWC_DispLibDynamicEnvManager_UpdateSunAndMoonAngle) == 0x000010, "Wrong alignment on BWC_DispLibDynamicEnvManager_UpdateSunAndMoonAngle");
static_assert(sizeof(BWC_DispLibDynamicEnvManager_UpdateSunAndMoonAngle) == 0x0001E0, "Wrong size on BWC_DispLibDynamicEnvManager_UpdateSunAndMoonAngle");
static_assert(offsetof(BWC_DispLibDynamicEnvManager_UpdateSunAndMoonAngle, Settings) == 0x000000, "Member 'BWC_DispLibDynamicEnvManager_UpdateSunAndMoonAngle::Settings' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWAddLevelToBlackList
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWAddLevelToBlackList final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InLevelName;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_BGWAddLevelToBlackList) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWAddLevelToBlackList");
static_assert(sizeof(BGWFunctionLibrary_BGWAddLevelToBlackList) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWAddLevelToBlackList");
static_assert(offsetof(BGWFunctionLibrary_BGWAddLevelToBlackList, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWAddLevelToBlackList::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWAddLevelToBlackList, InLevelName) == 0x000008, "Member 'BGWFunctionLibrary_BGWAddLevelToBlackList::InLevelName' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWAddLevelToWhiteList
// 0x0018 (0x0018 - 0x0000)
struct BGWFunctionLibrary_BGWAddLevelToWhiteList final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InLevelName;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGWStreamingVolumeUsage                      InUsage;                                           // 0x0010(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWFunctionLibrary_BGWAddLevelToWhiteList) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWAddLevelToWhiteList");
static_assert(sizeof(BGWFunctionLibrary_BGWAddLevelToWhiteList) == 0x000018, "Wrong size on BGWFunctionLibrary_BGWAddLevelToWhiteList");
static_assert(offsetof(BGWFunctionLibrary_BGWAddLevelToWhiteList, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWAddLevelToWhiteList::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWAddLevelToWhiteList, InLevelName) == 0x000008, "Member 'BGWFunctionLibrary_BGWAddLevelToWhiteList::InLevelName' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWAddLevelToWhiteList, InUsage) == 0x000010, "Member 'BGWFunctionLibrary_BGWAddLevelToWhiteList::InUsage' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWFindWorldInPackage
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWFindWorldInPackage final
{
public:
	class UPackage*                               Package;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_BGWFindWorldInPackage) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWFindWorldInPackage");
static_assert(sizeof(BGWFunctionLibrary_BGWFindWorldInPackage) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWFindWorldInPackage");
static_assert(offsetof(BGWFunctionLibrary_BGWFindWorldInPackage, Package) == 0x000000, "Member 'BGWFunctionLibrary_BGWFindWorldInPackage::Package' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWFindWorldInPackage, ReturnValue) == 0x000008, "Member 'BGWFunctionLibrary_BGWFindWorldInPackage::ReturnValue' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWGetAllStreamingLevels
// 0x0018 (0x0018 - 0x0000)
struct BGWFunctionLibrary_BGWGetAllStreamingLevels final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULevelStreaming*>                ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_BGWGetAllStreamingLevels) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWGetAllStreamingLevels");
static_assert(sizeof(BGWFunctionLibrary_BGWGetAllStreamingLevels) == 0x000018, "Wrong size on BGWFunctionLibrary_BGWGetAllStreamingLevels");
static_assert(offsetof(BGWFunctionLibrary_BGWGetAllStreamingLevels, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWGetAllStreamingLevels::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWGetAllStreamingLevels, ReturnValue) == 0x000008, "Member 'BGWFunctionLibrary_BGWGetAllStreamingLevels::ReturnValue' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWGetAlwaysCookPathList
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWGetAlwaysCookPathList final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_BGWGetAlwaysCookPathList) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWGetAlwaysCookPathList");
static_assert(sizeof(BGWFunctionLibrary_BGWGetAlwaysCookPathList) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWGetAlwaysCookPathList");
static_assert(offsetof(BGWFunctionLibrary_BGWGetAlwaysCookPathList, ReturnValue) == 0x000000, "Member 'BGWFunctionLibrary_BGWGetAlwaysCookPathList::ReturnValue' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWGetIsCameraMoveableWhenPaused
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused");
static_assert(sizeof(BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused");
static_assert(offsetof(BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused, ReturnValue) == 0x000008, "Member 'BGWFunctionLibrary_BGWGetIsCameraMoveableWhenPaused::ReturnValue' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWGetStatusChangedStreamingLevels
// 0x0058 (0x0058 - 0x0000)
struct BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class ULevelStreaming*, struct FGSStreamingLevelLoadSetting> OutStreamingLevels;                                // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels");
static_assert(sizeof(BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels) == 0x000058, "Wrong size on BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels");
static_assert(offsetof(BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels, OutStreamingLevels) == 0x000008, "Member 'BGWFunctionLibrary_BGWGetStatusChangedStreamingLevels::OutStreamingLevels' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWProcessLevelStreamingVolumes
// 0x0028 (0x0028 - 0x0000)
struct BGWFunctionLibrary_BGWProcessLevelStreamingVolumes final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OverrideViewLocation;                              // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideViewLocation;                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWFunctionLibrary_BGWProcessLevelStreamingVolumes) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWProcessLevelStreamingVolumes");
static_assert(sizeof(BGWFunctionLibrary_BGWProcessLevelStreamingVolumes) == 0x000028, "Wrong size on BGWFunctionLibrary_BGWProcessLevelStreamingVolumes");
static_assert(offsetof(BGWFunctionLibrary_BGWProcessLevelStreamingVolumes, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWProcessLevelStreamingVolumes::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWProcessLevelStreamingVolumes, OverrideViewLocation) == 0x000008, "Member 'BGWFunctionLibrary_BGWProcessLevelStreamingVolumes::OverrideViewLocation' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWProcessLevelStreamingVolumes, bUseOverrideViewLocation) == 0x000020, "Member 'BGWFunctionLibrary_BGWProcessLevelStreamingVolumes::bUseOverrideViewLocation' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWRemoveLevelFromBlackList
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWRemoveLevelFromBlackList final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InLevelName;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_BGWRemoveLevelFromBlackList) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWRemoveLevelFromBlackList");
static_assert(sizeof(BGWFunctionLibrary_BGWRemoveLevelFromBlackList) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWRemoveLevelFromBlackList");
static_assert(offsetof(BGWFunctionLibrary_BGWRemoveLevelFromBlackList, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWRemoveLevelFromBlackList::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWRemoveLevelFromBlackList, InLevelName) == 0x000008, "Member 'BGWFunctionLibrary_BGWRemoveLevelFromBlackList::InLevelName' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWRemoveLevelFromWhiteList
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWRemoveLevelFromWhiteList final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InLevelName;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_BGWRemoveLevelFromWhiteList) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWRemoveLevelFromWhiteList");
static_assert(sizeof(BGWFunctionLibrary_BGWRemoveLevelFromWhiteList) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWRemoveLevelFromWhiteList");
static_assert(offsetof(BGWFunctionLibrary_BGWRemoveLevelFromWhiteList, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWRemoveLevelFromWhiteList::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWRemoveLevelFromWhiteList, InLevelName) == 0x000008, "Member 'BGWFunctionLibrary_BGWRemoveLevelFromWhiteList::InLevelName' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWRequestAsyncLoad
// 0x0028 (0x0028 - 0x0000)
struct BGWFunctionLibrary_BGWRequestAsyncLoad final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                LoadList;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             CallBackDelegate;                                  // 0x0018(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_BGWRequestAsyncLoad) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWRequestAsyncLoad");
static_assert(sizeof(BGWFunctionLibrary_BGWRequestAsyncLoad) == 0x000028, "Wrong size on BGWFunctionLibrary_BGWRequestAsyncLoad");
static_assert(offsetof(BGWFunctionLibrary_BGWRequestAsyncLoad, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWRequestAsyncLoad::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWRequestAsyncLoad, LoadList) == 0x000008, "Member 'BGWFunctionLibrary_BGWRequestAsyncLoad::LoadList' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWRequestAsyncLoad, CallBackDelegate) == 0x000018, "Member 'BGWFunctionLibrary_BGWRequestAsyncLoad::CallBackDelegate' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWSetAllLevelStreamingVolumeEnabled
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled");
static_assert(sizeof(BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled");
static_assert(offsetof(BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled, bEnabled) == 0x000008, "Member 'BGWFunctionLibrary_BGWSetAllLevelStreamingVolumeEnabled::bEnabled' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWSetGamePaused
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWSetGamePaused final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWFunctionLibrary_BGWSetGamePaused) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWSetGamePaused");
static_assert(sizeof(BGWFunctionLibrary_BGWSetGamePaused) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWSetGamePaused");
static_assert(offsetof(BGWFunctionLibrary_BGWSetGamePaused, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWSetGamePaused::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWSetGamePaused, bPaused) == 0x000008, "Member 'BGWFunctionLibrary_BGWSetGamePaused::bPaused' has a wrong offset!");

// Function b1.BGWFunctionLibrary.BGWSetIsCameraMoveableWhenPaused
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCameraMoveable;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused) == 0x000008, "Wrong alignment on BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused");
static_assert(sizeof(BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused) == 0x000010, "Wrong size on BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused");
static_assert(offsetof(BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused, IsCameraMoveable) == 0x000008, "Member 'BGWFunctionLibrary_BGWSetIsCameraMoveableWhenPaused::IsCameraMoveable' has a wrong offset!");

// Function b1.BGWFunctionLibrary.GetBGWEvents
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_GetBGWEvents final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class b1::UBGW_EventCollection*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_GetBGWEvents) == 0x000008, "Wrong alignment on BGWFunctionLibrary_GetBGWEvents");
static_assert(sizeof(BGWFunctionLibrary_GetBGWEvents) == 0x000010, "Wrong size on BGWFunctionLibrary_GetBGWEvents");
static_assert(offsetof(BGWFunctionLibrary_GetBGWEvents, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_GetBGWEvents::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_GetBGWEvents, ReturnValue) == 0x000008, "Member 'BGWFunctionLibrary_GetBGWEvents::ReturnValue' has a wrong offset!");

// Function b1.BGWFunctionLibrary.GetLevelStreamingAssetName
// 0x0018 (0x0018 - 0x0000)
struct BGWFunctionLibrary_GetLevelStreamingAssetName final
{
public:
	class ULevelStreaming*                        LevelStreaming;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_GetLevelStreamingAssetName) == 0x000008, "Wrong alignment on BGWFunctionLibrary_GetLevelStreamingAssetName");
static_assert(sizeof(BGWFunctionLibrary_GetLevelStreamingAssetName) == 0x000018, "Wrong size on BGWFunctionLibrary_GetLevelStreamingAssetName");
static_assert(offsetof(BGWFunctionLibrary_GetLevelStreamingAssetName, LevelStreaming) == 0x000000, "Member 'BGWFunctionLibrary_GetLevelStreamingAssetName::LevelStreaming' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_GetLevelStreamingAssetName, ReturnValue) == 0x000008, "Member 'BGWFunctionLibrary_GetLevelStreamingAssetName::ReturnValue' has a wrong offset!");

// Function b1.BGWFunctionLibrary.IsDistanceStreamingValid
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_IsDistanceStreamingValid final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWFunctionLibrary_IsDistanceStreamingValid) == 0x000008, "Wrong alignment on BGWFunctionLibrary_IsDistanceStreamingValid");
static_assert(sizeof(BGWFunctionLibrary_IsDistanceStreamingValid) == 0x000010, "Wrong size on BGWFunctionLibrary_IsDistanceStreamingValid");
static_assert(offsetof(BGWFunctionLibrary_IsDistanceStreamingValid, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_IsDistanceStreamingValid::WorldContextObject' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_IsDistanceStreamingValid, ReturnValue) == 0x000008, "Member 'BGWFunctionLibrary_IsDistanceStreamingValid::ReturnValue' has a wrong offset!");

// Function b1.BGWFunctionLibrary.MaintainVolumesContainYuanjing
// 0x0010 (0x0010 - 0x0000)
struct BGWFunctionLibrary_MaintainVolumesContainYuanjing final
{
public:
	TArray<class ABGWLevelStreamingVolume*>       InStreamingVolumes;                                // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_MaintainVolumesContainYuanjing) == 0x000008, "Wrong alignment on BGWFunctionLibrary_MaintainVolumesContainYuanjing");
static_assert(sizeof(BGWFunctionLibrary_MaintainVolumesContainYuanjing) == 0x000010, "Wrong size on BGWFunctionLibrary_MaintainVolumesContainYuanjing");
static_assert(offsetof(BGWFunctionLibrary_MaintainVolumesContainYuanjing, InStreamingVolumes) == 0x000000, "Member 'BGWFunctionLibrary_MaintainVolumesContainYuanjing::InStreamingVolumes' has a wrong offset!");

// Function b1.BGWFunctionLibrary.PauseBGWVolumeLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct BGWFunctionLibrary_PauseBGWVolumeLevelStreaming final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_PauseBGWVolumeLevelStreaming) == 0x000008, "Wrong alignment on BGWFunctionLibrary_PauseBGWVolumeLevelStreaming");
static_assert(sizeof(BGWFunctionLibrary_PauseBGWVolumeLevelStreaming) == 0x000008, "Wrong size on BGWFunctionLibrary_PauseBGWVolumeLevelStreaming");
static_assert(offsetof(BGWFunctionLibrary_PauseBGWVolumeLevelStreaming, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_PauseBGWVolumeLevelStreaming::WorldContextObject' has a wrong offset!");

// Function b1.BGWFunctionLibrary.ResumeBGWVolumeLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct BGWFunctionLibrary_ResumeBGWVolumeLevelStreaming final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_ResumeBGWVolumeLevelStreaming) == 0x000008, "Wrong alignment on BGWFunctionLibrary_ResumeBGWVolumeLevelStreaming");
static_assert(sizeof(BGWFunctionLibrary_ResumeBGWVolumeLevelStreaming) == 0x000008, "Wrong size on BGWFunctionLibrary_ResumeBGWVolumeLevelStreaming");
static_assert(offsetof(BGWFunctionLibrary_ResumeBGWVolumeLevelStreaming, WorldContextObject) == 0x000000, "Member 'BGWFunctionLibrary_ResumeBGWVolumeLevelStreaming::WorldContextObject' has a wrong offset!");

// Function b1.BGWFunctionLibrary.RetargetLevelStreamingLevelNames
// 0x0038 (0x0038 - 0x0000)
struct BGWFunctionLibrary_RetargetLevelStreamingLevelNames final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SourceNames;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DestNames;                                         // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelPrefix;                                       // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWFunctionLibrary_RetargetLevelStreamingLevelNames) == 0x000008, "Wrong alignment on BGWFunctionLibrary_RetargetLevelStreamingLevelNames");
static_assert(sizeof(BGWFunctionLibrary_RetargetLevelStreamingLevelNames) == 0x000038, "Wrong size on BGWFunctionLibrary_RetargetLevelStreamingLevelNames");
static_assert(offsetof(BGWFunctionLibrary_RetargetLevelStreamingLevelNames, WorldContext) == 0x000000, "Member 'BGWFunctionLibrary_RetargetLevelStreamingLevelNames::WorldContext' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_RetargetLevelStreamingLevelNames, SourceNames) == 0x000008, "Member 'BGWFunctionLibrary_RetargetLevelStreamingLevelNames::SourceNames' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_RetargetLevelStreamingLevelNames, DestNames) == 0x000018, "Member 'BGWFunctionLibrary_RetargetLevelStreamingLevelNames::DestNames' has a wrong offset!");
static_assert(offsetof(BGWFunctionLibrary_RetargetLevelStreamingLevelNames, LevelPrefix) == 0x000028, "Member 'BGWFunctionLibrary_RetargetLevelStreamingLevelNames::LevelPrefix' has a wrong offset!");

// Function b1.BGWGameInstance.BeginToggleLoadingTips
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_BeginToggleLoadingTips final
{
public:
	class UGSInputComponent*                      InputComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_BeginToggleLoadingTips) == 0x000008, "Wrong alignment on BGWGameInstance_BeginToggleLoadingTips");
static_assert(sizeof(BGWGameInstance_BeginToggleLoadingTips) == 0x000008, "Wrong size on BGWGameInstance_BeginToggleLoadingTips");
static_assert(offsetof(BGWGameInstance_BeginToggleLoadingTips, InputComponent) == 0x000000, "Member 'BGWGameInstance_BeginToggleLoadingTips::InputComponent' has a wrong offset!");

// Function b1.BGWGameInstance.CanFadeAway
// 0x0001 (0x0001 - 0x0000)
struct BGWGameInstance_CanFadeAway final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_CanFadeAway) == 0x000001, "Wrong alignment on BGWGameInstance_CanFadeAway");
static_assert(sizeof(BGWGameInstance_CanFadeAway) == 0x000001, "Wrong size on BGWGameInstance_CanFadeAway");
static_assert(offsetof(BGWGameInstance_CanFadeAway, ReturnValue) == 0x000000, "Member 'BGWGameInstance_CanFadeAway::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetCurLoadingScreenState
// 0x0001 (0x0001 - 0x0000)
struct BGWGameInstance_GetCurLoadingScreenState final
{
public:
	EGSLoadingScreenState                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetCurLoadingScreenState) == 0x000001, "Wrong alignment on BGWGameInstance_GetCurLoadingScreenState");
static_assert(sizeof(BGWGameInstance_GetCurLoadingScreenState) == 0x000001, "Wrong size on BGWGameInstance_GetCurLoadingScreenState");
static_assert(offsetof(BGWGameInstance_GetCurLoadingScreenState, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetCurLoadingScreenState::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetCurLoadingScreenType
// 0x0001 (0x0001 - 0x0000)
struct BGWGameInstance_GetCurLoadingScreenType final
{
public:
	EGSLoadingScreenType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetCurLoadingScreenType) == 0x000001, "Wrong alignment on BGWGameInstance_GetCurLoadingScreenType");
static_assert(sizeof(BGWGameInstance_GetCurLoadingScreenType) == 0x000001, "Wrong size on BGWGameInstance_GetCurLoadingScreenType");
static_assert(offsetof(BGWGameInstance_GetCurLoadingScreenType, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetCurLoadingScreenType::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetEvents
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_GetEvents final
{
public:
	class b1::UBGW_EventCollection*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetEvents) == 0x000008, "Wrong alignment on BGWGameInstance_GetEvents");
static_assert(sizeof(BGWGameInstance_GetEvents) == 0x000008, "Wrong size on BGWGameInstance_GetEvents");
static_assert(offsetof(BGWGameInstance_GetEvents, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetEvents::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetFirstGamePlayerForCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_GetFirstGamePlayerForCS final
{
public:
	class ULocalPlayer*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetFirstGamePlayerForCS) == 0x000008, "Wrong alignment on BGWGameInstance_GetFirstGamePlayerForCS");
static_assert(sizeof(BGWGameInstance_GetFirstGamePlayerForCS) == 0x000008, "Wrong size on BGWGameInstance_GetFirstGamePlayerForCS");
static_assert(offsetof(BGWGameInstance_GetFirstGamePlayerForCS, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetFirstGamePlayerForCS::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetLastUseTips
// 0x0010 (0x0010 - 0x0000)
struct BGWGameInstance_GetLastUseTips final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetLastUseTips) == 0x000008, "Wrong alignment on BGWGameInstance_GetLastUseTips");
static_assert(sizeof(BGWGameInstance_GetLastUseTips) == 0x000010, "Wrong size on BGWGameInstance_GetLastUseTips");
static_assert(offsetof(BGWGameInstance_GetLastUseTips, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetLastUseTips::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetOnlineSessionClassCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_GetOnlineSessionClassCS final
{
public:
	TSubclassOf<class UOnlineSession>             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetOnlineSessionClassCS) == 0x000008, "Wrong alignment on BGWGameInstance_GetOnlineSessionClassCS");
static_assert(sizeof(BGWGameInstance_GetOnlineSessionClassCS) == 0x000008, "Wrong size on BGWGameInstance_GetOnlineSessionClassCS");
static_assert(offsetof(BGWGameInstance_GetOnlineSessionClassCS, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetOnlineSessionClassCS::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetTimeInMSSinceLoadingOpen
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_GetTimeInMSSinceLoadingOpen final
{
public:
	double                                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetTimeInMSSinceLoadingOpen) == 0x000008, "Wrong alignment on BGWGameInstance_GetTimeInMSSinceLoadingOpen");
static_assert(sizeof(BGWGameInstance_GetTimeInMSSinceLoadingOpen) == 0x000008, "Wrong size on BGWGameInstance_GetTimeInMSSinceLoadingOpen");
static_assert(offsetof(BGWGameInstance_GetTimeInMSSinceLoadingOpen, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetTimeInMSSinceLoadingOpen::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetTravelURLForCS
// 0x0010 (0x0010 - 0x0000)
struct BGWGameInstance_GetTravelURLForCS final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetTravelURLForCS) == 0x000008, "Wrong alignment on BGWGameInstance_GetTravelURLForCS");
static_assert(sizeof(BGWGameInstance_GetTravelURLForCS) == 0x000010, "Wrong size on BGWGameInstance_GetTravelURLForCS");
static_assert(offsetof(BGWGameInstance_GetTravelURLForCS, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetTravelURLForCS::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetTravelURLHost
// 0x0010 (0x0010 - 0x0000)
struct BGWGameInstance_GetTravelURLHost final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetTravelURLHost) == 0x000008, "Wrong alignment on BGWGameInstance_GetTravelURLHost");
static_assert(sizeof(BGWGameInstance_GetTravelURLHost) == 0x000010, "Wrong size on BGWGameInstance_GetTravelURLHost");
static_assert(offsetof(BGWGameInstance_GetTravelURLHost, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetTravelURLHost::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.GetWorldForCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_GetWorldForCS final
{
public:
	class UWorld*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_GetWorldForCS) == 0x000008, "Wrong alignment on BGWGameInstance_GetWorldForCS");
static_assert(sizeof(BGWGameInstance_GetWorldForCS) == 0x000008, "Wrong size on BGWGameInstance_GetWorldForCS");
static_assert(offsetof(BGWGameInstance_GetWorldForCS, ReturnValue) == 0x000000, "Member 'BGWGameInstance_GetWorldForCS::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.IsLoadingScreenFadeAwayFinish
// 0x0001 (0x0001 - 0x0000)
struct BGWGameInstance_IsLoadingScreenFadeAwayFinish final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_IsLoadingScreenFadeAwayFinish) == 0x000001, "Wrong alignment on BGWGameInstance_IsLoadingScreenFadeAwayFinish");
static_assert(sizeof(BGWGameInstance_IsLoadingScreenFadeAwayFinish) == 0x000001, "Wrong size on BGWGameInstance_IsLoadingScreenFadeAwayFinish");
static_assert(offsetof(BGWGameInstance_IsLoadingScreenFadeAwayFinish, ReturnValue) == 0x000000, "Member 'BGWGameInstance_IsLoadingScreenFadeAwayFinish::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.IsToggleLoadingTipsFinish
// 0x0001 (0x0001 - 0x0000)
struct BGWGameInstance_IsToggleLoadingTipsFinish final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_IsToggleLoadingTipsFinish) == 0x000001, "Wrong alignment on BGWGameInstance_IsToggleLoadingTipsFinish");
static_assert(sizeof(BGWGameInstance_IsToggleLoadingTipsFinish) == 0x000001, "Wrong size on BGWGameInstance_IsToggleLoadingTipsFinish");
static_assert(offsetof(BGWGameInstance_IsToggleLoadingTipsFinish, ReturnValue) == 0x000000, "Member 'BGWGameInstance_IsToggleLoadingTipsFinish::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.OnGameModeMatchStateSetCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_OnGameModeMatchStateSetCS final
{
public:
	class FName                                   NewMatchState;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_OnGameModeMatchStateSetCS) == 0x000004, "Wrong alignment on BGWGameInstance_OnGameModeMatchStateSetCS");
static_assert(sizeof(BGWGameInstance_OnGameModeMatchStateSetCS) == 0x000008, "Wrong size on BGWGameInstance_OnGameModeMatchStateSetCS");
static_assert(offsetof(BGWGameInstance_OnGameModeMatchStateSetCS, NewMatchState) == 0x000000, "Member 'BGWGameInstance_OnGameModeMatchStateSetCS::NewMatchState' has a wrong offset!");

// Function b1.BGWGameInstance.OnPostActorTickCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_OnPostActorTickCS final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_OnPostActorTickCS) == 0x000008, "Wrong alignment on BGWGameInstance_OnPostActorTickCS");
static_assert(sizeof(BGWGameInstance_OnPostActorTickCS) == 0x000008, "Wrong size on BGWGameInstance_OnPostActorTickCS");
static_assert(offsetof(BGWGameInstance_OnPostActorTickCS, World) == 0x000000, "Member 'BGWGameInstance_OnPostActorTickCS::World' has a wrong offset!");

// Function b1.BGWGameInstance.OnWorldChangedCS
// 0x0010 (0x0010 - 0x0000)
struct BGWGameInstance_OnWorldChangedCS final
{
public:
	class UWorld*                                 OldWorld;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 NewWorld;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_OnWorldChangedCS) == 0x000008, "Wrong alignment on BGWGameInstance_OnWorldChangedCS");
static_assert(sizeof(BGWGameInstance_OnWorldChangedCS) == 0x000010, "Wrong size on BGWGameInstance_OnWorldChangedCS");
static_assert(offsetof(BGWGameInstance_OnWorldChangedCS, OldWorld) == 0x000000, "Member 'BGWGameInstance_OnWorldChangedCS::OldWorld' has a wrong offset!");
static_assert(offsetof(BGWGameInstance_OnWorldChangedCS, NewWorld) == 0x000008, "Member 'BGWGameInstance_OnWorldChangedCS::NewWorld' has a wrong offset!");

// Function b1.BGWGameInstance.OnWorldTickStartCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_OnWorldTickStartCS final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_OnWorldTickStartCS) == 0x000008, "Wrong alignment on BGWGameInstance_OnWorldTickStartCS");
static_assert(sizeof(BGWGameInstance_OnWorldTickStartCS) == 0x000008, "Wrong size on BGWGameInstance_OnWorldTickStartCS");
static_assert(offsetof(BGWGameInstance_OnWorldTickStartCS, World) == 0x000000, "Member 'BGWGameInstance_OnWorldTickStartCS::World' has a wrong offset!");

// Function b1.BGWGameInstance.OpenLoadingScreen
// 0x0002 (0x0002 - 0x0000)
struct BGWGameInstance_OpenLoadingScreen final
{
public:
	bool                                          UseSlateThread;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSLoadingScreenType                          LoadingScreenType;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_OpenLoadingScreen) == 0x000001, "Wrong alignment on BGWGameInstance_OpenLoadingScreen");
static_assert(sizeof(BGWGameInstance_OpenLoadingScreen) == 0x000002, "Wrong size on BGWGameInstance_OpenLoadingScreen");
static_assert(offsetof(BGWGameInstance_OpenLoadingScreen, UseSlateThread) == 0x000000, "Member 'BGWGameInstance_OpenLoadingScreen::UseSlateThread' has a wrong offset!");
static_assert(offsetof(BGWGameInstance_OpenLoadingScreen, LoadingScreenType) == 0x000001, "Member 'BGWGameInstance_OpenLoadingScreen::LoadingScreenType' has a wrong offset!");

// Function b1.BGWGameInstance.ReceiveTick
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_ReceiveTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickGroup;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_ReceiveTick) == 0x000004, "Wrong alignment on BGWGameInstance_ReceiveTick");
static_assert(sizeof(BGWGameInstance_ReceiveTick) == 0x000008, "Wrong size on BGWGameInstance_ReceiveTick");
static_assert(offsetof(BGWGameInstance_ReceiveTick, DeltaSeconds) == 0x000000, "Member 'BGWGameInstance_ReceiveTick::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(BGWGameInstance_ReceiveTick, TickGroup) == 0x000004, "Member 'BGWGameInstance_ReceiveTick::TickGroup' has a wrong offset!");

// Function b1.BGWGameInstance.ReceiveTickEvenWhenPaused
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_ReceiveTickEvenWhenPaused final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickGroup;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_ReceiveTickEvenWhenPaused) == 0x000004, "Wrong alignment on BGWGameInstance_ReceiveTickEvenWhenPaused");
static_assert(sizeof(BGWGameInstance_ReceiveTickEvenWhenPaused) == 0x000008, "Wrong size on BGWGameInstance_ReceiveTickEvenWhenPaused");
static_assert(offsetof(BGWGameInstance_ReceiveTickEvenWhenPaused, DeltaSeconds) == 0x000000, "Member 'BGWGameInstance_ReceiveTickEvenWhenPaused::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(BGWGameInstance_ReceiveTickEvenWhenPaused, TickGroup) == 0x000004, "Member 'BGWGameInstance_ReceiveTickEvenWhenPaused::TickGroup' has a wrong offset!");

// Function b1.BGWGameInstance.RegisterChapterInfo
// 0x0040 (0x0040 - 0x0000)
struct BGWGameInstance_RegisterChapterInfo final
{
public:
	struct FChapterInfo                           ChapterInfo;                                       // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_RegisterChapterInfo) == 0x000008, "Wrong alignment on BGWGameInstance_RegisterChapterInfo");
static_assert(sizeof(BGWGameInstance_RegisterChapterInfo) == 0x000040, "Wrong size on BGWGameInstance_RegisterChapterInfo");
static_assert(offsetof(BGWGameInstance_RegisterChapterInfo, ChapterInfo) == 0x000000, "Member 'BGWGameInstance_RegisterChapterInfo::ChapterInfo' has a wrong offset!");

// Function b1.BGWGameInstance.RegisterLoadingTipsInfo
// 0x0040 (0x0040 - 0x0000)
struct BGWGameInstance_RegisterLoadingTipsInfo final
{
public:
	struct FLoadingTipsInfo                       TipsInfo;                                          // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_RegisterLoadingTipsInfo) == 0x000008, "Wrong alignment on BGWGameInstance_RegisterLoadingTipsInfo");
static_assert(sizeof(BGWGameInstance_RegisterLoadingTipsInfo) == 0x000040, "Wrong size on BGWGameInstance_RegisterLoadingTipsInfo");
static_assert(offsetof(BGWGameInstance_RegisterLoadingTipsInfo, TipsInfo) == 0x000000, "Member 'BGWGameInstance_RegisterLoadingTipsInfo::TipsInfo' has a wrong offset!");

// Function b1.BGWGameInstance.RegisterLoadingTipsMask
// 0x0008 (0x0008 - 0x0000)
struct BGWGameInstance_RegisterLoadingTipsMask final
{
public:
	class UTexture2D*                             MaskTexture;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_RegisterLoadingTipsMask) == 0x000008, "Wrong alignment on BGWGameInstance_RegisterLoadingTipsMask");
static_assert(sizeof(BGWGameInstance_RegisterLoadingTipsMask) == 0x000008, "Wrong size on BGWGameInstance_RegisterLoadingTipsMask");
static_assert(offsetof(BGWGameInstance_RegisterLoadingTipsMask, MaskTexture) == 0x000000, "Member 'BGWGameInstance_RegisterLoadingTipsMask::MaskTexture' has a wrong offset!");

// Function b1.BGWGameInstance.StartGameInstanceForCS
// 0x0001 (0x0001 - 0x0000)
struct BGWGameInstance_StartGameInstanceForCS final
{
public:
	EStartGameInstanceTypeForCS                   StartType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_StartGameInstanceForCS) == 0x000001, "Wrong alignment on BGWGameInstance_StartGameInstanceForCS");
static_assert(sizeof(BGWGameInstance_StartGameInstanceForCS) == 0x000001, "Wrong size on BGWGameInstance_StartGameInstanceForCS");
static_assert(offsetof(BGWGameInstance_StartGameInstanceForCS, StartType) == 0x000000, "Member 'BGWGameInstance_StartGameInstanceForCS::StartType' has a wrong offset!");

// Function b1.BGWGameInstance.SwitchLoadingScreenThread
// 0x0001 (0x0001 - 0x0000)
struct BGWGameInstance_SwitchLoadingScreenThread final
{
public:
	bool                                          UseSlateThread;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_SwitchLoadingScreenThread) == 0x000001, "Wrong alignment on BGWGameInstance_SwitchLoadingScreenThread");
static_assert(sizeof(BGWGameInstance_SwitchLoadingScreenThread) == 0x000001, "Wrong size on BGWGameInstance_SwitchLoadingScreenThread");
static_assert(offsetof(BGWGameInstance_SwitchLoadingScreenThread, UseSlateThread) == 0x000000, "Member 'BGWGameInstance_SwitchLoadingScreenThread::UseSlateThread' has a wrong offset!");

// Function b1.BGWGameInstance.TravelURLHasHost
// 0x0001 (0x0001 - 0x0000)
struct BGWGameInstance_TravelURLHasHost final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameInstance_TravelURLHasHost) == 0x000001, "Wrong alignment on BGWGameInstance_TravelURLHasHost");
static_assert(sizeof(BGWGameInstance_TravelURLHasHost) == 0x000001, "Wrong size on BGWGameInstance_TravelURLHasHost");
static_assert(offsetof(BGWGameInstance_TravelURLHasHost, ReturnValue) == 0x000000, "Member 'BGWGameInstance_TravelURLHasHost::ReturnValue' has a wrong offset!");

// Function b1.BGWGameInstance.TravelURLHasOption
// 0x0018 (0x0018 - 0x0000)
struct BGWGameInstance_TravelURLHasOption final
{
public:
	class FString                                 Option;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWGameInstance_TravelURLHasOption) == 0x000008, "Wrong alignment on BGWGameInstance_TravelURLHasOption");
static_assert(sizeof(BGWGameInstance_TravelURLHasOption) == 0x000018, "Wrong size on BGWGameInstance_TravelURLHasOption");
static_assert(offsetof(BGWGameInstance_TravelURLHasOption, Option) == 0x000000, "Member 'BGWGameInstance_TravelURLHasOption::Option' has a wrong offset!");
static_assert(offsetof(BGWGameInstance_TravelURLHasOption, ReturnValue) == 0x000010, "Member 'BGWGameInstance_TravelURLHasOption::ReturnValue' has a wrong offset!");

// Function b1.BGWGameMode.BeginEndPlayCS
// 0x0001 (0x0001 - 0x0000)
struct BGWGameMode_BeginEndPlayCS final
{
public:
	EEndPlayReason                                EndPlayReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_BeginEndPlayCS) == 0x000001, "Wrong alignment on BGWGameMode_BeginEndPlayCS");
static_assert(sizeof(BGWGameMode_BeginEndPlayCS) == 0x000001, "Wrong size on BGWGameMode_BeginEndPlayCS");
static_assert(offsetof(BGWGameMode_BeginEndPlayCS, EndPlayReason) == 0x000000, "Member 'BGWGameMode_BeginEndPlayCS::EndPlayReason' has a wrong offset!");

// Function b1.BGWGameMode.GetSeamlessTravelActorListCS
// 0x0018 (0x0018 - 0x0000)
struct BGWGameMode_GetSeamlessTravelActorListCS final
{
public:
	bool                                          bToTransition;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorList;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_GetSeamlessTravelActorListCS) == 0x000008, "Wrong alignment on BGWGameMode_GetSeamlessTravelActorListCS");
static_assert(sizeof(BGWGameMode_GetSeamlessTravelActorListCS) == 0x000018, "Wrong size on BGWGameMode_GetSeamlessTravelActorListCS");
static_assert(offsetof(BGWGameMode_GetSeamlessTravelActorListCS, bToTransition) == 0x000000, "Member 'BGWGameMode_GetSeamlessTravelActorListCS::bToTransition' has a wrong offset!");
static_assert(offsetof(BGWGameMode_GetSeamlessTravelActorListCS, ActorList) == 0x000008, "Member 'BGWGameMode_GetSeamlessTravelActorListCS::ActorList' has a wrong offset!");

// Function b1.BGWGameMode.HandleStartingNewPlayerCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameMode_HandleStartingNewPlayerCS final
{
public:
	class APlayerController*                      NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_HandleStartingNewPlayerCS) == 0x000008, "Wrong alignment on BGWGameMode_HandleStartingNewPlayerCS");
static_assert(sizeof(BGWGameMode_HandleStartingNewPlayerCS) == 0x000008, "Wrong size on BGWGameMode_HandleStartingNewPlayerCS");
static_assert(offsetof(BGWGameMode_HandleStartingNewPlayerCS, NewPlayer) == 0x000000, "Member 'BGWGameMode_HandleStartingNewPlayerCS::NewPlayer' has a wrong offset!");

// Function b1.BGWGameMode.InitGameCS
// 0x0030 (0x0030 - 0x0000)
struct BGWGameMode_InitGameCS final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Options;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorMessag;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_InitGameCS) == 0x000008, "Wrong alignment on BGWGameMode_InitGameCS");
static_assert(sizeof(BGWGameMode_InitGameCS) == 0x000030, "Wrong size on BGWGameMode_InitGameCS");
static_assert(offsetof(BGWGameMode_InitGameCS, MapName) == 0x000000, "Member 'BGWGameMode_InitGameCS::MapName' has a wrong offset!");
static_assert(offsetof(BGWGameMode_InitGameCS, Options) == 0x000010, "Member 'BGWGameMode_InitGameCS::Options' has a wrong offset!");
static_assert(offsetof(BGWGameMode_InitGameCS, ErrorMessag) == 0x000020, "Member 'BGWGameMode_InitGameCS::ErrorMessag' has a wrong offset!");

// Function b1.BGWGameMode.LoginOutCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameMode_LoginOutCS final
{
public:
	class AController*                            Exiting;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_LoginOutCS) == 0x000008, "Wrong alignment on BGWGameMode_LoginOutCS");
static_assert(sizeof(BGWGameMode_LoginOutCS) == 0x000008, "Wrong size on BGWGameMode_LoginOutCS");
static_assert(offsetof(BGWGameMode_LoginOutCS, Exiting) == 0x000000, "Member 'BGWGameMode_LoginOutCS::Exiting' has a wrong offset!");

// Function b1.BGWGameMode.PostLoginCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameMode_PostLoginCS final
{
public:
	class APlayerController*                      NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_PostLoginCS) == 0x000008, "Wrong alignment on BGWGameMode_PostLoginCS");
static_assert(sizeof(BGWGameMode_PostLoginCS) == 0x000008, "Wrong size on BGWGameMode_PostLoginCS");
static_assert(offsetof(BGWGameMode_PostLoginCS, NewPlayer) == 0x000000, "Member 'BGWGameMode_PostLoginCS::NewPlayer' has a wrong offset!");

// Function b1.BGWGameMode.PreLoginCS
// 0x0040 (0x0040 - 0x0000)
struct BGWGameMode_PreLoginCS final
{
public:
	class FString                                 Options;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginAddress;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UniqueId;                                          // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ErrorMessage;                                      // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_PreLoginCS) == 0x000008, "Wrong alignment on BGWGameMode_PreLoginCS");
static_assert(sizeof(BGWGameMode_PreLoginCS) == 0x000040, "Wrong size on BGWGameMode_PreLoginCS");
static_assert(offsetof(BGWGameMode_PreLoginCS, Options) == 0x000000, "Member 'BGWGameMode_PreLoginCS::Options' has a wrong offset!");
static_assert(offsetof(BGWGameMode_PreLoginCS, LoginAddress) == 0x000010, "Member 'BGWGameMode_PreLoginCS::LoginAddress' has a wrong offset!");
static_assert(offsetof(BGWGameMode_PreLoginCS, UniqueId) == 0x000020, "Member 'BGWGameMode_PreLoginCS::UniqueId' has a wrong offset!");
static_assert(offsetof(BGWGameMode_PreLoginCS, ErrorMessage) == 0x000030, "Member 'BGWGameMode_PreLoginCS::ErrorMessage' has a wrong offset!");

// Function b1.BGWGameMode.RestartPlayerCS
// 0x0008 (0x0008 - 0x0000)
struct BGWGameMode_RestartPlayerCS final
{
public:
	class AController*                            NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_RestartPlayerCS) == 0x000008, "Wrong alignment on BGWGameMode_RestartPlayerCS");
static_assert(sizeof(BGWGameMode_RestartPlayerCS) == 0x000008, "Wrong size on BGWGameMode_RestartPlayerCS");
static_assert(offsetof(BGWGameMode_RestartPlayerCS, NewPlayer) == 0x000000, "Member 'BGWGameMode_RestartPlayerCS::NewPlayer' has a wrong offset!");

// Function b1.BGWGameMode.IsMovieRendering
// 0x0001 (0x0001 - 0x0000)
struct BGWGameMode_IsMovieRendering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameMode_IsMovieRendering) == 0x000001, "Wrong alignment on BGWGameMode_IsMovieRendering");
static_assert(sizeof(BGWGameMode_IsMovieRendering) == 0x000001, "Wrong size on BGWGameMode_IsMovieRendering");
static_assert(offsetof(BGWGameMode_IsMovieRendering, ReturnValue) == 0x000000, "Member 'BGWGameMode_IsMovieRendering::ReturnValue' has a wrong offset!");

// Function b1.BGWGamePlayTraceObject.CanShutdown
// 0x0001 (0x0001 - 0x0000)
struct BGWGamePlayTraceObject_CanShutdown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGamePlayTraceObject_CanShutdown) == 0x000001, "Wrong alignment on BGWGamePlayTraceObject_CanShutdown");
static_assert(sizeof(BGWGamePlayTraceObject_CanShutdown) == 0x000001, "Wrong size on BGWGamePlayTraceObject_CanShutdown");
static_assert(offsetof(BGWGamePlayTraceObject_CanShutdown, ReturnValue) == 0x000000, "Member 'BGWGamePlayTraceObject_CanShutdown::ReturnValue' has a wrong offset!");

// Function b1.BGWGamePlayTraceObject.GetEnableTraceing
// 0x0001 (0x0001 - 0x0000)
struct BGWGamePlayTraceObject_GetEnableTraceing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGamePlayTraceObject_GetEnableTraceing) == 0x000001, "Wrong alignment on BGWGamePlayTraceObject_GetEnableTraceing");
static_assert(sizeof(BGWGamePlayTraceObject_GetEnableTraceing) == 0x000001, "Wrong size on BGWGamePlayTraceObject_GetEnableTraceing");
static_assert(offsetof(BGWGamePlayTraceObject_GetEnableTraceing, ReturnValue) == 0x000000, "Member 'BGWGamePlayTraceObject_GetEnableTraceing::ReturnValue' has a wrong offset!");

// Function b1.BGWGamePlayTraceObject.OnTick
// 0x0004 (0x0004 - 0x0000)
struct BGWGamePlayTraceObject_OnTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGamePlayTraceObject_OnTick) == 0x000004, "Wrong alignment on BGWGamePlayTraceObject_OnTick");
static_assert(sizeof(BGWGamePlayTraceObject_OnTick) == 0x000004, "Wrong size on BGWGamePlayTraceObject_OnTick");
static_assert(offsetof(BGWGamePlayTraceObject_OnTick, DeltaTime) == 0x000000, "Member 'BGWGamePlayTraceObject_OnTick::DeltaTime' has a wrong offset!");

// Function b1.BGWGamePlayTraceObject.RecordFrameRate_Stop
// 0x0010 (0x0010 - 0x0000)
struct BGWGamePlayTraceObject_RecordFrameRate_Stop final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGamePlayTraceObject_RecordFrameRate_Stop) == 0x000008, "Wrong alignment on BGWGamePlayTraceObject_RecordFrameRate_Stop");
static_assert(sizeof(BGWGamePlayTraceObject_RecordFrameRate_Stop) == 0x000010, "Wrong size on BGWGamePlayTraceObject_RecordFrameRate_Stop");
static_assert(offsetof(BGWGamePlayTraceObject_RecordFrameRate_Stop, ReturnValue) == 0x000000, "Member 'BGWGamePlayTraceObject_RecordFrameRate_Stop::ReturnValue' has a wrong offset!");

// Function b1.BGWGamePlayTraceObject.TraceStart
// 0x0010 (0x0010 - 0x0000)
struct BGWGamePlayTraceObject_TraceStart final
{
public:
	class FString                                 TraceTaskName;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGamePlayTraceObject_TraceStart) == 0x000008, "Wrong alignment on BGWGamePlayTraceObject_TraceStart");
static_assert(sizeof(BGWGamePlayTraceObject_TraceStart) == 0x000010, "Wrong size on BGWGamePlayTraceObject_TraceStart");
static_assert(offsetof(BGWGamePlayTraceObject_TraceStart, TraceTaskName) == 0x000000, "Member 'BGWGamePlayTraceObject_TraceStart::TraceTaskName' has a wrong offset!");

// Function b1.BGUSimpleGamePlayTraceObject.AddTraceStatByName
// 0x0010 (0x0010 - 0x0000)
struct BGUSimpleGamePlayTraceObject_AddTraceStatByName final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSimpleGamePlayTraceObject_AddTraceStatByName) == 0x000008, "Wrong alignment on BGUSimpleGamePlayTraceObject_AddTraceStatByName");
static_assert(sizeof(BGUSimpleGamePlayTraceObject_AddTraceStatByName) == 0x000010, "Wrong size on BGUSimpleGamePlayTraceObject_AddTraceStatByName");
static_assert(offsetof(BGUSimpleGamePlayTraceObject_AddTraceStatByName, Name_0) == 0x000000, "Member 'BGUSimpleGamePlayTraceObject_AddTraceStatByName::Name_0' has a wrong offset!");

// Function b1.BGUSimpleGamePlayTraceObject.FindTraceStatResult
// 0x0028 (0x0028 - 0x0000)
struct BGUSimpleGamePlayTraceObject_FindTraceStatResult final
{
public:
	class FString                                 Name_0;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTraceStatResult                       ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSimpleGamePlayTraceObject_FindTraceStatResult) == 0x000008, "Wrong alignment on BGUSimpleGamePlayTraceObject_FindTraceStatResult");
static_assert(sizeof(BGUSimpleGamePlayTraceObject_FindTraceStatResult) == 0x000028, "Wrong size on BGUSimpleGamePlayTraceObject_FindTraceStatResult");
static_assert(offsetof(BGUSimpleGamePlayTraceObject_FindTraceStatResult, Name_0) == 0x000000, "Member 'BGUSimpleGamePlayTraceObject_FindTraceStatResult::Name_0' has a wrong offset!");
static_assert(offsetof(BGUSimpleGamePlayTraceObject_FindTraceStatResult, ReturnValue) == 0x000010, "Member 'BGUSimpleGamePlayTraceObject_FindTraceStatResult::ReturnValue' has a wrong offset!");

// Function b1.BGUSimpleGamePlayTraceObject.OnTick
// 0x0004 (0x0004 - 0x0000)
struct BGUSimpleGamePlayTraceObject_OnTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGUSimpleGamePlayTraceObject_OnTick) == 0x000004, "Wrong alignment on BGUSimpleGamePlayTraceObject_OnTick");
static_assert(sizeof(BGUSimpleGamePlayTraceObject_OnTick) == 0x000004, "Wrong size on BGUSimpleGamePlayTraceObject_OnTick");
static_assert(offsetof(BGUSimpleGamePlayTraceObject_OnTick, DeltaTime) == 0x000000, "Member 'BGUSimpleGamePlayTraceObject_OnTick::DeltaTime' has a wrong offset!");

// Function b1.BGWGameState.IsGSEventDebuggerOpenCS
// 0x0001 (0x0001 - 0x0000)
struct BGWGameState_IsGSEventDebuggerOpenCS final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameState_IsGSEventDebuggerOpenCS) == 0x000001, "Wrong alignment on BGWGameState_IsGSEventDebuggerOpenCS");
static_assert(sizeof(BGWGameState_IsGSEventDebuggerOpenCS) == 0x000001, "Wrong size on BGWGameState_IsGSEventDebuggerOpenCS");
static_assert(offsetof(BGWGameState_IsGSEventDebuggerOpenCS, ReturnValue) == 0x000000, "Member 'BGWGameState_IsGSEventDebuggerOpenCS::ReturnValue' has a wrong offset!");

// Function b1.BGWGameState.OnTickDispatchEventCS
// 0x0004 (0x0004 - 0x0000)
struct BGWGameState_OnTickDispatchEventCS final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWGameState_OnTickDispatchEventCS) == 0x000004, "Wrong alignment on BGWGameState_OnTickDispatchEventCS");
static_assert(sizeof(BGWGameState_OnTickDispatchEventCS) == 0x000004, "Wrong size on BGWGameState_OnTickDispatchEventCS");
static_assert(offsetof(BGWGameState_OnTickDispatchEventCS, DeltaTime) == 0x000000, "Member 'BGWGameState_OnTickDispatchEventCS::DeltaTime' has a wrong offset!");

// Function b1.BGWLevelStreamingStateVolumeManager.Get
// 0x0010 (0x0010 - 0x0000)
struct BGWLevelStreamingStateVolumeManager_Get final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWLevelStreamingStateVolumeManager*   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWLevelStreamingStateVolumeManager_Get) == 0x000008, "Wrong alignment on BGWLevelStreamingStateVolumeManager_Get");
static_assert(sizeof(BGWLevelStreamingStateVolumeManager_Get) == 0x000010, "Wrong size on BGWLevelStreamingStateVolumeManager_Get");
static_assert(offsetof(BGWLevelStreamingStateVolumeManager_Get, WorldContext) == 0x000000, "Member 'BGWLevelStreamingStateVolumeManager_Get::WorldContext' has a wrong offset!");
static_assert(offsetof(BGWLevelStreamingStateVolumeManager_Get, ReturnValue) == 0x000008, "Member 'BGWLevelStreamingStateVolumeManager_Get::ReturnValue' has a wrong offset!");

// Function b1.BGWLevelStreamingVolume.SetEnableWorldCompositionGroup
// 0x0001 (0x0001 - 0x0000)
struct BGWLevelStreamingVolume_SetEnableWorldCompositionGroup final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWLevelStreamingVolume_SetEnableWorldCompositionGroup) == 0x000001, "Wrong alignment on BGWLevelStreamingVolume_SetEnableWorldCompositionGroup");
static_assert(sizeof(BGWLevelStreamingVolume_SetEnableWorldCompositionGroup) == 0x000001, "Wrong size on BGWLevelStreamingVolume_SetEnableWorldCompositionGroup");
static_assert(offsetof(BGWLevelStreamingVolume_SetEnableWorldCompositionGroup, bEnable) == 0x000000, "Member 'BGWLevelStreamingVolume_SetEnableWorldCompositionGroup::bEnable' has a wrong offset!");

// Function b1.BGWObjectExtend.OnPropertyChanged
// 0x0020 (0x0020 - 0x0000)
struct BGWObjectExtend_OnPropertyChanged final
{
public:
	class FString                                 MemberName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWObjectExtend_OnPropertyChanged) == 0x000008, "Wrong alignment on BGWObjectExtend_OnPropertyChanged");
static_assert(sizeof(BGWObjectExtend_OnPropertyChanged) == 0x000020, "Wrong size on BGWObjectExtend_OnPropertyChanged");
static_assert(offsetof(BGWObjectExtend_OnPropertyChanged, MemberName) == 0x000000, "Member 'BGWObjectExtend_OnPropertyChanged::MemberName' has a wrong offset!");
static_assert(offsetof(BGWObjectExtend_OnPropertyChanged, PropertyName) == 0x000010, "Member 'BGWObjectExtend_OnPropertyChanged::PropertyName' has a wrong offset!");

// Function b1.BGWOnlineAchievement.GetAllAchievements
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineAchievement_GetAllAchievements final
{
public:
	TArray<struct FBGWOnlineAchievementTag>       OutAchievements;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineAchievement_GetAllAchievements) == 0x000008, "Wrong alignment on BGWOnlineAchievement_GetAllAchievements");
static_assert(sizeof(BGWOnlineAchievement_GetAllAchievements) == 0x000018, "Wrong size on BGWOnlineAchievement_GetAllAchievements");
static_assert(offsetof(BGWOnlineAchievement_GetAllAchievements, OutAchievements) == 0x000000, "Member 'BGWOnlineAchievement_GetAllAchievements::OutAchievements' has a wrong offset!");
static_assert(offsetof(BGWOnlineAchievement_GetAllAchievements, ReturnValue) == 0x000010, "Member 'BGWOnlineAchievement_GetAllAchievements::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineAchievement.Init
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlineAchievement_Init final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineAchievement_Init) == 0x000004, "Wrong alignment on BGWOnlineAchievement_Init");
static_assert(sizeof(BGWOnlineAchievement_Init) == 0x000004, "Wrong size on BGWOnlineAchievement_Init");
static_assert(offsetof(BGWOnlineAchievement_Init, ReturnValue) == 0x000000, "Member 'BGWOnlineAchievement_Init::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineAchievement.OnAchievementsWrittenCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineAchievement_OnAchievementsWrittenCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineAchievement_OnAchievementsWrittenCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineAchievement_OnAchievementsWrittenCompleteCS");
static_assert(sizeof(BGWOnlineAchievement_OnAchievementsWrittenCompleteCS) == 0x000001, "Wrong size on BGWOnlineAchievement_OnAchievementsWrittenCompleteCS");
static_assert(offsetof(BGWOnlineAchievement_OnAchievementsWrittenCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineAchievement_OnAchievementsWrittenCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineAchievement.OnQueryAchievementsCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineAchievement_OnQueryAchievementsCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineAchievement_OnQueryAchievementsCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineAchievement_OnQueryAchievementsCompleteCS");
static_assert(sizeof(BGWOnlineAchievement_OnQueryAchievementsCompleteCS) == 0x000001, "Wrong size on BGWOnlineAchievement_OnQueryAchievementsCompleteCS");
static_assert(offsetof(BGWOnlineAchievement_OnQueryAchievementsCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineAchievement_OnQueryAchievementsCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineAchievement.OnStatUpdatedCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineAchievement_OnStatUpdatedCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineAchievement_OnStatUpdatedCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineAchievement_OnStatUpdatedCompleteCS");
static_assert(sizeof(BGWOnlineAchievement_OnStatUpdatedCompleteCS) == 0x000001, "Wrong size on BGWOnlineAchievement_OnStatUpdatedCompleteCS");
static_assert(offsetof(BGWOnlineAchievement_OnStatUpdatedCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineAchievement_OnStatUpdatedCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineAchievement.UpdateStat
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineAchievement_UpdateStat final
{
public:
	class FString                                 StatName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatValue;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineAchievement_UpdateStat) == 0x000008, "Wrong alignment on BGWOnlineAchievement_UpdateStat");
static_assert(sizeof(BGWOnlineAchievement_UpdateStat) == 0x000018, "Wrong size on BGWOnlineAchievement_UpdateStat");
static_assert(offsetof(BGWOnlineAchievement_UpdateStat, StatName) == 0x000000, "Member 'BGWOnlineAchievement_UpdateStat::StatName' has a wrong offset!");
static_assert(offsetof(BGWOnlineAchievement_UpdateStat, StatValue) == 0x000010, "Member 'BGWOnlineAchievement_UpdateStat::StatValue' has a wrong offset!");

// Function b1.BGWOnlineAchievement.WriteAchievement
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineAchievement_WriteAchievement final
{
public:
	class FString                                 WriteObjKey;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        WriteObjValue;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineAchievement_WriteAchievement) == 0x000008, "Wrong alignment on BGWOnlineAchievement_WriteAchievement");
static_assert(sizeof(BGWOnlineAchievement_WriteAchievement) == 0x000018, "Wrong size on BGWOnlineAchievement_WriteAchievement");
static_assert(offsetof(BGWOnlineAchievement_WriteAchievement, WriteObjKey) == 0x000000, "Member 'BGWOnlineAchievement_WriteAchievement::WriteObjKey' has a wrong offset!");
static_assert(offsetof(BGWOnlineAchievement_WriteAchievement, WriteObjValue) == 0x000010, "Member 'BGWOnlineAchievement_WriteAchievement::WriteObjValue' has a wrong offset!");

// Function b1.BGWOnlineActivity.EndActivity
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineActivity_EndActivity final
{
public:
	class FString                                 ActivityId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineActivityOutcomeType                    Outcome;                                           // 0x0010(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineActivity_EndActivity) == 0x000008, "Wrong alignment on BGWOnlineActivity_EndActivity");
static_assert(sizeof(BGWOnlineActivity_EndActivity) == 0x000018, "Wrong size on BGWOnlineActivity_EndActivity");
static_assert(offsetof(BGWOnlineActivity_EndActivity, ActivityId) == 0x000000, "Member 'BGWOnlineActivity_EndActivity::ActivityId' has a wrong offset!");
static_assert(offsetof(BGWOnlineActivity_EndActivity, Outcome) == 0x000010, "Member 'BGWOnlineActivity_EndActivity::Outcome' has a wrong offset!");

// Function b1.BGWOnlineActivity.Init
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlineActivity_Init final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_Init) == 0x000004, "Wrong alignment on BGWOnlineActivity_Init");
static_assert(sizeof(BGWOnlineActivity_Init) == 0x000004, "Wrong size on BGWOnlineActivity_Init");
static_assert(offsetof(BGWOnlineActivity_Init, ReturnValue) == 0x000000, "Member 'BGWOnlineActivity_Init::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineActivity.OnEndActivityCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineActivity_OnEndActivityCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_OnEndActivityCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineActivity_OnEndActivityCompleteCS");
static_assert(sizeof(BGWOnlineActivity_OnEndActivityCompleteCS) == 0x000001, "Wrong size on BGWOnlineActivity_OnEndActivityCompleteCS");
static_assert(offsetof(BGWOnlineActivity_OnEndActivityCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineActivity_OnEndActivityCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineActivity.OnGameActivityActivationCompleteCS
// 0x0020 (0x0020 - 0x0000)
struct BGWOnlineActivity_OnGameActivityActivationCompleteCS final
{
public:
	class FString                                 ActivityId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionStr;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_OnGameActivityActivationCompleteCS) == 0x000008, "Wrong alignment on BGWOnlineActivity_OnGameActivityActivationCompleteCS");
static_assert(sizeof(BGWOnlineActivity_OnGameActivityActivationCompleteCS) == 0x000020, "Wrong size on BGWOnlineActivity_OnGameActivityActivationCompleteCS");
static_assert(offsetof(BGWOnlineActivity_OnGameActivityActivationCompleteCS, ActivityId) == 0x000000, "Member 'BGWOnlineActivity_OnGameActivityActivationCompleteCS::ActivityId' has a wrong offset!");
static_assert(offsetof(BGWOnlineActivity_OnGameActivityActivationCompleteCS, SessionStr) == 0x000010, "Member 'BGWOnlineActivity_OnGameActivityActivationCompleteCS::SessionStr' has a wrong offset!");

// Function b1.BGWOnlineActivity.OnResetAllActiveActivitiesCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineActivity_OnResetAllActiveActivitiesCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_OnResetAllActiveActivitiesCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineActivity_OnResetAllActiveActivitiesCompleteCS");
static_assert(sizeof(BGWOnlineActivity_OnResetAllActiveActivitiesCompleteCS) == 0x000001, "Wrong size on BGWOnlineActivity_OnResetAllActiveActivitiesCompleteCS");
static_assert(offsetof(BGWOnlineActivity_OnResetAllActiveActivitiesCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineActivity_OnResetAllActiveActivitiesCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineActivity.OnResumeActivityCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineActivity_OnResumeActivityCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_OnResumeActivityCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineActivity_OnResumeActivityCompleteCS");
static_assert(sizeof(BGWOnlineActivity_OnResumeActivityCompleteCS) == 0x000001, "Wrong size on BGWOnlineActivity_OnResumeActivityCompleteCS");
static_assert(offsetof(BGWOnlineActivity_OnResumeActivityCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineActivity_OnResumeActivityCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineActivity.OnSetActivityAvailabilityCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineActivity_OnSetActivityAvailabilityCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_OnSetActivityAvailabilityCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineActivity_OnSetActivityAvailabilityCompleteCS");
static_assert(sizeof(BGWOnlineActivity_OnSetActivityAvailabilityCompleteCS) == 0x000001, "Wrong size on BGWOnlineActivity_OnSetActivityAvailabilityCompleteCS");
static_assert(offsetof(BGWOnlineActivity_OnSetActivityAvailabilityCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineActivity_OnSetActivityAvailabilityCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineActivity.OnSetActivityPriorityCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineActivity_OnSetActivityPriorityCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_OnSetActivityPriorityCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineActivity_OnSetActivityPriorityCompleteCS");
static_assert(sizeof(BGWOnlineActivity_OnSetActivityPriorityCompleteCS) == 0x000001, "Wrong size on BGWOnlineActivity_OnSetActivityPriorityCompleteCS");
static_assert(offsetof(BGWOnlineActivity_OnSetActivityPriorityCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineActivity_OnSetActivityPriorityCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineActivity.OnStartActivityCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineActivity_OnStartActivityCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_OnStartActivityCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineActivity_OnStartActivityCompleteCS");
static_assert(sizeof(BGWOnlineActivity_OnStartActivityCompleteCS) == 0x000001, "Wrong size on BGWOnlineActivity_OnStartActivityCompleteCS");
static_assert(offsetof(BGWOnlineActivity_OnStartActivityCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineActivity_OnStartActivityCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineActivity.ResumeActivity
// 0x0030 (0x0030 - 0x0000)
struct BGWOnlineActivity_ResumeActivity final
{
public:
	class FString                                 ActivityId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         InProgressTasks;                                   // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         CompletedTasks;                                    // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_ResumeActivity) == 0x000008, "Wrong alignment on BGWOnlineActivity_ResumeActivity");
static_assert(sizeof(BGWOnlineActivity_ResumeActivity) == 0x000030, "Wrong size on BGWOnlineActivity_ResumeActivity");
static_assert(offsetof(BGWOnlineActivity_ResumeActivity, ActivityId) == 0x000000, "Member 'BGWOnlineActivity_ResumeActivity::ActivityId' has a wrong offset!");
static_assert(offsetof(BGWOnlineActivity_ResumeActivity, InProgressTasks) == 0x000010, "Member 'BGWOnlineActivity_ResumeActivity::InProgressTasks' has a wrong offset!");
static_assert(offsetof(BGWOnlineActivity_ResumeActivity, CompletedTasks) == 0x000020, "Member 'BGWOnlineActivity_ResumeActivity::CompletedTasks' has a wrong offset!");

// Function b1.BGWOnlineActivity.SetActivityAvailability
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineActivity_SetActivityAvailability final
{
public:
	class FString                                 ActivityId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineActivity_SetActivityAvailability) == 0x000008, "Wrong alignment on BGWOnlineActivity_SetActivityAvailability");
static_assert(sizeof(BGWOnlineActivity_SetActivityAvailability) == 0x000018, "Wrong size on BGWOnlineActivity_SetActivityAvailability");
static_assert(offsetof(BGWOnlineActivity_SetActivityAvailability, ActivityId) == 0x000000, "Member 'BGWOnlineActivity_SetActivityAvailability::ActivityId' has a wrong offset!");
static_assert(offsetof(BGWOnlineActivity_SetActivityAvailability, bEnable) == 0x000010, "Member 'BGWOnlineActivity_SetActivityAvailability::bEnable' has a wrong offset!");

// Function b1.BGWOnlineActivity.SetActivityPriority
// 0x0050 (0x0050 - 0x0000)
struct BGWOnlineActivity_SetActivityPriority final
{
public:
	TMap<class FString, int32>                    PriorityMap;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_SetActivityPriority) == 0x000008, "Wrong alignment on BGWOnlineActivity_SetActivityPriority");
static_assert(sizeof(BGWOnlineActivity_SetActivityPriority) == 0x000050, "Wrong size on BGWOnlineActivity_SetActivityPriority");
static_assert(offsetof(BGWOnlineActivity_SetActivityPriority, PriorityMap) == 0x000000, "Member 'BGWOnlineActivity_SetActivityPriority::PriorityMap' has a wrong offset!");

// Function b1.BGWOnlineActivity.StartActivity
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineActivity_StartActivity final
{
public:
	class FString                                 ActivityId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineActivity_StartActivity) == 0x000008, "Wrong alignment on BGWOnlineActivity_StartActivity");
static_assert(sizeof(BGWOnlineActivity_StartActivity) == 0x000010, "Wrong size on BGWOnlineActivity_StartActivity");
static_assert(offsetof(BGWOnlineActivity_StartActivity, ActivityId) == 0x000000, "Member 'BGWOnlineActivity_StartActivity::ActivityId' has a wrong offset!");

// Function b1.BGWOnlineCloud.DeleteUserFile
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineCloud_DeleteUserFile final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloudDelete;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalDelete;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineCloud_DeleteUserFile) == 0x000008, "Wrong alignment on BGWOnlineCloud_DeleteUserFile");
static_assert(sizeof(BGWOnlineCloud_DeleteUserFile) == 0x000018, "Wrong size on BGWOnlineCloud_DeleteUserFile");
static_assert(offsetof(BGWOnlineCloud_DeleteUserFile, Filename) == 0x000000, "Member 'BGWOnlineCloud_DeleteUserFile::Filename' has a wrong offset!");
static_assert(offsetof(BGWOnlineCloud_DeleteUserFile, bCloudDelete) == 0x000010, "Member 'BGWOnlineCloud_DeleteUserFile::bCloudDelete' has a wrong offset!");
static_assert(offsetof(BGWOnlineCloud_DeleteUserFile, bLocalDelete) == 0x000011, "Member 'BGWOnlineCloud_DeleteUserFile::bLocalDelete' has a wrong offset!");

// Function b1.BGWOnlineCloud.Init
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlineCloud_Init final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineCloud_Init) == 0x000004, "Wrong alignment on BGWOnlineCloud_Init");
static_assert(sizeof(BGWOnlineCloud_Init) == 0x000004, "Wrong size on BGWOnlineCloud_Init");
static_assert(offsetof(BGWOnlineCloud_Init, ReturnValue) == 0x000000, "Member 'BGWOnlineCloud_Init::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineCloud.OnDeleteUserFilesCompleteCS
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineCloud_OnDeleteUserFilesCompleteCS final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineCloud_OnDeleteUserFilesCompleteCS) == 0x000008, "Wrong alignment on BGWOnlineCloud_OnDeleteUserFilesCompleteCS");
static_assert(sizeof(BGWOnlineCloud_OnDeleteUserFilesCompleteCS) == 0x000018, "Wrong size on BGWOnlineCloud_OnDeleteUserFilesCompleteCS");
static_assert(offsetof(BGWOnlineCloud_OnDeleteUserFilesCompleteCS, Filename) == 0x000000, "Member 'BGWOnlineCloud_OnDeleteUserFilesCompleteCS::Filename' has a wrong offset!");
static_assert(offsetof(BGWOnlineCloud_OnDeleteUserFilesCompleteCS, bWasSuccessful) == 0x000010, "Member 'BGWOnlineCloud_OnDeleteUserFilesCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineCloud.OnEnumerateUserFilesCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineCloud_OnEnumerateUserFilesCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineCloud_OnEnumerateUserFilesCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineCloud_OnEnumerateUserFilesCompleteCS");
static_assert(sizeof(BGWOnlineCloud_OnEnumerateUserFilesCompleteCS) == 0x000001, "Wrong size on BGWOnlineCloud_OnEnumerateUserFilesCompleteCS");
static_assert(offsetof(BGWOnlineCloud_OnEnumerateUserFilesCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineCloud_OnEnumerateUserFilesCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineCloud.OnReadUserFilesCompleteCS
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineCloud_OnReadUserFilesCompleteCS final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineCloud_OnReadUserFilesCompleteCS) == 0x000008, "Wrong alignment on BGWOnlineCloud_OnReadUserFilesCompleteCS");
static_assert(sizeof(BGWOnlineCloud_OnReadUserFilesCompleteCS) == 0x000018, "Wrong size on BGWOnlineCloud_OnReadUserFilesCompleteCS");
static_assert(offsetof(BGWOnlineCloud_OnReadUserFilesCompleteCS, Filename) == 0x000000, "Member 'BGWOnlineCloud_OnReadUserFilesCompleteCS::Filename' has a wrong offset!");
static_assert(offsetof(BGWOnlineCloud_OnReadUserFilesCompleteCS, bWasSuccessful) == 0x000010, "Member 'BGWOnlineCloud_OnReadUserFilesCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineCloud.OnWriteUserCloudFileCompleteCS
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineCloud_OnWriteUserCloudFileCompleteCS final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineCloud_OnWriteUserCloudFileCompleteCS) == 0x000008, "Wrong alignment on BGWOnlineCloud_OnWriteUserCloudFileCompleteCS");
static_assert(sizeof(BGWOnlineCloud_OnWriteUserCloudFileCompleteCS) == 0x000018, "Wrong size on BGWOnlineCloud_OnWriteUserCloudFileCompleteCS");
static_assert(offsetof(BGWOnlineCloud_OnWriteUserCloudFileCompleteCS, Filename) == 0x000000, "Member 'BGWOnlineCloud_OnWriteUserCloudFileCompleteCS::Filename' has a wrong offset!");
static_assert(offsetof(BGWOnlineCloud_OnWriteUserCloudFileCompleteCS, bWasSuccessful) == 0x000010, "Member 'BGWOnlineCloud_OnWriteUserCloudFileCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineCloud.ReadAllUserFiles
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineCloud_ReadAllUserFiles final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineCloud_ReadAllUserFiles) == 0x000001, "Wrong alignment on BGWOnlineCloud_ReadAllUserFiles");
static_assert(sizeof(BGWOnlineCloud_ReadAllUserFiles) == 0x000001, "Wrong size on BGWOnlineCloud_ReadAllUserFiles");
static_assert(offsetof(BGWOnlineCloud_ReadAllUserFiles, ReturnValue) == 0x000000, "Member 'BGWOnlineCloud_ReadAllUserFiles::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineCloud.ReadUserFile
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineCloud_ReadUserFile final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineCloud_ReadUserFile) == 0x000008, "Wrong alignment on BGWOnlineCloud_ReadUserFile");
static_assert(sizeof(BGWOnlineCloud_ReadUserFile) == 0x000018, "Wrong size on BGWOnlineCloud_ReadUserFile");
static_assert(offsetof(BGWOnlineCloud_ReadUserFile, Filename) == 0x000000, "Member 'BGWOnlineCloud_ReadUserFile::Filename' has a wrong offset!");
static_assert(offsetof(BGWOnlineCloud_ReadUserFile, ReturnValue) == 0x000010, "Member 'BGWOnlineCloud_ReadUserFile::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineCloud.WriteUserFile
// 0x0020 (0x0020 - 0x0000)
struct BGWOnlineCloud_WriteUserFile final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 UserData;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineCloud_WriteUserFile) == 0x000008, "Wrong alignment on BGWOnlineCloud_WriteUserFile");
static_assert(sizeof(BGWOnlineCloud_WriteUserFile) == 0x000020, "Wrong size on BGWOnlineCloud_WriteUserFile");
static_assert(offsetof(BGWOnlineCloud_WriteUserFile, Filename) == 0x000000, "Member 'BGWOnlineCloud_WriteUserFile::Filename' has a wrong offset!");
static_assert(offsetof(BGWOnlineCloud_WriteUserFile, UserData) == 0x000010, "Member 'BGWOnlineCloud_WriteUserFile::UserData' has a wrong offset!");

// Function b1.BGWOnlineFriend.GetFriend
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineFriend_GetFriend final
{
public:
	class FString                                 ListName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineFriend_GetFriend) == 0x000008, "Wrong alignment on BGWOnlineFriend_GetFriend");
static_assert(sizeof(BGWOnlineFriend_GetFriend) == 0x000018, "Wrong size on BGWOnlineFriend_GetFriend");
static_assert(offsetof(BGWOnlineFriend_GetFriend, ListName) == 0x000000, "Member 'BGWOnlineFriend_GetFriend::ListName' has a wrong offset!");
static_assert(offsetof(BGWOnlineFriend_GetFriend, ReturnValue) == 0x000010, "Member 'BGWOnlineFriend_GetFriend::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineFriend.GetFriendsList
// 0x0020 (0x0020 - 0x0000)
struct BGWOnlineFriend_GetFriendsList final
{
public:
	EFriendsListsType                             ListType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBGWOnlineFriendInfo>           OutFriends;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineFriend_GetFriendsList) == 0x000008, "Wrong alignment on BGWOnlineFriend_GetFriendsList");
static_assert(sizeof(BGWOnlineFriend_GetFriendsList) == 0x000020, "Wrong size on BGWOnlineFriend_GetFriendsList");
static_assert(offsetof(BGWOnlineFriend_GetFriendsList, ListType) == 0x000000, "Member 'BGWOnlineFriend_GetFriendsList::ListType' has a wrong offset!");
static_assert(offsetof(BGWOnlineFriend_GetFriendsList, OutFriends) == 0x000008, "Member 'BGWOnlineFriend_GetFriendsList::OutFriends' has a wrong offset!");
static_assert(offsetof(BGWOnlineFriend_GetFriendsList, ReturnValue) == 0x000018, "Member 'BGWOnlineFriend_GetFriendsList::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineFriend.Init
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlineFriend_Init final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineFriend_Init) == 0x000004, "Wrong alignment on BGWOnlineFriend_Init");
static_assert(sizeof(BGWOnlineFriend_Init) == 0x000004, "Wrong size on BGWOnlineFriend_Init");
static_assert(offsetof(BGWOnlineFriend_Init, ReturnValue) == 0x000000, "Member 'BGWOnlineFriend_Init::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineFriend.OnReadFriendListCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineFriend_OnReadFriendListCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineFriend_OnReadFriendListCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineFriend_OnReadFriendListCompleteCS");
static_assert(sizeof(BGWOnlineFriend_OnReadFriendListCompleteCS) == 0x000001, "Wrong size on BGWOnlineFriend_OnReadFriendListCompleteCS");
static_assert(offsetof(BGWOnlineFriend_OnReadFriendListCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineFriend_OnReadFriendListCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineFriend.ReadFriendsList
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineFriend_ReadFriendsList final
{
public:
	EFriendsListsType                             ListType;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineFriend_ReadFriendsList) == 0x000001, "Wrong alignment on BGWOnlineFriend_ReadFriendsList");
static_assert(sizeof(BGWOnlineFriend_ReadFriendsList) == 0x000001, "Wrong size on BGWOnlineFriend_ReadFriendsList");
static_assert(offsetof(BGWOnlineFriend_ReadFriendsList, ListType) == 0x000000, "Member 'BGWOnlineFriend_ReadFriendsList::ListType' has a wrong offset!");

// Function b1.BGWOnlineIdentity.GetAuthToken
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineIdentity_GetAuthToken final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_GetAuthToken) == 0x000008, "Wrong alignment on BGWOnlineIdentity_GetAuthToken");
static_assert(sizeof(BGWOnlineIdentity_GetAuthToken) == 0x000010, "Wrong size on BGWOnlineIdentity_GetAuthToken");
static_assert(offsetof(BGWOnlineIdentity_GetAuthToken, ReturnValue) == 0x000000, "Member 'BGWOnlineIdentity_GetAuthToken::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineIdentity.GetLinkedAccountExternalToken
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineIdentity_GetLinkedAccountExternalToken final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_GetLinkedAccountExternalToken) == 0x000008, "Wrong alignment on BGWOnlineIdentity_GetLinkedAccountExternalToken");
static_assert(sizeof(BGWOnlineIdentity_GetLinkedAccountExternalToken) == 0x000010, "Wrong size on BGWOnlineIdentity_GetLinkedAccountExternalToken");
static_assert(offsetof(BGWOnlineIdentity_GetLinkedAccountExternalToken, ReturnValue) == 0x000000, "Member 'BGWOnlineIdentity_GetLinkedAccountExternalToken::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineIdentity.GetUserPrivilege
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineIdentity_GetUserPrivilege final
{
public:
	EBGWUserPrivileges                            Privilege;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_GetUserPrivilege) == 0x000001, "Wrong alignment on BGWOnlineIdentity_GetUserPrivilege");
static_assert(sizeof(BGWOnlineIdentity_GetUserPrivilege) == 0x000001, "Wrong size on BGWOnlineIdentity_GetUserPrivilege");
static_assert(offsetof(BGWOnlineIdentity_GetUserPrivilege, Privilege) == 0x000000, "Member 'BGWOnlineIdentity_GetUserPrivilege::Privilege' has a wrong offset!");

// Function b1.BGWOnlineIdentity.Init
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlineIdentity_Init final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_Init) == 0x000004, "Wrong alignment on BGWOnlineIdentity_Init");
static_assert(sizeof(BGWOnlineIdentity_Init) == 0x000004, "Wrong size on BGWOnlineIdentity_Init");
static_assert(offsetof(BGWOnlineIdentity_Init, ReturnValue) == 0x000000, "Member 'BGWOnlineIdentity_Init::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineIdentity.OnGetUserPrivilegeCompleteCS
// 0x0002 (0x0002 - 0x0000)
struct BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS final
{
public:
	EBGWUserPrivileges                            Privilege;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGWPrivilegeResult                           PrivilegeResult;                                   // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS");
static_assert(sizeof(BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS) == 0x000002, "Wrong size on BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS");
static_assert(offsetof(BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS, Privilege) == 0x000000, "Member 'BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS::Privilege' has a wrong offset!");
static_assert(offsetof(BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS, PrivilegeResult) == 0x000001, "Member 'BGWOnlineIdentity_OnGetUserPrivilegeCompleteCS::PrivilegeResult' has a wrong offset!");

// Function b1.BGWOnlineIdentity.OnLoginCompletedCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineIdentity_OnLoginCompletedCS final
{
public:
	bool                                          bSuccessful;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_OnLoginCompletedCS) == 0x000001, "Wrong alignment on BGWOnlineIdentity_OnLoginCompletedCS");
static_assert(sizeof(BGWOnlineIdentity_OnLoginCompletedCS) == 0x000001, "Wrong size on BGWOnlineIdentity_OnLoginCompletedCS");
static_assert(offsetof(BGWOnlineIdentity_OnLoginCompletedCS, bSuccessful) == 0x000000, "Member 'BGWOnlineIdentity_OnLoginCompletedCS::bSuccessful' has a wrong offset!");

// Function b1.BGWOnlineIdentity.OnRecvAntiAddictionActionCS
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineIdentity_OnRecvAntiAddictionActionCS final
{
public:
	class FString                                 RecvActionsJsonStr;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_OnRecvAntiAddictionActionCS) == 0x000008, "Wrong alignment on BGWOnlineIdentity_OnRecvAntiAddictionActionCS");
static_assert(sizeof(BGWOnlineIdentity_OnRecvAntiAddictionActionCS) == 0x000010, "Wrong size on BGWOnlineIdentity_OnRecvAntiAddictionActionCS");
static_assert(offsetof(BGWOnlineIdentity_OnRecvAntiAddictionActionCS, RecvActionsJsonStr) == 0x000000, "Member 'BGWOnlineIdentity_OnRecvAntiAddictionActionCS::RecvActionsJsonStr' has a wrong offset!");

// Function b1.BGWOnlineIdentity.GetAuthOnlineUserId
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineIdentity_GetAuthOnlineUserId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_GetAuthOnlineUserId) == 0x000008, "Wrong alignment on BGWOnlineIdentity_GetAuthOnlineUserId");
static_assert(sizeof(BGWOnlineIdentity_GetAuthOnlineUserId) == 0x000010, "Wrong size on BGWOnlineIdentity_GetAuthOnlineUserId");
static_assert(offsetof(BGWOnlineIdentity_GetAuthOnlineUserId, ReturnValue) == 0x000000, "Member 'BGWOnlineIdentity_GetAuthOnlineUserId::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineIdentity.GetLoginStatus
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineIdentity_GetLoginStatus final
{
public:
	EBGWLoginStatus                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_GetLoginStatus) == 0x000001, "Wrong alignment on BGWOnlineIdentity_GetLoginStatus");
static_assert(sizeof(BGWOnlineIdentity_GetLoginStatus) == 0x000001, "Wrong size on BGWOnlineIdentity_GetLoginStatus");
static_assert(offsetof(BGWOnlineIdentity_GetLoginStatus, ReturnValue) == 0x000000, "Member 'BGWOnlineIdentity_GetLoginStatus::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineIdentity.GetPlayerNickname
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineIdentity_GetPlayerNickname final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_GetPlayerNickname) == 0x000008, "Wrong alignment on BGWOnlineIdentity_GetPlayerNickname");
static_assert(sizeof(BGWOnlineIdentity_GetPlayerNickname) == 0x000010, "Wrong size on BGWOnlineIdentity_GetPlayerNickname");
static_assert(offsetof(BGWOnlineIdentity_GetPlayerNickname, ReturnValue) == 0x000000, "Member 'BGWOnlineIdentity_GetPlayerNickname::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineIdentity.GetUniquePlayerId
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineIdentity_GetUniquePlayerId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineIdentity_GetUniquePlayerId) == 0x000008, "Wrong alignment on BGWOnlineIdentity_GetUniquePlayerId");
static_assert(sizeof(BGWOnlineIdentity_GetUniquePlayerId) == 0x000010, "Wrong size on BGWOnlineIdentity_GetUniquePlayerId");
static_assert(offsetof(BGWOnlineIdentity_GetUniquePlayerId, ReturnValue) == 0x000000, "Member 'BGWOnlineIdentity_GetUniquePlayerId::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlinePresence.Init
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlinePresence_Init final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlinePresence_Init) == 0x000004, "Wrong alignment on BGWOnlinePresence_Init");
static_assert(sizeof(BGWOnlinePresence_Init) == 0x000004, "Wrong size on BGWOnlinePresence_Init");
static_assert(offsetof(BGWOnlinePresence_Init, ReturnValue) == 0x000000, "Member 'BGWOnlinePresence_Init::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlinePresence.OnSetPresenceCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlinePresence_OnSetPresenceCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlinePresence_OnSetPresenceCompleteCS) == 0x000001, "Wrong alignment on BGWOnlinePresence_OnSetPresenceCompleteCS");
static_assert(sizeof(BGWOnlinePresence_OnSetPresenceCompleteCS) == 0x000001, "Wrong size on BGWOnlinePresence_OnSetPresenceCompleteCS");
static_assert(offsetof(BGWOnlinePresence_OnSetPresenceCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlinePresence_OnSetPresenceCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlinePresence.SetRichPresence
// 0x0070 (0x0070 - 0x0000)
struct BGWOnlinePresence_SetRichPresence final
{
public:
	class FString                                 PresenceId;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatusStr;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            Properties;                                        // 0x0020(0x0050)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlinePresence_SetRichPresence) == 0x000008, "Wrong alignment on BGWOnlinePresence_SetRichPresence");
static_assert(sizeof(BGWOnlinePresence_SetRichPresence) == 0x000070, "Wrong size on BGWOnlinePresence_SetRichPresence");
static_assert(offsetof(BGWOnlinePresence_SetRichPresence, PresenceId) == 0x000000, "Member 'BGWOnlinePresence_SetRichPresence::PresenceId' has a wrong offset!");
static_assert(offsetof(BGWOnlinePresence_SetRichPresence, StatusStr) == 0x000010, "Member 'BGWOnlinePresence_SetRichPresence::StatusStr' has a wrong offset!");
static_assert(offsetof(BGWOnlinePresence_SetRichPresence, Properties) == 0x000020, "Member 'BGWOnlinePresence_SetRichPresence::Properties' has a wrong offset!");

// Function b1.BGWOnlineSession.CreateSession
// 0x0070 (0x0070 - 0x0000)
struct BGWOnlineSession_CreateSession final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumPlayers;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              CustumSettings;                                    // 0x0008(0x0050)(Parm, NativeAccessSpecifierPublic)
	bool                                          bIsLANMatch;                                       // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OverrideSessionTemplate;                           // 0x0060(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_CreateSession) == 0x000008, "Wrong alignment on BGWOnlineSession_CreateSession");
static_assert(sizeof(BGWOnlineSession_CreateSession) == 0x000070, "Wrong size on BGWOnlineSession_CreateSession");
static_assert(offsetof(BGWOnlineSession_CreateSession, SessionType) == 0x000000, "Member 'BGWOnlineSession_CreateSession::SessionType' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_CreateSession, MaxNumPlayers) == 0x000004, "Member 'BGWOnlineSession_CreateSession::MaxNumPlayers' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_CreateSession, CustumSettings) == 0x000008, "Member 'BGWOnlineSession_CreateSession::CustumSettings' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_CreateSession, bIsLANMatch) == 0x000058, "Member 'BGWOnlineSession_CreateSession::bIsLANMatch' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_CreateSession, OverrideSessionTemplate) == 0x000060, "Member 'BGWOnlineSession_CreateSession::OverrideSessionTemplate' has a wrong offset!");

// Function b1.BGWOnlineSession.DestroySession
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSession_DestroySession final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_DestroySession) == 0x000001, "Wrong alignment on BGWOnlineSession_DestroySession");
static_assert(sizeof(BGWOnlineSession_DestroySession) == 0x000001, "Wrong size on BGWOnlineSession_DestroySession");
static_assert(offsetof(BGWOnlineSession_DestroySession, SessionType) == 0x000000, "Member 'BGWOnlineSession_DestroySession::SessionType' has a wrong offset!");

// Function b1.BGWOnlineSession.FindSessionById
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineSession_FindSessionById final
{
public:
	class FString                                 SessionId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGameSession;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSession_FindSessionById) == 0x000008, "Wrong alignment on BGWOnlineSession_FindSessionById");
static_assert(sizeof(BGWOnlineSession_FindSessionById) == 0x000018, "Wrong size on BGWOnlineSession_FindSessionById");
static_assert(offsetof(BGWOnlineSession_FindSessionById, SessionId) == 0x000000, "Member 'BGWOnlineSession_FindSessionById::SessionId' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_FindSessionById, IsGameSession) == 0x000010, "Member 'BGWOnlineSession_FindSessionById::IsGameSession' has a wrong offset!");

// Function b1.BGWOnlineSession.GetSessionIdStr
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineSession_GetSessionIdStr final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_GetSessionIdStr) == 0x000008, "Wrong alignment on BGWOnlineSession_GetSessionIdStr");
static_assert(sizeof(BGWOnlineSession_GetSessionIdStr) == 0x000018, "Wrong size on BGWOnlineSession_GetSessionIdStr");
static_assert(offsetof(BGWOnlineSession_GetSessionIdStr, SessionType) == 0x000000, "Member 'BGWOnlineSession_GetSessionIdStr::SessionType' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_GetSessionIdStr, ReturnValue) == 0x000008, "Member 'BGWOnlineSession_GetSessionIdStr::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSession.GetSessionState
// 0x0002 (0x0002 - 0x0000)
struct BGWOnlineSession_GetSessionState final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGWOnlineSessionState                        ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_GetSessionState) == 0x000001, "Wrong alignment on BGWOnlineSession_GetSessionState");
static_assert(sizeof(BGWOnlineSession_GetSessionState) == 0x000002, "Wrong size on BGWOnlineSession_GetSessionState");
static_assert(offsetof(BGWOnlineSession_GetSessionState, SessionType) == 0x000000, "Member 'BGWOnlineSession_GetSessionState::SessionType' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_GetSessionState, ReturnValue) == 0x000001, "Member 'BGWOnlineSession_GetSessionState::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSession.GetTravelUrl
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineSession_GetTravelUrl final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_GetTravelUrl) == 0x000008, "Wrong alignment on BGWOnlineSession_GetTravelUrl");
static_assert(sizeof(BGWOnlineSession_GetTravelUrl) == 0x000018, "Wrong size on BGWOnlineSession_GetTravelUrl");
static_assert(offsetof(BGWOnlineSession_GetTravelUrl, SessionType) == 0x000000, "Member 'BGWOnlineSession_GetTravelUrl::SessionType' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_GetTravelUrl, ReturnValue) == 0x000008, "Member 'BGWOnlineSession_GetTravelUrl::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSession.Init
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlineSession_Init final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_Init) == 0x000004, "Wrong alignment on BGWOnlineSession_Init");
static_assert(sizeof(BGWOnlineSession_Init) == 0x000004, "Wrong size on BGWOnlineSession_Init");
static_assert(offsetof(BGWOnlineSession_Init, ReturnValue) == 0x000000, "Member 'BGWOnlineSession_Init::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSession.JoinSession
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineSession_JoinSession final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SessionId;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_JoinSession) == 0x000008, "Wrong alignment on BGWOnlineSession_JoinSession");
static_assert(sizeof(BGWOnlineSession_JoinSession) == 0x000018, "Wrong size on BGWOnlineSession_JoinSession");
static_assert(offsetof(BGWOnlineSession_JoinSession, SessionType) == 0x000000, "Member 'BGWOnlineSession_JoinSession::SessionType' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_JoinSession, SessionId) == 0x000008, "Member 'BGWOnlineSession_JoinSession::SessionId' has a wrong offset!");

// Function b1.BGWOnlineSession.OnCreateSessionCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSession_OnCreateSessionCompleteCS final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_OnCreateSessionCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineSession_OnCreateSessionCompleteCS");
static_assert(sizeof(BGWOnlineSession_OnCreateSessionCompleteCS) == 0x000001, "Wrong size on BGWOnlineSession_OnCreateSessionCompleteCS");
static_assert(offsetof(BGWOnlineSession_OnCreateSessionCompleteCS, Success) == 0x000000, "Member 'BGWOnlineSession_OnCreateSessionCompleteCS::Success' has a wrong offset!");

// Function b1.BGWOnlineSession.OnDestroySessionCompleteCS
// 0x0002 (0x0002 - 0x0000)
struct BGWOnlineSession_OnDestroySessionCompleteCS final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_OnDestroySessionCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineSession_OnDestroySessionCompleteCS");
static_assert(sizeof(BGWOnlineSession_OnDestroySessionCompleteCS) == 0x000002, "Wrong size on BGWOnlineSession_OnDestroySessionCompleteCS");
static_assert(offsetof(BGWOnlineSession_OnDestroySessionCompleteCS, SessionType) == 0x000000, "Member 'BGWOnlineSession_OnDestroySessionCompleteCS::SessionType' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_OnDestroySessionCompleteCS, Success) == 0x000001, "Member 'BGWOnlineSession_OnDestroySessionCompleteCS::Success' has a wrong offset!");

// Function b1.BGWOnlineSession.OnFindSessionByIdCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSession_OnFindSessionByIdCompleteCS final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_OnFindSessionByIdCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineSession_OnFindSessionByIdCompleteCS");
static_assert(sizeof(BGWOnlineSession_OnFindSessionByIdCompleteCS) == 0x000001, "Wrong size on BGWOnlineSession_OnFindSessionByIdCompleteCS");
static_assert(offsetof(BGWOnlineSession_OnFindSessionByIdCompleteCS, Success) == 0x000000, "Member 'BGWOnlineSession_OnFindSessionByIdCompleteCS::Success' has a wrong offset!");

// Function b1.BGWOnlineSession.OnJoinSessionCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSession_OnJoinSessionCompleteCS final
{
public:
	EBGWJoinSessionResult                         Result;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_OnJoinSessionCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineSession_OnJoinSessionCompleteCS");
static_assert(sizeof(BGWOnlineSession_OnJoinSessionCompleteCS) == 0x000001, "Wrong size on BGWOnlineSession_OnJoinSessionCompleteCS");
static_assert(offsetof(BGWOnlineSession_OnJoinSessionCompleteCS, Result) == 0x000000, "Member 'BGWOnlineSession_OnJoinSessionCompleteCS::Result' has a wrong offset!");

// Function b1.BGWOnlineSession.OnSearchSessionsCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSession_OnSearchSessionsCompleteCS final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_OnSearchSessionsCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineSession_OnSearchSessionsCompleteCS");
static_assert(sizeof(BGWOnlineSession_OnSearchSessionsCompleteCS) == 0x000001, "Wrong size on BGWOnlineSession_OnSearchSessionsCompleteCS");
static_assert(offsetof(BGWOnlineSession_OnSearchSessionsCompleteCS, Success) == 0x000000, "Member 'BGWOnlineSession_OnSearchSessionsCompleteCS::Success' has a wrong offset!");

// Function b1.BGWOnlineSession.OnSessionUserInviteAcceptedCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSession_OnSessionUserInviteAcceptedCS final
{
public:
	bool                                          bWasSuccess;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_OnSessionUserInviteAcceptedCS) == 0x000001, "Wrong alignment on BGWOnlineSession_OnSessionUserInviteAcceptedCS");
static_assert(sizeof(BGWOnlineSession_OnSessionUserInviteAcceptedCS) == 0x000001, "Wrong size on BGWOnlineSession_OnSessionUserInviteAcceptedCS");
static_assert(offsetof(BGWOnlineSession_OnSessionUserInviteAcceptedCS, bWasSuccess) == 0x000000, "Member 'BGWOnlineSession_OnSessionUserInviteAcceptedCS::bWasSuccess' has a wrong offset!");

// Function b1.BGWOnlineSession.SearchSessions
// 0x0060 (0x0060 - 0x0000)
struct BGWOnlineSession_SearchSessions final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FString>              SearchFilters;                                     // 0x0008(0x0050)(Parm, NativeAccessSpecifierPublic)
	bool                                          bIsLANMatch;                                       // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSession_SearchSessions) == 0x000008, "Wrong alignment on BGWOnlineSession_SearchSessions");
static_assert(sizeof(BGWOnlineSession_SearchSessions) == 0x000060, "Wrong size on BGWOnlineSession_SearchSessions");
static_assert(offsetof(BGWOnlineSession_SearchSessions, SessionType) == 0x000000, "Member 'BGWOnlineSession_SearchSessions::SessionType' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_SearchSessions, SearchFilters) == 0x000008, "Member 'BGWOnlineSession_SearchSessions::SearchFilters' has a wrong offset!");
static_assert(offsetof(BGWOnlineSession_SearchSessions, bIsLANMatch) == 0x000058, "Member 'BGWOnlineSession_SearchSessions::bIsLANMatch' has a wrong offset!");

// Function b1.BGWOnlineSession.ShowInviteUI
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSession_ShowInviteUI final
{
public:
	EBGWOnlineSessionType                         SessionType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSession_ShowInviteUI) == 0x000001, "Wrong alignment on BGWOnlineSession_ShowInviteUI");
static_assert(sizeof(BGWOnlineSession_ShowInviteUI) == 0x000001, "Wrong size on BGWOnlineSession_ShowInviteUI");
static_assert(offsetof(BGWOnlineSession_ShowInviteUI, SessionType) == 0x000000, "Member 'BGWOnlineSession_ShowInviteUI::SessionType' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.GetSubsystemType
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSubsystem_GetSubsystemType final
{
public:
	EBGWSubsystemType                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubsystem_GetSubsystemType) == 0x000001, "Wrong alignment on BGWOnlineSubsystem_GetSubsystemType");
static_assert(sizeof(BGWOnlineSubsystem_GetSubsystemType) == 0x000001, "Wrong size on BGWOnlineSubsystem_GetSubsystemType");
static_assert(offsetof(BGWOnlineSubsystem_GetSubsystemType, ReturnValue) == 0x000000, "Member 'BGWOnlineSubsystem_GetSubsystemType::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.AfterInit
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlineSubsystem_AfterInit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubsystem_AfterInit) == 0x000004, "Wrong alignment on BGWOnlineSubsystem_AfterInit");
static_assert(sizeof(BGWOnlineSubsystem_AfterInit) == 0x000004, "Wrong size on BGWOnlineSubsystem_AfterInit");
static_assert(offsetof(BGWOnlineSubsystem_AfterInit, ReturnValue) == 0x000000, "Member 'BGWOnlineSubsystem_AfterInit::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.GetInstanceName
// 0x0008 (0x0008 - 0x0000)
struct BGWOnlineSubsystem_GetInstanceName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubsystem_GetInstanceName) == 0x000004, "Wrong alignment on BGWOnlineSubsystem_GetInstanceName");
static_assert(sizeof(BGWOnlineSubsystem_GetInstanceName) == 0x000008, "Wrong size on BGWOnlineSubsystem_GetInstanceName");
static_assert(offsetof(BGWOnlineSubsystem_GetInstanceName, ReturnValue) == 0x000000, "Member 'BGWOnlineSubsystem_GetInstanceName::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.GetLocalPlatformName
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineSubsystem_GetLocalPlatformName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubsystem_GetLocalPlatformName) == 0x000008, "Wrong alignment on BGWOnlineSubsystem_GetLocalPlatformName");
static_assert(sizeof(BGWOnlineSubsystem_GetLocalPlatformName) == 0x000010, "Wrong size on BGWOnlineSubsystem_GetLocalPlatformName");
static_assert(offsetof(BGWOnlineSubsystem_GetLocalPlatformName, ReturnValue) == 0x000000, "Member 'BGWOnlineSubsystem_GetLocalPlatformName::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.GetSubsystemNameForDebug
// 0x0008 (0x0008 - 0x0000)
struct BGWOnlineSubsystem_GetSubsystemNameForDebug final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubsystem_GetSubsystemNameForDebug) == 0x000004, "Wrong alignment on BGWOnlineSubsystem_GetSubsystemNameForDebug");
static_assert(sizeof(BGWOnlineSubsystem_GetSubsystemNameForDebug) == 0x000008, "Wrong size on BGWOnlineSubsystem_GetSubsystemNameForDebug");
static_assert(offsetof(BGWOnlineSubsystem_GetSubsystemNameForDebug, ReturnValue) == 0x000000, "Member 'BGWOnlineSubsystem_GetSubsystemNameForDebug::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.Init
// 0x0004 (0x0004 - 0x0000)
struct BGWOnlineSubsystem_Init final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubsystem_Init) == 0x000004, "Wrong alignment on BGWOnlineSubsystem_Init");
static_assert(sizeof(BGWOnlineSubsystem_Init) == 0x000004, "Wrong size on BGWOnlineSubsystem_Init");
static_assert(offsetof(BGWOnlineSubsystem_Init, ReturnValue) == 0x000000, "Member 'BGWOnlineSubsystem_Init::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.OnQueryIsOwnAdditionContentCompleteCS
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS final
{
public:
	class FString                                 EntitlementId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS) == 0x000008, "Wrong alignment on BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS");
static_assert(sizeof(BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS) == 0x000018, "Wrong size on BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS");
static_assert(offsetof(BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS, EntitlementId) == 0x000000, "Member 'BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS::EntitlementId' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS, bWasSuccessful) == 0x000010, "Member 'BGWOnlineSubsystem_OnQueryIsOwnAdditionContentCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.OnShowStoreUIClosedCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSubsystem_OnShowStoreUIClosedCS final
{
public:
	bool                                          bPurchased;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubsystem_OnShowStoreUIClosedCS) == 0x000001, "Wrong alignment on BGWOnlineSubsystem_OnShowStoreUIClosedCS");
static_assert(sizeof(BGWOnlineSubsystem_OnShowStoreUIClosedCS) == 0x000001, "Wrong size on BGWOnlineSubsystem_OnShowStoreUIClosedCS");
static_assert(offsetof(BGWOnlineSubsystem_OnShowStoreUIClosedCS, bPurchased) == 0x000000, "Member 'BGWOnlineSubsystem_OnShowStoreUIClosedCS::bPurchased' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.QueryIsOwnAdditionContent
// 0x0010 (0x0010 - 0x0000)
struct BGWOnlineSubsystem_QueryIsOwnAdditionContent final
{
public:
	class FString                                 EntitlementId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubsystem_QueryIsOwnAdditionContent) == 0x000008, "Wrong alignment on BGWOnlineSubsystem_QueryIsOwnAdditionContent");
static_assert(sizeof(BGWOnlineSubsystem_QueryIsOwnAdditionContent) == 0x000010, "Wrong size on BGWOnlineSubsystem_QueryIsOwnAdditionContent");
static_assert(offsetof(BGWOnlineSubsystem_QueryIsOwnAdditionContent, EntitlementId) == 0x000000, "Member 'BGWOnlineSubsystem_QueryIsOwnAdditionContent::EntitlementId' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.QueryIsOwnAdditionContentSync
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineSubsystem_QueryIsOwnAdditionContentSync final
{
public:
	class FString                                 EntitlementId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubsystem_QueryIsOwnAdditionContentSync) == 0x000008, "Wrong alignment on BGWOnlineSubsystem_QueryIsOwnAdditionContentSync");
static_assert(sizeof(BGWOnlineSubsystem_QueryIsOwnAdditionContentSync) == 0x000018, "Wrong size on BGWOnlineSubsystem_QueryIsOwnAdditionContentSync");
static_assert(offsetof(BGWOnlineSubsystem_QueryIsOwnAdditionContentSync, EntitlementId) == 0x000000, "Member 'BGWOnlineSubsystem_QueryIsOwnAdditionContentSync::EntitlementId' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubsystem_QueryIsOwnAdditionContentSync, ReturnValue) == 0x000010, "Member 'BGWOnlineSubsystem_QueryIsOwnAdditionContentSync::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubsystem.ShowStoreUI
// 0x0018 (0x0018 - 0x0000)
struct BGWOnlineSubsystem_ShowStoreUI final
{
public:
	class FString                                 ProductId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddToCard;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubsystem_ShowStoreUI) == 0x000008, "Wrong alignment on BGWOnlineSubsystem_ShowStoreUI");
static_assert(sizeof(BGWOnlineSubsystem_ShowStoreUI) == 0x000018, "Wrong size on BGWOnlineSubsystem_ShowStoreUI");
static_assert(offsetof(BGWOnlineSubsystem_ShowStoreUI, ProductId) == 0x000000, "Member 'BGWOnlineSubsystem_ShowStoreUI::ProductId' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubsystem_ShowStoreUI, AddToCard) == 0x000010, "Member 'BGWOnlineSubsystem_ShowStoreUI::AddToCard' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubsystem_ShowStoreUI, ReturnValue) == 0x000011, "Member 'BGWOnlineSubsystem_ShowStoreUI::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.FindGames
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSubSystemMgr_FindGames final
{
public:
	bool                                          bIsLAN;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubSystemMgr_FindGames) == 0x000001, "Wrong alignment on BGWOnlineSubSystemMgr_FindGames");
static_assert(sizeof(BGWOnlineSubSystemMgr_FindGames) == 0x000001, "Wrong size on BGWOnlineSubSystemMgr_FindGames");
static_assert(offsetof(BGWOnlineSubSystemMgr_FindGames, bIsLAN) == 0x000000, "Member 'BGWOnlineSubSystemMgr_FindGames::bIsLAN' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.HandleNetworkErrorCS
// 0x0020 (0x0020 - 0x0000)
struct BGWOnlineSubSystemMgr_HandleNetworkErrorCS final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENetworkFailure                               FailureType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorString;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubSystemMgr_HandleNetworkErrorCS) == 0x000008, "Wrong alignment on BGWOnlineSubSystemMgr_HandleNetworkErrorCS");
static_assert(sizeof(BGWOnlineSubSystemMgr_HandleNetworkErrorCS) == 0x000020, "Wrong size on BGWOnlineSubSystemMgr_HandleNetworkErrorCS");
static_assert(offsetof(BGWOnlineSubSystemMgr_HandleNetworkErrorCS, World) == 0x000000, "Member 'BGWOnlineSubSystemMgr_HandleNetworkErrorCS::World' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_HandleNetworkErrorCS, FailureType) == 0x000008, "Member 'BGWOnlineSubSystemMgr_HandleNetworkErrorCS::FailureType' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_HandleNetworkErrorCS, ErrorString) == 0x000010, "Member 'BGWOnlineSubSystemMgr_HandleNetworkErrorCS::ErrorString' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.HostGame
// 0x0060 (0x0060 - 0x0000)
struct BGWOnlineSubSystemMgr_HostGame final
{
public:
	bool                                          bIsLAN;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumPlayers;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            CustumSettings;                                    // 0x0008(0x0050)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubSystemMgr_HostGame) == 0x000008, "Wrong alignment on BGWOnlineSubSystemMgr_HostGame");
static_assert(sizeof(BGWOnlineSubSystemMgr_HostGame) == 0x000060, "Wrong size on BGWOnlineSubSystemMgr_HostGame");
static_assert(offsetof(BGWOnlineSubSystemMgr_HostGame, bIsLAN) == 0x000000, "Member 'BGWOnlineSubSystemMgr_HostGame::bIsLAN' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_HostGame, MaxNumPlayers) == 0x000004, "Member 'BGWOnlineSubSystemMgr_HostGame::MaxNumPlayers' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_HostGame, CustumSettings) == 0x000008, "Member 'BGWOnlineSubSystemMgr_HostGame::CustumSettings' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_HostGame, ReturnValue) == 0x000058, "Member 'BGWOnlineSubSystemMgr_HostGame::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.JoinGame
// 0x0168 (0x0168 - 0x0000)
struct BGWOnlineSubSystemMgr_JoinGame final
{
public:
	struct FBlueprintSearchResult                 Result;                                            // 0x0000(0x0160)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0160(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubSystemMgr_JoinGame) == 0x000008, "Wrong alignment on BGWOnlineSubSystemMgr_JoinGame");
static_assert(sizeof(BGWOnlineSubSystemMgr_JoinGame) == 0x000168, "Wrong size on BGWOnlineSubSystemMgr_JoinGame");
static_assert(offsetof(BGWOnlineSubSystemMgr_JoinGame, Result) == 0x000000, "Member 'BGWOnlineSubSystemMgr_JoinGame::Result' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_JoinGame, ReturnValue) == 0x000160, "Member 'BGWOnlineSubSystemMgr_JoinGame::ReturnValue' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.OnCreateSessionCompleteCS
// 0x000C (0x000C - 0x0000)
struct BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS final
{
public:
	class FName                                   SessionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS) == 0x000004, "Wrong alignment on BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS");
static_assert(sizeof(BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS) == 0x00000C, "Wrong size on BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS, SessionName) == 0x000000, "Member 'BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS::SessionName' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS, bWasSuccessful) == 0x000008, "Member 'BGWOnlineSubSystemMgr_OnCreateSessionCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.OnDestroySessionCompleteCS
// 0x000C (0x000C - 0x0000)
struct BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS final
{
public:
	class FName                                   SessionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS) == 0x000004, "Wrong alignment on BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS");
static_assert(sizeof(BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS) == 0x00000C, "Wrong size on BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS, SessionName) == 0x000000, "Member 'BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS::SessionName' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS, bWasSuccessful) == 0x000008, "Member 'BGWOnlineSubSystemMgr_OnDestroySessionCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.OnFindSessionsCompleteCS
// 0x0001 (0x0001 - 0x0000)
struct BGWOnlineSubSystemMgr_OnFindSessionsCompleteCS final
{
public:
	bool                                          bWasSuccessful;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubSystemMgr_OnFindSessionsCompleteCS) == 0x000001, "Wrong alignment on BGWOnlineSubSystemMgr_OnFindSessionsCompleteCS");
static_assert(sizeof(BGWOnlineSubSystemMgr_OnFindSessionsCompleteCS) == 0x000001, "Wrong size on BGWOnlineSubSystemMgr_OnFindSessionsCompleteCS");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnFindSessionsCompleteCS, bWasSuccessful) == 0x000000, "Member 'BGWOnlineSubSystemMgr_OnFindSessionsCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.OnJoinSessionCompleteCS
// 0x000C (0x000C - 0x0000)
struct BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS final
{
public:
	class FName                                   SessionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Result;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS) == 0x000004, "Wrong alignment on BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS");
static_assert(sizeof(BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS) == 0x00000C, "Wrong size on BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS, SessionName) == 0x000000, "Member 'BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS::SessionName' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS, Result) == 0x000008, "Member 'BGWOnlineSubSystemMgr_OnJoinSessionCompleteCS::Result' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.OnStartOnlineGameCompleteCS
// 0x000C (0x000C - 0x0000)
struct BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS final
{
public:
	class FName                                   SessionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS) == 0x000004, "Wrong alignment on BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS");
static_assert(sizeof(BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS) == 0x00000C, "Wrong size on BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS, SessionName) == 0x000000, "Member 'BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS::SessionName' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS, bWasSuccessful) == 0x000008, "Member 'BGWOnlineSubSystemMgr_OnStartOnlineGameCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWOnlineSubSystemMgr.OnUpdateSessionCompleteCS
// 0x000C (0x000C - 0x0000)
struct BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS final
{
public:
	class FName                                   SessionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasSuccessful;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS) == 0x000004, "Wrong alignment on BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS");
static_assert(sizeof(BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS) == 0x00000C, "Wrong size on BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS, SessionName) == 0x000000, "Member 'BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS::SessionName' has a wrong offset!");
static_assert(offsetof(BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS, bWasSuccessful) == 0x000008, "Member 'BGWOnlineSubSystemMgr_OnUpdateSessionCompleteCS::bWasSuccessful' has a wrong offset!");

// Function b1.BGWPlatformEventMgr.OnNetworkInitializedChangeCS
// 0x0001 (0x0001 - 0x0000)
struct BGWPlatformEventMgr_OnNetworkInitializedChangeCS final
{
public:
	bool                                          bIsNetworkInitialized;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWPlatformEventMgr_OnNetworkInitializedChangeCS) == 0x000001, "Wrong alignment on BGWPlatformEventMgr_OnNetworkInitializedChangeCS");
static_assert(sizeof(BGWPlatformEventMgr_OnNetworkInitializedChangeCS) == 0x000001, "Wrong size on BGWPlatformEventMgr_OnNetworkInitializedChangeCS");
static_assert(offsetof(BGWPlatformEventMgr_OnNetworkInitializedChangeCS, bIsNetworkInitialized) == 0x000000, "Member 'BGWPlatformEventMgr_OnNetworkInitializedChangeCS::bIsNetworkInitialized' has a wrong offset!");

// Function b1.BGWPlatformEventMgr.OnUserLoginChangeCS
// 0x000C (0x000C - 0x0000)
struct BGWPlatformEventMgr_OnUserLoginChangeCS final
{
public:
	bool                                          bIsSignIn;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlatformUserId;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWPlatformEventMgr_OnUserLoginChangeCS) == 0x000004, "Wrong alignment on BGWPlatformEventMgr_OnUserLoginChangeCS");
static_assert(sizeof(BGWPlatformEventMgr_OnUserLoginChangeCS) == 0x00000C, "Wrong size on BGWPlatformEventMgr_OnUserLoginChangeCS");
static_assert(offsetof(BGWPlatformEventMgr_OnUserLoginChangeCS, bIsSignIn) == 0x000000, "Member 'BGWPlatformEventMgr_OnUserLoginChangeCS::bIsSignIn' has a wrong offset!");
static_assert(offsetof(BGWPlatformEventMgr_OnUserLoginChangeCS, PlatformUserId) == 0x000004, "Member 'BGWPlatformEventMgr_OnUserLoginChangeCS::PlatformUserId' has a wrong offset!");
static_assert(offsetof(BGWPlatformEventMgr_OnUserLoginChangeCS, UserIndex) == 0x000008, "Member 'BGWPlatformEventMgr_OnUserLoginChangeCS::UserIndex' has a wrong offset!");

// Function b1.BGWPlayerController.BGWDeprojectScreenToWorld
// 0x0048 (0x0048 - 0x0000)
struct BGWPlayerController_BGWDeprojectScreenToWorld final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayOrigin;                                         // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayDirection;                                      // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWPlayerController_BGWDeprojectScreenToWorld) == 0x000008, "Wrong alignment on BGWPlayerController_BGWDeprojectScreenToWorld");
static_assert(sizeof(BGWPlayerController_BGWDeprojectScreenToWorld) == 0x000048, "Wrong size on BGWPlayerController_BGWDeprojectScreenToWorld");
static_assert(offsetof(BGWPlayerController_BGWDeprojectScreenToWorld, ScreenPosition) == 0x000000, "Member 'BGWPlayerController_BGWDeprojectScreenToWorld::ScreenPosition' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_BGWDeprojectScreenToWorld, RayOrigin) == 0x000010, "Member 'BGWPlayerController_BGWDeprojectScreenToWorld::RayOrigin' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_BGWDeprojectScreenToWorld, RayDirection) == 0x000028, "Member 'BGWPlayerController_BGWDeprojectScreenToWorld::RayDirection' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_BGWDeprojectScreenToWorld, ReturnValue) == 0x000040, "Member 'BGWPlayerController_BGWDeprojectScreenToWorld::ReturnValue' has a wrong offset!");

// Function b1.BGWPlayerController.GetViewportClientMousePosition
// 0x0018 (0x0018 - 0x0000)
struct BGWPlayerController_GetViewportClientMousePosition final
{
public:
	struct FVector2D                              MousePosition;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWPlayerController_GetViewportClientMousePosition) == 0x000008, "Wrong alignment on BGWPlayerController_GetViewportClientMousePosition");
static_assert(sizeof(BGWPlayerController_GetViewportClientMousePosition) == 0x000018, "Wrong size on BGWPlayerController_GetViewportClientMousePosition");
static_assert(offsetof(BGWPlayerController_GetViewportClientMousePosition, MousePosition) == 0x000000, "Member 'BGWPlayerController_GetViewportClientMousePosition::MousePosition' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_GetViewportClientMousePosition, ReturnValue) == 0x000010, "Member 'BGWPlayerController_GetViewportClientMousePosition::ReturnValue' has a wrong offset!");

// Function b1.BGWPlayerController.ProcessPlayerInputCS
// 0x0008 (0x0008 - 0x0000)
struct BGWPlayerController_ProcessPlayerInputCS final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamePaused;                                       // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWPlayerController_ProcessPlayerInputCS) == 0x000004, "Wrong alignment on BGWPlayerController_ProcessPlayerInputCS");
static_assert(sizeof(BGWPlayerController_ProcessPlayerInputCS) == 0x000008, "Wrong size on BGWPlayerController_ProcessPlayerInputCS");
static_assert(offsetof(BGWPlayerController_ProcessPlayerInputCS, DeltaTime) == 0x000000, "Member 'BGWPlayerController_ProcessPlayerInputCS::DeltaTime' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_ProcessPlayerInputCS, bGamePaused) == 0x000004, "Member 'BGWPlayerController_ProcessPlayerInputCS::bGamePaused' has a wrong offset!");

// Function b1.BGWPlayerController.BGWGetHitResultAtScreenPosition
// 0x0108 (0x0108 - 0x0000)
struct BGWPlayerController_BGWGetHitResultAtScreenPosition final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0018(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWPlayerController_BGWGetHitResultAtScreenPosition) == 0x000008, "Wrong alignment on BGWPlayerController_BGWGetHitResultAtScreenPosition");
static_assert(sizeof(BGWPlayerController_BGWGetHitResultAtScreenPosition) == 0x000108, "Wrong size on BGWPlayerController_BGWGetHitResultAtScreenPosition");
static_assert(offsetof(BGWPlayerController_BGWGetHitResultAtScreenPosition, ScreenPosition) == 0x000000, "Member 'BGWPlayerController_BGWGetHitResultAtScreenPosition::ScreenPosition' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_BGWGetHitResultAtScreenPosition, TraceChannel) == 0x000010, "Member 'BGWPlayerController_BGWGetHitResultAtScreenPosition::TraceChannel' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_BGWGetHitResultAtScreenPosition, bTraceComplex) == 0x000011, "Member 'BGWPlayerController_BGWGetHitResultAtScreenPosition::bTraceComplex' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_BGWGetHitResultAtScreenPosition, HitResult) == 0x000018, "Member 'BGWPlayerController_BGWGetHitResultAtScreenPosition::HitResult' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_BGWGetHitResultAtScreenPosition, ReturnValue) == 0x000100, "Member 'BGWPlayerController_BGWGetHitResultAtScreenPosition::ReturnValue' has a wrong offset!");

// Function b1.BGWPlayerController.GetPlayerInputTouch
// 0x0020 (0x0020 - 0x0000)
struct BGWPlayerController_GetPlayerInputTouch final
{
public:
	int32                                         Idx;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWPlayerController_GetPlayerInputTouch) == 0x000008, "Wrong alignment on BGWPlayerController_GetPlayerInputTouch");
static_assert(sizeof(BGWPlayerController_GetPlayerInputTouch) == 0x000020, "Wrong size on BGWPlayerController_GetPlayerInputTouch");
static_assert(offsetof(BGWPlayerController_GetPlayerInputTouch, Idx) == 0x000000, "Member 'BGWPlayerController_GetPlayerInputTouch::Idx' has a wrong offset!");
static_assert(offsetof(BGWPlayerController_GetPlayerInputTouch, ReturnValue) == 0x000008, "Member 'BGWPlayerController_GetPlayerInputTouch::ReturnValue' has a wrong offset!");

// Function b1.BGWPlayerController.GetPlayerInputTouchesCount
// 0x0004 (0x0004 - 0x0000)
struct BGWPlayerController_GetPlayerInputTouchesCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWPlayerController_GetPlayerInputTouchesCount) == 0x000004, "Wrong alignment on BGWPlayerController_GetPlayerInputTouchesCount");
static_assert(sizeof(BGWPlayerController_GetPlayerInputTouchesCount) == 0x000004, "Wrong size on BGWPlayerController_GetPlayerInputTouchesCount");
static_assert(offsetof(BGWPlayerController_GetPlayerInputTouchesCount, ReturnValue) == 0x000000, "Member 'BGWPlayerController_GetPlayerInputTouchesCount::ReturnValue' has a wrong offset!");

// Function b1.BGWSplinePrismVolume.K2_EncompassesPoint
// 0x0028 (0x0028 - 0x0000)
struct BGWSplinePrismVolume_K2_EncompassesPoint final
{
public:
	struct FVector                                InPoint;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutDistanceToPoint;                                // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWSplinePrismVolume_K2_EncompassesPoint) == 0x000008, "Wrong alignment on BGWSplinePrismVolume_K2_EncompassesPoint");
static_assert(sizeof(BGWSplinePrismVolume_K2_EncompassesPoint) == 0x000028, "Wrong size on BGWSplinePrismVolume_K2_EncompassesPoint");
static_assert(offsetof(BGWSplinePrismVolume_K2_EncompassesPoint, InPoint) == 0x000000, "Member 'BGWSplinePrismVolume_K2_EncompassesPoint::InPoint' has a wrong offset!");
static_assert(offsetof(BGWSplinePrismVolume_K2_EncompassesPoint, OutDistanceToPoint) == 0x000018, "Member 'BGWSplinePrismVolume_K2_EncompassesPoint::OutDistanceToPoint' has a wrong offset!");
static_assert(offsetof(BGWSplinePrismVolume_K2_EncompassesPoint, SphereRadius) == 0x00001C, "Member 'BGWSplinePrismVolume_K2_EncompassesPoint::SphereRadius' has a wrong offset!");
static_assert(offsetof(BGWSplinePrismVolume_K2_EncompassesPoint, ReturnValue) == 0x000020, "Member 'BGWSplinePrismVolume_K2_EncompassesPoint::ReturnValue' has a wrong offset!");

// Function b1.BGWStatsCapturer.DisableCapturing
// 0x0001 (0x0001 - 0x0000)
struct BGWStatsCapturer_DisableCapturing final
{
public:
	bool                                          bIsStop;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWStatsCapturer_DisableCapturing) == 0x000001, "Wrong alignment on BGWStatsCapturer_DisableCapturing");
static_assert(sizeof(BGWStatsCapturer_DisableCapturing) == 0x000001, "Wrong size on BGWStatsCapturer_DisableCapturing");
static_assert(offsetof(BGWStatsCapturer_DisableCapturing, bIsStop) == 0x000000, "Member 'BGWStatsCapturer_DisableCapturing::bIsStop' has a wrong offset!");

// Function b1.BGWStatsCapturer.EnableCapturing
// 0x0018 (0x0018 - 0x0000)
struct BGWStatsCapturer_EnableCapturing final
{
public:
	bool                                          bTriggerLogListening;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MetricsConfigPathUnderProjDir;                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWStatsCapturer_EnableCapturing) == 0x000008, "Wrong alignment on BGWStatsCapturer_EnableCapturing");
static_assert(sizeof(BGWStatsCapturer_EnableCapturing) == 0x000018, "Wrong size on BGWStatsCapturer_EnableCapturing");
static_assert(offsetof(BGWStatsCapturer_EnableCapturing, bTriggerLogListening) == 0x000000, "Member 'BGWStatsCapturer_EnableCapturing::bTriggerLogListening' has a wrong offset!");
static_assert(offsetof(BGWStatsCapturer_EnableCapturing, MetricsConfigPathUnderProjDir) == 0x000008, "Member 'BGWStatsCapturer_EnableCapturing::MetricsConfigPathUnderProjDir' has a wrong offset!");

// Function b1.BGWStatsCapturer.EnableCapturing_DT
// 0x0010 (0x0010 - 0x0000)
struct BGWStatsCapturer_EnableCapturing_DT final
{
public:
	bool                                          bTriggerLogListening;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             InStatDataTable;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWStatsCapturer_EnableCapturing_DT) == 0x000008, "Wrong alignment on BGWStatsCapturer_EnableCapturing_DT");
static_assert(sizeof(BGWStatsCapturer_EnableCapturing_DT) == 0x000010, "Wrong size on BGWStatsCapturer_EnableCapturing_DT");
static_assert(offsetof(BGWStatsCapturer_EnableCapturing_DT, bTriggerLogListening) == 0x000000, "Member 'BGWStatsCapturer_EnableCapturing_DT::bTriggerLogListening' has a wrong offset!");
static_assert(offsetof(BGWStatsCapturer_EnableCapturing_DT, InStatDataTable) == 0x000008, "Member 'BGWStatsCapturer_EnableCapturing_DT::InStatDataTable' has a wrong offset!");

// Function b1.BGWStatsCapturer.GetDesiredStatsValue
// 0x0010 (0x0010 - 0x0000)
struct BGWStatsCapturer_GetDesiredStatsValue final
{
public:
	TArray<struct FGSCapturedStatResult>          ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWStatsCapturer_GetDesiredStatsValue) == 0x000008, "Wrong alignment on BGWStatsCapturer_GetDesiredStatsValue");
static_assert(sizeof(BGWStatsCapturer_GetDesiredStatsValue) == 0x000010, "Wrong size on BGWStatsCapturer_GetDesiredStatsValue");
static_assert(offsetof(BGWStatsCapturer_GetDesiredStatsValue, ReturnValue) == 0x000000, "Member 'BGWStatsCapturer_GetDesiredStatsValue::ReturnValue' has a wrong offset!");

// Function b1.BGWStatsCapturer.GetDesiredVRAMInfo
// 0x0010 (0x0010 - 0x0000)
struct BGWStatsCapturer_GetDesiredVRAMInfo final
{
public:
	TArray<struct FGSCapturedStatResult>          ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWStatsCapturer_GetDesiredVRAMInfo) == 0x000008, "Wrong alignment on BGWStatsCapturer_GetDesiredVRAMInfo");
static_assert(sizeof(BGWStatsCapturer_GetDesiredVRAMInfo) == 0x000010, "Wrong size on BGWStatsCapturer_GetDesiredVRAMInfo");
static_assert(offsetof(BGWStatsCapturer_GetDesiredVRAMInfo, ReturnValue) == 0x000000, "Member 'BGWStatsCapturer_GetDesiredVRAMInfo::ReturnValue' has a wrong offset!");

// Function b1.BGWStatsCapturer.GetStartCycle
// 0x0008 (0x0008 - 0x0000)
struct BGWStatsCapturer_GetStartCycle final
{
public:
	int64                                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWStatsCapturer_GetStartCycle) == 0x000008, "Wrong alignment on BGWStatsCapturer_GetStartCycle");
static_assert(sizeof(BGWStatsCapturer_GetStartCycle) == 0x000008, "Wrong size on BGWStatsCapturer_GetStartCycle");
static_assert(offsetof(BGWStatsCapturer_GetStartCycle, ReturnValue) == 0x000000, "Member 'BGWStatsCapturer_GetStartCycle::ReturnValue' has a wrong offset!");

// Function b1.BGWStatsCapturer.GetTotalCapturedPerfInfo
// 0x0010 (0x0010 - 0x0000)
struct BGWStatsCapturer_GetTotalCapturedPerfInfo final
{
public:
	TArray<struct FGSCapturedStatResult>          ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWStatsCapturer_GetTotalCapturedPerfInfo) == 0x000008, "Wrong alignment on BGWStatsCapturer_GetTotalCapturedPerfInfo");
static_assert(sizeof(BGWStatsCapturer_GetTotalCapturedPerfInfo) == 0x000010, "Wrong size on BGWStatsCapturer_GetTotalCapturedPerfInfo");
static_assert(offsetof(BGWStatsCapturer_GetTotalCapturedPerfInfo, ReturnValue) == 0x000000, "Member 'BGWStatsCapturer_GetTotalCapturedPerfInfo::ReturnValue' has a wrong offset!");

// Function b1.BGWVolumeManager.OnGSLevelStateChanged
// 0x0008 (0x0008 - 0x0000)
struct BGWVolumeManager_OnGSLevelStateChanged final
{
public:
	int32                                         ActionID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Linkage;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWVolumeManager_OnGSLevelStateChanged) == 0x000004, "Wrong alignment on BGWVolumeManager_OnGSLevelStateChanged");
static_assert(sizeof(BGWVolumeManager_OnGSLevelStateChanged) == 0x000008, "Wrong size on BGWVolumeManager_OnGSLevelStateChanged");
static_assert(offsetof(BGWVolumeManager_OnGSLevelStateChanged, ActionID) == 0x000000, "Member 'BGWVolumeManager_OnGSLevelStateChanged::ActionID' has a wrong offset!");
static_assert(offsetof(BGWVolumeManager_OnGSLevelStateChanged, Linkage) == 0x000004, "Member 'BGWVolumeManager_OnGSLevelStateChanged::Linkage' has a wrong offset!");

// Function b1.BGWWorldSubSystem.GetWorldRefCS
// 0x0008 (0x0008 - 0x0000)
struct BGWWorldSubSystem_GetWorldRefCS final
{
public:
	class UWorld*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWWorldSubSystem_GetWorldRefCS) == 0x000008, "Wrong alignment on BGWWorldSubSystem_GetWorldRefCS");
static_assert(sizeof(BGWWorldSubSystem_GetWorldRefCS) == 0x000008, "Wrong size on BGWWorldSubSystem_GetWorldRefCS");
static_assert(offsetof(BGWWorldSubSystem_GetWorldRefCS, ReturnValue) == 0x000000, "Member 'BGWWorldSubSystem_GetWorldRefCS::ReturnValue' has a wrong offset!");

// Function b1.BGWWorldSubSystem.OnWorldBeginPlayCS
// 0x0008 (0x0008 - 0x0000)
struct BGWWorldSubSystem_OnWorldBeginPlayCS final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWWorldSubSystem_OnWorldBeginPlayCS) == 0x000008, "Wrong alignment on BGWWorldSubSystem_OnWorldBeginPlayCS");
static_assert(sizeof(BGWWorldSubSystem_OnWorldBeginPlayCS) == 0x000008, "Wrong size on BGWWorldSubSystem_OnWorldBeginPlayCS");
static_assert(offsetof(BGWWorldSubSystem_OnWorldBeginPlayCS, InWorld) == 0x000000, "Member 'BGWWorldSubSystem_OnWorldBeginPlayCS::InWorld' has a wrong offset!");

// Function b1.BGWWorldSubSystem.OnWorldComponentsUpdatedCS
// 0x0008 (0x0008 - 0x0000)
struct BGWWorldSubSystem_OnWorldComponentsUpdatedCS final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWWorldSubSystem_OnWorldComponentsUpdatedCS) == 0x000008, "Wrong alignment on BGWWorldSubSystem_OnWorldComponentsUpdatedCS");
static_assert(sizeof(BGWWorldSubSystem_OnWorldComponentsUpdatedCS) == 0x000008, "Wrong size on BGWWorldSubSystem_OnWorldComponentsUpdatedCS");
static_assert(offsetof(BGWWorldSubSystem_OnWorldComponentsUpdatedCS, World) == 0x000000, "Member 'BGWWorldSubSystem_OnWorldComponentsUpdatedCS::World' has a wrong offset!");

// Function b1.BGWWorldSubSystem.DoesSupportWorldTypeCS
// 0x0008 (0x0008 - 0x0000)
struct BGWWorldSubSystem_DoesSupportWorldTypeCS final
{
public:
	int32                                         WorldType;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWWorldSubSystem_DoesSupportWorldTypeCS) == 0x000004, "Wrong alignment on BGWWorldSubSystem_DoesSupportWorldTypeCS");
static_assert(sizeof(BGWWorldSubSystem_DoesSupportWorldTypeCS) == 0x000008, "Wrong size on BGWWorldSubSystem_DoesSupportWorldTypeCS");
static_assert(offsetof(BGWWorldSubSystem_DoesSupportWorldTypeCS, WorldType) == 0x000000, "Member 'BGWWorldSubSystem_DoesSupportWorldTypeCS::WorldType' has a wrong offset!");
static_assert(offsetof(BGWWorldSubSystem_DoesSupportWorldTypeCS, ReturnValue) == 0x000004, "Member 'BGWWorldSubSystem_DoesSupportWorldTypeCS::ReturnValue' has a wrong offset!");

// Function b1.BGWTickableWorldSubSystem.GetWorldRefCS
// 0x0008 (0x0008 - 0x0000)
struct BGWTickableWorldSubSystem_GetWorldRefCS final
{
public:
	class UWorld*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWTickableWorldSubSystem_GetWorldRefCS) == 0x000008, "Wrong alignment on BGWTickableWorldSubSystem_GetWorldRefCS");
static_assert(sizeof(BGWTickableWorldSubSystem_GetWorldRefCS) == 0x000008, "Wrong size on BGWTickableWorldSubSystem_GetWorldRefCS");
static_assert(offsetof(BGWTickableWorldSubSystem_GetWorldRefCS, ReturnValue) == 0x000000, "Member 'BGWTickableWorldSubSystem_GetWorldRefCS::ReturnValue' has a wrong offset!");

// Function b1.BGWTickableWorldSubSystem.OnTickCS
// 0x0004 (0x0004 - 0x0000)
struct BGWTickableWorldSubSystem_OnTickCS final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWTickableWorldSubSystem_OnTickCS) == 0x000004, "Wrong alignment on BGWTickableWorldSubSystem_OnTickCS");
static_assert(sizeof(BGWTickableWorldSubSystem_OnTickCS) == 0x000004, "Wrong size on BGWTickableWorldSubSystem_OnTickCS");
static_assert(offsetof(BGWTickableWorldSubSystem_OnTickCS, DeltaTime) == 0x000000, "Member 'BGWTickableWorldSubSystem_OnTickCS::DeltaTime' has a wrong offset!");

// Function b1.BGWTickableWorldSubSystem.OnWorldBeginPlayCS
// 0x0008 (0x0008 - 0x0000)
struct BGWTickableWorldSubSystem_OnWorldBeginPlayCS final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWTickableWorldSubSystem_OnWorldBeginPlayCS) == 0x000008, "Wrong alignment on BGWTickableWorldSubSystem_OnWorldBeginPlayCS");
static_assert(sizeof(BGWTickableWorldSubSystem_OnWorldBeginPlayCS) == 0x000008, "Wrong size on BGWTickableWorldSubSystem_OnWorldBeginPlayCS");
static_assert(offsetof(BGWTickableWorldSubSystem_OnWorldBeginPlayCS, InWorld) == 0x000000, "Member 'BGWTickableWorldSubSystem_OnWorldBeginPlayCS::InWorld' has a wrong offset!");

// Function b1.BGWTickableWorldSubSystem.OnWorldComponentsUpdatedCS
// 0x0008 (0x0008 - 0x0000)
struct BGWTickableWorldSubSystem_OnWorldComponentsUpdatedCS final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGWTickableWorldSubSystem_OnWorldComponentsUpdatedCS) == 0x000008, "Wrong alignment on BGWTickableWorldSubSystem_OnWorldComponentsUpdatedCS");
static_assert(sizeof(BGWTickableWorldSubSystem_OnWorldComponentsUpdatedCS) == 0x000008, "Wrong size on BGWTickableWorldSubSystem_OnWorldComponentsUpdatedCS");
static_assert(offsetof(BGWTickableWorldSubSystem_OnWorldComponentsUpdatedCS, World) == 0x000000, "Member 'BGWTickableWorldSubSystem_OnWorldComponentsUpdatedCS::World' has a wrong offset!");

// Function b1.BGWTickableWorldSubSystem.DoesSupportWorldTypeCS
// 0x0008 (0x0008 - 0x0000)
struct BGWTickableWorldSubSystem_DoesSupportWorldTypeCS final
{
public:
	int32                                         WorldType;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BGWTickableWorldSubSystem_DoesSupportWorldTypeCS) == 0x000004, "Wrong alignment on BGWTickableWorldSubSystem_DoesSupportWorldTypeCS");
static_assert(sizeof(BGWTickableWorldSubSystem_DoesSupportWorldTypeCS) == 0x000008, "Wrong size on BGWTickableWorldSubSystem_DoesSupportWorldTypeCS");
static_assert(offsetof(BGWTickableWorldSubSystem_DoesSupportWorldTypeCS, WorldType) == 0x000000, "Member 'BGWTickableWorldSubSystem_DoesSupportWorldTypeCS::WorldType' has a wrong offset!");
static_assert(offsetof(BGWTickableWorldSubSystem_DoesSupportWorldTypeCS, ReturnValue) == 0x000004, "Member 'BGWTickableWorldSubSystem_DoesSupportWorldTypeCS::ReturnValue' has a wrong offset!");

// Function b1.GSDescPropertyDetailCustomizationHelper.FindDescIdByRowName
// 0x000C (0x000C - 0x0000)
struct GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName final
{
public:
	class FName                                   RowName;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName) == 0x000004, "Wrong alignment on GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName");
static_assert(sizeof(GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName) == 0x00000C, "Wrong size on GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName");
static_assert(offsetof(GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName, RowName) == 0x000000, "Member 'GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName::RowName' has a wrong offset!");
static_assert(offsetof(GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName, ReturnValue) == 0x000008, "Member 'GSDescPropertyDetailCustomizationHelper_FindDescIdByRowName::ReturnValue' has a wrong offset!");

// Function b1.GSDescPropertyDetailCustomizationHelper.GetRowNameByDescId
// 0x0010 (0x0010 - 0x0000)
struct GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId final
{
public:
	int32                                         DescID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0004(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId) == 0x000004, "Wrong alignment on GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId");
static_assert(sizeof(GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId) == 0x000010, "Wrong size on GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId");
static_assert(offsetof(GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId, DescID) == 0x000000, "Member 'GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId::DescID' has a wrong offset!");
static_assert(offsetof(GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId, RowName) == 0x000004, "Member 'GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId::RowName' has a wrong offset!");
static_assert(offsetof(GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId, ReturnValue) == 0x00000C, "Member 'GSDescPropertyDetailCustomizationHelper_GetRowNameByDescId::ReturnValue' has a wrong offset!");

// Function b1.GSDescPropertyDetailCustomizationHelper.OnGetRowStrings
// 0x0020 (0x0020 - 0x0000)
struct GSDescPropertyDetailCustomizationHelper_OnGetRowStrings final
{
public:
	TArray<class FString>                         OutStrings;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  OutRestrictedItems;                                // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSDescPropertyDetailCustomizationHelper_OnGetRowStrings) == 0x000008, "Wrong alignment on GSDescPropertyDetailCustomizationHelper_OnGetRowStrings");
static_assert(sizeof(GSDescPropertyDetailCustomizationHelper_OnGetRowStrings) == 0x000020, "Wrong size on GSDescPropertyDetailCustomizationHelper_OnGetRowStrings");
static_assert(offsetof(GSDescPropertyDetailCustomizationHelper_OnGetRowStrings, OutStrings) == 0x000000, "Member 'GSDescPropertyDetailCustomizationHelper_OnGetRowStrings::OutStrings' has a wrong offset!");
static_assert(offsetof(GSDescPropertyDetailCustomizationHelper_OnGetRowStrings, OutRestrictedItems) == 0x000010, "Member 'GSDescPropertyDetailCustomizationHelper_OnGetRowStrings::OutRestrictedItems' has a wrong offset!");

// Function b1.BTDecorator_USharpBase.OnPropertyChanged
// 0x0020 (0x0020 - 0x0000)
struct BTDecorator_USharpBase_OnPropertyChanged final
{
public:
	class FString                                 MemberName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTDecorator_USharpBase_OnPropertyChanged) == 0x000008, "Wrong alignment on BTDecorator_USharpBase_OnPropertyChanged");
static_assert(sizeof(BTDecorator_USharpBase_OnPropertyChanged) == 0x000020, "Wrong size on BTDecorator_USharpBase_OnPropertyChanged");
static_assert(offsetof(BTDecorator_USharpBase_OnPropertyChanged, MemberName) == 0x000000, "Member 'BTDecorator_USharpBase_OnPropertyChanged::MemberName' has a wrong offset!");
static_assert(offsetof(BTDecorator_USharpBase_OnPropertyChanged, PropertyName) == 0x000010, "Member 'BTDecorator_USharpBase_OnPropertyChanged::PropertyName' has a wrong offset!");

// Function b1.BTDecorator_USharpBase.SetNodeNameInCS
// 0x0010 (0x0010 - 0x0000)
struct BTDecorator_USharpBase_SetNodeNameInCS final
{
public:
	class FString                                 NewNodeName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTDecorator_USharpBase_SetNodeNameInCS) == 0x000008, "Wrong alignment on BTDecorator_USharpBase_SetNodeNameInCS");
static_assert(sizeof(BTDecorator_USharpBase_SetNodeNameInCS) == 0x000010, "Wrong size on BTDecorator_USharpBase_SetNodeNameInCS");
static_assert(offsetof(BTDecorator_USharpBase_SetNodeNameInCS, NewNodeName) == 0x000000, "Member 'BTDecorator_USharpBase_SetNodeNameInCS::NewNodeName' has a wrong offset!");

// Function b1.BTService_USharpBase.OnPropertyChanged
// 0x0020 (0x0020 - 0x0000)
struct BTService_USharpBase_OnPropertyChanged final
{
public:
	class FString                                 MemberName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTService_USharpBase_OnPropertyChanged) == 0x000008, "Wrong alignment on BTService_USharpBase_OnPropertyChanged");
static_assert(sizeof(BTService_USharpBase_OnPropertyChanged) == 0x000020, "Wrong size on BTService_USharpBase_OnPropertyChanged");
static_assert(offsetof(BTService_USharpBase_OnPropertyChanged, MemberName) == 0x000000, "Member 'BTService_USharpBase_OnPropertyChanged::MemberName' has a wrong offset!");
static_assert(offsetof(BTService_USharpBase_OnPropertyChanged, PropertyName) == 0x000010, "Member 'BTService_USharpBase_OnPropertyChanged::PropertyName' has a wrong offset!");

// Function b1.BTService_USharpBase.SetNodeNameInCS
// 0x0010 (0x0010 - 0x0000)
struct BTService_USharpBase_SetNodeNameInCS final
{
public:
	class FString                                 NewNodeName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTService_USharpBase_SetNodeNameInCS) == 0x000008, "Wrong alignment on BTService_USharpBase_SetNodeNameInCS");
static_assert(sizeof(BTService_USharpBase_SetNodeNameInCS) == 0x000010, "Wrong size on BTService_USharpBase_SetNodeNameInCS");
static_assert(offsetof(BTService_USharpBase_SetNodeNameInCS, NewNodeName) == 0x000000, "Member 'BTService_USharpBase_SetNodeNameInCS::NewNodeName' has a wrong offset!");

// Function b1.BTService_USharpBase.IsServiceActive
// 0x0001 (0x0001 - 0x0000)
struct BTService_USharpBase_IsServiceActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTService_USharpBase_IsServiceActive) == 0x000001, "Wrong alignment on BTService_USharpBase_IsServiceActive");
static_assert(sizeof(BTService_USharpBase_IsServiceActive) == 0x000001, "Wrong size on BTService_USharpBase_IsServiceActive");
static_assert(offsetof(BTService_USharpBase_IsServiceActive, ReturnValue) == 0x000000, "Member 'BTService_USharpBase_IsServiceActive::ReturnValue' has a wrong offset!");

// Function b1.BTTask_USharpBase.FinishExecute
// 0x0001 (0x0001 - 0x0000)
struct BTTask_USharpBase_FinishExecute final
{
public:
	bool                                          bSuccess;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTTask_USharpBase_FinishExecute) == 0x000001, "Wrong alignment on BTTask_USharpBase_FinishExecute");
static_assert(sizeof(BTTask_USharpBase_FinishExecute) == 0x000001, "Wrong size on BTTask_USharpBase_FinishExecute");
static_assert(offsetof(BTTask_USharpBase_FinishExecute, bSuccess) == 0x000000, "Member 'BTTask_USharpBase_FinishExecute::bSuccess' has a wrong offset!");

// Function b1.BTTask_USharpBase.OnPropertyChanged
// 0x0020 (0x0020 - 0x0000)
struct BTTask_USharpBase_OnPropertyChanged final
{
public:
	class FString                                 MemberName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTTask_USharpBase_OnPropertyChanged) == 0x000008, "Wrong alignment on BTTask_USharpBase_OnPropertyChanged");
static_assert(sizeof(BTTask_USharpBase_OnPropertyChanged) == 0x000020, "Wrong size on BTTask_USharpBase_OnPropertyChanged");
static_assert(offsetof(BTTask_USharpBase_OnPropertyChanged, MemberName) == 0x000000, "Member 'BTTask_USharpBase_OnPropertyChanged::MemberName' has a wrong offset!");
static_assert(offsetof(BTTask_USharpBase_OnPropertyChanged, PropertyName) == 0x000010, "Member 'BTTask_USharpBase_OnPropertyChanged::PropertyName' has a wrong offset!");

// Function b1.BTTask_USharpBase.SetNodeNameInCS
// 0x0010 (0x0010 - 0x0000)
struct BTTask_USharpBase_SetNodeNameInCS final
{
public:
	class FString                                 NewNodeName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTTask_USharpBase_SetNodeNameInCS) == 0x000008, "Wrong alignment on BTTask_USharpBase_SetNodeNameInCS");
static_assert(sizeof(BTTask_USharpBase_SetNodeNameInCS) == 0x000010, "Wrong size on BTTask_USharpBase_SetNodeNameInCS");
static_assert(offsetof(BTTask_USharpBase_SetNodeNameInCS, NewNodeName) == 0x000000, "Member 'BTTask_USharpBase_SetNodeNameInCS::NewNodeName' has a wrong offset!");

// Function b1.BTTask_USharpBase.IsTaskAborting
// 0x0001 (0x0001 - 0x0000)
struct BTTask_USharpBase_IsTaskAborting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTTask_USharpBase_IsTaskAborting) == 0x000001, "Wrong alignment on BTTask_USharpBase_IsTaskAborting");
static_assert(sizeof(BTTask_USharpBase_IsTaskAborting) == 0x000001, "Wrong size on BTTask_USharpBase_IsTaskAborting");
static_assert(offsetof(BTTask_USharpBase_IsTaskAborting, ReturnValue) == 0x000000, "Member 'BTTask_USharpBase_IsTaskAborting::ReturnValue' has a wrong offset!");

// Function b1.BTTask_USharpBase.IsTaskExecuting
// 0x0001 (0x0001 - 0x0000)
struct BTTask_USharpBase_IsTaskExecuting final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BTTask_USharpBase_IsTaskExecuting) == 0x000001, "Wrong alignment on BTTask_USharpBase_IsTaskExecuting");
static_assert(sizeof(BTTask_USharpBase_IsTaskExecuting) == 0x000001, "Wrong size on BTTask_USharpBase_IsTaskExecuting");
static_assert(offsetof(BTTask_USharpBase_IsTaskExecuting, ReturnValue) == 0x000000, "Member 'BTTask_USharpBase_IsTaskExecuting::ReturnValue' has a wrong offset!");

// Function b1.BUAnimLocomotionEx.SetLocoExEnable
// 0x0001 (0x0001 - 0x0000)
struct BUAnimLocomotionEx_SetLocoExEnable final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUAnimLocomotionEx_SetLocoExEnable) == 0x000001, "Wrong alignment on BUAnimLocomotionEx_SetLocoExEnable");
static_assert(sizeof(BUAnimLocomotionEx_SetLocoExEnable) == 0x000001, "Wrong size on BUAnimLocomotionEx_SetLocoExEnable");
static_assert(offsetof(BUAnimLocomotionEx_SetLocoExEnable, bEnable) == 0x000000, "Member 'BUAnimLocomotionEx_SetLocoExEnable::bEnable' has a wrong offset!");

// Function b1.BUAnimLocomotionEx.SetLocoExSettings
// 0x0040 (0x0040 - 0x0000)
struct BUAnimLocomotionEx_SetLocoExSettings final
{
public:
	struct FBUAnimSettingsLocomotionEx            Settings;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUAnimLocomotionEx_SetLocoExSettings) == 0x000008, "Wrong alignment on BUAnimLocomotionEx_SetLocoExSettings");
static_assert(sizeof(BUAnimLocomotionEx_SetLocoExSettings) == 0x000040, "Wrong size on BUAnimLocomotionEx_SetLocoExSettings");
static_assert(offsetof(BUAnimLocomotionEx_SetLocoExSettings, Settings) == 0x000000, "Member 'BUAnimLocomotionEx_SetLocoExSettings::Settings' has a wrong offset!");

// Function b1.BGU_AIMover.GetRequestID
// 0x0004 (0x0004 - 0x0000)
struct BGU_AIMover_GetRequestID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGU_AIMover_GetRequestID) == 0x000004, "Wrong alignment on BGU_AIMover_GetRequestID");
static_assert(sizeof(BGU_AIMover_GetRequestID) == 0x000004, "Wrong size on BGU_AIMover_GetRequestID");
static_assert(offsetof(BGU_AIMover_GetRequestID, ReturnValue) == 0x000000, "Member 'BGU_AIMover_GetRequestID::ReturnValue' has a wrong offset!");

// Function b1.BGU_AIMover.Init
// 0x0008 (0x0008 - 0x0000)
struct BGU_AIMover_Init final
{
public:
	class AController*                            OwnerAICtrl;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGU_AIMover_Init) == 0x000008, "Wrong alignment on BGU_AIMover_Init");
static_assert(sizeof(BGU_AIMover_Init) == 0x000008, "Wrong size on BGU_AIMover_Init");
static_assert(offsetof(BGU_AIMover_Init, OwnerAICtrl) == 0x000000, "Member 'BGU_AIMover_Init::OwnerAICtrl' has a wrong offset!");

// Function b1.BGU_AIMover.IsOutOfRange
// 0x0001 (0x0001 - 0x0000)
struct BGU_AIMover_IsOutOfRange final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGU_AIMover_IsOutOfRange) == 0x000001, "Wrong alignment on BGU_AIMover_IsOutOfRange");
static_assert(sizeof(BGU_AIMover_IsOutOfRange) == 0x000001, "Wrong size on BGU_AIMover_IsOutOfRange");
static_assert(offsetof(BGU_AIMover_IsOutOfRange, ReturnValue) == 0x000000, "Member 'BGU_AIMover_IsOutOfRange::ReturnValue' has a wrong offset!");

// Function b1.BGU_AIMover.IsRequestValid
// 0x0001 (0x0001 - 0x0000)
struct BGU_AIMover_IsRequestValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGU_AIMover_IsRequestValid) == 0x000001, "Wrong alignment on BGU_AIMover_IsRequestValid");
static_assert(sizeof(BGU_AIMover_IsRequestValid) == 0x000001, "Wrong size on BGU_AIMover_IsRequestValid");
static_assert(offsetof(BGU_AIMover_IsRequestValid, ReturnValue) == 0x000000, "Member 'BGU_AIMover_IsRequestValid::ReturnValue' has a wrong offset!");

// Function b1.BGU_AIMover.MoveTo
// 0x0030 (0x0030 - 0x0000)
struct BGU_AIMover_MoveTo final
{
public:
	struct FBGU_AIMoverRequest                    Request;                                           // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGU_AIMover_MoveTo) == 0x000008, "Wrong alignment on BGU_AIMover_MoveTo");
static_assert(sizeof(BGU_AIMover_MoveTo) == 0x000030, "Wrong size on BGU_AIMover_MoveTo");
static_assert(offsetof(BGU_AIMover_MoveTo, Request) == 0x000000, "Member 'BGU_AIMover_MoveTo::Request' has a wrong offset!");

// Function b1.BGU_AIMover.GetMoveStatus
// 0x0001 (0x0001 - 0x0000)
struct BGU_AIMover_GetMoveStatus final
{
public:
	EPathFollowingStatus                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGU_AIMover_GetMoveStatus) == 0x000001, "Wrong alignment on BGU_AIMover_GetMoveStatus");
static_assert(sizeof(BGU_AIMover_GetMoveStatus) == 0x000001, "Wrong size on BGU_AIMover_GetMoveStatus");
static_assert(offsetof(BGU_AIMover_GetMoveStatus, ReturnValue) == 0x000000, "Member 'BGU_AIMover_GetMoveStatus::ReturnValue' has a wrong offset!");

// Function b1.BGU_AIMover.GetPathFollowingComponent
// 0x0008 (0x0008 - 0x0000)
struct BGU_AIMover_GetPathFollowingComponent final
{
public:
	class UPathFollowingComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BGU_AIMover_GetPathFollowingComponent) == 0x000008, "Wrong alignment on BGU_AIMover_GetPathFollowingComponent");
static_assert(sizeof(BGU_AIMover_GetPathFollowingComponent) == 0x000008, "Wrong size on BGU_AIMover_GetPathFollowingComponent");
static_assert(offsetof(BGU_AIMover_GetPathFollowingComponent, ReturnValue) == 0x000000, "Member 'BGU_AIMover_GetPathFollowingComponent::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.CalcDegreeFromRotatorsInYaw
// 0x0038 (0x0038 - 0x0000)
struct BUS_UtilComm_CalcDegreeFromRotatorsInYaw final
{
public:
	struct FRotator                               ARotator;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BRotator;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_CalcDegreeFromRotatorsInYaw) == 0x000008, "Wrong alignment on BUS_UtilComm_CalcDegreeFromRotatorsInYaw");
static_assert(sizeof(BUS_UtilComm_CalcDegreeFromRotatorsInYaw) == 0x000038, "Wrong size on BUS_UtilComm_CalcDegreeFromRotatorsInYaw");
static_assert(offsetof(BUS_UtilComm_CalcDegreeFromRotatorsInYaw, ARotator) == 0x000000, "Member 'BUS_UtilComm_CalcDegreeFromRotatorsInYaw::ARotator' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcDegreeFromRotatorsInYaw, BRotator) == 0x000018, "Member 'BUS_UtilComm_CalcDegreeFromRotatorsInYaw::BRotator' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcDegreeFromRotatorsInYaw, ReturnValue) == 0x000030, "Member 'BUS_UtilComm_CalcDegreeFromRotatorsInYaw::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.CalcDegreeFromVectorsProjectInXYPlane
// 0x0038 (0x0038 - 0x0000)
struct BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane final
{
public:
	struct FVector                                AVector;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BVector;                                           // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane) == 0x000008, "Wrong alignment on BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane");
static_assert(sizeof(BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane) == 0x000038, "Wrong size on BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane");
static_assert(offsetof(BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane, AVector) == 0x000000, "Member 'BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane::AVector' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane, BVector) == 0x000018, "Member 'BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane::BVector' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane, ReturnValue) == 0x000030, "Member 'BUS_UtilComm_CalcDegreeFromVectorsProjectInXYPlane::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.CalcDirWithInput
// 0x0028 (0x0028 - 0x0000)
struct BUS_UtilComm_CalcDirWithInput final
{
public:
	class ACharacter*                             CurCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardVal;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightVal;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_CalcDirWithInput) == 0x000008, "Wrong alignment on BUS_UtilComm_CalcDirWithInput");
static_assert(sizeof(BUS_UtilComm_CalcDirWithInput) == 0x000028, "Wrong size on BUS_UtilComm_CalcDirWithInput");
static_assert(offsetof(BUS_UtilComm_CalcDirWithInput, CurCharacter) == 0x000000, "Member 'BUS_UtilComm_CalcDirWithInput::CurCharacter' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcDirWithInput, ForwardVal) == 0x000008, "Member 'BUS_UtilComm_CalcDirWithInput::ForwardVal' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcDirWithInput, RightVal) == 0x00000C, "Member 'BUS_UtilComm_CalcDirWithInput::RightVal' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcDirWithInput, ReturnValue) == 0x000010, "Member 'BUS_UtilComm_CalcDirWithInput::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.CalcYawRotator
// 0x0048 (0x0048 - 0x0000)
struct BUS_UtilComm_CalcYawRotator final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FromLocation;                                      // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_CalcYawRotator) == 0x000008, "Wrong alignment on BUS_UtilComm_CalcYawRotator");
static_assert(sizeof(BUS_UtilComm_CalcYawRotator) == 0x000048, "Wrong size on BUS_UtilComm_CalcYawRotator");
static_assert(offsetof(BUS_UtilComm_CalcYawRotator, TargetLocation) == 0x000000, "Member 'BUS_UtilComm_CalcYawRotator::TargetLocation' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcYawRotator, FromLocation) == 0x000018, "Member 'BUS_UtilComm_CalcYawRotator::FromLocation' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_CalcYawRotator, ReturnValue) == 0x000030, "Member 'BUS_UtilComm_CalcYawRotator::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.GetCurActiveMontagePos
// 0x0010 (0x0010 - 0x0000)
struct BUS_UtilComm_GetCurActiveMontagePos final
{
public:
	class ACharacter*                             CurCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_GetCurActiveMontagePos) == 0x000008, "Wrong alignment on BUS_UtilComm_GetCurActiveMontagePos");
static_assert(sizeof(BUS_UtilComm_GetCurActiveMontagePos) == 0x000010, "Wrong size on BUS_UtilComm_GetCurActiveMontagePos");
static_assert(offsetof(BUS_UtilComm_GetCurActiveMontagePos, CurCharacter) == 0x000000, "Member 'BUS_UtilComm_GetCurActiveMontagePos::CurCharacter' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GetCurActiveMontagePos, ReturnValue) == 0x000008, "Member 'BUS_UtilComm_GetCurActiveMontagePos::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.GetEasingFuncType
// 0x0008 (0x0008 - 0x0000)
struct BUS_UtilComm_GetEasingFuncType final
{
public:
	EGSBlendTypeG                                 GSBlengTypeG;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_GetEasingFuncType) == 0x000004, "Wrong alignment on BUS_UtilComm_GetEasingFuncType");
static_assert(sizeof(BUS_UtilComm_GetEasingFuncType) == 0x000008, "Wrong size on BUS_UtilComm_GetEasingFuncType");
static_assert(offsetof(BUS_UtilComm_GetEasingFuncType, GSBlengTypeG) == 0x000000, "Member 'BUS_UtilComm_GetEasingFuncType::GSBlengTypeG' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GetEasingFuncType, ReturnValue) == 0x000004, "Member 'BUS_UtilComm_GetEasingFuncType::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.GetUMatineeCameraShakeBlendOutTime
// 0x0010 (0x0010 - 0x0000)
struct BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime final
{
public:
	class UMatineeCameraShake*                    CameraShake;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime) == 0x000008, "Wrong alignment on BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime");
static_assert(sizeof(BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime) == 0x000010, "Wrong size on BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime");
static_assert(offsetof(BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime, CameraShake) == 0x000000, "Member 'BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime::CameraShake' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime, ReturnValue) == 0x000008, "Member 'BUS_UtilComm_GetUMatineeCameraShakeBlendOutTime::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.GSEase
// 0x0018 (0x0018 - 0x0000)
struct BUS_UtilComm_GSEase final
{
public:
	float                                         Start;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSBlendTypeG                                 GSBlendTypeG;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EaseExp;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_GSEase) == 0x000004, "Wrong alignment on BUS_UtilComm_GSEase");
static_assert(sizeof(BUS_UtilComm_GSEase) == 0x000018, "Wrong size on BUS_UtilComm_GSEase");
static_assert(offsetof(BUS_UtilComm_GSEase, Start) == 0x000000, "Member 'BUS_UtilComm_GSEase::Start' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEase, End) == 0x000004, "Member 'BUS_UtilComm_GSEase::End' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEase, Alpha) == 0x000008, "Member 'BUS_UtilComm_GSEase::Alpha' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEase, GSBlendTypeG) == 0x00000C, "Member 'BUS_UtilComm_GSEase::GSBlendTypeG' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEase, EaseExp) == 0x000010, "Member 'BUS_UtilComm_GSEase::EaseExp' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEase, ReturnValue) == 0x000014, "Member 'BUS_UtilComm_GSEase::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.GSEaseRotator
// 0x0058 (0x0058 - 0x0000)
struct BUS_UtilComm_GSEaseRotator final
{
public:
	struct FRotator                               Start;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               End;                                               // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSBlendTypeG                                 GSBlendTypeG;                                      // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EaseExp;                                           // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShortestPath;                                    // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_GSEaseRotator) == 0x000008, "Wrong alignment on BUS_UtilComm_GSEaseRotator");
static_assert(sizeof(BUS_UtilComm_GSEaseRotator) == 0x000058, "Wrong size on BUS_UtilComm_GSEaseRotator");
static_assert(offsetof(BUS_UtilComm_GSEaseRotator, Start) == 0x000000, "Member 'BUS_UtilComm_GSEaseRotator::Start' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEaseRotator, End) == 0x000018, "Member 'BUS_UtilComm_GSEaseRotator::End' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEaseRotator, Alpha) == 0x000030, "Member 'BUS_UtilComm_GSEaseRotator::Alpha' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEaseRotator, GSBlendTypeG) == 0x000034, "Member 'BUS_UtilComm_GSEaseRotator::GSBlendTypeG' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEaseRotator, EaseExp) == 0x000038, "Member 'BUS_UtilComm_GSEaseRotator::EaseExp' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEaseRotator, IsShortestPath) == 0x00003C, "Member 'BUS_UtilComm_GSEaseRotator::IsShortestPath' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_GSEaseRotator, ReturnValue) == 0x000040, "Member 'BUS_UtilComm_GSEaseRotator::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.IsCharacterStoped
// 0x0010 (0x0010 - 0x0000)
struct BUS_UtilComm_IsCharacterStoped final
{
public:
	class ACharacter*                             CurCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_IsCharacterStoped) == 0x000008, "Wrong alignment on BUS_UtilComm_IsCharacterStoped");
static_assert(sizeof(BUS_UtilComm_IsCharacterStoped) == 0x000010, "Wrong size on BUS_UtilComm_IsCharacterStoped");
static_assert(offsetof(BUS_UtilComm_IsCharacterStoped, CurCharacter) == 0x000000, "Member 'BUS_UtilComm_IsCharacterStoped::CurCharacter' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_IsCharacterStoped, ReturnValue) == 0x000008, "Member 'BUS_UtilComm_IsCharacterStoped::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.LoadAKEventFromString
// 0x0018 (0x0018 - 0x0000)
struct BUS_UtilComm_LoadAKEventFromString final
{
public:
	class FString                                 ResPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_LoadAKEventFromString) == 0x000008, "Wrong alignment on BUS_UtilComm_LoadAKEventFromString");
static_assert(sizeof(BUS_UtilComm_LoadAKEventFromString) == 0x000018, "Wrong size on BUS_UtilComm_LoadAKEventFromString");
static_assert(offsetof(BUS_UtilComm_LoadAKEventFromString, ResPath) == 0x000000, "Member 'BUS_UtilComm_LoadAKEventFromString::ResPath' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_LoadAKEventFromString, ReturnValue) == 0x000010, "Member 'BUS_UtilComm_LoadAKEventFromString::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.LoadAnimMontageFromString
// 0x0018 (0x0018 - 0x0000)
struct BUS_UtilComm_LoadAnimMontageFromString final
{
public:
	class FString                                 ResPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_LoadAnimMontageFromString) == 0x000008, "Wrong alignment on BUS_UtilComm_LoadAnimMontageFromString");
static_assert(sizeof(BUS_UtilComm_LoadAnimMontageFromString) == 0x000018, "Wrong size on BUS_UtilComm_LoadAnimMontageFromString");
static_assert(offsetof(BUS_UtilComm_LoadAnimMontageFromString, ResPath) == 0x000000, "Member 'BUS_UtilComm_LoadAnimMontageFromString::ResPath' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_LoadAnimMontageFromString, ReturnValue) == 0x000010, "Member 'BUS_UtilComm_LoadAnimMontageFromString::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.LoadCameraShakeFromString
// 0x0018 (0x0018 - 0x0000)
struct BUS_UtilComm_LoadCameraShakeFromString final
{
public:
	class FString                                 ResPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_LoadCameraShakeFromString) == 0x000008, "Wrong alignment on BUS_UtilComm_LoadCameraShakeFromString");
static_assert(sizeof(BUS_UtilComm_LoadCameraShakeFromString) == 0x000018, "Wrong size on BUS_UtilComm_LoadCameraShakeFromString");
static_assert(offsetof(BUS_UtilComm_LoadCameraShakeFromString, ResPath) == 0x000000, "Member 'BUS_UtilComm_LoadCameraShakeFromString::ResPath' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_LoadCameraShakeFromString, ReturnValue) == 0x000010, "Member 'BUS_UtilComm_LoadCameraShakeFromString::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.LoadCurveFloatFromString
// 0x0018 (0x0018 - 0x0000)
struct BUS_UtilComm_LoadCurveFloatFromString final
{
public:
	class FString                                 ResPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_LoadCurveFloatFromString) == 0x000008, "Wrong alignment on BUS_UtilComm_LoadCurveFloatFromString");
static_assert(sizeof(BUS_UtilComm_LoadCurveFloatFromString) == 0x000018, "Wrong size on BUS_UtilComm_LoadCurveFloatFromString");
static_assert(offsetof(BUS_UtilComm_LoadCurveFloatFromString, ResPath) == 0x000000, "Member 'BUS_UtilComm_LoadCurveFloatFromString::ResPath' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_LoadCurveFloatFromString, ReturnValue) == 0x000010, "Member 'BUS_UtilComm_LoadCurveFloatFromString::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.LoadLevelSequenceFromString
// 0x0018 (0x0018 - 0x0000)
struct BUS_UtilComm_LoadLevelSequenceFromString final
{
public:
	class FString                                 ResPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_LoadLevelSequenceFromString) == 0x000008, "Wrong alignment on BUS_UtilComm_LoadLevelSequenceFromString");
static_assert(sizeof(BUS_UtilComm_LoadLevelSequenceFromString) == 0x000018, "Wrong size on BUS_UtilComm_LoadLevelSequenceFromString");
static_assert(offsetof(BUS_UtilComm_LoadLevelSequenceFromString, ResPath) == 0x000000, "Member 'BUS_UtilComm_LoadLevelSequenceFromString::ResPath' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_LoadLevelSequenceFromString, ReturnValue) == 0x000010, "Member 'BUS_UtilComm_LoadLevelSequenceFromString::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.LoadParticleSystemFromString
// 0x0020 (0x0020 - 0x0000)
struct BUS_UtilComm_LoadParticleSystemFromString final
{
public:
	class FString                                 ResPath;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDelayTime;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_LoadParticleSystemFromString) == 0x000008, "Wrong alignment on BUS_UtilComm_LoadParticleSystemFromString");
static_assert(sizeof(BUS_UtilComm_LoadParticleSystemFromString) == 0x000020, "Wrong size on BUS_UtilComm_LoadParticleSystemFromString");
static_assert(offsetof(BUS_UtilComm_LoadParticleSystemFromString, ResPath) == 0x000000, "Member 'BUS_UtilComm_LoadParticleSystemFromString::ResPath' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_LoadParticleSystemFromString, DefaultDelayTime) == 0x000010, "Member 'BUS_UtilComm_LoadParticleSystemFromString::DefaultDelayTime' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_LoadParticleSystemFromString, ReturnValue) == 0x000018, "Member 'BUS_UtilComm_LoadParticleSystemFromString::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.ParticleSystemComponentTrailSetTimeRate
// 0x0010 (0x0010 - 0x0000)
struct BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate final
{
public:
	class ACharacter*                             CurCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRate;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate) == 0x000008, "Wrong alignment on BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate");
static_assert(sizeof(BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate) == 0x000010, "Wrong size on BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate");
static_assert(offsetof(BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate, CurCharacter) == 0x000000, "Member 'BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate::CurCharacter' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate, TimeRate) == 0x000008, "Member 'BUS_UtilComm_ParticleSystemComponentTrailSetTimeRate::TimeRate' has a wrong offset!");

// Function b1.BUS_UtilComm.PlayCameraShakeByClass
// 0x0018 (0x0018 - 0x0000)
struct BUS_UtilComm_PlayCameraShakeByClass final
{
public:
	class AActor*                                 Caster;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 CameraShakeCls;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMatineeCameraShake*                    ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BUS_UtilComm_PlayCameraShakeByClass) == 0x000008, "Wrong alignment on BUS_UtilComm_PlayCameraShakeByClass");
static_assert(sizeof(BUS_UtilComm_PlayCameraShakeByClass) == 0x000018, "Wrong size on BUS_UtilComm_PlayCameraShakeByClass");
static_assert(offsetof(BUS_UtilComm_PlayCameraShakeByClass, Caster) == 0x000000, "Member 'BUS_UtilComm_PlayCameraShakeByClass::Caster' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_PlayCameraShakeByClass, CameraShakeCls) == 0x000008, "Member 'BUS_UtilComm_PlayCameraShakeByClass::CameraShakeCls' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_PlayCameraShakeByClass, ReturnValue) == 0x000010, "Member 'BUS_UtilComm_PlayCameraShakeByClass::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.PlayMontage
// 0x0018 (0x0018 - 0x0000)
struct BUS_UtilComm_PlayMontage final
{
public:
	class ACharacter*                             CurCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontage;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_PlayMontage) == 0x000008, "Wrong alignment on BUS_UtilComm_PlayMontage");
static_assert(sizeof(BUS_UtilComm_PlayMontage) == 0x000018, "Wrong size on BUS_UtilComm_PlayMontage");
static_assert(offsetof(BUS_UtilComm_PlayMontage, CurCharacter) == 0x000000, "Member 'BUS_UtilComm_PlayMontage::CurCharacter' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_PlayMontage, AnimMontage) == 0x000008, "Member 'BUS_UtilComm_PlayMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_PlayMontage, ReturnValue) == 0x000010, "Member 'BUS_UtilComm_PlayMontage::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.SafeSetCharacterMontagePlaying
// 0x0010 (0x0010 - 0x0000)
struct BUS_UtilComm_SafeSetCharacterMontagePlaying final
{
public:
	class ACharacter*                             CurCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlaying;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_SafeSetCharacterMontagePlaying) == 0x000008, "Wrong alignment on BUS_UtilComm_SafeSetCharacterMontagePlaying");
static_assert(sizeof(BUS_UtilComm_SafeSetCharacterMontagePlaying) == 0x000010, "Wrong size on BUS_UtilComm_SafeSetCharacterMontagePlaying");
static_assert(offsetof(BUS_UtilComm_SafeSetCharacterMontagePlaying, CurCharacter) == 0x000000, "Member 'BUS_UtilComm_SafeSetCharacterMontagePlaying::CurCharacter' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_SafeSetCharacterMontagePlaying, IsPlaying) == 0x000008, "Member 'BUS_UtilComm_SafeSetCharacterMontagePlaying::IsPlaying' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_SafeSetCharacterMontagePlaying, ReturnValue) == 0x000009, "Member 'BUS_UtilComm_SafeSetCharacterMontagePlaying::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.SafeSetCharacterMontagePlayingRate
// 0x0010 (0x0010 - 0x0000)
struct BUS_UtilComm_SafeSetCharacterMontagePlayingRate final
{
public:
	class ACharacter*                             CurCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_SafeSetCharacterMontagePlayingRate) == 0x000008, "Wrong alignment on BUS_UtilComm_SafeSetCharacterMontagePlayingRate");
static_assert(sizeof(BUS_UtilComm_SafeSetCharacterMontagePlayingRate) == 0x000010, "Wrong size on BUS_UtilComm_SafeSetCharacterMontagePlayingRate");
static_assert(offsetof(BUS_UtilComm_SafeSetCharacterMontagePlayingRate, CurCharacter) == 0x000000, "Member 'BUS_UtilComm_SafeSetCharacterMontagePlayingRate::CurCharacter' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_SafeSetCharacterMontagePlayingRate, PlayRate) == 0x000008, "Member 'BUS_UtilComm_SafeSetCharacterMontagePlayingRate::PlayRate' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_SafeSetCharacterMontagePlayingRate, ReturnValue) == 0x00000C, "Member 'BUS_UtilComm_SafeSetCharacterMontagePlayingRate::ReturnValue' has a wrong offset!");

// Function b1.BUS_UtilComm.SetCurActiveMontagePos
// 0x0010 (0x0010 - 0x0000)
struct BUS_UtilComm_SetCurActiveMontagePos final
{
public:
	class ACharacter*                             CurCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetPos;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BUS_UtilComm_SetCurActiveMontagePos) == 0x000008, "Wrong alignment on BUS_UtilComm_SetCurActiveMontagePos");
static_assert(sizeof(BUS_UtilComm_SetCurActiveMontagePos) == 0x000010, "Wrong size on BUS_UtilComm_SetCurActiveMontagePos");
static_assert(offsetof(BUS_UtilComm_SetCurActiveMontagePos, CurCharacter) == 0x000000, "Member 'BUS_UtilComm_SetCurActiveMontagePos::CurCharacter' has a wrong offset!");
static_assert(offsetof(BUS_UtilComm_SetCurActiveMontagePos, TargetPos) == 0x000008, "Member 'BUS_UtilComm_SetCurActiveMontagePos::TargetPos' has a wrong offset!");

// Function b1.EnvironmentSurfaceEffectMgr.GetEnvironmentSurfaceVolumeByLocation
// 0x0020 (0x0020 - 0x0000)
struct EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGWEnvironmentSurfaceVolume*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation) == 0x000008, "Wrong alignment on EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation");
static_assert(sizeof(EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation) == 0x000020, "Wrong size on EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation");
static_assert(offsetof(EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation, Location) == 0x000000, "Member 'EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation::Location' has a wrong offset!");
static_assert(offsetof(EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation, ReturnValue) == 0x000018, "Member 'EnvironmentSurfaceEffectMgr_GetEnvironmentSurfaceVolumeByLocation::ReturnValue' has a wrong offset!");

// Function b1.EnvironmentSurfaceEffectMgr.RegisterVolume
// 0x0028 (0x0028 - 0x0000)
struct EnvironmentSurfaceEffectMgr_RegisterVolume final
{
public:
	TSoftObjectPtr<class ABGWEnvironmentSurfaceVolume> InVolume;                                          // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EnvironmentSurfaceEffectMgr_RegisterVolume) == 0x000008, "Wrong alignment on EnvironmentSurfaceEffectMgr_RegisterVolume");
static_assert(sizeof(EnvironmentSurfaceEffectMgr_RegisterVolume) == 0x000028, "Wrong size on EnvironmentSurfaceEffectMgr_RegisterVolume");
static_assert(offsetof(EnvironmentSurfaceEffectMgr_RegisterVolume, InVolume) == 0x000000, "Member 'EnvironmentSurfaceEffectMgr_RegisterVolume::InVolume' has a wrong offset!");

// Function b1.EnvironmentSurfaceEffectMgr.UnregisterVolume
// 0x0030 (0x0030 - 0x0000)
struct EnvironmentSurfaceEffectMgr_UnregisterVolume final
{
public:
	TSoftObjectPtr<class ABGWEnvironmentSurfaceVolume> InVolume;                                          // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDisableVolume;                                   // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EnvironmentSurfaceEffectMgr_UnregisterVolume) == 0x000008, "Wrong alignment on EnvironmentSurfaceEffectMgr_UnregisterVolume");
static_assert(sizeof(EnvironmentSurfaceEffectMgr_UnregisterVolume) == 0x000030, "Wrong size on EnvironmentSurfaceEffectMgr_UnregisterVolume");
static_assert(offsetof(EnvironmentSurfaceEffectMgr_UnregisterVolume, InVolume) == 0x000000, "Member 'EnvironmentSurfaceEffectMgr_UnregisterVolume::InVolume' has a wrong offset!");
static_assert(offsetof(EnvironmentSurfaceEffectMgr_UnregisterVolume, IsDisableVolume) == 0x000028, "Member 'EnvironmentSurfaceEffectMgr_UnregisterVolume::IsDisableVolume' has a wrong offset!");

// Function b1.GSEQCBase.ProvideActorsSetCS
// 0x0010 (0x0010 - 0x0000)
struct GSEQCBase_ProvideActorsSetCS final
{
public:
	class UObject*                                QuerierObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 QuerierActor;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQCBase_ProvideActorsSetCS) == 0x000008, "Wrong alignment on GSEQCBase_ProvideActorsSetCS");
static_assert(sizeof(GSEQCBase_ProvideActorsSetCS) == 0x000010, "Wrong size on GSEQCBase_ProvideActorsSetCS");
static_assert(offsetof(GSEQCBase_ProvideActorsSetCS, QuerierObject) == 0x000000, "Member 'GSEQCBase_ProvideActorsSetCS::QuerierObject' has a wrong offset!");
static_assert(offsetof(GSEQCBase_ProvideActorsSetCS, QuerierActor) == 0x000008, "Member 'GSEQCBase_ProvideActorsSetCS::QuerierActor' has a wrong offset!");

// Function b1.GSEQCBase.ProvideLocationsSetCS
// 0x0010 (0x0010 - 0x0000)
struct GSEQCBase_ProvideLocationsSetCS final
{
public:
	class UObject*                                QuerierObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 QuerierActor;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQCBase_ProvideLocationsSetCS) == 0x000008, "Wrong alignment on GSEQCBase_ProvideLocationsSetCS");
static_assert(sizeof(GSEQCBase_ProvideLocationsSetCS) == 0x000010, "Wrong size on GSEQCBase_ProvideLocationsSetCS");
static_assert(offsetof(GSEQCBase_ProvideLocationsSetCS, QuerierObject) == 0x000000, "Member 'GSEQCBase_ProvideLocationsSetCS::QuerierObject' has a wrong offset!");
static_assert(offsetof(GSEQCBase_ProvideLocationsSetCS, QuerierActor) == 0x000008, "Member 'GSEQCBase_ProvideLocationsSetCS::QuerierActor' has a wrong offset!");

// Function b1.GSEQCBase.ProvideSingleActorCS
// 0x0010 (0x0010 - 0x0000)
struct GSEQCBase_ProvideSingleActorCS final
{
public:
	class UObject*                                QuerierObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 QuerierActor;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQCBase_ProvideSingleActorCS) == 0x000008, "Wrong alignment on GSEQCBase_ProvideSingleActorCS");
static_assert(sizeof(GSEQCBase_ProvideSingleActorCS) == 0x000010, "Wrong size on GSEQCBase_ProvideSingleActorCS");
static_assert(offsetof(GSEQCBase_ProvideSingleActorCS, QuerierObject) == 0x000000, "Member 'GSEQCBase_ProvideSingleActorCS::QuerierObject' has a wrong offset!");
static_assert(offsetof(GSEQCBase_ProvideSingleActorCS, QuerierActor) == 0x000008, "Member 'GSEQCBase_ProvideSingleActorCS::QuerierActor' has a wrong offset!");

// Function b1.GSEQCBase.ProvideSingleLocationCS
// 0x0010 (0x0010 - 0x0000)
struct GSEQCBase_ProvideSingleLocationCS final
{
public:
	class UObject*                                QuerierObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 QuerierActor;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQCBase_ProvideSingleLocationCS) == 0x000008, "Wrong alignment on GSEQCBase_ProvideSingleLocationCS");
static_assert(sizeof(GSEQCBase_ProvideSingleLocationCS) == 0x000010, "Wrong size on GSEQCBase_ProvideSingleLocationCS");
static_assert(offsetof(GSEQCBase_ProvideSingleLocationCS, QuerierObject) == 0x000000, "Member 'GSEQCBase_ProvideSingleLocationCS::QuerierObject' has a wrong offset!");
static_assert(offsetof(GSEQCBase_ProvideSingleLocationCS, QuerierActor) == 0x000008, "Member 'GSEQCBase_ProvideSingleLocationCS::QuerierActor' has a wrong offset!");

// Function b1.GSEQGBase_ProjectedPoint.AddGeneratedActor
// 0x0008 (0x0008 - 0x0000)
struct GSEQGBase_ProjectedPoint_AddGeneratedActor final
{
public:
	class AActor*                                 GeneratedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQGBase_ProjectedPoint_AddGeneratedActor) == 0x000008, "Wrong alignment on GSEQGBase_ProjectedPoint_AddGeneratedActor");
static_assert(sizeof(GSEQGBase_ProjectedPoint_AddGeneratedActor) == 0x000008, "Wrong size on GSEQGBase_ProjectedPoint_AddGeneratedActor");
static_assert(offsetof(GSEQGBase_ProjectedPoint_AddGeneratedActor, GeneratedActor) == 0x000000, "Member 'GSEQGBase_ProjectedPoint_AddGeneratedActor::GeneratedActor' has a wrong offset!");

// Function b1.GSEQGBase_ProjectedPoint.AddGeneratedVector
// 0x0018 (0x0018 - 0x0000)
struct GSEQGBase_ProjectedPoint_AddGeneratedVector final
{
public:
	struct FVector                                GeneratedVector;                                   // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQGBase_ProjectedPoint_AddGeneratedVector) == 0x000008, "Wrong alignment on GSEQGBase_ProjectedPoint_AddGeneratedVector");
static_assert(sizeof(GSEQGBase_ProjectedPoint_AddGeneratedVector) == 0x000018, "Wrong size on GSEQGBase_ProjectedPoint_AddGeneratedVector");
static_assert(offsetof(GSEQGBase_ProjectedPoint_AddGeneratedVector, GeneratedVector) == 0x000000, "Member 'GSEQGBase_ProjectedPoint_AddGeneratedVector::GeneratedVector' has a wrong offset!");

// Function b1.GSEQGBase_ProjectedPoint.DoItemGenerationCS
// 0x0010 (0x0010 - 0x0000)
struct GSEQGBase_ProjectedPoint_DoItemGenerationCS final
{
public:
	TArray<struct FVector>                        ContextLocations;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQGBase_ProjectedPoint_DoItemGenerationCS) == 0x000008, "Wrong alignment on GSEQGBase_ProjectedPoint_DoItemGenerationCS");
static_assert(sizeof(GSEQGBase_ProjectedPoint_DoItemGenerationCS) == 0x000010, "Wrong size on GSEQGBase_ProjectedPoint_DoItemGenerationCS");
static_assert(offsetof(GSEQGBase_ProjectedPoint_DoItemGenerationCS, ContextLocations) == 0x000000, "Member 'GSEQGBase_ProjectedPoint_DoItemGenerationCS::ContextLocations' has a wrong offset!");

// Function b1.GSEQGBase_ProjectedPoint.GetQuerier
// 0x0008 (0x0008 - 0x0000)
struct GSEQGBase_ProjectedPoint_GetQuerier final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQGBase_ProjectedPoint_GetQuerier) == 0x000008, "Wrong alignment on GSEQGBase_ProjectedPoint_GetQuerier");
static_assert(sizeof(GSEQGBase_ProjectedPoint_GetQuerier) == 0x000008, "Wrong size on GSEQGBase_ProjectedPoint_GetQuerier");
static_assert(offsetof(GSEQGBase_ProjectedPoint_GetQuerier, ReturnValue) == 0x000000, "Member 'GSEQGBase_ProjectedPoint_GetQuerier::ReturnValue' has a wrong offset!");

// Function b1.GSEQGBase_ProjectedPoint.ProjectAndFilterNavPointsInCS
// 0x0020 (0x0020 - 0x0000)
struct GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS) == 0x000008, "Wrong alignment on GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS");
static_assert(sizeof(GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS) == 0x000020, "Wrong size on GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS");
static_assert(offsetof(GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS, Points) == 0x000000, "Member 'GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS::Points' has a wrong offset!");
static_assert(offsetof(GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS, ReturnValue) == 0x000010, "Member 'GSEQGBase_ProjectedPoint_ProjectAndFilterNavPointsInCS::ReturnValue' has a wrong offset!");

// Function b1.GSEQGBase_ProjectedPoint.RunNavRaycastsInCS
// 0x0038 (0x0038 - 0x0000)
struct GSEQGBase_ProjectedPoint_RunNavRaycastsInCS final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                SourcePt;                                          // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQGBase_ProjectedPoint_RunNavRaycastsInCS) == 0x000008, "Wrong alignment on GSEQGBase_ProjectedPoint_RunNavRaycastsInCS");
static_assert(sizeof(GSEQGBase_ProjectedPoint_RunNavRaycastsInCS) == 0x000038, "Wrong size on GSEQGBase_ProjectedPoint_RunNavRaycastsInCS");
static_assert(offsetof(GSEQGBase_ProjectedPoint_RunNavRaycastsInCS, Points) == 0x000000, "Member 'GSEQGBase_ProjectedPoint_RunNavRaycastsInCS::Points' has a wrong offset!");
static_assert(offsetof(GSEQGBase_ProjectedPoint_RunNavRaycastsInCS, SourcePt) == 0x000010, "Member 'GSEQGBase_ProjectedPoint_RunNavRaycastsInCS::SourcePt' has a wrong offset!");
static_assert(offsetof(GSEQGBase_ProjectedPoint_RunNavRaycastsInCS, ReturnValue) == 0x000028, "Member 'GSEQGBase_ProjectedPoint_RunNavRaycastsInCS::ReturnValue' has a wrong offset!");

// Function b1.GSEQTBase.GetWorkOnFloatValuesCS
// 0x0001 (0x0001 - 0x0000)
struct GSEQTBase_GetWorkOnFloatValuesCS final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_GetWorkOnFloatValuesCS) == 0x000001, "Wrong alignment on GSEQTBase_GetWorkOnFloatValuesCS");
static_assert(sizeof(GSEQTBase_GetWorkOnFloatValuesCS) == 0x000001, "Wrong size on GSEQTBase_GetWorkOnFloatValuesCS");
static_assert(offsetof(GSEQTBase_GetWorkOnFloatValuesCS, ReturnValue) == 0x000000, "Member 'GSEQTBase_GetWorkOnFloatValuesCS::ReturnValue' has a wrong offset!");

// Function b1.GSEQTBase.OnPropertyChanged
// 0x0020 (0x0020 - 0x0000)
struct GSEQTBase_OnPropertyChanged final
{
public:
	class FString                                 MemberName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyName;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_OnPropertyChanged) == 0x000008, "Wrong alignment on GSEQTBase_OnPropertyChanged");
static_assert(sizeof(GSEQTBase_OnPropertyChanged) == 0x000020, "Wrong size on GSEQTBase_OnPropertyChanged");
static_assert(offsetof(GSEQTBase_OnPropertyChanged, MemberName) == 0x000000, "Member 'GSEQTBase_OnPropertyChanged::MemberName' has a wrong offset!");
static_assert(offsetof(GSEQTBase_OnPropertyChanged, PropertyName) == 0x000010, "Member 'GSEQTBase_OnPropertyChanged::PropertyName' has a wrong offset!");

// Function b1.GSEQTBase.SetWorkOnFloatValuesCS
// 0x0001 (0x0001 - 0x0000)
struct GSEQTBase_SetWorkOnFloatValuesCS final
{
public:
	bool                                          bWorkOnFloats;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_SetWorkOnFloatValuesCS) == 0x000001, "Wrong alignment on GSEQTBase_SetWorkOnFloatValuesCS");
static_assert(sizeof(GSEQTBase_SetWorkOnFloatValuesCS) == 0x000001, "Wrong size on GSEQTBase_SetWorkOnFloatValuesCS");
static_assert(offsetof(GSEQTBase_SetWorkOnFloatValuesCS, bWorkOnFloats) == 0x000000, "Member 'GSEQTBase_SetWorkOnFloatValuesCS::bWorkOnFloats' has a wrong offset!");

// Function b1.GSEQTBase.GetDescriptionDetailsCS
// 0x0010 (0x0010 - 0x0000)
struct GSEQTBase_GetDescriptionDetailsCS final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_GetDescriptionDetailsCS) == 0x000008, "Wrong alignment on GSEQTBase_GetDescriptionDetailsCS");
static_assert(sizeof(GSEQTBase_GetDescriptionDetailsCS) == 0x000010, "Wrong size on GSEQTBase_GetDescriptionDetailsCS");
static_assert(offsetof(GSEQTBase_GetDescriptionDetailsCS, ReturnValue) == 0x000000, "Member 'GSEQTBase_GetDescriptionDetailsCS::ReturnValue' has a wrong offset!");

// Function b1.GSEQTBase.GetDescriptionTitleCS
// 0x0010 (0x0010 - 0x0000)
struct GSEQTBase_GetDescriptionTitleCS final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_GetDescriptionTitleCS) == 0x000008, "Wrong alignment on GSEQTBase_GetDescriptionTitleCS");
static_assert(sizeof(GSEQTBase_GetDescriptionTitleCS) == 0x000010, "Wrong size on GSEQTBase_GetDescriptionTitleCS");
static_assert(offsetof(GSEQTBase_GetDescriptionTitleCS, ReturnValue) == 0x000000, "Member 'GSEQTBase_GetDescriptionTitleCS::ReturnValue' has a wrong offset!");

// Function b1.GSEQTBase.PreProcessItems
// 0x0020 (0x0020 - 0x0000)
struct GSEQTBase_PreProcessItems final
{
public:
	TArray<class AActor*>                         ContextActors;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ContextLocations;                                  // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_PreProcessItems) == 0x000008, "Wrong alignment on GSEQTBase_PreProcessItems");
static_assert(sizeof(GSEQTBase_PreProcessItems) == 0x000020, "Wrong size on GSEQTBase_PreProcessItems");
static_assert(offsetof(GSEQTBase_PreProcessItems, ContextActors) == 0x000000, "Member 'GSEQTBase_PreProcessItems::ContextActors' has a wrong offset!");
static_assert(offsetof(GSEQTBase_PreProcessItems, ContextLocations) == 0x000010, "Member 'GSEQTBase_PreProcessItems::ContextLocations' has a wrong offset!");

// Function b1.GSEQTBase.ProcessCustomItemScoreCS
// 0x0040 (0x0040 - 0x0000)
struct GSEQTBase_ProcessCustomItemScoreCS final
{
public:
	struct FGSEnvQueryTestItem                    Item;                                              // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_ProcessCustomItemScoreCS) == 0x000008, "Wrong alignment on GSEQTBase_ProcessCustomItemScoreCS");
static_assert(sizeof(GSEQTBase_ProcessCustomItemScoreCS) == 0x000040, "Wrong size on GSEQTBase_ProcessCustomItemScoreCS");
static_assert(offsetof(GSEQTBase_ProcessCustomItemScoreCS, Item) == 0x000000, "Member 'GSEQTBase_ProcessCustomItemScoreCS::Item' has a wrong offset!");

// Function b1.GSEQTBase.ProcessItemCS
// 0x0038 (0x0038 - 0x0000)
struct GSEQTBase_ProcessItemCS final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ItemLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ItemActor;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Querier;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSEQTBase_ProcessItemCS) == 0x000008, "Wrong alignment on GSEQTBase_ProcessItemCS");
static_assert(sizeof(GSEQTBase_ProcessItemCS) == 0x000038, "Wrong size on GSEQTBase_ProcessItemCS");
static_assert(offsetof(GSEQTBase_ProcessItemCS, World) == 0x000000, "Member 'GSEQTBase_ProcessItemCS::World' has a wrong offset!");
static_assert(offsetof(GSEQTBase_ProcessItemCS, ItemLocation) == 0x000008, "Member 'GSEQTBase_ProcessItemCS::ItemLocation' has a wrong offset!");
static_assert(offsetof(GSEQTBase_ProcessItemCS, ItemActor) == 0x000020, "Member 'GSEQTBase_ProcessItemCS::ItemActor' has a wrong offset!");
static_assert(offsetof(GSEQTBase_ProcessItemCS, Querier) == 0x000028, "Member 'GSEQTBase_ProcessItemCS::Querier' has a wrong offset!");
static_assert(offsetof(GSEQTBase_ProcessItemCS, ReturnValue) == 0x000030, "Member 'GSEQTBase_ProcessItemCS::ReturnValue' has a wrong offset!");

// Function b1.GSEQTBase.SetItemScoreBool
// 0x0001 (0x0001 - 0x0000)
struct GSEQTBase_SetItemScoreBool final
{
public:
	bool                                          bScore;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_SetItemScoreBool) == 0x000001, "Wrong alignment on GSEQTBase_SetItemScoreBool");
static_assert(sizeof(GSEQTBase_SetItemScoreBool) == 0x000001, "Wrong size on GSEQTBase_SetItemScoreBool");
static_assert(offsetof(GSEQTBase_SetItemScoreBool, bScore) == 0x000000, "Member 'GSEQTBase_SetItemScoreBool::bScore' has a wrong offset!");

// Function b1.GSEQTBase.SetItemScoreFloat
// 0x0004 (0x0004 - 0x0000)
struct GSEQTBase_SetItemScoreFloat final
{
public:
	float                                         Score;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_SetItemScoreFloat) == 0x000004, "Wrong alignment on GSEQTBase_SetItemScoreFloat");
static_assert(sizeof(GSEQTBase_SetItemScoreFloat) == 0x000004, "Wrong size on GSEQTBase_SetItemScoreFloat");
static_assert(offsetof(GSEQTBase_SetItemScoreFloat, Score) == 0x000000, "Member 'GSEQTBase_SetItemScoreFloat::Score' has a wrong offset!");

// Function b1.GSEQTBase.ShouldPrepareContext
// 0x0001 (0x0001 - 0x0000)
struct GSEQTBase_ShouldPrepareContext final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_ShouldPrepareContext) == 0x000001, "Wrong alignment on GSEQTBase_ShouldPrepareContext");
static_assert(sizeof(GSEQTBase_ShouldPrepareContext) == 0x000001, "Wrong size on GSEQTBase_ShouldPrepareContext");
static_assert(offsetof(GSEQTBase_ShouldPrepareContext, ReturnValue) == 0x000000, "Member 'GSEQTBase_ShouldPrepareContext::ReturnValue' has a wrong offset!");

// Function b1.GSEQTBase.ShouldUseCustomItemScore
// 0x0001 (0x0001 - 0x0000)
struct GSEQTBase_ShouldUseCustomItemScore final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEQTBase_ShouldUseCustomItemScore) == 0x000001, "Wrong alignment on GSEQTBase_ShouldUseCustomItemScore");
static_assert(sizeof(GSEQTBase_ShouldUseCustomItemScore) == 0x000001, "Wrong size on GSEQTBase_ShouldUseCustomItemScore");
static_assert(offsetof(GSEQTBase_ShouldUseCustomItemScore, ReturnValue) == 0x000000, "Member 'GSEQTBase_ShouldUseCustomItemScore::ReturnValue' has a wrong offset!");

// Function b1.GSLocalPlayer.GetGameLoginOptionsCS
// 0x0010 (0x0010 - 0x0000)
struct GSLocalPlayer_GetGameLoginOptionsCS final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSLocalPlayer_GetGameLoginOptionsCS) == 0x000008, "Wrong alignment on GSLocalPlayer_GetGameLoginOptionsCS");
static_assert(sizeof(GSLocalPlayer_GetGameLoginOptionsCS) == 0x000010, "Wrong size on GSLocalPlayer_GetGameLoginOptionsCS");
static_assert(offsetof(GSLocalPlayer_GetGameLoginOptionsCS, ReturnValue) == 0x000000, "Member 'GSLocalPlayer_GetGameLoginOptionsCS::ReturnValue' has a wrong offset!");

// Function b1.U3DebugUtil.DisableAllScreenMessages
// 0x0008 (0x0008 - 0x0000)
struct U3DebugUtil_DisableAllScreenMessages final
{
public:
	class UObject*                                WorldCtx;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_DisableAllScreenMessages) == 0x000008, "Wrong alignment on U3DebugUtil_DisableAllScreenMessages");
static_assert(sizeof(U3DebugUtil_DisableAllScreenMessages) == 0x000008, "Wrong size on U3DebugUtil_DisableAllScreenMessages");
static_assert(offsetof(U3DebugUtil_DisableAllScreenMessages, WorldCtx) == 0x000000, "Member 'U3DebugUtil_DisableAllScreenMessages::WorldCtx' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawCircle
// 0x0070 (0x0070 - 0x0000)
struct U3DebugUtil_U3DrawCircle final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Base;                                              // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawCircle) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawCircle");
static_assert(sizeof(U3DebugUtil_U3DrawCircle) == 0x000070, "Wrong size on U3DebugUtil_U3DrawCircle");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawCircle::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, Base) == 0x000008, "Member 'U3DebugUtil_U3DrawCircle::Base' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, X) == 0x000020, "Member 'U3DebugUtil_U3DrawCircle::X' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, Y) == 0x000038, "Member 'U3DebugUtil_U3DrawCircle::Y' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, Color) == 0x000050, "Member 'U3DebugUtil_U3DrawCircle::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, Radius) == 0x000054, "Member 'U3DebugUtil_U3DrawCircle::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, NumSides) == 0x000058, "Member 'U3DebugUtil_U3DrawCircle::NumSides' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, bPersistentLines) == 0x00005C, "Member 'U3DebugUtil_U3DrawCircle::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, LifeTime) == 0x000060, "Member 'U3DebugUtil_U3DrawCircle::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, DepthPriority) == 0x000064, "Member 'U3DebugUtil_U3DrawCircle::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawCircle, Thickness) == 0x000068, "Member 'U3DebugUtil_U3DrawCircle::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebug2DDonut
// 0x00B0 (0x00B0 - 0x0000)
struct U3DebugUtil_U3DrawDebug2DDonut final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                TransformMatrix;                                   // 0x0010(0x0080)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x0094(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x009C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x00A0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x00A4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x00A8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x00AC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3DrawDebug2DDonut) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebug2DDonut");
static_assert(sizeof(U3DebugUtil_U3DrawDebug2DDonut) == 0x0000B0, "Wrong size on U3DebugUtil_U3DrawDebug2DDonut");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebug2DDonut::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, TransformMatrix) == 0x000010, "Member 'U3DebugUtil_U3DrawDebug2DDonut::TransformMatrix' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, InnerRadius) == 0x000090, "Member 'U3DebugUtil_U3DrawDebug2DDonut::InnerRadius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, OuterRadius) == 0x000094, "Member 'U3DebugUtil_U3DrawDebug2DDonut::OuterRadius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, Segments) == 0x000098, "Member 'U3DebugUtil_U3DrawDebug2DDonut::Segments' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, Color) == 0x00009C, "Member 'U3DebugUtil_U3DrawDebug2DDonut::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, bPersistentLines) == 0x0000A0, "Member 'U3DebugUtil_U3DrawDebug2DDonut::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, LifeTime) == 0x0000A4, "Member 'U3DebugUtil_U3DrawDebug2DDonut::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, DepthPriority) == 0x0000A8, "Member 'U3DebugUtil_U3DrawDebug2DDonut::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebug2DDonut, Thickness) == 0x0000AC, "Member 'U3DebugUtil_U3DrawDebug2DDonut::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugAltCone
// 0x0058 (0x0058 - 0x0000)
struct U3DebugUtil_U3DrawDebugAltCone final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWidth;                                        // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHeight;                                       // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DrawColor;                                         // 0x0044(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3DrawDebugAltCone) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugAltCone");
static_assert(sizeof(U3DebugUtil_U3DrawDebugAltCone) == 0x000058, "Wrong size on U3DebugUtil_U3DrawDebugAltCone");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugAltCone::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, Origin) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugAltCone::Origin' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, Rotation) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugAltCone::Rotation' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, Length) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugAltCone::Length' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, AngleWidth) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugAltCone::AngleWidth' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, AngleHeight) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugAltCone::AngleHeight' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, DrawColor) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugAltCone::DrawColor' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, bPersistentLines) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugAltCone::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, LifeTime) == 0x00004C, "Member 'U3DebugUtil_U3DrawDebugAltCone::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, DepthPriority) == 0x000050, "Member 'U3DebugUtil_U3DrawDebugAltCone::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugAltCone, Thickness) == 0x000054, "Member 'U3DebugUtil_U3DrawDebugAltCone::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugBox
// 0x0050 (0x0050 - 0x0000)
struct U3DebugUtil_U3DrawDebugBox final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0038(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugBox) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugBox");
static_assert(sizeof(U3DebugUtil_U3DrawDebugBox) == 0x000050, "Wrong size on U3DebugUtil_U3DrawDebugBox");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugBox::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox, Center) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugBox::Center' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox, Extent) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugBox::Extent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox, Color) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugBox::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox, bPersistentLines) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugBox::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox, LifeTime) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugBox::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox, DepthPriority) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugBox::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox, Thickness) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugBox::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugBox2
// 0x0080 (0x0080 - 0x0000)
struct U3DebugUtil_U3DrawDebugBox2 final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0040(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0060(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x006C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugBox2) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugBox2");
static_assert(sizeof(U3DebugUtil_U3DrawDebugBox2) == 0x000080, "Wrong size on U3DebugUtil_U3DrawDebugBox2");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugBox2::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, Center) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugBox2::Center' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, Extent) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugBox2::Extent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, Rotation) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugBox2::Rotation' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, Color) == 0x000060, "Member 'U3DebugUtil_U3DrawDebugBox2::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, bPersistentLines) == 0x000064, "Member 'U3DebugUtil_U3DrawDebugBox2::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, LifeTime) == 0x000068, "Member 'U3DebugUtil_U3DrawDebugBox2::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, DepthPriority) == 0x00006C, "Member 'U3DebugUtil_U3DrawDebugBox2::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugBox2, Thickness) == 0x000070, "Member 'U3DebugUtil_U3DrawDebugBox2::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCamera
// 0x0050 (0x0050 - 0x0000)
struct U3DebugUtil_U3DrawDebugCamera final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOVDeg;                                            // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCamera) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCamera");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCamera) == 0x000050, "Wrong size on U3DebugUtil_U3DrawDebugCamera");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCamera::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, Location) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCamera::Location' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, Rotation) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCamera::Rotation' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, FOVDeg) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCamera::FOVDeg' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, Scale) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugCamera::Scale' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, Color) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugCamera::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, bPersistentLines) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugCamera::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, LifeTime) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugCamera::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCamera, DepthPriority) == 0x00004C, "Member 'U3DebugUtil_U3DrawDebugCamera::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCanvas2DBox
// 0x0048 (0x0048 - 0x0000)
struct U3DebugUtil_U3DrawDebugCanvas2DBox final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 Box;                                               // 0x0008(0x0028)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCanvas2DBox) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCanvas2DBox");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCanvas2DBox) == 0x000048, "Wrong size on U3DebugUtil_U3DrawDebugCanvas2DBox");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DBox, Canvas) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCanvas2DBox::Canvas' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DBox, Box) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCanvas2DBox::Box' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DBox, LineColor) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugCanvas2DBox::LineColor' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DBox, LineThickness) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugCanvas2DBox::LineThickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCanvas2DCircle
// 0x0038 (0x0038 - 0x0000)
struct U3DebugUtil_U3DrawDebugCanvas2DCircle final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Center;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0030(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCanvas2DCircle) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCanvas2DCircle");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCanvas2DCircle) == 0x000038, "Wrong size on U3DebugUtil_U3DrawDebugCanvas2DCircle");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DCircle, Canvas) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCanvas2DCircle::Canvas' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DCircle, Center) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCanvas2DCircle::Center' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DCircle, Radius) == 0x000018, "Member 'U3DebugUtil_U3DrawDebugCanvas2DCircle::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DCircle, NumSides) == 0x00001C, "Member 'U3DebugUtil_U3DrawDebugCanvas2DCircle::NumSides' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DCircle, LineColor) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCanvas2DCircle::LineColor' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DCircle, LineThickness) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugCanvas2DCircle::LineThickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCanvas2DLine
// 0x0048 (0x0048 - 0x0000)
struct U3DebugUtil_U3DrawDebugCanvas2DLine final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCanvas2DLine) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCanvas2DLine");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCanvas2DLine) == 0x000048, "Wrong size on U3DebugUtil_U3DrawDebugCanvas2DLine");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine, Canvas) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine::Canvas' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine, Start) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine::Start' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine, End) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine::End' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine, LineColor) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine::LineColor' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCanvas2DLine2
// 0x0040 (0x0040 - 0x0000)
struct U3DebugUtil_U3DrawDebugCanvas2DLine2 final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartPosition;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EndPosition;                                       // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0038(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCanvas2DLine2) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCanvas2DLine2");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCanvas2DLine2) == 0x000040, "Wrong size on U3DebugUtil_U3DrawDebugCanvas2DLine2");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine2, Canvas) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine2::Canvas' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine2, StartPosition) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine2::StartPosition' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine2, EndPosition) == 0x000018, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine2::EndPosition' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine2, LineColor) == 0x000028, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine2::LineColor' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvas2DLine2, LineThickness) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCanvas2DLine2::LineThickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCanvasCircle
// 0x0060 (0x0060 - 0x0000)
struct U3DebugUtil_U3DrawDebugCanvasCircle final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Base;                                              // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x0038(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCanvasCircle) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCanvasCircle");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCanvasCircle) == 0x000060, "Wrong size on U3DebugUtil_U3DrawDebugCanvasCircle");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasCircle, Canvas) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCanvasCircle::Canvas' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasCircle, Base) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCanvasCircle::Base' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasCircle, X) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCanvasCircle::X' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasCircle, Y) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCanvasCircle::Y' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasCircle, Color) == 0x000050, "Member 'U3DebugUtil_U3DrawDebugCanvasCircle::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasCircle, Radius) == 0x000054, "Member 'U3DebugUtil_U3DrawDebugCanvasCircle::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasCircle, NumSides) == 0x000058, "Member 'U3DebugUtil_U3DrawDebugCanvasCircle::NumSides' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCanvasLine
// 0x0048 (0x0048 - 0x0000)
struct U3DebugUtil_U3DrawDebugCanvasLine final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCanvasLine) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCanvasLine");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCanvasLine) == 0x000048, "Wrong size on U3DebugUtil_U3DrawDebugCanvasLine");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasLine, Canvas) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCanvasLine::Canvas' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasLine, Start) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCanvasLine::Start' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasLine, End) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCanvasLine::End' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasLine, LineColor) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCanvasLine::LineColor' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCanvasWireCone
// 0x0080 (0x0080 - 0x0000)
struct U3DebugUtil_U3DrawDebugCanvasWireCone final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConeRadius;                                        // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngle;                                         // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConeSides;                                         // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCanvasWireCone) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugCanvasWireCone");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCanvasWireCone) == 0x000080, "Wrong size on U3DebugUtil_U3DrawDebugCanvasWireCone");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireCone, Canvas) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCanvasWireCone::Canvas' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireCone, Transform) == 0x000010, "Member 'U3DebugUtil_U3DrawDebugCanvasWireCone::Transform' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireCone, ConeRadius) == 0x000070, "Member 'U3DebugUtil_U3DrawDebugCanvasWireCone::ConeRadius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireCone, ConeAngle) == 0x000074, "Member 'U3DebugUtil_U3DrawDebugCanvasWireCone::ConeAngle' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireCone, ConeSides) == 0x000078, "Member 'U3DebugUtil_U3DrawDebugCanvasWireCone::ConeSides' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireCone, Color) == 0x00007C, "Member 'U3DebugUtil_U3DrawDebugCanvasWireCone::Color' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCanvasWireSphere
// 0x0030 (0x0030 - 0x0000)
struct U3DebugUtil_U3DrawDebugCanvasWireSphere final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Base;                                              // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCanvasWireSphere) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCanvasWireSphere");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCanvasWireSphere) == 0x000030, "Wrong size on U3DebugUtil_U3DrawDebugCanvasWireSphere");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireSphere, Canvas) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCanvasWireSphere::Canvas' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireSphere, Base) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCanvasWireSphere::Base' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireSphere, Color) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCanvasWireSphere::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireSphere, Radius) == 0x000024, "Member 'U3DebugUtil_U3DrawDebugCanvasWireSphere::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCanvasWireSphere, NumSides) == 0x000028, "Member 'U3DebugUtil_U3DrawDebugCanvasWireSphere::NumSides' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCapsule
// 0x0070 (0x0070 - 0x0000)
struct U3DebugUtil_U3DrawDebugCapsule final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0030(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCapsule) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugCapsule");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCapsule) == 0x000070, "Wrong size on U3DebugUtil_U3DrawDebugCapsule");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCapsule::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, Center) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCapsule::Center' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, HalfHeight) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, Radius) == 0x000024, "Member 'U3DebugUtil_U3DrawDebugCapsule::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, Rotation) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugCapsule::Rotation' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, Color) == 0x000050, "Member 'U3DebugUtil_U3DrawDebugCapsule::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, bPersistentLines) == 0x000054, "Member 'U3DebugUtil_U3DrawDebugCapsule::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, LifeTime) == 0x000058, "Member 'U3DebugUtil_U3DrawDebugCapsule::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, DepthPriority) == 0x00005C, "Member 'U3DebugUtil_U3DrawDebugCapsule::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCapsule, Thickness) == 0x000060, "Member 'U3DebugUtil_U3DrawDebugCapsule::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCircle
// 0x00B0 (0x00B0 - 0x0000)
struct U3DebugUtil_U3DrawDebugCircle final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                TransformMatrix;                                   // 0x0010(0x0080)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0094(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0098(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x009C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x00A0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x00A4(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x00A8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAxis;                                         // 0x00AC(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCircle) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugCircle");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCircle) == 0x0000B0, "Wrong size on U3DebugUtil_U3DrawDebugCircle");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCircle::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, TransformMatrix) == 0x000010, "Member 'U3DebugUtil_U3DrawDebugCircle::TransformMatrix' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, Radius) == 0x000090, "Member 'U3DebugUtil_U3DrawDebugCircle::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, Segments) == 0x000094, "Member 'U3DebugUtil_U3DrawDebugCircle::Segments' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, Color) == 0x000098, "Member 'U3DebugUtil_U3DrawDebugCircle::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, bPersistentLines) == 0x00009C, "Member 'U3DebugUtil_U3DrawDebugCircle::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, LifeTime) == 0x0000A0, "Member 'U3DebugUtil_U3DrawDebugCircle::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, DepthPriority) == 0x0000A4, "Member 'U3DebugUtil_U3DrawDebugCircle::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, Thickness) == 0x0000A8, "Member 'U3DebugUtil_U3DrawDebugCircle::Thickness' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle, bDrawAxis) == 0x0000AC, "Member 'U3DebugUtil_U3DrawDebugCircle::bDrawAxis' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCircle2
// 0x0078 (0x0078 - 0x0000)
struct U3DebugUtil_U3DrawDebugCircle2 final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0028(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                YAxis;                                             // 0x0040(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZAxis;                                             // 0x0058(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAxis;                                         // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCircle2) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCircle2");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCircle2) == 0x000078, "Wrong size on U3DebugUtil_U3DrawDebugCircle2");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCircle2::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, Center) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCircle2::Center' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, Radius) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCircle2::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, Segments) == 0x000024, "Member 'U3DebugUtil_U3DrawDebugCircle2::Segments' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, Color) == 0x000028, "Member 'U3DebugUtil_U3DrawDebugCircle2::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, bPersistentLines) == 0x00002C, "Member 'U3DebugUtil_U3DrawDebugCircle2::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, LifeTime) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugCircle2::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, DepthPriority) == 0x000034, "Member 'U3DebugUtil_U3DrawDebugCircle2::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, Thickness) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCircle2::Thickness' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, YAxis) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugCircle2::YAxis' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, ZAxis) == 0x000058, "Member 'U3DebugUtil_U3DrawDebugCircle2::ZAxis' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCircle2, bDrawAxis) == 0x000070, "Member 'U3DebugUtil_U3DrawDebugCircle2::bDrawAxis' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCone
// 0x0060 (0x0060 - 0x0000)
struct U3DebugUtil_U3DrawDebugCone final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWidth;                                        // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHeight;                                       // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0048(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCone) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCone");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCone) == 0x000060, "Wrong size on U3DebugUtil_U3DrawDebugCone");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCone::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, Origin) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCone::Origin' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, Direction) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCone::Direction' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, Length) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCone::Length' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, AngleWidth) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugCone::AngleWidth' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, AngleHeight) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugCone::AngleHeight' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, NumSides) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugCone::NumSides' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, Color) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugCone::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, bPersistentLines) == 0x00004C, "Member 'U3DebugUtil_U3DrawDebugCone::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, LifeTime) == 0x000050, "Member 'U3DebugUtil_U3DrawDebugCone::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, DepthPriority) == 0x000054, "Member 'U3DebugUtil_U3DrawDebugCone::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCone, Thickness) == 0x000058, "Member 'U3DebugUtil_U3DrawDebugCone::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCoordinateSystem
// 0x0050 (0x0050 - 0x0000)
struct U3DebugUtil_U3DrawDebugCoordinateSystem final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisLoc;                                           // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AxisRot;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCoordinateSystem) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCoordinateSystem");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCoordinateSystem) == 0x000050, "Wrong size on U3DebugUtil_U3DrawDebugCoordinateSystem");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCoordinateSystem, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCoordinateSystem::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCoordinateSystem, AxisLoc) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCoordinateSystem::AxisLoc' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCoordinateSystem, AxisRot) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCoordinateSystem::AxisRot' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCoordinateSystem, Scale) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCoordinateSystem::Scale' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCoordinateSystem, bPersistentLines) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugCoordinateSystem::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCoordinateSystem, LifeTime) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugCoordinateSystem::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCoordinateSystem, DepthPriority) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugCoordinateSystem::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCoordinateSystem, Thickness) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugCoordinateSystem::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCrosshairs
// 0x0050 (0x0050 - 0x0000)
struct U3DebugUtil_U3DrawDebugCrosshairs final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisLoc;                                           // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AxisRot;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x003C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCrosshairs) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCrosshairs");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCrosshairs) == 0x000050, "Wrong size on U3DebugUtil_U3DrawDebugCrosshairs");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCrosshairs, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCrosshairs::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCrosshairs, AxisLoc) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCrosshairs::AxisLoc' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCrosshairs, AxisRot) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCrosshairs::AxisRot' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCrosshairs, Scale) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCrosshairs::Scale' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCrosshairs, Color) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugCrosshairs::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCrosshairs, bPersistentLines) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugCrosshairs::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCrosshairs, LifeTime) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugCrosshairs::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCrosshairs, DepthPriority) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugCrosshairs::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugCylinder
// 0x0058 (0x0058 - 0x0000)
struct U3DebugUtil_U3DrawDebugCylinder final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugCylinder) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugCylinder");
static_assert(sizeof(U3DebugUtil_U3DrawDebugCylinder) == 0x000058, "Wrong size on U3DebugUtil_U3DrawDebugCylinder");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugCylinder::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, Start) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugCylinder::Start' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, End) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugCylinder::End' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, Radius) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugCylinder::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, Segments) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugCylinder::Segments' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, Color) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugCylinder::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, bPersistentLines) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugCylinder::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, LifeTime) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugCylinder::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, DepthPriority) == 0x00004C, "Member 'U3DebugUtil_U3DrawDebugCylinder::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugCylinder, Thickness) == 0x000050, "Member 'U3DebugUtil_U3DrawDebugCylinder::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugDirectionalArrow
// 0x0050 (0x0050 - 0x0000)
struct U3DebugUtil_U3DrawDebugDirectionalArrow final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowSize;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x003C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3DrawDebugDirectionalArrow) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugDirectionalArrow");
static_assert(sizeof(U3DebugUtil_U3DrawDebugDirectionalArrow) == 0x000050, "Wrong size on U3DebugUtil_U3DrawDebugDirectionalArrow");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, LineStart) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::LineStart' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, LineEnd) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::LineEnd' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, ArrowSize) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::ArrowSize' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, Color) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, bPersistentLines) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, LifeTime) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, DepthPriority) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugDirectionalArrow, Thickness) == 0x00004C, "Member 'U3DebugUtil_U3DrawDebugDirectionalArrow::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugFrustum
// 0x00B0 (0x00B0 - 0x0000)
struct U3DebugUtil_U3DrawDebugFrustum final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                FrustumToWorld;                                    // 0x0010(0x0080)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0090(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x009C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x00A0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugFrustum) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugFrustum");
static_assert(sizeof(U3DebugUtil_U3DrawDebugFrustum) == 0x0000B0, "Wrong size on U3DebugUtil_U3DrawDebugFrustum");
static_assert(offsetof(U3DebugUtil_U3DrawDebugFrustum, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugFrustum::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugFrustum, FrustumToWorld) == 0x000010, "Member 'U3DebugUtil_U3DrawDebugFrustum::FrustumToWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugFrustum, Color) == 0x000090, "Member 'U3DebugUtil_U3DrawDebugFrustum::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugFrustum, bPersistentLines) == 0x000094, "Member 'U3DebugUtil_U3DrawDebugFrustum::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugFrustum, LifeTime) == 0x000098, "Member 'U3DebugUtil_U3DrawDebugFrustum::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugFrustum, DepthPriority) == 0x00009C, "Member 'U3DebugUtil_U3DrawDebugFrustum::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugFrustum, Thickness) == 0x0000A0, "Member 'U3DebugUtil_U3DrawDebugFrustum::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugLine
// 0x0050 (0x0050 - 0x0000)
struct U3DebugUtil_U3DrawDebugLine final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0038(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugLine) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugLine");
static_assert(sizeof(U3DebugUtil_U3DrawDebugLine) == 0x000050, "Wrong size on U3DebugUtil_U3DrawDebugLine");
static_assert(offsetof(U3DebugUtil_U3DrawDebugLine, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugLine::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugLine, LineStart) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugLine::LineStart' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugLine, LineEnd) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugLine::LineEnd' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugLine, Color) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugLine::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugLine, bPersistentLines) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugLine::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugLine, LifeTime) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugLine::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugLine, DepthPriority) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugLine::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugLine, Thickness) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugLine::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugMesh
// 0x0038 (0x0038 - 0x0000)
struct U3DebugUtil_U3DrawDebugMesh final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Verts;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 Indices;                                           // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0028(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugMesh) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugMesh");
static_assert(sizeof(U3DebugUtil_U3DrawDebugMesh) == 0x000038, "Wrong size on U3DebugUtil_U3DrawDebugMesh");
static_assert(offsetof(U3DebugUtil_U3DrawDebugMesh, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugMesh::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugMesh, Verts) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugMesh::Verts' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugMesh, Indices) == 0x000018, "Member 'U3DebugUtil_U3DrawDebugMesh::Indices' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugMesh, Color) == 0x000028, "Member 'U3DebugUtil_U3DrawDebugMesh::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugMesh, bPersistent) == 0x00002C, "Member 'U3DebugUtil_U3DrawDebugMesh::bPersistent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugMesh, LifeTime) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugMesh::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugMesh, DepthPriority) == 0x000034, "Member 'U3DebugUtil_U3DrawDebugMesh::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugPoint
// 0x0038 (0x0038 - 0x0000)
struct U3DebugUtil_U3DrawDebugPoint final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 PointColor;                                        // 0x0024(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugPoint) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugPoint");
static_assert(sizeof(U3DebugUtil_U3DrawDebugPoint) == 0x000038, "Wrong size on U3DebugUtil_U3DrawDebugPoint");
static_assert(offsetof(U3DebugUtil_U3DrawDebugPoint, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugPoint::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugPoint, Position) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugPoint::Position' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugPoint, Size) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugPoint::Size' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugPoint, PointColor) == 0x000024, "Member 'U3DebugUtil_U3DrawDebugPoint::PointColor' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugPoint, bPersistentLines) == 0x000028, "Member 'U3DebugUtil_U3DrawDebugPoint::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugPoint, LifeTime) == 0x00002C, "Member 'U3DebugUtil_U3DrawDebugPoint::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugPoint, DepthPriority) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugPoint::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugSolidBox
// 0x00C0 (0x00C0 - 0x0000)
struct U3DebugUtil_U3DrawDebugSolidBox final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0008(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0050(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x00B0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x00B4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x00B8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugSolidBox) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugSolidBox");
static_assert(sizeof(U3DebugUtil_U3DrawDebugSolidBox) == 0x0000C0, "Wrong size on U3DebugUtil_U3DrawDebugSolidBox");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugSolidBox::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox, Box) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugSolidBox::Box' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox, Color) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugSolidBox::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox, Transform) == 0x000050, "Member 'U3DebugUtil_U3DrawDebugSolidBox::Transform' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox, bPersistent) == 0x0000B0, "Member 'U3DebugUtil_U3DrawDebugSolidBox::bPersistent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox, LifeTime) == 0x0000B4, "Member 'U3DebugUtil_U3DrawDebugSolidBox::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox, DepthPriority) == 0x0000B8, "Member 'U3DebugUtil_U3DrawDebugSolidBox::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugSolidBox2
// 0x0048 (0x0048 - 0x0000)
struct U3DebugUtil_U3DrawDebugSolidBox2 final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0038(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugSolidBox2) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugSolidBox2");
static_assert(sizeof(U3DebugUtil_U3DrawDebugSolidBox2) == 0x000048, "Wrong size on U3DebugUtil_U3DrawDebugSolidBox2");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox2, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugSolidBox2::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox2, Center) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugSolidBox2::Center' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox2, Extent) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugSolidBox2::Extent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox2, Color) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugSolidBox2::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox2, bPersistent) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugSolidBox2::bPersistent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox2, LifeTime) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugSolidBox2::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox2, DepthPriority) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugSolidBox2::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugSolidBox3
// 0x0070 (0x0070 - 0x0000)
struct U3DebugUtil_U3DrawDebugSolidBox3 final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0040(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0060(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x006C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugSolidBox3) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugSolidBox3");
static_assert(sizeof(U3DebugUtil_U3DrawDebugSolidBox3) == 0x000070, "Wrong size on U3DebugUtil_U3DrawDebugSolidBox3");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox3, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugSolidBox3::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox3, Center) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugSolidBox3::Center' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox3, Extent) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugSolidBox3::Extent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox3, Rotation) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugSolidBox3::Rotation' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox3, Color) == 0x000060, "Member 'U3DebugUtil_U3DrawDebugSolidBox3::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox3, bPersistent) == 0x000064, "Member 'U3DebugUtil_U3DrawDebugSolidBox3::bPersistent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox3, LifeTime) == 0x000068, "Member 'U3DebugUtil_U3DrawDebugSolidBox3::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidBox3, DepthPriority) == 0x00006C, "Member 'U3DebugUtil_U3DrawDebugSolidBox3::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugSolidPlane
// 0x0060 (0x0060 - 0x0000)
struct U3DebugUtil_U3DrawDebugSolidPlane final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlane                                 P;                                                 // 0x0010(0x0020)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Loc;                                               // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x004C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugSolidPlane) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugSolidPlane");
static_assert(sizeof(U3DebugUtil_U3DrawDebugSolidPlane) == 0x000060, "Wrong size on U3DebugUtil_U3DrawDebugSolidPlane");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugSolidPlane::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane, P) == 0x000010, "Member 'U3DebugUtil_U3DrawDebugSolidPlane::P' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane, Loc) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugSolidPlane::Loc' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane, Size) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugSolidPlane::Size' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane, Color) == 0x00004C, "Member 'U3DebugUtil_U3DrawDebugSolidPlane::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane, bPersistent) == 0x000050, "Member 'U3DebugUtil_U3DrawDebugSolidPlane::bPersistent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane, LifeTime) == 0x000054, "Member 'U3DebugUtil_U3DrawDebugSolidPlane::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane, DepthPriority) == 0x000058, "Member 'U3DebugUtil_U3DrawDebugSolidPlane::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugSolidPlane2
// 0x0070 (0x0070 - 0x0000)
struct U3DebugUtil_U3DrawDebugSolidPlane2 final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlane                                 P;                                                 // 0x0010(0x0020)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Loc;                                               // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Extents;                                           // 0x0048(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0058(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0xB];                                       // 0x0065(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugSolidPlane2) == 0x000010, "Wrong alignment on U3DebugUtil_U3DrawDebugSolidPlane2");
static_assert(sizeof(U3DebugUtil_U3DrawDebugSolidPlane2) == 0x000070, "Wrong size on U3DebugUtil_U3DrawDebugSolidPlane2");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane2, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugSolidPlane2::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane2, P) == 0x000010, "Member 'U3DebugUtil_U3DrawDebugSolidPlane2::P' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane2, Loc) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugSolidPlane2::Loc' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane2, Extents) == 0x000048, "Member 'U3DebugUtil_U3DrawDebugSolidPlane2::Extents' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane2, Color) == 0x000058, "Member 'U3DebugUtil_U3DrawDebugSolidPlane2::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane2, bPersistent) == 0x00005C, "Member 'U3DebugUtil_U3DrawDebugSolidPlane2::bPersistent' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane2, LifeTime) == 0x000060, "Member 'U3DebugUtil_U3DrawDebugSolidPlane2::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSolidPlane2, DepthPriority) == 0x000064, "Member 'U3DebugUtil_U3DrawDebugSolidPlane2::DepthPriority' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugSphere
// 0x0040 (0x0040 - 0x0000)
struct U3DebugUtil_U3DrawDebugSphere final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0028(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(U3DebugUtil_U3DrawDebugSphere) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugSphere");
static_assert(sizeof(U3DebugUtil_U3DrawDebugSphere) == 0x000040, "Wrong size on U3DebugUtil_U3DrawDebugSphere");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugSphere::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, Center) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugSphere::Center' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, Radius) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugSphere::Radius' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, Segments) == 0x000024, "Member 'U3DebugUtil_U3DrawDebugSphere::Segments' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, Color) == 0x000028, "Member 'U3DebugUtil_U3DrawDebugSphere::Color' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, bPersistentLines) == 0x00002C, "Member 'U3DebugUtil_U3DrawDebugSphere::bPersistentLines' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, LifeTime) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugSphere::LifeTime' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, DepthPriority) == 0x000034, "Member 'U3DebugUtil_U3DrawDebugSphere::DepthPriority' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugSphere, Thickness) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugSphere::Thickness' has a wrong offset!");

// Function b1.U3DebugUtil.U3DrawDebugString
// 0x0048 (0x0048 - 0x0000)
struct U3DebugUtil_U3DrawDebugString final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TextLocation;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TestBaseActor;                                     // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColor;                                         // 0x0038(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawShadow;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FontScale;                                         // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3DrawDebugString) == 0x000008, "Wrong alignment on U3DebugUtil_U3DrawDebugString");
static_assert(sizeof(U3DebugUtil_U3DrawDebugString) == 0x000048, "Wrong size on U3DebugUtil_U3DrawDebugString");
static_assert(offsetof(U3DebugUtil_U3DrawDebugString, InWorld) == 0x000000, "Member 'U3DebugUtil_U3DrawDebugString::InWorld' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugString, TextLocation) == 0x000008, "Member 'U3DebugUtil_U3DrawDebugString::TextLocation' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugString, Text) == 0x000020, "Member 'U3DebugUtil_U3DrawDebugString::Text' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugString, TestBaseActor) == 0x000030, "Member 'U3DebugUtil_U3DrawDebugString::TestBaseActor' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugString, TextColor) == 0x000038, "Member 'U3DebugUtil_U3DrawDebugString::TextColor' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugString, Duration) == 0x00003C, "Member 'U3DebugUtil_U3DrawDebugString::Duration' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugString, bDrawShadow) == 0x000040, "Member 'U3DebugUtil_U3DrawDebugString::bDrawShadow' has a wrong offset!");
static_assert(offsetof(U3DebugUtil_U3DrawDebugString, FontScale) == 0x000044, "Member 'U3DebugUtil_U3DrawDebugString::FontScale' has a wrong offset!");

// Function b1.U3DebugUtil.U3FlushDebugStrings
// 0x0008 (0x0008 - 0x0000)
struct U3DebugUtil_U3FlushDebugStrings final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3FlushDebugStrings) == 0x000008, "Wrong alignment on U3DebugUtil_U3FlushDebugStrings");
static_assert(sizeof(U3DebugUtil_U3FlushDebugStrings) == 0x000008, "Wrong size on U3DebugUtil_U3FlushDebugStrings");
static_assert(offsetof(U3DebugUtil_U3FlushDebugStrings, InWorld) == 0x000000, "Member 'U3DebugUtil_U3FlushDebugStrings::InWorld' has a wrong offset!");

// Function b1.U3DebugUtil.U3FlushPersistentDebugLines
// 0x0008 (0x0008 - 0x0000)
struct U3DebugUtil_U3FlushPersistentDebugLines final
{
public:
	const class UWorld*                           InWorld;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(U3DebugUtil_U3FlushPersistentDebugLines) == 0x000008, "Wrong alignment on U3DebugUtil_U3FlushPersistentDebugLines");
static_assert(sizeof(U3DebugUtil_U3FlushPersistentDebugLines) == 0x000008, "Wrong size on U3DebugUtil_U3FlushPersistentDebugLines");
static_assert(offsetof(U3DebugUtil_U3FlushPersistentDebugLines, InWorld) == 0x000000, "Member 'U3DebugUtil_U3FlushPersistentDebugLines::InWorld' has a wrong offset!");

// Function b1.USharpPerfTestBase.BoolRetTest
// 0x000C (0x000C - 0x0000)
struct USharpPerfTestBase_BoolRetTest final
{
public:
	int32                                         P1;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P2;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bP3;                                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(USharpPerfTestBase_BoolRetTest) == 0x000004, "Wrong alignment on USharpPerfTestBase_BoolRetTest");
static_assert(sizeof(USharpPerfTestBase_BoolRetTest) == 0x00000C, "Wrong size on USharpPerfTestBase_BoolRetTest");
static_assert(offsetof(USharpPerfTestBase_BoolRetTest, P1) == 0x000000, "Member 'USharpPerfTestBase_BoolRetTest::P1' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_BoolRetTest, P2) == 0x000004, "Member 'USharpPerfTestBase_BoolRetTest::P2' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_BoolRetTest, bP3) == 0x000008, "Member 'USharpPerfTestBase_BoolRetTest::bP3' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_BoolRetTest, ReturnValue) == 0x000009, "Member 'USharpPerfTestBase_BoolRetTest::ReturnValue' has a wrong offset!");

// Function b1.USharpPerfTestBase.EmptyCallableFuncWithParams
// 0x0010 (0x0010 - 0x0000)
struct USharpPerfTestBase_EmptyCallableFuncWithParams final
{
public:
	int32                                         P1;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P2;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P3;                                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bP4;                                               // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(USharpPerfTestBase_EmptyCallableFuncWithParams) == 0x000004, "Wrong alignment on USharpPerfTestBase_EmptyCallableFuncWithParams");
static_assert(sizeof(USharpPerfTestBase_EmptyCallableFuncWithParams) == 0x000010, "Wrong size on USharpPerfTestBase_EmptyCallableFuncWithParams");
static_assert(offsetof(USharpPerfTestBase_EmptyCallableFuncWithParams, P1) == 0x000000, "Member 'USharpPerfTestBase_EmptyCallableFuncWithParams::P1' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_EmptyCallableFuncWithParams, P2) == 0x000004, "Member 'USharpPerfTestBase_EmptyCallableFuncWithParams::P2' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_EmptyCallableFuncWithParams, P3) == 0x000008, "Member 'USharpPerfTestBase_EmptyCallableFuncWithParams::P3' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_EmptyCallableFuncWithParams, bP4) == 0x00000C, "Member 'USharpPerfTestBase_EmptyCallableFuncWithParams::bP4' has a wrong offset!");

// Function b1.USharpPerfTestBase.EmptyCallableFuncWithParams2
// 0x0030 (0x0030 - 0x0000)
struct USharpPerfTestBase_EmptyCallableFuncWithParams2 final
{
public:
	class FName                                   P1;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 P2;                                                // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   P3;                                                // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(USharpPerfTestBase_EmptyCallableFuncWithParams2) == 0x000008, "Wrong alignment on USharpPerfTestBase_EmptyCallableFuncWithParams2");
static_assert(sizeof(USharpPerfTestBase_EmptyCallableFuncWithParams2) == 0x000030, "Wrong size on USharpPerfTestBase_EmptyCallableFuncWithParams2");
static_assert(offsetof(USharpPerfTestBase_EmptyCallableFuncWithParams2, P1) == 0x000000, "Member 'USharpPerfTestBase_EmptyCallableFuncWithParams2::P1' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_EmptyCallableFuncWithParams2, P2) == 0x000008, "Member 'USharpPerfTestBase_EmptyCallableFuncWithParams2::P2' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_EmptyCallableFuncWithParams2, P3) == 0x000018, "Member 'USharpPerfTestBase_EmptyCallableFuncWithParams2::P3' has a wrong offset!");

// Function b1.USharpPerfTestBase.IntRetTest
// 0x0014 (0x0014 - 0x0000)
struct USharpPerfTestBase_IntRetTest final
{
public:
	int32                                         P1;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P2;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bP3;                                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Out1;                                              // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(USharpPerfTestBase_IntRetTest) == 0x000004, "Wrong alignment on USharpPerfTestBase_IntRetTest");
static_assert(sizeof(USharpPerfTestBase_IntRetTest) == 0x000014, "Wrong size on USharpPerfTestBase_IntRetTest");
static_assert(offsetof(USharpPerfTestBase_IntRetTest, P1) == 0x000000, "Member 'USharpPerfTestBase_IntRetTest::P1' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_IntRetTest, P2) == 0x000004, "Member 'USharpPerfTestBase_IntRetTest::P2' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_IntRetTest, bP3) == 0x000008, "Member 'USharpPerfTestBase_IntRetTest::bP3' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_IntRetTest, Out1) == 0x00000C, "Member 'USharpPerfTestBase_IntRetTest::Out1' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_IntRetTest, ReturnValue) == 0x000010, "Member 'USharpPerfTestBase_IntRetTest::ReturnValue' has a wrong offset!");

// Function b1.USharpPerfTestBase.IntRetTest2
// 0x0010 (0x0010 - 0x0000)
struct USharpPerfTestBase_IntRetTest2 final
{
public:
	int32                                         P1;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P2;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bP3;                                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(USharpPerfTestBase_IntRetTest2) == 0x000004, "Wrong alignment on USharpPerfTestBase_IntRetTest2");
static_assert(sizeof(USharpPerfTestBase_IntRetTest2) == 0x000010, "Wrong size on USharpPerfTestBase_IntRetTest2");
static_assert(offsetof(USharpPerfTestBase_IntRetTest2, P1) == 0x000000, "Member 'USharpPerfTestBase_IntRetTest2::P1' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_IntRetTest2, P2) == 0x000004, "Member 'USharpPerfTestBase_IntRetTest2::P2' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_IntRetTest2, bP3) == 0x000008, "Member 'USharpPerfTestBase_IntRetTest2::bP3' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_IntRetTest2, ReturnValue) == 0x00000C, "Member 'USharpPerfTestBase_IntRetTest2::ReturnValue' has a wrong offset!");

// Function b1.USharpPerfTestBase.InvokeMultiDelegate
// 0x0010 (0x0010 - 0x0000)
struct USharpPerfTestBase_InvokeMultiDelegate final
{
public:
	int32                                         AttrID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RealNewValue;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RealOrgValue;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectChangeValue;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(USharpPerfTestBase_InvokeMultiDelegate) == 0x000004, "Wrong alignment on USharpPerfTestBase_InvokeMultiDelegate");
static_assert(sizeof(USharpPerfTestBase_InvokeMultiDelegate) == 0x000010, "Wrong size on USharpPerfTestBase_InvokeMultiDelegate");
static_assert(offsetof(USharpPerfTestBase_InvokeMultiDelegate, AttrID) == 0x000000, "Member 'USharpPerfTestBase_InvokeMultiDelegate::AttrID' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_InvokeMultiDelegate, RealNewValue) == 0x000004, "Member 'USharpPerfTestBase_InvokeMultiDelegate::RealNewValue' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_InvokeMultiDelegate, RealOrgValue) == 0x000008, "Member 'USharpPerfTestBase_InvokeMultiDelegate::RealOrgValue' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_InvokeMultiDelegate, ExpectChangeValue) == 0x00000C, "Member 'USharpPerfTestBase_InvokeMultiDelegate::ExpectChangeValue' has a wrong offset!");

// Function b1.USharpPerfTestBase.InvokeMultiDelegateNoDyn
// 0x0010 (0x0010 - 0x0000)
struct USharpPerfTestBase_InvokeMultiDelegateNoDyn final
{
public:
	int32                                         AttrID;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RealNewValue;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RealOrgValue;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectChangeValue;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(USharpPerfTestBase_InvokeMultiDelegateNoDyn) == 0x000004, "Wrong alignment on USharpPerfTestBase_InvokeMultiDelegateNoDyn");
static_assert(sizeof(USharpPerfTestBase_InvokeMultiDelegateNoDyn) == 0x000010, "Wrong size on USharpPerfTestBase_InvokeMultiDelegateNoDyn");
static_assert(offsetof(USharpPerfTestBase_InvokeMultiDelegateNoDyn, AttrID) == 0x000000, "Member 'USharpPerfTestBase_InvokeMultiDelegateNoDyn::AttrID' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_InvokeMultiDelegateNoDyn, RealNewValue) == 0x000004, "Member 'USharpPerfTestBase_InvokeMultiDelegateNoDyn::RealNewValue' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_InvokeMultiDelegateNoDyn, RealOrgValue) == 0x000008, "Member 'USharpPerfTestBase_InvokeMultiDelegateNoDyn::RealOrgValue' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_InvokeMultiDelegateNoDyn, ExpectChangeValue) == 0x00000C, "Member 'USharpPerfTestBase_InvokeMultiDelegateNoDyn::ExpectChangeValue' has a wrong offset!");

// Function b1.USharpPerfTestBase.StructAsClassCreate
// 0x0020 (0x0020 - 0x0000)
struct USharpPerfTestBase_StructAsClassCreate final
{
public:
	int32                                         RawValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUSharpTestStructAsClass               ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(USharpPerfTestBase_StructAsClassCreate) == 0x000008, "Wrong alignment on USharpPerfTestBase_StructAsClassCreate");
static_assert(sizeof(USharpPerfTestBase_StructAsClassCreate) == 0x000020, "Wrong size on USharpPerfTestBase_StructAsClassCreate");
static_assert(offsetof(USharpPerfTestBase_StructAsClassCreate, RawValue) == 0x000000, "Member 'USharpPerfTestBase_StructAsClassCreate::RawValue' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_StructAsClassCreate, ReturnValue) == 0x000008, "Member 'USharpPerfTestBase_StructAsClassCreate::ReturnValue' has a wrong offset!");

// Function b1.USharpPerfTestBase.StructAsClassGetInt
// 0x0020 (0x0020 - 0x0000)
struct USharpPerfTestBase_StructAsClassGetInt final
{
public:
	struct FUSharpTestStructAsClass               InVal;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(USharpPerfTestBase_StructAsClassGetInt) == 0x000008, "Wrong alignment on USharpPerfTestBase_StructAsClassGetInt");
static_assert(sizeof(USharpPerfTestBase_StructAsClassGetInt) == 0x000020, "Wrong size on USharpPerfTestBase_StructAsClassGetInt");
static_assert(offsetof(USharpPerfTestBase_StructAsClassGetInt, InVal) == 0x000000, "Member 'USharpPerfTestBase_StructAsClassGetInt::InVal' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_StructAsClassGetInt, ReturnValue) == 0x000018, "Member 'USharpPerfTestBase_StructAsClassGetInt::ReturnValue' has a wrong offset!");

// Function b1.USharpPerfTestBase.TestFastFuncExport
// 0x0014 (0x0014 - 0x0000)
struct USharpPerfTestBase_TestFastFuncExport final
{
public:
	int32                                         P1;                                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P2;                                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         P3;                                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bP4;                                               // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(USharpPerfTestBase_TestFastFuncExport) == 0x000004, "Wrong alignment on USharpPerfTestBase_TestFastFuncExport");
static_assert(sizeof(USharpPerfTestBase_TestFastFuncExport) == 0x000014, "Wrong size on USharpPerfTestBase_TestFastFuncExport");
static_assert(offsetof(USharpPerfTestBase_TestFastFuncExport, P1) == 0x000000, "Member 'USharpPerfTestBase_TestFastFuncExport::P1' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_TestFastFuncExport, P2) == 0x000004, "Member 'USharpPerfTestBase_TestFastFuncExport::P2' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_TestFastFuncExport, P3) == 0x000008, "Member 'USharpPerfTestBase_TestFastFuncExport::P3' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_TestFastFuncExport, bP4) == 0x00000C, "Member 'USharpPerfTestBase_TestFastFuncExport::bP4' has a wrong offset!");
static_assert(offsetof(USharpPerfTestBase_TestFastFuncExport, ReturnValue) == 0x000010, "Member 'USharpPerfTestBase_TestFastFuncExport::ReturnValue' has a wrong offset!");

// Function b1.USharpPerfTestBase.TickInCS
// 0x0004 (0x0004 - 0x0000)
struct USharpPerfTestBase_TickInCS final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(USharpPerfTestBase_TickInCS) == 0x000004, "Wrong alignment on USharpPerfTestBase_TickInCS");
static_assert(sizeof(USharpPerfTestBase_TickInCS) == 0x000004, "Wrong size on USharpPerfTestBase_TickInCS");
static_assert(offsetof(USharpPerfTestBase_TickInCS, DeltaTime) == 0x000000, "Member 'USharpPerfTestBase_TickInCS::DeltaTime' has a wrong offset!");

// Function b1.X2DebugUtil.DisableAllScreenMessages
// 0x0008 (0x0008 - 0x0000)
struct X2DebugUtil_DisableAllScreenMessages final
{
public:
	class UObject*                                WorldCtx;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_DisableAllScreenMessages) == 0x000008, "Wrong alignment on X2DebugUtil_DisableAllScreenMessages");
static_assert(sizeof(X2DebugUtil_DisableAllScreenMessages) == 0x000008, "Wrong size on X2DebugUtil_DisableAllScreenMessages");
static_assert(offsetof(X2DebugUtil_DisableAllScreenMessages, WorldCtx) == 0x000000, "Member 'X2DebugUtil_DisableAllScreenMessages::WorldCtx' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawCircle
// 0x0078 (0x0078 - 0x0000)
struct X2DebugUtil_X2DrawCircle final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Base;                                              // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x0040(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0058(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x006C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawCircle) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawCircle");
static_assert(sizeof(X2DebugUtil_X2DrawCircle) == 0x000078, "Wrong size on X2DebugUtil_X2DrawCircle");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawCircle::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawCircle::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, Base) == 0x000010, "Member 'X2DebugUtil_X2DrawCircle::Base' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, X) == 0x000028, "Member 'X2DebugUtil_X2DrawCircle::X' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, Y) == 0x000040, "Member 'X2DebugUtil_X2DrawCircle::Y' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, Color) == 0x000058, "Member 'X2DebugUtil_X2DrawCircle::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, Radius) == 0x00005C, "Member 'X2DebugUtil_X2DrawCircle::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, NumSides) == 0x000060, "Member 'X2DebugUtil_X2DrawCircle::NumSides' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, bPersistentLines) == 0x000064, "Member 'X2DebugUtil_X2DrawCircle::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, LifeTime) == 0x000068, "Member 'X2DebugUtil_X2DrawCircle::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, DepthPriority) == 0x00006C, "Member 'X2DebugUtil_X2DrawCircle::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawCircle, Thickness) == 0x000070, "Member 'X2DebugUtil_X2DrawCircle::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebug2DDonut
// 0x00B0 (0x00B0 - 0x0000)
struct X2DebugUtil_X2DrawDebug2DDonut final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatrix                                TransformMatrix;                                   // 0x0010(0x0080)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x0094(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x009C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x00A0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x00A4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x00A8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x00AC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2DrawDebug2DDonut) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebug2DDonut");
static_assert(sizeof(X2DebugUtil_X2DrawDebug2DDonut) == 0x0000B0, "Wrong size on X2DebugUtil_X2DrawDebug2DDonut");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebug2DDonut::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebug2DDonut::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, TransformMatrix) == 0x000010, "Member 'X2DebugUtil_X2DrawDebug2DDonut::TransformMatrix' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, InnerRadius) == 0x000090, "Member 'X2DebugUtil_X2DrawDebug2DDonut::InnerRadius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, OuterRadius) == 0x000094, "Member 'X2DebugUtil_X2DrawDebug2DDonut::OuterRadius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, Segments) == 0x000098, "Member 'X2DebugUtil_X2DrawDebug2DDonut::Segments' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, Color) == 0x00009C, "Member 'X2DebugUtil_X2DrawDebug2DDonut::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, bPersistentLines) == 0x0000A0, "Member 'X2DebugUtil_X2DrawDebug2DDonut::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, LifeTime) == 0x0000A4, "Member 'X2DebugUtil_X2DrawDebug2DDonut::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, DepthPriority) == 0x0000A8, "Member 'X2DebugUtil_X2DrawDebug2DDonut::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebug2DDonut, Thickness) == 0x0000AC, "Member 'X2DebugUtil_X2DrawDebug2DDonut::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugAltCone
// 0x0060 (0x0060 - 0x0000)
struct X2DebugUtil_X2DrawDebugAltCone final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWidth;                                        // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHeight;                                       // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DrawColor;                                         // 0x004C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2DrawDebugAltCone) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugAltCone");
static_assert(sizeof(X2DebugUtil_X2DrawDebugAltCone) == 0x000060, "Wrong size on X2DebugUtil_X2DrawDebugAltCone");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugAltCone::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugAltCone::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, Origin) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugAltCone::Origin' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, Rotation) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugAltCone::Rotation' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, Length) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugAltCone::Length' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, AngleWidth) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugAltCone::AngleWidth' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, AngleHeight) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugAltCone::AngleHeight' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, DrawColor) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugAltCone::DrawColor' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, bPersistentLines) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugAltCone::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, LifeTime) == 0x000054, "Member 'X2DebugUtil_X2DrawDebugAltCone::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, DepthPriority) == 0x000058, "Member 'X2DebugUtil_X2DrawDebugAltCone::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugAltCone, Thickness) == 0x00005C, "Member 'X2DebugUtil_X2DrawDebugAltCone::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugBox
// 0x0058 (0x0058 - 0x0000)
struct X2DebugUtil_X2DrawDebugBox final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugBox) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugBox");
static_assert(sizeof(X2DebugUtil_X2DrawDebugBox) == 0x000058, "Wrong size on X2DebugUtil_X2DrawDebugBox");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugBox::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugBox::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, Center) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugBox::Center' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, Extent) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugBox::Extent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, Color) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugBox::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, bPersistentLines) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugBox::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, LifeTime) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugBox::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, DepthPriority) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugBox::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox, Thickness) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugBox::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugBox2
// 0x0080 (0x0080 - 0x0000)
struct X2DebugUtil_X2DrawDebugBox2 final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rotation;                                          // 0x0040(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0060(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x006C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugBox2) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugBox2");
static_assert(sizeof(X2DebugUtil_X2DrawDebugBox2) == 0x000080, "Wrong size on X2DebugUtil_X2DrawDebugBox2");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugBox2::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugBox2::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, Center) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugBox2::Center' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, Extent) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugBox2::Extent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, Rotation) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugBox2::Rotation' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, Color) == 0x000060, "Member 'X2DebugUtil_X2DrawDebugBox2::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, bPersistentLines) == 0x000064, "Member 'X2DebugUtil_X2DrawDebugBox2::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, LifeTime) == 0x000068, "Member 'X2DebugUtil_X2DrawDebugBox2::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, DepthPriority) == 0x00006C, "Member 'X2DebugUtil_X2DrawDebugBox2::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugBox2, Thickness) == 0x000070, "Member 'X2DebugUtil_X2DrawDebugBox2::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCamera
// 0x0058 (0x0058 - 0x0000)
struct X2DebugUtil_X2DrawDebugCamera final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOVDeg;                                            // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0048(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCamera) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCamera");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCamera) == 0x000058, "Wrong size on X2DebugUtil_X2DrawDebugCamera");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCamera::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCamera::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, Location) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCamera::Location' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, Rotation) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCamera::Rotation' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, FOVDeg) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCamera::FOVDeg' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, Scale) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugCamera::Scale' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, Color) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugCamera::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, bPersistentLines) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugCamera::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, LifeTime) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugCamera::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCamera, DepthPriority) == 0x000054, "Member 'X2DebugUtil_X2DrawDebugCamera::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCanvas2DBox
// 0x0050 (0x0050 - 0x0000)
struct X2DebugUtil_X2DrawDebugCanvas2DBox final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvas*                                Canvas;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 Box;                                               // 0x0010(0x0028)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0048(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCanvas2DBox) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCanvas2DBox");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCanvas2DBox) == 0x000050, "Wrong size on X2DebugUtil_X2DrawDebugCanvas2DBox");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DBox, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCanvas2DBox::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DBox, Canvas) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCanvas2DBox::Canvas' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DBox, Box) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCanvas2DBox::Box' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DBox, LineColor) == 0x000038, "Member 'X2DebugUtil_X2DrawDebugCanvas2DBox::LineColor' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DBox, LineThickness) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugCanvas2DBox::LineThickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCanvas2DCircle
// 0x0040 (0x0040 - 0x0000)
struct X2DebugUtil_X2DrawDebugCanvas2DCircle final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvas*                                Canvas;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Center;                                            // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0038(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCanvas2DCircle) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCanvas2DCircle");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCanvas2DCircle) == 0x000040, "Wrong size on X2DebugUtil_X2DrawDebugCanvas2DCircle");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DCircle, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCanvas2DCircle::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DCircle, Canvas) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCanvas2DCircle::Canvas' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DCircle, Center) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCanvas2DCircle::Center' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DCircle, Radius) == 0x000020, "Member 'X2DebugUtil_X2DrawDebugCanvas2DCircle::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DCircle, NumSides) == 0x000024, "Member 'X2DebugUtil_X2DrawDebugCanvas2DCircle::NumSides' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DCircle, LineColor) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCanvas2DCircle::LineColor' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DCircle, LineThickness) == 0x000038, "Member 'X2DebugUtil_X2DrawDebugCanvas2DCircle::LineThickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCanvas2DLine
// 0x0050 (0x0050 - 0x0000)
struct X2DebugUtil_X2DrawDebugCanvas2DLine final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvas*                                Canvas;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCanvas2DLine) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCanvas2DLine");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCanvas2DLine) == 0x000050, "Wrong size on X2DebugUtil_X2DrawDebugCanvas2DLine");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine, Canvas) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine::Canvas' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine, Start) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine::Start' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine, End) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine::End' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine, LineColor) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine::LineColor' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCanvas2DLine2
// 0x0048 (0x0048 - 0x0000)
struct X2DebugUtil_X2DrawDebugCanvas2DLine2 final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvas*                                Canvas;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartPosition;                                     // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EndPosition;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCanvas2DLine2) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCanvas2DLine2");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCanvas2DLine2) == 0x000048, "Wrong size on X2DebugUtil_X2DrawDebugCanvas2DLine2");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine2, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine2::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine2, Canvas) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine2::Canvas' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine2, StartPosition) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine2::StartPosition' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine2, EndPosition) == 0x000020, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine2::EndPosition' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine2, LineColor) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine2::LineColor' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvas2DLine2, LineThickness) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCanvas2DLine2::LineThickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCanvasCircle
// 0x0068 (0x0068 - 0x0000)
struct X2DebugUtil_X2DrawDebugCanvasCircle final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvas*                                Canvas;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Base;                                              // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x0040(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCanvasCircle) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCanvasCircle");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCanvasCircle) == 0x000068, "Wrong size on X2DebugUtil_X2DrawDebugCanvasCircle");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasCircle, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCanvasCircle::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasCircle, Canvas) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCanvasCircle::Canvas' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasCircle, Base) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCanvasCircle::Base' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasCircle, X) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCanvasCircle::X' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasCircle, Y) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCanvasCircle::Y' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasCircle, Color) == 0x000058, "Member 'X2DebugUtil_X2DrawDebugCanvasCircle::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasCircle, Radius) == 0x00005C, "Member 'X2DebugUtil_X2DrawDebugCanvasCircle::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasCircle, NumSides) == 0x000060, "Member 'X2DebugUtil_X2DrawDebugCanvasCircle::NumSides' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCanvasLine
// 0x0050 (0x0050 - 0x0000)
struct X2DebugUtil_X2DrawDebugCanvasLine final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvas*                                Canvas;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCanvasLine) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCanvasLine");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCanvasLine) == 0x000050, "Wrong size on X2DebugUtil_X2DrawDebugCanvasLine");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasLine, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCanvasLine::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasLine, Canvas) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCanvasLine::Canvas' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasLine, Start) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCanvasLine::Start' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasLine, End) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCanvasLine::End' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasLine, LineColor) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCanvasLine::LineColor' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCanvasWireCone
// 0x0080 (0x0080 - 0x0000)
struct X2DebugUtil_X2DrawDebugCanvasWireCone final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvas*                                Canvas;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConeRadius;                                        // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngle;                                         // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConeSides;                                         // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCanvasWireCone) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugCanvasWireCone");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCanvasWireCone) == 0x000080, "Wrong size on X2DebugUtil_X2DrawDebugCanvasWireCone");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireCone, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCanvasWireCone::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireCone, Canvas) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCanvasWireCone::Canvas' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireCone, Transform) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCanvasWireCone::Transform' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireCone, ConeRadius) == 0x000070, "Member 'X2DebugUtil_X2DrawDebugCanvasWireCone::ConeRadius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireCone, ConeAngle) == 0x000074, "Member 'X2DebugUtil_X2DrawDebugCanvasWireCone::ConeAngle' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireCone, ConeSides) == 0x000078, "Member 'X2DebugUtil_X2DrawDebugCanvasWireCone::ConeSides' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireCone, Color) == 0x00007C, "Member 'X2DebugUtil_X2DrawDebugCanvasWireCone::Color' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCanvasWireSphere
// 0x0038 (0x0038 - 0x0000)
struct X2DebugUtil_X2DrawDebugCanvasWireSphere final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvas*                                Canvas;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Base;                                              // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCanvasWireSphere) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCanvasWireSphere");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCanvasWireSphere) == 0x000038, "Wrong size on X2DebugUtil_X2DrawDebugCanvasWireSphere");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireSphere, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCanvasWireSphere::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireSphere, Canvas) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCanvasWireSphere::Canvas' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireSphere, Base) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCanvasWireSphere::Base' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireSphere, Color) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCanvasWireSphere::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireSphere, Radius) == 0x00002C, "Member 'X2DebugUtil_X2DrawDebugCanvasWireSphere::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCanvasWireSphere, NumSides) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugCanvasWireSphere::NumSides' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCapsule
// 0x0070 (0x0070 - 0x0000)
struct X2DebugUtil_X2DrawDebugCapsule final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rotation;                                          // 0x0030(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCapsule) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugCapsule");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCapsule) == 0x000070, "Wrong size on X2DebugUtil_X2DrawDebugCapsule");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCapsule::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCapsule::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, Center) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCapsule::Center' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, HalfHeight) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, Radius) == 0x00002C, "Member 'X2DebugUtil_X2DrawDebugCapsule::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, Rotation) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugCapsule::Rotation' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, Color) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugCapsule::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, bPersistentLines) == 0x000054, "Member 'X2DebugUtil_X2DrawDebugCapsule::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, LifeTime) == 0x000058, "Member 'X2DebugUtil_X2DrawDebugCapsule::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, DepthPriority) == 0x00005C, "Member 'X2DebugUtil_X2DrawDebugCapsule::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCapsule, Thickness) == 0x000060, "Member 'X2DebugUtil_X2DrawDebugCapsule::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCircle
// 0x00B0 (0x00B0 - 0x0000)
struct X2DebugUtil_X2DrawDebugCircle final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatrix                                TransformMatrix;                                   // 0x0010(0x0080)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0094(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0098(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x009C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x00A0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x00A4(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x00A8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAxis;                                         // 0x00AC(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCircle) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugCircle");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCircle) == 0x0000B0, "Wrong size on X2DebugUtil_X2DrawDebugCircle");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCircle::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCircle::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, TransformMatrix) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCircle::TransformMatrix' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, Radius) == 0x000090, "Member 'X2DebugUtil_X2DrawDebugCircle::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, Segments) == 0x000094, "Member 'X2DebugUtil_X2DrawDebugCircle::Segments' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, Color) == 0x000098, "Member 'X2DebugUtil_X2DrawDebugCircle::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, bPersistentLines) == 0x00009C, "Member 'X2DebugUtil_X2DrawDebugCircle::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, LifeTime) == 0x0000A0, "Member 'X2DebugUtil_X2DrawDebugCircle::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, DepthPriority) == 0x0000A4, "Member 'X2DebugUtil_X2DrawDebugCircle::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, Thickness) == 0x0000A8, "Member 'X2DebugUtil_X2DrawDebugCircle::Thickness' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle, bDrawAxis) == 0x0000AC, "Member 'X2DebugUtil_X2DrawDebugCircle::bDrawAxis' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCircle2
// 0x0080 (0x0080 - 0x0000)
struct X2DebugUtil_X2DrawDebugCircle2 final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0030(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                YAxis;                                             // 0x0048(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZAxis;                                             // 0x0060(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAxis;                                         // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCircle2) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCircle2");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCircle2) == 0x000080, "Wrong size on X2DebugUtil_X2DrawDebugCircle2");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCircle2::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCircle2::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, Center) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCircle2::Center' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, Radius) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCircle2::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, Segments) == 0x00002C, "Member 'X2DebugUtil_X2DrawDebugCircle2::Segments' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, Color) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugCircle2::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, bPersistentLines) == 0x000034, "Member 'X2DebugUtil_X2DrawDebugCircle2::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, LifeTime) == 0x000038, "Member 'X2DebugUtil_X2DrawDebugCircle2::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, DepthPriority) == 0x00003C, "Member 'X2DebugUtil_X2DrawDebugCircle2::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, Thickness) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCircle2::Thickness' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, YAxis) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugCircle2::YAxis' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, ZAxis) == 0x000060, "Member 'X2DebugUtil_X2DrawDebugCircle2::ZAxis' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCircle2, bDrawAxis) == 0x000078, "Member 'X2DebugUtil_X2DrawDebugCircle2::bDrawAxis' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCone
// 0x0068 (0x0068 - 0x0000)
struct X2DebugUtil_X2DrawDebugCone final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWidth;                                        // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHeight;                                       // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCone) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCone");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCone) == 0x000068, "Wrong size on X2DebugUtil_X2DrawDebugCone");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCone::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCone::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, Origin) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCone::Origin' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, Direction) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCone::Direction' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, Length) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCone::Length' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, AngleWidth) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugCone::AngleWidth' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, AngleHeight) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugCone::AngleHeight' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, NumSides) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugCone::NumSides' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, Color) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugCone::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, bPersistentLines) == 0x000054, "Member 'X2DebugUtil_X2DrawDebugCone::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, LifeTime) == 0x000058, "Member 'X2DebugUtil_X2DrawDebugCone::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, DepthPriority) == 0x00005C, "Member 'X2DebugUtil_X2DrawDebugCone::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCone, Thickness) == 0x000060, "Member 'X2DebugUtil_X2DrawDebugCone::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCoordinateSystem
// 0x0058 (0x0058 - 0x0000)
struct X2DebugUtil_X2DrawDebugCoordinateSystem final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisLoc;                                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AxisRot;                                           // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCoordinateSystem) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCoordinateSystem");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCoordinateSystem) == 0x000058, "Wrong size on X2DebugUtil_X2DrawDebugCoordinateSystem");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, AxisLoc) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::AxisLoc' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, AxisRot) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::AxisRot' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, Scale) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::Scale' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, bPersistentLines) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, LifeTime) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, DepthPriority) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCoordinateSystem, Thickness) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugCoordinateSystem::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCrosshairs
// 0x0058 (0x0058 - 0x0000)
struct X2DebugUtil_X2DrawDebugCrosshairs final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisLoc;                                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AxisRot;                                           // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0044(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCrosshairs) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCrosshairs");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCrosshairs) == 0x000058, "Wrong size on X2DebugUtil_X2DrawDebugCrosshairs");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, AxisLoc) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::AxisLoc' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, AxisRot) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::AxisRot' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, Scale) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::Scale' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, Color) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, bPersistentLines) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, LifeTime) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCrosshairs, DepthPriority) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugCrosshairs::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugCylinder
// 0x0060 (0x0060 - 0x0000)
struct X2DebugUtil_X2DrawDebugCylinder final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0048(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugCylinder) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugCylinder");
static_assert(sizeof(X2DebugUtil_X2DrawDebugCylinder) == 0x000060, "Wrong size on X2DebugUtil_X2DrawDebugCylinder");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugCylinder::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugCylinder::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, Start) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugCylinder::Start' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, End) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugCylinder::End' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, Radius) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugCylinder::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, Segments) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugCylinder::Segments' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, Color) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugCylinder::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, bPersistentLines) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugCylinder::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, LifeTime) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugCylinder::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, DepthPriority) == 0x000054, "Member 'X2DebugUtil_X2DrawDebugCylinder::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugCylinder, Thickness) == 0x000058, "Member 'X2DebugUtil_X2DrawDebugCylinder::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugDirectionalArrow
// 0x0058 (0x0058 - 0x0000)
struct X2DebugUtil_X2DrawDebugDirectionalArrow final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowSize;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0044(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2DrawDebugDirectionalArrow) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugDirectionalArrow");
static_assert(sizeof(X2DebugUtil_X2DrawDebugDirectionalArrow) == 0x000058, "Wrong size on X2DebugUtil_X2DrawDebugDirectionalArrow");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, LineStart) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::LineStart' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, LineEnd) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::LineEnd' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, ArrowSize) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::ArrowSize' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, Color) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, bPersistentLines) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, LifeTime) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, DepthPriority) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugDirectionalArrow, Thickness) == 0x000054, "Member 'X2DebugUtil_X2DrawDebugDirectionalArrow::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugFrustum
// 0x00B0 (0x00B0 - 0x0000)
struct X2DebugUtil_X2DrawDebugFrustum final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatrix                                FrustumToWorld;                                    // 0x0010(0x0080)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0090(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x009C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x00A0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugFrustum) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugFrustum");
static_assert(sizeof(X2DebugUtil_X2DrawDebugFrustum) == 0x0000B0, "Wrong size on X2DebugUtil_X2DrawDebugFrustum");
static_assert(offsetof(X2DebugUtil_X2DrawDebugFrustum, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugFrustum::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugFrustum, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugFrustum::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugFrustum, FrustumToWorld) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugFrustum::FrustumToWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugFrustum, Color) == 0x000090, "Member 'X2DebugUtil_X2DrawDebugFrustum::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugFrustum, bPersistentLines) == 0x000094, "Member 'X2DebugUtil_X2DrawDebugFrustum::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugFrustum, LifeTime) == 0x000098, "Member 'X2DebugUtil_X2DrawDebugFrustum::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugFrustum, DepthPriority) == 0x00009C, "Member 'X2DebugUtil_X2DrawDebugFrustum::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugFrustum, Thickness) == 0x0000A0, "Member 'X2DebugUtil_X2DrawDebugFrustum::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugLine
// 0x0058 (0x0058 - 0x0000)
struct X2DebugUtil_X2DrawDebugLine final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugLine) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugLine");
static_assert(sizeof(X2DebugUtil_X2DrawDebugLine) == 0x000058, "Wrong size on X2DebugUtil_X2DrawDebugLine");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugLine::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugLine::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, LineStart) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugLine::LineStart' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, LineEnd) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugLine::LineEnd' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, Color) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugLine::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, bPersistentLines) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugLine::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, LifeTime) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugLine::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, DepthPriority) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugLine::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugLine, Thickness) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugLine::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugMesh
// 0x0040 (0x0040 - 0x0000)
struct X2DebugUtil_X2DrawDebugMesh final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Verts;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 Indices;                                           // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0030(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugMesh) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugMesh");
static_assert(sizeof(X2DebugUtil_X2DrawDebugMesh) == 0x000040, "Wrong size on X2DebugUtil_X2DrawDebugMesh");
static_assert(offsetof(X2DebugUtil_X2DrawDebugMesh, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugMesh::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugMesh, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugMesh::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugMesh, Verts) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugMesh::Verts' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugMesh, Indices) == 0x000020, "Member 'X2DebugUtil_X2DrawDebugMesh::Indices' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugMesh, Color) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugMesh::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugMesh, bPersistent) == 0x000034, "Member 'X2DebugUtil_X2DrawDebugMesh::bPersistent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugMesh, LifeTime) == 0x000038, "Member 'X2DebugUtil_X2DrawDebugMesh::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugMesh, DepthPriority) == 0x00003C, "Member 'X2DebugUtil_X2DrawDebugMesh::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugPoint
// 0x0040 (0x0040 - 0x0000)
struct X2DebugUtil_X2DrawDebugPoint final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 PointColor;                                        // 0x002C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugPoint) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugPoint");
static_assert(sizeof(X2DebugUtil_X2DrawDebugPoint) == 0x000040, "Wrong size on X2DebugUtil_X2DrawDebugPoint");
static_assert(offsetof(X2DebugUtil_X2DrawDebugPoint, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugPoint::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugPoint, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugPoint::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugPoint, Position) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugPoint::Position' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugPoint, Size) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugPoint::Size' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugPoint, PointColor) == 0x00002C, "Member 'X2DebugUtil_X2DrawDebugPoint::PointColor' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugPoint, bPersistentLines) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugPoint::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugPoint, LifeTime) == 0x000034, "Member 'X2DebugUtil_X2DrawDebugPoint::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugPoint, DepthPriority) == 0x000038, "Member 'X2DebugUtil_X2DrawDebugPoint::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugSolidBox
// 0x00C0 (0x00C0 - 0x0000)
struct X2DebugUtil_X2DrawDebugSolidBox final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0010(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0048(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0050(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x00B0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x00B4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x00B8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugSolidBox) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugSolidBox");
static_assert(sizeof(X2DebugUtil_X2DrawDebugSolidBox) == 0x0000C0, "Wrong size on X2DebugUtil_X2DrawDebugSolidBox");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugSolidBox::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugSolidBox::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox, Box) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugSolidBox::Box' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox, Color) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugSolidBox::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox, Transform) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugSolidBox::Transform' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox, bPersistent) == 0x0000B0, "Member 'X2DebugUtil_X2DrawDebugSolidBox::bPersistent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox, LifeTime) == 0x0000B4, "Member 'X2DebugUtil_X2DrawDebugSolidBox::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox, DepthPriority) == 0x0000B8, "Member 'X2DebugUtil_X2DrawDebugSolidBox::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugSolidBox2
// 0x0050 (0x0050 - 0x0000)
struct X2DebugUtil_X2DrawDebugSolidBox2 final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugSolidBox2) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugSolidBox2");
static_assert(sizeof(X2DebugUtil_X2DrawDebugSolidBox2) == 0x000050, "Wrong size on X2DebugUtil_X2DrawDebugSolidBox2");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox2, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugSolidBox2::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox2, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugSolidBox2::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox2, Center) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugSolidBox2::Center' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox2, Extent) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugSolidBox2::Extent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox2, Color) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugSolidBox2::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox2, bPersistent) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugSolidBox2::bPersistent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox2, LifeTime) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugSolidBox2::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox2, DepthPriority) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugSolidBox2::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugSolidBox3
// 0x0070 (0x0070 - 0x0000)
struct X2DebugUtil_X2DrawDebugSolidBox3 final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0028(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rotation;                                          // 0x0040(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0060(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x006C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugSolidBox3) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugSolidBox3");
static_assert(sizeof(X2DebugUtil_X2DrawDebugSolidBox3) == 0x000070, "Wrong size on X2DebugUtil_X2DrawDebugSolidBox3");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, Center) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::Center' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, Extent) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::Extent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, Rotation) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::Rotation' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, Color) == 0x000060, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, bPersistent) == 0x000064, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::bPersistent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, LifeTime) == 0x000068, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidBox3, DepthPriority) == 0x00006C, "Member 'X2DebugUtil_X2DrawDebugSolidBox3::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugSolidPlane
// 0x0060 (0x0060 - 0x0000)
struct X2DebugUtil_X2DrawDebugSolidPlane final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 P;                                                 // 0x0010(0x0020)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Loc;                                               // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x004C(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugSolidPlane) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugSolidPlane");
static_assert(sizeof(X2DebugUtil_X2DrawDebugSolidPlane) == 0x000060, "Wrong size on X2DebugUtil_X2DrawDebugSolidPlane");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, P) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::P' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, Loc) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::Loc' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, Size) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::Size' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, Color) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, bPersistent) == 0x000050, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::bPersistent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, LifeTime) == 0x000054, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane, DepthPriority) == 0x000058, "Member 'X2DebugUtil_X2DrawDebugSolidPlane::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugSolidPlane2
// 0x0070 (0x0070 - 0x0000)
struct X2DebugUtil_X2DrawDebugSolidPlane2 final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 P;                                                 // 0x0010(0x0020)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Loc;                                               // 0x0030(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Extents;                                           // 0x0048(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0058(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistent;                                       // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0xB];                                       // 0x0065(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugSolidPlane2) == 0x000010, "Wrong alignment on X2DebugUtil_X2DrawDebugSolidPlane2");
static_assert(sizeof(X2DebugUtil_X2DrawDebugSolidPlane2) == 0x000070, "Wrong size on X2DebugUtil_X2DrawDebugSolidPlane2");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, P) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::P' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, Loc) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::Loc' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, Extents) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::Extents' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, Color) == 0x000058, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, bPersistent) == 0x00005C, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::bPersistent' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, LifeTime) == 0x000060, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSolidPlane2, DepthPriority) == 0x000064, "Member 'X2DebugUtil_X2DrawDebugSolidPlane2::DepthPriority' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugSphere
// 0x0048 (0x0048 - 0x0000)
struct X2DebugUtil_X2DrawDebugSphere final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0030(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentLines;                                  // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DepthPriority;                                     // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Thickness;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(X2DebugUtil_X2DrawDebugSphere) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugSphere");
static_assert(sizeof(X2DebugUtil_X2DrawDebugSphere) == 0x000048, "Wrong size on X2DebugUtil_X2DrawDebugSphere");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugSphere::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugSphere::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, Center) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugSphere::Center' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, Radius) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugSphere::Radius' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, Segments) == 0x00002C, "Member 'X2DebugUtil_X2DrawDebugSphere::Segments' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, Color) == 0x000030, "Member 'X2DebugUtil_X2DrawDebugSphere::Color' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, bPersistentLines) == 0x000034, "Member 'X2DebugUtil_X2DrawDebugSphere::bPersistentLines' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, LifeTime) == 0x000038, "Member 'X2DebugUtil_X2DrawDebugSphere::LifeTime' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, DepthPriority) == 0x00003C, "Member 'X2DebugUtil_X2DrawDebugSphere::DepthPriority' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugSphere, Thickness) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugSphere::Thickness' has a wrong offset!");

// Function b1.X2DebugUtil.X2DrawDebugString
// 0x0050 (0x0050 - 0x0000)
struct X2DebugUtil_X2DrawDebugString final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TextLocation;                                      // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TestBaseActor;                                     // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColor;                                         // 0x0040(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawShadow;                                       // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FontScale;                                         // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2DrawDebugString) == 0x000008, "Wrong alignment on X2DebugUtil_X2DrawDebugString");
static_assert(sizeof(X2DebugUtil_X2DrawDebugString) == 0x000050, "Wrong size on X2DebugUtil_X2DrawDebugString");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2DrawDebugString::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, InWorld) == 0x000008, "Member 'X2DebugUtil_X2DrawDebugString::InWorld' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, TextLocation) == 0x000010, "Member 'X2DebugUtil_X2DrawDebugString::TextLocation' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, Text) == 0x000028, "Member 'X2DebugUtil_X2DrawDebugString::Text' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, TestBaseActor) == 0x000038, "Member 'X2DebugUtil_X2DrawDebugString::TestBaseActor' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, TextColor) == 0x000040, "Member 'X2DebugUtil_X2DrawDebugString::TextColor' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, Duration) == 0x000044, "Member 'X2DebugUtil_X2DrawDebugString::Duration' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, bDrawShadow) == 0x000048, "Member 'X2DebugUtil_X2DrawDebugString::bDrawShadow' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2DrawDebugString, FontScale) == 0x00004C, "Member 'X2DebugUtil_X2DrawDebugString::FontScale' has a wrong offset!");

// Function b1.X2DebugUtil.X2FlushDebugStrings
// 0x0010 (0x0010 - 0x0000)
struct X2DebugUtil_X2FlushDebugStrings final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2FlushDebugStrings) == 0x000008, "Wrong alignment on X2DebugUtil_X2FlushDebugStrings");
static_assert(sizeof(X2DebugUtil_X2FlushDebugStrings) == 0x000010, "Wrong size on X2DebugUtil_X2FlushDebugStrings");
static_assert(offsetof(X2DebugUtil_X2FlushDebugStrings, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2FlushDebugStrings::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2FlushDebugStrings, InWorld) == 0x000008, "Member 'X2DebugUtil_X2FlushDebugStrings::InWorld' has a wrong offset!");

// Function b1.X2DebugUtil.X2FlushPersistentDebugLines
// 0x0010 (0x0010 - 0x0000)
struct X2DebugUtil_X2FlushPersistentDebugLines final
{
public:
	bool                                          DebugTag;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UWorld*                           InWorld;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(X2DebugUtil_X2FlushPersistentDebugLines) == 0x000008, "Wrong alignment on X2DebugUtil_X2FlushPersistentDebugLines");
static_assert(sizeof(X2DebugUtil_X2FlushPersistentDebugLines) == 0x000010, "Wrong size on X2DebugUtil_X2FlushPersistentDebugLines");
static_assert(offsetof(X2DebugUtil_X2FlushPersistentDebugLines, DebugTag) == 0x000000, "Member 'X2DebugUtil_X2FlushPersistentDebugLines::DebugTag' has a wrong offset!");
static_assert(offsetof(X2DebugUtil_X2FlushPersistentDebugLines, InWorld) == 0x000008, "Member 'X2DebugUtil_X2FlushPersistentDebugLines::InWorld' has a wrong offset!");

}

