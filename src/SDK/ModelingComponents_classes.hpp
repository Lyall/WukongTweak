#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ModelingComponents

#include "Basic.hpp"

#include "InteractiveToolsFramework_classes.hpp"
#include "Engine_classes.hpp"
#include "ModelingComponents_structs.hpp"
#include "GeometryFramework_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// Class ModelingComponents.OnAcceptHandleSourcesPropertiesBase
// 0x0000 (0x00A8 - 0x00A8)
class UOnAcceptHandleSourcesPropertiesBase : public UInteractiveToolPropertySet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnAcceptHandleSourcesPropertiesBase">();
	}
	static class UOnAcceptHandleSourcesPropertiesBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnAcceptHandleSourcesPropertiesBase>();
	}
};
static_assert(alignof(UOnAcceptHandleSourcesPropertiesBase) == 0x000008, "Wrong alignment on UOnAcceptHandleSourcesPropertiesBase");
static_assert(sizeof(UOnAcceptHandleSourcesPropertiesBase) == 0x0000A8, "Wrong size on UOnAcceptHandleSourcesPropertiesBase");

// Class ModelingComponents.OnAcceptHandleSourcesPropertiesSingle
// 0x0008 (0x00B0 - 0x00A8)
class UOnAcceptHandleSourcesPropertiesSingle final : public UOnAcceptHandleSourcesPropertiesBase
{
public:
	EHandleSourcesMethod                          HandleInputs;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnAcceptHandleSourcesPropertiesSingle">();
	}
	static class UOnAcceptHandleSourcesPropertiesSingle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnAcceptHandleSourcesPropertiesSingle>();
	}
};
static_assert(alignof(UOnAcceptHandleSourcesPropertiesSingle) == 0x000008, "Wrong alignment on UOnAcceptHandleSourcesPropertiesSingle");
static_assert(sizeof(UOnAcceptHandleSourcesPropertiesSingle) == 0x0000B0, "Wrong size on UOnAcceptHandleSourcesPropertiesSingle");
static_assert(offsetof(UOnAcceptHandleSourcesPropertiesSingle, HandleInputs) == 0x0000A8, "Member 'UOnAcceptHandleSourcesPropertiesSingle::HandleInputs' has a wrong offset!");

// Class ModelingComponents.MultiSelectionMeshEditingToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UMultiSelectionMeshEditingToolBuilder : public UInteractiveToolWithToolTargetsBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiSelectionMeshEditingToolBuilder">();
	}
	static class UMultiSelectionMeshEditingToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiSelectionMeshEditingToolBuilder>();
	}
};
static_assert(alignof(UMultiSelectionMeshEditingToolBuilder) == 0x000008, "Wrong alignment on UMultiSelectionMeshEditingToolBuilder");
static_assert(sizeof(UMultiSelectionMeshEditingToolBuilder) == 0x000028, "Wrong size on UMultiSelectionMeshEditingToolBuilder");

// Class ModelingComponents.BaseMeshProcessingTool
// 0x0358 (0x0400 - 0x00A8)
class alignas(0x10) UBaseMeshProcessingTool : public USingleSelectionTool
{
public:
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x330];                                     // 0x00D0(0x0330)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMeshProcessingTool">();
	}
	static class UBaseMeshProcessingTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseMeshProcessingTool>();
	}
};
static_assert(alignof(UBaseMeshProcessingTool) == 0x000010, "Wrong alignment on UBaseMeshProcessingTool");
static_assert(sizeof(UBaseMeshProcessingTool) == 0x000400, "Wrong size on UBaseMeshProcessingTool");
static_assert(offsetof(UBaseMeshProcessingTool, Preview) == 0x0000C8, "Member 'UBaseMeshProcessingTool::Preview' has a wrong offset!");

// Class ModelingComponents.MultiTransformer
// 0x0188 (0x01B0 - 0x0028)
class alignas(0x10) UMultiTransformer final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractiveGizmoManager*               GizmoManager;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x70];                                      // 0x0090(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UCombinedTransformGizmo*                TransformGizmo;                                    // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTransformProxy*                        TransformProxy;                                    // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragAlignmentMechanic*                 DragAlignmentMechanic;                             // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x98];                                     // 0x0118(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiTransformer">();
	}
	static class UMultiTransformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiTransformer>();
	}
};
static_assert(alignof(UMultiTransformer) == 0x000010, "Wrong alignment on UMultiTransformer");
static_assert(sizeof(UMultiTransformer) == 0x0001B0, "Wrong size on UMultiTransformer");
static_assert(offsetof(UMultiTransformer, GizmoManager) == 0x000088, "Member 'UMultiTransformer::GizmoManager' has a wrong offset!");
static_assert(offsetof(UMultiTransformer, TransformGizmo) == 0x000100, "Member 'UMultiTransformer::TransformGizmo' has a wrong offset!");
static_assert(offsetof(UMultiTransformer, TransformProxy) == 0x000108, "Member 'UMultiTransformer::TransformProxy' has a wrong offset!");
static_assert(offsetof(UMultiTransformer, DragAlignmentMechanic) == 0x000110, "Member 'UMultiTransformer::DragAlignmentMechanic' has a wrong offset!");

// Class ModelingComponents.WeightMapSetProperties
// 0x0020 (0x00C8 - 0x00A8)
class UWeightMapSetProperties : public UInteractiveToolPropertySet
{
public:
	class FName                                   WeightMap;                                         // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         WeightMapsList;                                    // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInvertWeightMap;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetWeightMapsFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightMapSetProperties">();
	}
	static class UWeightMapSetProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightMapSetProperties>();
	}
};
static_assert(alignof(UWeightMapSetProperties) == 0x000008, "Wrong alignment on UWeightMapSetProperties");
static_assert(sizeof(UWeightMapSetProperties) == 0x0000C8, "Wrong size on UWeightMapSetProperties");
static_assert(offsetof(UWeightMapSetProperties, WeightMap) == 0x0000A8, "Member 'UWeightMapSetProperties::WeightMap' has a wrong offset!");
static_assert(offsetof(UWeightMapSetProperties, WeightMapsList) == 0x0000B0, "Member 'UWeightMapSetProperties::WeightMapsList' has a wrong offset!");
static_assert(offsetof(UWeightMapSetProperties, bInvertWeightMap) == 0x0000C0, "Member 'UWeightMapSetProperties::bInvertWeightMap' has a wrong offset!");

// Class ModelingComponents.DynamicMeshReplacementChangeTarget
// 0x0030 (0x0058 - 0x0028)
class UDynamicMeshReplacementChangeTarget final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshReplacementChangeTarget">();
	}
	static class UDynamicMeshReplacementChangeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMeshReplacementChangeTarget>();
	}
};
static_assert(alignof(UDynamicMeshReplacementChangeTarget) == 0x000008, "Wrong alignment on UDynamicMeshReplacementChangeTarget");
static_assert(sizeof(UDynamicMeshReplacementChangeTarget) == 0x000058, "Wrong size on UDynamicMeshReplacementChangeTarget");

// Class ModelingComponents.MultiSelectionMeshEditingTool
// 0x0008 (0x00B8 - 0x00B0)
class UMultiSelectionMeshEditingTool : public UMultiSelectionTool
{
public:
	TWeakObjectPtr<class UWorld>                  TargetWorld;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiSelectionMeshEditingTool">();
	}
	static class UMultiSelectionMeshEditingTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiSelectionMeshEditingTool>();
	}
};
static_assert(alignof(UMultiSelectionMeshEditingTool) == 0x000008, "Wrong alignment on UMultiSelectionMeshEditingTool");
static_assert(sizeof(UMultiSelectionMeshEditingTool) == 0x0000B8, "Wrong size on UMultiSelectionMeshEditingTool");
static_assert(offsetof(UMultiSelectionMeshEditingTool, TargetWorld) == 0x0000B0, "Member 'UMultiSelectionMeshEditingTool::TargetWorld' has a wrong offset!");

// Class ModelingComponents.TransformInputsToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class UTransformInputsToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bShowTransformGizmo;                               // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformInputsToolProperties">();
	}
	static class UTransformInputsToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformInputsToolProperties>();
	}
};
static_assert(alignof(UTransformInputsToolProperties) == 0x000008, "Wrong alignment on UTransformInputsToolProperties");
static_assert(sizeof(UTransformInputsToolProperties) == 0x0000B0, "Wrong size on UTransformInputsToolProperties");
static_assert(offsetof(UTransformInputsToolProperties, bShowTransformGizmo) == 0x0000A8, "Member 'UTransformInputsToolProperties::bShowTransformGizmo' has a wrong offset!");

// Class ModelingComponents.SingleSelectionMeshEditingToolBuilder
// 0x0000 (0x0028 - 0x0028)
class USingleSelectionMeshEditingToolBuilder : public UInteractiveToolWithToolTargetsBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleSelectionMeshEditingToolBuilder">();
	}
	static class USingleSelectionMeshEditingToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleSelectionMeshEditingToolBuilder>();
	}
};
static_assert(alignof(USingleSelectionMeshEditingToolBuilder) == 0x000008, "Wrong alignment on USingleSelectionMeshEditingToolBuilder");
static_assert(sizeof(USingleSelectionMeshEditingToolBuilder) == 0x000028, "Wrong size on USingleSelectionMeshEditingToolBuilder");

// Class ModelingComponents.MeshSurfacePointMeshEditingToolBuilder
// 0x0000 (0x0030 - 0x0030)
class UMeshSurfacePointMeshEditingToolBuilder : public UMeshSurfacePointToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSurfacePointMeshEditingToolBuilder">();
	}
	static class UMeshSurfacePointMeshEditingToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSurfacePointMeshEditingToolBuilder>();
	}
};
static_assert(alignof(UMeshSurfacePointMeshEditingToolBuilder) == 0x000008, "Wrong alignment on UMeshSurfacePointMeshEditingToolBuilder");
static_assert(sizeof(UMeshSurfacePointMeshEditingToolBuilder) == 0x000030, "Wrong size on UMeshSurfacePointMeshEditingToolBuilder");

// Class ModelingComponents.SingleSelectionMeshEditingTool
// 0x0010 (0x00B8 - 0x00A8)
class USingleSelectionMeshEditingTool : public USingleSelectionTool
{
public:
	TWeakObjectPtr<class UWorld>                  TargetWorld;                                       // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersistentMeshSelection*               InputSelection;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleSelectionMeshEditingTool">();
	}
	static class USingleSelectionMeshEditingTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleSelectionMeshEditingTool>();
	}
};
static_assert(alignof(USingleSelectionMeshEditingTool) == 0x000008, "Wrong alignment on USingleSelectionMeshEditingTool");
static_assert(sizeof(USingleSelectionMeshEditingTool) == 0x0000B8, "Wrong size on USingleSelectionMeshEditingTool");
static_assert(offsetof(USingleSelectionMeshEditingTool, TargetWorld) == 0x0000A8, "Member 'USingleSelectionMeshEditingTool::TargetWorld' has a wrong offset!");
static_assert(offsetof(USingleSelectionMeshEditingTool, InputSelection) == 0x0000B0, "Member 'USingleSelectionMeshEditingTool::InputSelection' has a wrong offset!");

// Class ModelingComponents.PersistentMeshSelectionManager
// 0x0018 (0x0040 - 0x0028)
class UPersistentMeshSelectionManager final : public UObject
{
public:
	class UInteractiveToolsContext*               ParentContext;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersistentMeshSelection*               ActiveSelection;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewGeometry*                       SelectionDisplay;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistentMeshSelectionManager">();
	}
	static class UPersistentMeshSelectionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersistentMeshSelectionManager>();
	}
};
static_assert(alignof(UPersistentMeshSelectionManager) == 0x000008, "Wrong alignment on UPersistentMeshSelectionManager");
static_assert(sizeof(UPersistentMeshSelectionManager) == 0x000040, "Wrong size on UPersistentMeshSelectionManager");
static_assert(offsetof(UPersistentMeshSelectionManager, ParentContext) == 0x000028, "Member 'UPersistentMeshSelectionManager::ParentContext' has a wrong offset!");
static_assert(offsetof(UPersistentMeshSelectionManager, ActiveSelection) == 0x000030, "Member 'UPersistentMeshSelectionManager::ActiveSelection' has a wrong offset!");
static_assert(offsetof(UPersistentMeshSelectionManager, SelectionDisplay) == 0x000038, "Member 'UPersistentMeshSelectionManager::SelectionDisplay' has a wrong offset!");

// Class ModelingComponents.BaseMeshProcessingToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UBaseMeshProcessingToolBuilder : public UInteractiveToolWithToolTargetsBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMeshProcessingToolBuilder">();
	}
	static class UBaseMeshProcessingToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseMeshProcessingToolBuilder>();
	}
};
static_assert(alignof(UBaseMeshProcessingToolBuilder) == 0x000008, "Wrong alignment on UBaseMeshProcessingToolBuilder");
static_assert(sizeof(UBaseMeshProcessingToolBuilder) == 0x000028, "Wrong size on UBaseMeshProcessingToolBuilder");

// Class ModelingComponents.SpatialCurveDistanceMechanic
// 0x03E0 (0x0410 - 0x0030)
class USpatialCurveDistanceMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x3E0];                                     // 0x0030(0x03E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpatialCurveDistanceMechanic">();
	}
	static class USpatialCurveDistanceMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpatialCurveDistanceMechanic>();
	}
};
static_assert(alignof(USpatialCurveDistanceMechanic) == 0x000008, "Wrong alignment on USpatialCurveDistanceMechanic");
static_assert(sizeof(USpatialCurveDistanceMechanic) == 0x000410, "Wrong size on USpatialCurveDistanceMechanic");

// Class ModelingComponents.BaseCreateFromSelectedTool
// 0x0048 (0x0100 - 0x00B8)
class UBaseCreateFromSelectedTool : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformInputsToolProperties*         TransformProperties;                               // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseCreateFromSelectedHandleSourceProperties* HandleSourcesProperties;                           // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTransformProxy*>                TransformProxies;                                  // 0x00E0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UCombinedTransformGizmo*>        TransformGizmos;                                   // 0x00F0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCreateFromSelectedTool">();
	}
	static class UBaseCreateFromSelectedTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCreateFromSelectedTool>();
	}
};
static_assert(alignof(UBaseCreateFromSelectedTool) == 0x000008, "Wrong alignment on UBaseCreateFromSelectedTool");
static_assert(sizeof(UBaseCreateFromSelectedTool) == 0x000100, "Wrong size on UBaseCreateFromSelectedTool");
static_assert(offsetof(UBaseCreateFromSelectedTool, TransformProperties) == 0x0000C0, "Member 'UBaseCreateFromSelectedTool::TransformProperties' has a wrong offset!");
static_assert(offsetof(UBaseCreateFromSelectedTool, OutputTypeProperties) == 0x0000C8, "Member 'UBaseCreateFromSelectedTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(UBaseCreateFromSelectedTool, HandleSourcesProperties) == 0x0000D0, "Member 'UBaseCreateFromSelectedTool::HandleSourcesProperties' has a wrong offset!");
static_assert(offsetof(UBaseCreateFromSelectedTool, Preview) == 0x0000D8, "Member 'UBaseCreateFromSelectedTool::Preview' has a wrong offset!");
static_assert(offsetof(UBaseCreateFromSelectedTool, TransformProxies) == 0x0000E0, "Member 'UBaseCreateFromSelectedTool::TransformProxies' has a wrong offset!");
static_assert(offsetof(UBaseCreateFromSelectedTool, TransformGizmos) == 0x0000F0, "Member 'UBaseCreateFromSelectedTool::TransformGizmos' has a wrong offset!");

// Class ModelingComponents.BaseCreateFromSelectedToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UBaseCreateFromSelectedToolBuilder : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCreateFromSelectedToolBuilder">();
	}
	static class UBaseCreateFromSelectedToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCreateFromSelectedToolBuilder>();
	}
};
static_assert(alignof(UBaseCreateFromSelectedToolBuilder) == 0x000008, "Wrong alignment on UBaseCreateFromSelectedToolBuilder");
static_assert(sizeof(UBaseCreateFromSelectedToolBuilder) == 0x000028, "Wrong size on UBaseCreateFromSelectedToolBuilder");

// Class ModelingComponents.SpaceCurveDeformationMechanic
// 0x02A0 (0x02D0 - 0x0030)
class alignas(0x10) USpaceCurveDeformationMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USingleClickInputBehavior*              ClickBehavior;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMouseHoverBehavior*                    HoverBehavior;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USpaceCurveDeformationMechanicPropertySet* TransformProperties;                               // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0xF8];                                      // 0x0070(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class APreviewGeometryActor*                  PreviewGeometryActor;                              // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointSetComponent*                     RenderPoints;                                      // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULineSetComponent*                      RenderSegments;                                    // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x38];                                     // 0x0180(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformProxy*                        PointTransformProxy;                               // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCombinedTransformGizmo*                PointTransformGizmo;                               // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C8[0x108];                                    // 0x01C8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpaceCurveDeformationMechanic">();
	}
	static class USpaceCurveDeformationMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpaceCurveDeformationMechanic>();
	}
};
static_assert(alignof(USpaceCurveDeformationMechanic) == 0x000010, "Wrong alignment on USpaceCurveDeformationMechanic");
static_assert(sizeof(USpaceCurveDeformationMechanic) == 0x0002D0, "Wrong size on USpaceCurveDeformationMechanic");
static_assert(offsetof(USpaceCurveDeformationMechanic, ClickBehavior) == 0x000040, "Member 'USpaceCurveDeformationMechanic::ClickBehavior' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanic, HoverBehavior) == 0x000048, "Member 'USpaceCurveDeformationMechanic::HoverBehavior' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanic, TransformProperties) == 0x000068, "Member 'USpaceCurveDeformationMechanic::TransformProperties' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanic, PreviewGeometryActor) == 0x000168, "Member 'USpaceCurveDeformationMechanic::PreviewGeometryActor' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanic, RenderPoints) == 0x000170, "Member 'USpaceCurveDeformationMechanic::RenderPoints' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanic, RenderSegments) == 0x000178, "Member 'USpaceCurveDeformationMechanic::RenderSegments' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanic, PointTransformProxy) == 0x0001B8, "Member 'USpaceCurveDeformationMechanic::PointTransformProxy' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanic, PointTransformGizmo) == 0x0001C0, "Member 'USpaceCurveDeformationMechanic::PointTransformGizmo' has a wrong offset!");

// Class ModelingComponents.PersistentMeshSelection
// 0x0060 (0x0088 - 0x0028)
class UPersistentMeshSelection final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistentMeshSelection">();
	}
	static class UPersistentMeshSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersistentMeshSelection>();
	}
};
static_assert(alignof(UPersistentMeshSelection) == 0x000008, "Wrong alignment on UPersistentMeshSelection");
static_assert(sizeof(UPersistentMeshSelection) == 0x000088, "Wrong size on UPersistentMeshSelection");

// Class ModelingComponents.BaseVoxelTool
// 0x0018 (0x0118 - 0x0100)
class UBaseVoxelTool : public UBaseCreateFromSelectedTool
{
public:
	class UVoxelProperties*                       VoxProperties;                                     // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseVoxelTool">();
	}
	static class UBaseVoxelTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseVoxelTool>();
	}
};
static_assert(alignof(UBaseVoxelTool) == 0x000008, "Wrong alignment on UBaseVoxelTool");
static_assert(sizeof(UBaseVoxelTool) == 0x000118, "Wrong size on UBaseVoxelTool");
static_assert(offsetof(UBaseVoxelTool, VoxProperties) == 0x000100, "Member 'UBaseVoxelTool::VoxProperties' has a wrong offset!");

// Class ModelingComponents.InteractiveToolActivity
// 0x0000 (0x0030 - 0x0030)
class UInteractiveToolActivity : public UInteractionMechanic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveToolActivity">();
	}
	static class UInteractiveToolActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveToolActivity>();
	}
};
static_assert(alignof(UInteractiveToolActivity) == 0x000008, "Wrong alignment on UInteractiveToolActivity");
static_assert(sizeof(UInteractiveToolActivity) == 0x000030, "Wrong size on UInteractiveToolActivity");

// Class ModelingComponents.OnAcceptHandleSourcesProperties
// 0x0008 (0x00B0 - 0x00A8)
class UOnAcceptHandleSourcesProperties : public UOnAcceptHandleSourcesPropertiesBase
{
public:
	EHandleSourcesMethod                          HandleInputs;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnAcceptHandleSourcesProperties">();
	}
	static class UOnAcceptHandleSourcesProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnAcceptHandleSourcesProperties>();
	}
};
static_assert(alignof(UOnAcceptHandleSourcesProperties) == 0x000008, "Wrong alignment on UOnAcceptHandleSourcesProperties");
static_assert(sizeof(UOnAcceptHandleSourcesProperties) == 0x0000B0, "Wrong size on UOnAcceptHandleSourcesProperties");
static_assert(offsetof(UOnAcceptHandleSourcesProperties, HandleInputs) == 0x0000A8, "Member 'UOnAcceptHandleSourcesProperties::HandleInputs' has a wrong offset!");

// Class ModelingComponents.BaseCreateFromSelectedHandleSourceProperties
// 0x0028 (0x00D8 - 0x00B0)
class UBaseCreateFromSelectedHandleSourceProperties final : public UOnAcceptHandleSourcesProperties
{
public:
	EBaseCreateFromSelectedTargetType             OutputWriteTo;                                     // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutputNewName;                                     // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutputExistingName;                                // 0x00C8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCreateFromSelectedHandleSourceProperties">();
	}
	static class UBaseCreateFromSelectedHandleSourceProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCreateFromSelectedHandleSourceProperties>();
	}
};
static_assert(alignof(UBaseCreateFromSelectedHandleSourceProperties) == 0x000008, "Wrong alignment on UBaseCreateFromSelectedHandleSourceProperties");
static_assert(sizeof(UBaseCreateFromSelectedHandleSourceProperties) == 0x0000D8, "Wrong size on UBaseCreateFromSelectedHandleSourceProperties");
static_assert(offsetof(UBaseCreateFromSelectedHandleSourceProperties, OutputWriteTo) == 0x0000B0, "Member 'UBaseCreateFromSelectedHandleSourceProperties::OutputWriteTo' has a wrong offset!");
static_assert(offsetof(UBaseCreateFromSelectedHandleSourceProperties, OutputNewName) == 0x0000B8, "Member 'UBaseCreateFromSelectedHandleSourceProperties::OutputNewName' has a wrong offset!");
static_assert(offsetof(UBaseCreateFromSelectedHandleSourceProperties, OutputExistingName) == 0x0000C8, "Member 'UBaseCreateFromSelectedHandleSourceProperties::OutputExistingName' has a wrong offset!");

// Class ModelingComponents.CollectSurfacePathMechanic
// 0x0590 (0x05C0 - 0x0030)
class UCollectSurfacePathMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x590];                                     // 0x0030(0x0590)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectSurfacePathMechanic">();
	}
	static class UCollectSurfacePathMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectSurfacePathMechanic>();
	}
};
static_assert(alignof(UCollectSurfacePathMechanic) == 0x000008, "Wrong alignment on UCollectSurfacePathMechanic");
static_assert(sizeof(UCollectSurfacePathMechanic) == 0x0005C0, "Wrong size on UCollectSurfacePathMechanic");

// Class ModelingComponents.ConstructionPlaneMechanic
// 0x00C0 (0x00F0 - 0x0030)
class alignas(0x10) UConstructionPlaneMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x98];                                      // 0x0030(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UCombinedTransformGizmo*                PlaneTransformGizmo;                               // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTransformProxy*                        PlaneTransformProxy;                               // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USingleClickInputBehavior*              ClickToSetPlaneBehavior;                           // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConstructionPlaneMechanic">();
	}
	static class UConstructionPlaneMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConstructionPlaneMechanic>();
	}
};
static_assert(alignof(UConstructionPlaneMechanic) == 0x000010, "Wrong alignment on UConstructionPlaneMechanic");
static_assert(sizeof(UConstructionPlaneMechanic) == 0x0000F0, "Wrong size on UConstructionPlaneMechanic");
static_assert(offsetof(UConstructionPlaneMechanic, PlaneTransformGizmo) == 0x0000C8, "Member 'UConstructionPlaneMechanic::PlaneTransformGizmo' has a wrong offset!");
static_assert(offsetof(UConstructionPlaneMechanic, PlaneTransformProxy) == 0x0000D0, "Member 'UConstructionPlaneMechanic::PlaneTransformProxy' has a wrong offset!");
static_assert(offsetof(UConstructionPlaneMechanic, ClickToSetPlaneBehavior) == 0x0000E0, "Member 'UConstructionPlaneMechanic::ClickToSetPlaneBehavior' has a wrong offset!");

// Class ModelingComponents.CreateMeshObjectTypeProperties
// 0x0030 (0x00D8 - 0x00A8)
class UCreateMeshObjectTypeProperties final : public UInteractiveToolPropertySet
{
public:
	class FString                                 OutputType;                                        // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVolume>                    VolumeType;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutputTypeNamesList;                               // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowVolumeList;                                   // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class FString> GetOutputTypeNamesFunc();

	ECreateObjectTypeHint GetCurrentCreateMeshType() const;
	bool ShouldShowPropertySet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateMeshObjectTypeProperties">();
	}
	static class UCreateMeshObjectTypeProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateMeshObjectTypeProperties>();
	}
};
static_assert(alignof(UCreateMeshObjectTypeProperties) == 0x000008, "Wrong alignment on UCreateMeshObjectTypeProperties");
static_assert(sizeof(UCreateMeshObjectTypeProperties) == 0x0000D8, "Wrong size on UCreateMeshObjectTypeProperties");
static_assert(offsetof(UCreateMeshObjectTypeProperties, OutputType) == 0x0000A8, "Member 'UCreateMeshObjectTypeProperties::OutputType' has a wrong offset!");
static_assert(offsetof(UCreateMeshObjectTypeProperties, VolumeType) == 0x0000B8, "Member 'UCreateMeshObjectTypeProperties::VolumeType' has a wrong offset!");
static_assert(offsetof(UCreateMeshObjectTypeProperties, OutputTypeNamesList) == 0x0000C0, "Member 'UCreateMeshObjectTypeProperties::OutputTypeNamesList' has a wrong offset!");
static_assert(offsetof(UCreateMeshObjectTypeProperties, bShowVolumeList) == 0x0000D0, "Member 'UCreateMeshObjectTypeProperties::bShowVolumeList' has a wrong offset!");

// Class ModelingComponents.CurveControlPointsMechanic
// 0x0650 (0x0680 - 0x0030)
class alignas(0x10) UCurveControlPointsMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USingleClickInputBehavior*              ClickBehavior;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMouseHoverBehavior*                    HoverBehavior;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x498];                                     // 0x0050(0x0498)(Fixing Size After Last Property [ Dumper-7 ])
	class APreviewGeometryActor*                  PreviewGeometryActor;                              // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointSetComponent*                     DrawnControlPoints;                                // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULineSetComponent*                      DrawnControlSegments;                              // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointSetComponent*                     PreviewPoint;                                      // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULineSetComponent*                      PreviewSegment;                                    // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x78];                                     // 0x0510(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformProxy*                        PointTransformProxy;                               // 0x0588(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCombinedTransformGizmo*                PointTransformGizmo;                               // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0xE8];                                     // 0x0598(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveControlPointsMechanic">();
	}
	static class UCurveControlPointsMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveControlPointsMechanic>();
	}
};
static_assert(alignof(UCurveControlPointsMechanic) == 0x000010, "Wrong alignment on UCurveControlPointsMechanic");
static_assert(sizeof(UCurveControlPointsMechanic) == 0x000680, "Wrong size on UCurveControlPointsMechanic");
static_assert(offsetof(UCurveControlPointsMechanic, ClickBehavior) == 0x000040, "Member 'UCurveControlPointsMechanic::ClickBehavior' has a wrong offset!");
static_assert(offsetof(UCurveControlPointsMechanic, HoverBehavior) == 0x000048, "Member 'UCurveControlPointsMechanic::HoverBehavior' has a wrong offset!");
static_assert(offsetof(UCurveControlPointsMechanic, PreviewGeometryActor) == 0x0004E8, "Member 'UCurveControlPointsMechanic::PreviewGeometryActor' has a wrong offset!");
static_assert(offsetof(UCurveControlPointsMechanic, DrawnControlPoints) == 0x0004F0, "Member 'UCurveControlPointsMechanic::DrawnControlPoints' has a wrong offset!");
static_assert(offsetof(UCurveControlPointsMechanic, DrawnControlSegments) == 0x0004F8, "Member 'UCurveControlPointsMechanic::DrawnControlSegments' has a wrong offset!");
static_assert(offsetof(UCurveControlPointsMechanic, PreviewPoint) == 0x000500, "Member 'UCurveControlPointsMechanic::PreviewPoint' has a wrong offset!");
static_assert(offsetof(UCurveControlPointsMechanic, PreviewSegment) == 0x000508, "Member 'UCurveControlPointsMechanic::PreviewSegment' has a wrong offset!");
static_assert(offsetof(UCurveControlPointsMechanic, PointTransformProxy) == 0x000588, "Member 'UCurveControlPointsMechanic::PointTransformProxy' has a wrong offset!");
static_assert(offsetof(UCurveControlPointsMechanic, PointTransformGizmo) == 0x000590, "Member 'UCurveControlPointsMechanic::PointTransformGizmo' has a wrong offset!");

// Class ModelingComponents.DragAlignmentMechanic
// 0x0230 (0x0260 - 0x0030)
class UDragAlignmentMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x230];                                     // 0x0030(0x0230)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragAlignmentMechanic">();
	}
	static class UDragAlignmentMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragAlignmentMechanic>();
	}
};
static_assert(alignof(UDragAlignmentMechanic) == 0x000008, "Wrong alignment on UDragAlignmentMechanic");
static_assert(sizeof(UDragAlignmentMechanic) == 0x000260, "Wrong size on UDragAlignmentMechanic");

// Class ModelingComponents.DynamicMeshCommitter
// 0x0000 (0x0028 - 0x0028)
class IDynamicMeshCommitter final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshCommitter">();
	}
	static class IDynamicMeshCommitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicMeshCommitter>();
	}
};
static_assert(alignof(IDynamicMeshCommitter) == 0x000008, "Wrong alignment on IDynamicMeshCommitter");
static_assert(sizeof(IDynamicMeshCommitter) == 0x000028, "Wrong size on IDynamicMeshCommitter");

// Class ModelingComponents.DynamicMeshProvider
// 0x0000 (0x0028 - 0x0028)
class IDynamicMeshProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshProvider">();
	}
	static class IDynamicMeshProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicMeshProvider>();
	}
};
static_assert(alignof(IDynamicMeshProvider) == 0x000008, "Wrong alignment on IDynamicMeshProvider");
static_assert(sizeof(IDynamicMeshProvider) == 0x000028, "Wrong size on IDynamicMeshProvider");

// Class ModelingComponents.PersistentDynamicMeshSource
// 0x0000 (0x0028 - 0x0028)
class IPersistentDynamicMeshSource final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersistentDynamicMeshSource">();
	}
	static class IPersistentDynamicMeshSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPersistentDynamicMeshSource>();
	}
};
static_assert(alignof(IPersistentDynamicMeshSource) == 0x000008, "Wrong alignment on IPersistentDynamicMeshSource");
static_assert(sizeof(IPersistentDynamicMeshSource) == 0x000028, "Wrong size on IPersistentDynamicMeshSource");

// Class ModelingComponents.ToolActivityHost
// 0x0000 (0x0028 - 0x0028)
class IToolActivityHost final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolActivityHost">();
	}
	static class IToolActivityHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToolActivityHost>();
	}
};
static_assert(alignof(IToolActivityHost) == 0x000008, "Wrong alignment on IToolActivityHost");
static_assert(sizeof(IToolActivityHost) == 0x000028, "Wrong size on IToolActivityHost");

// Class ModelingComponents.LatticeControlPointsMechanic
// 0x04C0 (0x04F0 - 0x0030)
class alignas(0x10) ULatticeControlPointsMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x1E0];                                     // 0x0030(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class APreviewGeometryActor*                  PreviewGeometryActor;                              // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointSetComponent*                     DrawnControlPoints;                                // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULineSetComponent*                      DrawnLatticeEdges;                                 // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0xA8];                                     // 0x0228(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformProxy*                        PointTransformProxy;                               // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCombinedTransformGizmo*                PointTransformGizmo;                               // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x58];                                     // 0x02E0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class URectangleMarqueeMechanic*              MarqueeMechanic;                                   // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x1B0];                                    // 0x0340(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LatticeControlPointsMechanic">();
	}
	static class ULatticeControlPointsMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULatticeControlPointsMechanic>();
	}
};
static_assert(alignof(ULatticeControlPointsMechanic) == 0x000010, "Wrong alignment on ULatticeControlPointsMechanic");
static_assert(sizeof(ULatticeControlPointsMechanic) == 0x0004F0, "Wrong size on ULatticeControlPointsMechanic");
static_assert(offsetof(ULatticeControlPointsMechanic, PreviewGeometryActor) == 0x000210, "Member 'ULatticeControlPointsMechanic::PreviewGeometryActor' has a wrong offset!");
static_assert(offsetof(ULatticeControlPointsMechanic, DrawnControlPoints) == 0x000218, "Member 'ULatticeControlPointsMechanic::DrawnControlPoints' has a wrong offset!");
static_assert(offsetof(ULatticeControlPointsMechanic, DrawnLatticeEdges) == 0x000220, "Member 'ULatticeControlPointsMechanic::DrawnLatticeEdges' has a wrong offset!");
static_assert(offsetof(ULatticeControlPointsMechanic, PointTransformProxy) == 0x0002D0, "Member 'ULatticeControlPointsMechanic::PointTransformProxy' has a wrong offset!");
static_assert(offsetof(ULatticeControlPointsMechanic, PointTransformGizmo) == 0x0002D8, "Member 'ULatticeControlPointsMechanic::PointTransformGizmo' has a wrong offset!");
static_assert(offsetof(ULatticeControlPointsMechanic, MarqueeMechanic) == 0x000338, "Member 'ULatticeControlPointsMechanic::MarqueeMechanic' has a wrong offset!");

// Class ModelingComponents.LineSetComponent
// 0x0080 (0x0600 - 0x0580)
class ULineSetComponent final : public UMeshComponent
{
public:
	class UMaterialInterface*                     LineMaterial;                                      // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0588(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bBoundsDirty;                                      // 0x05C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C1[0x3F];                                     // 0x05C1(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LineSetComponent">();
	}
	static class ULineSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULineSetComponent>();
	}
};
static_assert(alignof(ULineSetComponent) == 0x000010, "Wrong alignment on ULineSetComponent");
static_assert(sizeof(ULineSetComponent) == 0x000600, "Wrong size on ULineSetComponent");
static_assert(offsetof(ULineSetComponent, LineMaterial) == 0x000580, "Member 'ULineSetComponent::LineMaterial' has a wrong offset!");
static_assert(offsetof(ULineSetComponent, Bounds) == 0x000588, "Member 'ULineSetComponent::Bounds' has a wrong offset!");
static_assert(offsetof(ULineSetComponent, bBoundsDirty) == 0x0005C0, "Member 'ULineSetComponent::bBoundsDirty' has a wrong offset!");

// Class ModelingComponents.MeshElementsVisualizerProperties
// 0x0028 (0x00D0 - 0x00A8)
class UMeshElementsVisualizerProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bVisible;                                          // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWireframe;                                    // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBorders;                                      // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowUVSeams;                                      // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNormalSeams;                                  // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowColorSeams;                                   // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThicknessScale;                                    // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 WireframeColor;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BoundaryEdgeColor;                                 // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 UVSeamColor;                                       // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 NormalSeamColor;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorSeamColor;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBias;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustDepthBiasUsingMeshSize;                     // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshElementsVisualizerProperties">();
	}
	static class UMeshElementsVisualizerProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshElementsVisualizerProperties>();
	}
};
static_assert(alignof(UMeshElementsVisualizerProperties) == 0x000008, "Wrong alignment on UMeshElementsVisualizerProperties");
static_assert(sizeof(UMeshElementsVisualizerProperties) == 0x0000D0, "Wrong size on UMeshElementsVisualizerProperties");
static_assert(offsetof(UMeshElementsVisualizerProperties, bVisible) == 0x0000A8, "Member 'UMeshElementsVisualizerProperties::bVisible' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, bShowWireframe) == 0x0000A9, "Member 'UMeshElementsVisualizerProperties::bShowWireframe' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, bShowBorders) == 0x0000AA, "Member 'UMeshElementsVisualizerProperties::bShowBorders' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, bShowUVSeams) == 0x0000AB, "Member 'UMeshElementsVisualizerProperties::bShowUVSeams' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, bShowNormalSeams) == 0x0000AC, "Member 'UMeshElementsVisualizerProperties::bShowNormalSeams' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, bShowColorSeams) == 0x0000AD, "Member 'UMeshElementsVisualizerProperties::bShowColorSeams' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, ThicknessScale) == 0x0000B0, "Member 'UMeshElementsVisualizerProperties::ThicknessScale' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, WireframeColor) == 0x0000B4, "Member 'UMeshElementsVisualizerProperties::WireframeColor' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, BoundaryEdgeColor) == 0x0000B8, "Member 'UMeshElementsVisualizerProperties::BoundaryEdgeColor' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, UVSeamColor) == 0x0000BC, "Member 'UMeshElementsVisualizerProperties::UVSeamColor' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, NormalSeamColor) == 0x0000C0, "Member 'UMeshElementsVisualizerProperties::NormalSeamColor' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, ColorSeamColor) == 0x0000C4, "Member 'UMeshElementsVisualizerProperties::ColorSeamColor' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, DepthBias) == 0x0000C8, "Member 'UMeshElementsVisualizerProperties::DepthBias' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizerProperties, bAdjustDepthBiasUsingMeshSize) == 0x0000CC, "Member 'UMeshElementsVisualizerProperties::bAdjustDepthBiasUsingMeshSize' has a wrong offset!");

// Class ModelingComponents.PreviewGeometry
// 0x00A8 (0x00D0 - 0x0028)
class UPreviewGeometry : public UObject
{
public:
	class APreviewGeometryActor*                  ParentActor;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class ULineSetComponent*> LineSets;                                          // 0x0030(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, class UPointSetComponent*> PointSets;                                         // 0x0080(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	class ULineSetComponent* AddLineSet(const class FString& LineSetIdentifier);
	class UPointSetComponent* AddPointSet(const class FString& PointSetIdentifier);
	void CreateInWorld(class UWorld* World, const struct FTransform& WithTransform);
	void Disconnect();
	class ULineSetComponent* FindLineSet(const class FString& LineSetIdentifier);
	class UPointSetComponent* FindPointSet(const class FString& PointSetIdentifier);
	void RemoveAllLineSets(bool bDestroy);
	void RemoveAllPointSets(bool bDestroy);
	bool RemoveLineSet(const class FString& LineSetIdentifier, bool bDestroy);
	bool RemovePointSet(const class FString& PointSetIdentifier, bool bDestroy);
	void SetAllLineSetsMaterial(class UMaterialInterface* Material);
	void SetAllPointSetsMaterial(class UMaterialInterface* Material);
	bool SetLineSetMaterial(const class FString& LineSetIdentifier, class UMaterialInterface* NewMaterial);
	bool SetLineSetVisibility(const class FString& LineSetIdentifier, bool bVisible);
	bool SetPointSetMaterial(const class FString& PointSetIdentifier, class UMaterialInterface* NewMaterial);
	bool SetPointSetVisibility(const class FString& PointSetIdentifier, bool bVisible);

	class APreviewGeometryActor* GetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewGeometry">();
	}
	static class UPreviewGeometry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreviewGeometry>();
	}
};
static_assert(alignof(UPreviewGeometry) == 0x000008, "Wrong alignment on UPreviewGeometry");
static_assert(sizeof(UPreviewGeometry) == 0x0000D0, "Wrong size on UPreviewGeometry");
static_assert(offsetof(UPreviewGeometry, ParentActor) == 0x000028, "Member 'UPreviewGeometry::ParentActor' has a wrong offset!");
static_assert(offsetof(UPreviewGeometry, LineSets) == 0x000030, "Member 'UPreviewGeometry::LineSets' has a wrong offset!");
static_assert(offsetof(UPreviewGeometry, PointSets) == 0x000080, "Member 'UPreviewGeometry::PointSets' has a wrong offset!");

// Class ModelingComponents.MeshElementsVisualizer
// 0x0028 (0x00F8 - 0x00D0)
class UMeshElementsVisualizer final : public UPreviewGeometry
{
public:
	class UMeshElementsVisualizerProperties*      Settings;                                          // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshWireframeComponent*                WireframeComponent;                                // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshElementsVisualizer">();
	}
	static class UMeshElementsVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshElementsVisualizer>();
	}
};
static_assert(alignof(UMeshElementsVisualizer) == 0x000008, "Wrong alignment on UMeshElementsVisualizer");
static_assert(sizeof(UMeshElementsVisualizer) == 0x0000F8, "Wrong size on UMeshElementsVisualizer");
static_assert(offsetof(UMeshElementsVisualizer, Settings) == 0x0000D0, "Member 'UMeshElementsVisualizer::Settings' has a wrong offset!");
static_assert(offsetof(UMeshElementsVisualizer, WireframeComponent) == 0x0000D8, "Member 'UMeshElementsVisualizer::WireframeComponent' has a wrong offset!");

// Class ModelingComponents.MeshOpPreviewWithBackgroundCompute
// 0x0090 (0x00B8 - 0x0028)
class UMeshOpPreviewWithBackgroundCompute final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewMesh*                           PreviewMesh;                                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             StandardMaterials;                                 // 0x0060(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     WorkingMaterial;                                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SecondaryMaterial;                                 // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UWorld>                  PreviewWorld;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x28];                                      // 0x0090(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshOpPreviewWithBackgroundCompute">();
	}
	static class UMeshOpPreviewWithBackgroundCompute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshOpPreviewWithBackgroundCompute>();
	}
};
static_assert(alignof(UMeshOpPreviewWithBackgroundCompute) == 0x000008, "Wrong alignment on UMeshOpPreviewWithBackgroundCompute");
static_assert(sizeof(UMeshOpPreviewWithBackgroundCompute) == 0x0000B8, "Wrong size on UMeshOpPreviewWithBackgroundCompute");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, PreviewMesh) == 0x000058, "Member 'UMeshOpPreviewWithBackgroundCompute::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, StandardMaterials) == 0x000060, "Member 'UMeshOpPreviewWithBackgroundCompute::StandardMaterials' has a wrong offset!");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, OverrideMaterial) == 0x000070, "Member 'UMeshOpPreviewWithBackgroundCompute::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, WorkingMaterial) == 0x000078, "Member 'UMeshOpPreviewWithBackgroundCompute::WorkingMaterial' has a wrong offset!");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, SecondaryMaterial) == 0x000080, "Member 'UMeshOpPreviewWithBackgroundCompute::SecondaryMaterial' has a wrong offset!");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, PreviewWorld) == 0x000088, "Member 'UMeshOpPreviewWithBackgroundCompute::PreviewWorld' has a wrong offset!");

// Class ModelingComponents.MeshWireframeComponent
// 0x00A0 (0x0620 - 0x0580)
class UMeshWireframeComponent final : public UMeshComponent
{
public:
	float                                         LineDepthBias;                                     // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDepthBiasSizeScale;                            // 0x0584(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThicknessScale;                                    // 0x0588(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWireframe;                                  // 0x058C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58D[0x3];                                      // 0x058D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 WireframeColor;                                    // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WireframeThickness;                                // 0x0594(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBoundaryEdges;                              // 0x0598(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_599[0x3];                                      // 0x0599(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 BoundaryEdgeColor;                                 // 0x059C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryEdgeThickness;                             // 0x05A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableUVSeams;                                    // 0x05A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A5[0x3];                                      // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 UVSeamColor;                                       // 0x05A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UVSeamThickness;                                   // 0x05AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNormalSeams;                                // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0x3];                                      // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 NormalSeamColor;                                   // 0x05B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalSeamThickness;                               // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableColorSeams;                                 // 0x05BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BD[0x3];                                      // 0x05BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 ColorSeamColor;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorSeamThickness;                                // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LineMaterial;                                      // 0x05C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       LocalBounds;                                       // 0x05D0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x18];                                     // 0x0608(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshWireframeComponent">();
	}
	static class UMeshWireframeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshWireframeComponent>();
	}
};
static_assert(alignof(UMeshWireframeComponent) == 0x000010, "Wrong alignment on UMeshWireframeComponent");
static_assert(sizeof(UMeshWireframeComponent) == 0x000620, "Wrong size on UMeshWireframeComponent");
static_assert(offsetof(UMeshWireframeComponent, LineDepthBias) == 0x000580, "Member 'UMeshWireframeComponent::LineDepthBias' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, LineDepthBiasSizeScale) == 0x000584, "Member 'UMeshWireframeComponent::LineDepthBiasSizeScale' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, ThicknessScale) == 0x000588, "Member 'UMeshWireframeComponent::ThicknessScale' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, bEnableWireframe) == 0x00058C, "Member 'UMeshWireframeComponent::bEnableWireframe' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, WireframeColor) == 0x000590, "Member 'UMeshWireframeComponent::WireframeColor' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, WireframeThickness) == 0x000594, "Member 'UMeshWireframeComponent::WireframeThickness' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, bEnableBoundaryEdges) == 0x000598, "Member 'UMeshWireframeComponent::bEnableBoundaryEdges' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, BoundaryEdgeColor) == 0x00059C, "Member 'UMeshWireframeComponent::BoundaryEdgeColor' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, BoundaryEdgeThickness) == 0x0005A0, "Member 'UMeshWireframeComponent::BoundaryEdgeThickness' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, bEnableUVSeams) == 0x0005A4, "Member 'UMeshWireframeComponent::bEnableUVSeams' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, UVSeamColor) == 0x0005A8, "Member 'UMeshWireframeComponent::UVSeamColor' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, UVSeamThickness) == 0x0005AC, "Member 'UMeshWireframeComponent::UVSeamThickness' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, bEnableNormalSeams) == 0x0005B0, "Member 'UMeshWireframeComponent::bEnableNormalSeams' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, NormalSeamColor) == 0x0005B4, "Member 'UMeshWireframeComponent::NormalSeamColor' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, NormalSeamThickness) == 0x0005B8, "Member 'UMeshWireframeComponent::NormalSeamThickness' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, bEnableColorSeams) == 0x0005BC, "Member 'UMeshWireframeComponent::bEnableColorSeams' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, ColorSeamColor) == 0x0005C0, "Member 'UMeshWireframeComponent::ColorSeamColor' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, ColorSeamThickness) == 0x0005C4, "Member 'UMeshWireframeComponent::ColorSeamThickness' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, LineMaterial) == 0x0005C8, "Member 'UMeshWireframeComponent::LineMaterial' has a wrong offset!");
static_assert(offsetof(UMeshWireframeComponent, LocalBounds) == 0x0005D0, "Member 'UMeshWireframeComponent::LocalBounds' has a wrong offset!");

// Class ModelingComponents.ModelingComponentsSettings
// 0x0008 (0x0040 - 0x0038)
class UModelingComponentsSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnableRayTracingWhileEditing;                     // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRayTracing;                                 // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollision;                                  // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionTraceFlag                           CollisionMode;                                     // 0x003B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelingComponentsSettings">();
	}
	static class UModelingComponentsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModelingComponentsSettings>();
	}
};
static_assert(alignof(UModelingComponentsSettings) == 0x000008, "Wrong alignment on UModelingComponentsSettings");
static_assert(sizeof(UModelingComponentsSettings) == 0x000040, "Wrong size on UModelingComponentsSettings");
static_assert(offsetof(UModelingComponentsSettings, bEnableRayTracingWhileEditing) == 0x000038, "Member 'UModelingComponentsSettings::bEnableRayTracingWhileEditing' has a wrong offset!");
static_assert(offsetof(UModelingComponentsSettings, bEnableRayTracing) == 0x000039, "Member 'UModelingComponentsSettings::bEnableRayTracing' has a wrong offset!");
static_assert(offsetof(UModelingComponentsSettings, bEnableCollision) == 0x00003A, "Member 'UModelingComponentsSettings::bEnableCollision' has a wrong offset!");
static_assert(offsetof(UModelingComponentsSettings, CollisionMode) == 0x00003B, "Member 'UModelingComponentsSettings::CollisionMode' has a wrong offset!");

// Class ModelingComponents.ModelingObjectsCreationAPI
// 0x0000 (0x0028 - 0x0028)
class UModelingObjectsCreationAPI final : public UObject
{
public:
	struct FCreateMeshObjectResult CreateMeshObject(const struct FCreateMeshObjectParams& CreateMeshParams);
	struct FCreateTextureObjectResult CreateTextureObject(const struct FCreateTextureObjectParams& CreateTexParams);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelingObjectsCreationAPI">();
	}
	static class UModelingObjectsCreationAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModelingObjectsCreationAPI>();
	}
};
static_assert(alignof(UModelingObjectsCreationAPI) == 0x000008, "Wrong alignment on UModelingObjectsCreationAPI");
static_assert(sizeof(UModelingObjectsCreationAPI) == 0x000028, "Wrong size on UModelingObjectsCreationAPI");

// Class ModelingComponents.ModelingSceneSnappingManager
// 0x00D0 (0x00F8 - 0x0028)
class UModelingSceneSnappingManager final : public USceneSnappingManager
{
public:
	class UInteractiveToolsContext*               ParentContext;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0xC8];                                      // 0x0030(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelingSceneSnappingManager">();
	}
	static class UModelingSceneSnappingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModelingSceneSnappingManager>();
	}
};
static_assert(alignof(UModelingSceneSnappingManager) == 0x000008, "Wrong alignment on UModelingSceneSnappingManager");
static_assert(sizeof(UModelingSceneSnappingManager) == 0x0000F8, "Wrong size on UModelingSceneSnappingManager");
static_assert(offsetof(UModelingSceneSnappingManager, ParentContext) == 0x000028, "Member 'UModelingSceneSnappingManager::ParentContext' has a wrong offset!");

// Class ModelingComponents.OctreeDynamicMeshComponent
// 0x0120 (0x06F0 - 0x05D0)
class UOctreeDynamicMeshComponent final : public UBaseDynamicMeshComponent
{
public:
	uint8                                         Pad_5D0[0x60];                                     // 0x05D0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           MeshObject;                                        // 0x0630(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0xB8];                                     // 0x0638(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDynamicMesh(class UDynamicMesh* NewMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctreeDynamicMeshComponent">();
	}
	static class UOctreeDynamicMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOctreeDynamicMeshComponent>();
	}
};
static_assert(alignof(UOctreeDynamicMeshComponent) == 0x000010, "Wrong alignment on UOctreeDynamicMeshComponent");
static_assert(sizeof(UOctreeDynamicMeshComponent) == 0x0006F0, "Wrong size on UOctreeDynamicMeshComponent");
static_assert(offsetof(UOctreeDynamicMeshComponent, MeshObject) == 0x000630, "Member 'UOctreeDynamicMeshComponent::MeshObject' has a wrong offset!");

// Class ModelingComponents.PolyLassoMarqueeMechanic
// 0x01A0 (0x01D0 - 0x0030)
class alignas(0x10) UPolyLassoMarqueeMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpacingTolerance;                                  // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0090(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ClosedColor;                                       // 0x00A0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFreehandPolygons;                           // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMultiClickPolygons;                         // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UClickDragInputBehavior*                ClickDragBehavior;                                 // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMouseHoverBehavior*                    HoverBehavior;                                     // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x108];                                     // 0x00C8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolyLassoMarqueeMechanic">();
	}
	static class UPolyLassoMarqueeMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolyLassoMarqueeMechanic>();
	}
};
static_assert(alignof(UPolyLassoMarqueeMechanic) == 0x000010, "Wrong alignment on UPolyLassoMarqueeMechanic");
static_assert(sizeof(UPolyLassoMarqueeMechanic) == 0x0001D0, "Wrong size on UPolyLassoMarqueeMechanic");
static_assert(offsetof(UPolyLassoMarqueeMechanic, SpacingTolerance) == 0x000088, "Member 'UPolyLassoMarqueeMechanic::SpacingTolerance' has a wrong offset!");
static_assert(offsetof(UPolyLassoMarqueeMechanic, LineThickness) == 0x00008C, "Member 'UPolyLassoMarqueeMechanic::LineThickness' has a wrong offset!");
static_assert(offsetof(UPolyLassoMarqueeMechanic, LineColor) == 0x000090, "Member 'UPolyLassoMarqueeMechanic::LineColor' has a wrong offset!");
static_assert(offsetof(UPolyLassoMarqueeMechanic, ClosedColor) == 0x0000A0, "Member 'UPolyLassoMarqueeMechanic::ClosedColor' has a wrong offset!");
static_assert(offsetof(UPolyLassoMarqueeMechanic, bEnableFreehandPolygons) == 0x0000B0, "Member 'UPolyLassoMarqueeMechanic::bEnableFreehandPolygons' has a wrong offset!");
static_assert(offsetof(UPolyLassoMarqueeMechanic, bEnableMultiClickPolygons) == 0x0000B1, "Member 'UPolyLassoMarqueeMechanic::bEnableMultiClickPolygons' has a wrong offset!");
static_assert(offsetof(UPolyLassoMarqueeMechanic, ClickDragBehavior) == 0x0000B8, "Member 'UPolyLassoMarqueeMechanic::ClickDragBehavior' has a wrong offset!");
static_assert(offsetof(UPolyLassoMarqueeMechanic, HoverBehavior) == 0x0000C0, "Member 'UPolyLassoMarqueeMechanic::HoverBehavior' has a wrong offset!");

// Class ModelingComponents.PlaneDistanceFromHitMechanic
// 0x04E0 (0x0510 - 0x0030)
class UPlaneDistanceFromHitMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x4E0];                                     // 0x0030(0x04E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneDistanceFromHitMechanic">();
	}
	static class UPlaneDistanceFromHitMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneDistanceFromHitMechanic>();
	}
};
static_assert(alignof(UPlaneDistanceFromHitMechanic) == 0x000008, "Wrong alignment on UPlaneDistanceFromHitMechanic");
static_assert(sizeof(UPlaneDistanceFromHitMechanic) == 0x000510, "Wrong size on UPlaneDistanceFromHitMechanic");

// Class ModelingComponents.PointSetComponent
// 0x0080 (0x0600 - 0x0580)
class UPointSetComponent final : public UMeshComponent
{
public:
	class UMaterialInterface*                     PointMaterial;                                     // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0588(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bBoundsDirty;                                      // 0x05C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C1[0x3F];                                     // 0x05C1(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointSetComponent">();
	}
	static class UPointSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointSetComponent>();
	}
};
static_assert(alignof(UPointSetComponent) == 0x000010, "Wrong alignment on UPointSetComponent");
static_assert(sizeof(UPointSetComponent) == 0x000600, "Wrong size on UPointSetComponent");
static_assert(offsetof(UPointSetComponent, PointMaterial) == 0x000580, "Member 'UPointSetComponent::PointMaterial' has a wrong offset!");
static_assert(offsetof(UPointSetComponent, Bounds) == 0x000588, "Member 'UPointSetComponent::Bounds' has a wrong offset!");
static_assert(offsetof(UPointSetComponent, bBoundsDirty) == 0x0005C0, "Member 'UPointSetComponent::bBoundsDirty' has a wrong offset!");

// Class ModelingComponents.PreviewMesh
// 0x0118 (0x0140 - 0x0028)
class alignas(0x10) UPreviewMesh : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBuildSpatialDataStructure;                        // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMeshComponent*                  DynamicMeshComponent;                              // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0xE8];                                      // 0x0058(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewMesh">();
	}
	static class UPreviewMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreviewMesh>();
	}
};
static_assert(alignof(UPreviewMesh) == 0x000010, "Wrong alignment on UPreviewMesh");
static_assert(sizeof(UPreviewMesh) == 0x000140, "Wrong size on UPreviewMesh");
static_assert(offsetof(UPreviewMesh, bBuildSpatialDataStructure) == 0x000040, "Member 'UPreviewMesh::bBuildSpatialDataStructure' has a wrong offset!");
static_assert(offsetof(UPreviewMesh, DynamicMeshComponent) == 0x000050, "Member 'UPreviewMesh::DynamicMeshComponent' has a wrong offset!");

// Class ModelingComponents.PolyEditPreviewMesh
// 0x0410 (0x0550 - 0x0140)
class UPolyEditPreviewMesh final : public UPreviewMesh
{
public:
	uint8                                         Pad_140[0x410];                                    // 0x0140(0x0410)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolyEditPreviewMesh">();
	}
	static class UPolyEditPreviewMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolyEditPreviewMesh>();
	}
};
static_assert(alignof(UPolyEditPreviewMesh) == 0x000010, "Wrong alignment on UPolyEditPreviewMesh");
static_assert(sizeof(UPolyEditPreviewMesh) == 0x000550, "Wrong size on UPolyEditPreviewMesh");

// Class ModelingComponents.RectangleMarqueeMechanic
// 0x01B0 (0x01E0 - 0x0030)
class alignas(0x10) URectangleMarqueeMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseExternalClickDragBehavior;                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        OnDragRectangleChangedDeferredThreshold;           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x48];                                      // 0x0048(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UClickDragInputBehavior*                ClickDragBehavior;                                 // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x148];                                     // 0x0098(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RectangleMarqueeMechanic">();
	}
	static class URectangleMarqueeMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<URectangleMarqueeMechanic>();
	}
};
static_assert(alignof(URectangleMarqueeMechanic) == 0x000010, "Wrong alignment on URectangleMarqueeMechanic");
static_assert(sizeof(URectangleMarqueeMechanic) == 0x0001E0, "Wrong size on URectangleMarqueeMechanic");
static_assert(offsetof(URectangleMarqueeMechanic, bUseExternalClickDragBehavior) == 0x000038, "Member 'URectangleMarqueeMechanic::bUseExternalClickDragBehavior' has a wrong offset!");
static_assert(offsetof(URectangleMarqueeMechanic, OnDragRectangleChangedDeferredThreshold) == 0x000040, "Member 'URectangleMarqueeMechanic::OnDragRectangleChangedDeferredThreshold' has a wrong offset!");
static_assert(offsetof(URectangleMarqueeMechanic, ClickDragBehavior) == 0x000090, "Member 'URectangleMarqueeMechanic::ClickDragBehavior' has a wrong offset!");

// Class ModelingComponents.PolygonSelectionMechanicProperties
// 0x0010 (0x00B8 - 0x00A8)
class UPolygonSelectionMechanicProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bSelectVertices;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectEdges;                                      // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectFaces;                                      // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectEdgeLoops;                                  // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectEdgeRings;                                  // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitBackFaces;                                     // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMarquee;                                    // 0x00AE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarqueeIgnoreOcclusion;                           // 0x00AF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreferProjectedElement;                           // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectDownRay;                                    // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOcclusion;                                  // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolygonSelectionMechanicProperties">();
	}
	static class UPolygonSelectionMechanicProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolygonSelectionMechanicProperties>();
	}
};
static_assert(alignof(UPolygonSelectionMechanicProperties) == 0x000008, "Wrong alignment on UPolygonSelectionMechanicProperties");
static_assert(sizeof(UPolygonSelectionMechanicProperties) == 0x0000B8, "Wrong size on UPolygonSelectionMechanicProperties");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectVertices) == 0x0000A8, "Member 'UPolygonSelectionMechanicProperties::bSelectVertices' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectEdges) == 0x0000A9, "Member 'UPolygonSelectionMechanicProperties::bSelectEdges' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectFaces) == 0x0000AA, "Member 'UPolygonSelectionMechanicProperties::bSelectFaces' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectEdgeLoops) == 0x0000AB, "Member 'UPolygonSelectionMechanicProperties::bSelectEdgeLoops' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectEdgeRings) == 0x0000AC, "Member 'UPolygonSelectionMechanicProperties::bSelectEdgeRings' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bHitBackFaces) == 0x0000AD, "Member 'UPolygonSelectionMechanicProperties::bHitBackFaces' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bEnableMarquee) == 0x0000AE, "Member 'UPolygonSelectionMechanicProperties::bEnableMarquee' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bMarqueeIgnoreOcclusion) == 0x0000AF, "Member 'UPolygonSelectionMechanicProperties::bMarqueeIgnoreOcclusion' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bPreferProjectedElement) == 0x0000B0, "Member 'UPolygonSelectionMechanicProperties::bPreferProjectedElement' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectDownRay) == 0x0000B1, "Member 'UPolygonSelectionMechanicProperties::bSelectDownRay' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bIgnoreOcclusion) == 0x0000B2, "Member 'UPolygonSelectionMechanicProperties::bIgnoreOcclusion' has a wrong offset!");

// Class ModelingComponents.PolygonSelectionMechanic
// 0x0AD0 (0x0B00 - 0x0030)
class alignas(0x10) UPolygonSelectionMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UPolygonSelectionMechanicProperties*    Properties;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x60];                                      // 0x0080(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UMouseHoverBehavior*                    HoverBehavior;                                     // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USingleClickOrDragInputBehavior*        ClickOrDragBehavior;                               // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URectangleMarqueeMechanic*              MarqueeMechanic;                                   // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x5D8];                                     // 0x00F8(0x05D8)(Fixing Size After Last Property [ Dumper-7 ])
	class APreviewGeometryActor*                  PreviewGeometryActor;                              // 0x06D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTriangleSetComponent*                  DrawnTriangleSetComponent;                         // 0x06D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E0[0x50];                                     // 0x06E0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     HighlightedFaceMaterial;                           // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_738[0x3C8];                                    // 0x0738(0x03C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolygonSelectionMechanic">();
	}
	static class UPolygonSelectionMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolygonSelectionMechanic>();
	}
};
static_assert(alignof(UPolygonSelectionMechanic) == 0x000010, "Wrong alignment on UPolygonSelectionMechanic");
static_assert(sizeof(UPolygonSelectionMechanic) == 0x000B00, "Wrong size on UPolygonSelectionMechanic");
static_assert(offsetof(UPolygonSelectionMechanic, Properties) == 0x000078, "Member 'UPolygonSelectionMechanic::Properties' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanic, HoverBehavior) == 0x0000E0, "Member 'UPolygonSelectionMechanic::HoverBehavior' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanic, ClickOrDragBehavior) == 0x0000E8, "Member 'UPolygonSelectionMechanic::ClickOrDragBehavior' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanic, MarqueeMechanic) == 0x0000F0, "Member 'UPolygonSelectionMechanic::MarqueeMechanic' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanic, PreviewGeometryActor) == 0x0006D0, "Member 'UPolygonSelectionMechanic::PreviewGeometryActor' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanic, DrawnTriangleSetComponent) == 0x0006D8, "Member 'UPolygonSelectionMechanic::DrawnTriangleSetComponent' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanic, HighlightedFaceMaterial) == 0x000730, "Member 'UPolygonSelectionMechanic::HighlightedFaceMaterial' has a wrong offset!");

// Class ModelingComponents.PolygroupLayersProperties
// 0x0018 (0x00C0 - 0x00A8)
class UPolygroupLayersProperties final : public UInteractiveToolPropertySet
{
public:
	class FName                                   ActiveGroupLayer;                                  // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         GroupLayersList;                                   // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	TArray<class FString> GetGroupLayersFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolygroupLayersProperties">();
	}
	static class UPolygroupLayersProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolygroupLayersProperties>();
	}
};
static_assert(alignof(UPolygroupLayersProperties) == 0x000008, "Wrong alignment on UPolygroupLayersProperties");
static_assert(sizeof(UPolygroupLayersProperties) == 0x0000C0, "Wrong size on UPolygroupLayersProperties");
static_assert(offsetof(UPolygroupLayersProperties, ActiveGroupLayer) == 0x0000A8, "Member 'UPolygroupLayersProperties::ActiveGroupLayer' has a wrong offset!");
static_assert(offsetof(UPolygroupLayersProperties, GroupLayersList) == 0x0000B0, "Member 'UPolygroupLayersProperties::GroupLayersList' has a wrong offset!");

// Class ModelingComponents.PreviewGeometryActor
// 0x0000 (0x0280 - 0x0280)
class APreviewGeometryActor final : public AInternalToolFrameworkActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewGeometryActor">();
	}
	static class APreviewGeometryActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreviewGeometryActor>();
	}
};
static_assert(alignof(APreviewGeometryActor) == 0x000008, "Wrong alignment on APreviewGeometryActor");
static_assert(sizeof(APreviewGeometryActor) == 0x000280, "Wrong size on APreviewGeometryActor");

// Class ModelingComponents.PreviewMeshActor
// 0x0000 (0x0280 - 0x0280)
class APreviewMeshActor final : public AInternalToolFrameworkActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewMeshActor">();
	}
	static class APreviewMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreviewMeshActor>();
	}
};
static_assert(alignof(APreviewMeshActor) == 0x000008, "Wrong alignment on APreviewMeshActor");
static_assert(sizeof(APreviewMeshActor) == 0x000280, "Wrong size on APreviewMeshActor");

// Class ModelingComponents.SpaceCurveDeformationMechanicPropertySet
// 0x0010 (0x00B8 - 0x00A8)
class USpaceCurveDeformationMechanicPropertySet final : public UInteractiveToolPropertySet
{
public:
	ESpaceCurveControlPointTransformMode          TransformMode;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpaceCurveControlPointOriginMode             TransformOrigin;                                   // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Softness;                                          // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpaceCurveControlPointFalloffType            SoftFalloff;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpaceCurveDeformationMechanicPropertySet">();
	}
	static class USpaceCurveDeformationMechanicPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpaceCurveDeformationMechanicPropertySet>();
	}
};
static_assert(alignof(USpaceCurveDeformationMechanicPropertySet) == 0x000008, "Wrong alignment on USpaceCurveDeformationMechanicPropertySet");
static_assert(sizeof(USpaceCurveDeformationMechanicPropertySet) == 0x0000B8, "Wrong size on USpaceCurveDeformationMechanicPropertySet");
static_assert(offsetof(USpaceCurveDeformationMechanicPropertySet, TransformMode) == 0x0000A8, "Member 'USpaceCurveDeformationMechanicPropertySet::TransformMode' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanicPropertySet, TransformOrigin) == 0x0000AC, "Member 'USpaceCurveDeformationMechanicPropertySet::TransformOrigin' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanicPropertySet, Softness) == 0x0000B0, "Member 'USpaceCurveDeformationMechanicPropertySet::Softness' has a wrong offset!");
static_assert(offsetof(USpaceCurveDeformationMechanicPropertySet, SoftFalloff) == 0x0000B4, "Member 'USpaceCurveDeformationMechanicPropertySet::SoftFalloff' has a wrong offset!");

// Class ModelingComponents.TriangleSetComponent
// 0x0100 (0x0680 - 0x0580)
class UTriangleSetComponent final : public UMeshComponent
{
public:
	struct FBoxSphereBounds                       Bounds;                                            // 0x0580(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bBoundsDirty;                                      // 0x05B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B9[0xC7];                                     // 0x05B9(0x00C7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriangleSetComponent">();
	}
	static class UTriangleSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriangleSetComponent>();
	}
};
static_assert(alignof(UTriangleSetComponent) == 0x000010, "Wrong alignment on UTriangleSetComponent");
static_assert(sizeof(UTriangleSetComponent) == 0x000680, "Wrong size on UTriangleSetComponent");
static_assert(offsetof(UTriangleSetComponent, Bounds) == 0x000580, "Member 'UTriangleSetComponent::Bounds' has a wrong offset!");
static_assert(offsetof(UTriangleSetComponent, bBoundsDirty) == 0x0005B8, "Member 'UTriangleSetComponent::bBoundsDirty' has a wrong offset!");

// Class ModelingComponents.UVLayoutPreviewProperties
// 0x0028 (0x00D0 - 0x00A8)
class UUVLayoutPreviewProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bEnabled;                                          // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EUVLayoutPreviewSide                          Side;                                              // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset;                                            // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWireframe;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UVLayoutPreviewProperties">();
	}
	static class UUVLayoutPreviewProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUVLayoutPreviewProperties>();
	}
};
static_assert(alignof(UUVLayoutPreviewProperties) == 0x000008, "Wrong alignment on UUVLayoutPreviewProperties");
static_assert(sizeof(UUVLayoutPreviewProperties) == 0x0000D0, "Wrong size on UUVLayoutPreviewProperties");
static_assert(offsetof(UUVLayoutPreviewProperties, bEnabled) == 0x0000A8, "Member 'UUVLayoutPreviewProperties::bEnabled' has a wrong offset!");
static_assert(offsetof(UUVLayoutPreviewProperties, Side) == 0x0000AC, "Member 'UUVLayoutPreviewProperties::Side' has a wrong offset!");
static_assert(offsetof(UUVLayoutPreviewProperties, Scale) == 0x0000B0, "Member 'UUVLayoutPreviewProperties::Scale' has a wrong offset!");
static_assert(offsetof(UUVLayoutPreviewProperties, Offset) == 0x0000B8, "Member 'UUVLayoutPreviewProperties::Offset' has a wrong offset!");
static_assert(offsetof(UUVLayoutPreviewProperties, bShowWireframe) == 0x0000C8, "Member 'UUVLayoutPreviewProperties::bShowWireframe' has a wrong offset!");

// Class ModelingComponents.UVLayoutPreview
// 0x0138 (0x0160 - 0x0028)
class alignas(0x10) UUVLayoutPreview final : public UObject
{
public:
	class UUVLayoutPreviewProperties*             Settings;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPreviewMesh*                           PreviewMesh;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriangleSetComponent*                  TriangleComponent;                                 // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBackingRectangle;                             // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     BackingRectangleMaterial;                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x110];                                     // 0x0050(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UVLayoutPreview">();
	}
	static class UUVLayoutPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUVLayoutPreview>();
	}
};
static_assert(alignof(UUVLayoutPreview) == 0x000010, "Wrong alignment on UUVLayoutPreview");
static_assert(sizeof(UUVLayoutPreview) == 0x000160, "Wrong size on UUVLayoutPreview");
static_assert(offsetof(UUVLayoutPreview, Settings) == 0x000028, "Member 'UUVLayoutPreview::Settings' has a wrong offset!");
static_assert(offsetof(UUVLayoutPreview, PreviewMesh) == 0x000030, "Member 'UUVLayoutPreview::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UUVLayoutPreview, TriangleComponent) == 0x000038, "Member 'UUVLayoutPreview::TriangleComponent' has a wrong offset!");
static_assert(offsetof(UUVLayoutPreview, bShowBackingRectangle) == 0x000040, "Member 'UUVLayoutPreview::bShowBackingRectangle' has a wrong offset!");
static_assert(offsetof(UUVLayoutPreview, BackingRectangleMaterial) == 0x000048, "Member 'UUVLayoutPreview::BackingRectangleMaterial' has a wrong offset!");

// Class ModelingComponents.VoxelProperties
// 0x0018 (0x00C0 - 0x00A8)
class UVoxelProperties final : public UInteractiveToolPropertySet
{
public:
	int32                                         VoxelCount;                                        // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSimplify;                                     // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveInternalSurfaces;                           // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SimplifyMaxErrorFactor;                            // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CubeRootMinComponentVolume;                        // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelProperties">();
	}
	static class UVoxelProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelProperties>();
	}
};
static_assert(alignof(UVoxelProperties) == 0x000008, "Wrong alignment on UVoxelProperties");
static_assert(sizeof(UVoxelProperties) == 0x0000C0, "Wrong size on UVoxelProperties");
static_assert(offsetof(UVoxelProperties, VoxelCount) == 0x0000A8, "Member 'UVoxelProperties::VoxelCount' has a wrong offset!");
static_assert(offsetof(UVoxelProperties, bAutoSimplify) == 0x0000AC, "Member 'UVoxelProperties::bAutoSimplify' has a wrong offset!");
static_assert(offsetof(UVoxelProperties, bRemoveInternalSurfaces) == 0x0000AD, "Member 'UVoxelProperties::bRemoveInternalSurfaces' has a wrong offset!");
static_assert(offsetof(UVoxelProperties, SimplifyMaxErrorFactor) == 0x0000B0, "Member 'UVoxelProperties::SimplifyMaxErrorFactor' has a wrong offset!");
static_assert(offsetof(UVoxelProperties, CubeRootMinComponentVolume) == 0x0000B8, "Member 'UVoxelProperties::CubeRootMinComponentVolume' has a wrong offset!");

}

