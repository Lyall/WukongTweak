#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: IKRig

#include "Basic.hpp"

#include "PBIK_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "IKRig_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class IKRig.RetargetChainSettings
// 0x0068 (0x0090 - 0x0028)
class URetargetChainSettings final : public UObject
{
public:
	class FName                                   SourceChain;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetChain;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CopyPoseUsingFK;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERetargetRotationMode                         RotationMode;                                      // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationAlpha;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERetargetTranslationMode                      TranslationMode;                                   // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TranslationAlpha;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriveIKGoal;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendToSource;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BlendToSourceWeights;                              // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StaticOffset;                                      // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Extension;                                         // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MatchSourceVelocity;                               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityThreshold;                                 // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RetargetChainSettings">();
	}
	static class URetargetChainSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URetargetChainSettings>();
	}
};
static_assert(alignof(URetargetChainSettings) == 0x000008, "Wrong alignment on URetargetChainSettings");
static_assert(sizeof(URetargetChainSettings) == 0x000090, "Wrong size on URetargetChainSettings");
static_assert(offsetof(URetargetChainSettings, SourceChain) == 0x000028, "Member 'URetargetChainSettings::SourceChain' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, TargetChain) == 0x000030, "Member 'URetargetChainSettings::TargetChain' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, CopyPoseUsingFK) == 0x000038, "Member 'URetargetChainSettings::CopyPoseUsingFK' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, RotationMode) == 0x000039, "Member 'URetargetChainSettings::RotationMode' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, RotationAlpha) == 0x00003C, "Member 'URetargetChainSettings::RotationAlpha' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, TranslationMode) == 0x000040, "Member 'URetargetChainSettings::TranslationMode' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, TranslationAlpha) == 0x000044, "Member 'URetargetChainSettings::TranslationAlpha' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, DriveIKGoal) == 0x000048, "Member 'URetargetChainSettings::DriveIKGoal' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, BlendToSource) == 0x00004C, "Member 'URetargetChainSettings::BlendToSource' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, BlendToSourceWeights) == 0x000050, "Member 'URetargetChainSettings::BlendToSourceWeights' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, StaticOffset) == 0x000068, "Member 'URetargetChainSettings::StaticOffset' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, Extension) == 0x000080, "Member 'URetargetChainSettings::Extension' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, MatchSourceVelocity) == 0x000084, "Member 'URetargetChainSettings::MatchSourceVelocity' has a wrong offset!");
static_assert(offsetof(URetargetChainSettings, VelocityThreshold) == 0x000088, "Member 'URetargetChainSettings::VelocityThreshold' has a wrong offset!");

// Class IKRig.IKRetargeter
// 0x0090 (0x00B8 - 0x0028)
class UIKRetargeter final : public UObject
{
public:
	class UIKRigDefinition*                       SourceIKRigAsset;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UIKRigDefinition*                       TargetIKRigAsset;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRetargetRoot;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRetargetFK;                                       // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRetargetIK;                                       // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FIKRetargetPose>     RetargetPoses;                                     // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FRetargetChainMap>              ChainMapping;                                      // 0x0090(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<class URetargetChainSettings*>         ChainSettings;                                     // 0x00A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   CurrentRetargetPose;                               // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRetargeter">();
	}
	static class UIKRetargeter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRetargeter>();
	}
};
static_assert(alignof(UIKRetargeter) == 0x000008, "Wrong alignment on UIKRetargeter");
static_assert(sizeof(UIKRetargeter) == 0x0000B8, "Wrong size on UIKRetargeter");
static_assert(offsetof(UIKRetargeter, SourceIKRigAsset) == 0x000028, "Member 'UIKRetargeter::SourceIKRigAsset' has a wrong offset!");
static_assert(offsetof(UIKRetargeter, TargetIKRigAsset) == 0x000030, "Member 'UIKRetargeter::TargetIKRigAsset' has a wrong offset!");
static_assert(offsetof(UIKRetargeter, bRetargetRoot) == 0x000038, "Member 'UIKRetargeter::bRetargetRoot' has a wrong offset!");
static_assert(offsetof(UIKRetargeter, bRetargetFK) == 0x000039, "Member 'UIKRetargeter::bRetargetFK' has a wrong offset!");
static_assert(offsetof(UIKRetargeter, bRetargetIK) == 0x00003A, "Member 'UIKRetargeter::bRetargetIK' has a wrong offset!");
static_assert(offsetof(UIKRetargeter, RetargetPoses) == 0x000040, "Member 'UIKRetargeter::RetargetPoses' has a wrong offset!");
static_assert(offsetof(UIKRetargeter, ChainMapping) == 0x000090, "Member 'UIKRetargeter::ChainMapping' has a wrong offset!");
static_assert(offsetof(UIKRetargeter, ChainSettings) == 0x0000A0, "Member 'UIKRetargeter::ChainSettings' has a wrong offset!");
static_assert(offsetof(UIKRetargeter, CurrentRetargetPose) == 0x0000B0, "Member 'UIKRetargeter::CurrentRetargetPose' has a wrong offset!");

// Class IKRig.IKRetargetProcessor
// 0x01D8 (0x0200 - 0x0028)
class alignas(0x10) UIKRetargetProcessor final : public UObject
{
public:
	uint8                                         Pad_28[0xF0];                                      // 0x0028(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UIKRigProcessor*                        IKRigProcessor;                                    // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0xE0];                                     // 0x0120(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRetargetProcessor">();
	}
	static class UIKRetargetProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRetargetProcessor>();
	}
};
static_assert(alignof(UIKRetargetProcessor) == 0x000010, "Wrong alignment on UIKRetargetProcessor");
static_assert(sizeof(UIKRetargetProcessor) == 0x000200, "Wrong size on UIKRetargetProcessor");
static_assert(offsetof(UIKRetargetProcessor, IKRigProcessor) == 0x000118, "Member 'UIKRetargetProcessor::IKRigProcessor' has a wrong offset!");

// Class IKRig.IKRigComponent
// 0x0018 (0x00C8 - 0x00B0)
class UIKRigComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllGoals();
	void SetIKRigGoal(const struct FIKRigGoal& Goal);
	void SetIKRigGoalPositionAndRotation(const class FName GoalName, const struct FVector& Position, const struct FQuat& Rotation, const float PositionAlpha, const float RotationAlpha);
	void SetIKRigGoalTransform(const class FName GoalName, const struct FTransform& Transform, const float PositionAlpha, const float RotationAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRigComponent">();
	}
	static class UIKRigComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRigComponent>();
	}
};
static_assert(alignof(UIKRigComponent) == 0x000008, "Wrong alignment on UIKRigComponent");
static_assert(sizeof(UIKRigComponent) == 0x0000C8, "Wrong size on UIKRigComponent");

// Class IKRig.IKRigEffectorGoal
// 0x00D8 (0x0100 - 0x0028)
class UIKRigEffectorGoal final : public UObject
{
public:
	class FName                                   GoalName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionAlpha;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAlpha;                                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             CurrentTransform;                                  // 0x0040(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitialTransform;                                  // 0x00A0(0x0060)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRigEffectorGoal">();
	}
	static class UIKRigEffectorGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRigEffectorGoal>();
	}
};
static_assert(alignof(UIKRigEffectorGoal) == 0x000010, "Wrong alignment on UIKRigEffectorGoal");
static_assert(sizeof(UIKRigEffectorGoal) == 0x000100, "Wrong size on UIKRigEffectorGoal");
static_assert(offsetof(UIKRigEffectorGoal, GoalName) == 0x000028, "Member 'UIKRigEffectorGoal::GoalName' has a wrong offset!");
static_assert(offsetof(UIKRigEffectorGoal, BoneName) == 0x000030, "Member 'UIKRigEffectorGoal::BoneName' has a wrong offset!");
static_assert(offsetof(UIKRigEffectorGoal, PositionAlpha) == 0x000038, "Member 'UIKRigEffectorGoal::PositionAlpha' has a wrong offset!");
static_assert(offsetof(UIKRigEffectorGoal, RotationAlpha) == 0x00003C, "Member 'UIKRigEffectorGoal::RotationAlpha' has a wrong offset!");
static_assert(offsetof(UIKRigEffectorGoal, CurrentTransform) == 0x000040, "Member 'UIKRigEffectorGoal::CurrentTransform' has a wrong offset!");
static_assert(offsetof(UIKRigEffectorGoal, InitialTransform) == 0x0000A0, "Member 'UIKRigEffectorGoal::InitialTransform' has a wrong offset!");

// Class IKRig.IKRigDefinition
// 0x00B8 (0x00E0 - 0x0028)
class UIKRigDefinition final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          PreviewSkeletalMesh;                               // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIKRigSkeleton                         Skeleton;                                          // 0x0038(0x0070)(NativeAccessSpecifierPublic)
	TArray<class UIKRigEffectorGoal*>             Goals;                                             // 0x00A8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UIKRigSolver*>                   Solvers;                                           // 0x00B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FRetargetDefinition                    RetargetDefinition;                                // 0x00C8(0x0018)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRigDefinition">();
	}
	static class UIKRigDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRigDefinition>();
	}
};
static_assert(alignof(UIKRigDefinition) == 0x000008, "Wrong alignment on UIKRigDefinition");
static_assert(sizeof(UIKRigDefinition) == 0x0000E0, "Wrong size on UIKRigDefinition");
static_assert(offsetof(UIKRigDefinition, PreviewSkeletalMesh) == 0x000030, "Member 'UIKRigDefinition::PreviewSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UIKRigDefinition, Skeleton) == 0x000038, "Member 'UIKRigDefinition::Skeleton' has a wrong offset!");
static_assert(offsetof(UIKRigDefinition, Goals) == 0x0000A8, "Member 'UIKRigDefinition::Goals' has a wrong offset!");
static_assert(offsetof(UIKRigDefinition, Solvers) == 0x0000B8, "Member 'UIKRigDefinition::Solvers' has a wrong offset!");
static_assert(offsetof(UIKRigDefinition, RetargetDefinition) == 0x0000C8, "Member 'UIKRigDefinition::RetargetDefinition' has a wrong offset!");

// Class IKRig.IKGoalCreatorInterface
// 0x0000 (0x0028 - 0x0028)
class IIKGoalCreatorInterface final : public IInterface
{
public:
	void AddIKGoals(TMap<class FName, struct FIKRigGoal>* OutGoals);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKGoalCreatorInterface">();
	}
	static class IIKGoalCreatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IIKGoalCreatorInterface>();
	}
};
static_assert(alignof(IIKGoalCreatorInterface) == 0x000008, "Wrong alignment on IIKGoalCreatorInterface");
static_assert(sizeof(IIKGoalCreatorInterface) == 0x000028, "Wrong size on IIKGoalCreatorInterface");

// Class IKRig.IKRigProcessor
// 0x00E8 (0x0110 - 0x0028)
class UIKRigProcessor final : public UObject
{
public:
	TArray<class UIKRigSolver*>                   Solvers;                                           // 0x0028(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0xD8];                                      // 0x0038(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRigProcessor">();
	}
	static class UIKRigProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRigProcessor>();
	}
};
static_assert(alignof(UIKRigProcessor) == 0x000008, "Wrong alignment on UIKRigProcessor");
static_assert(sizeof(UIKRigProcessor) == 0x000110, "Wrong size on UIKRigProcessor");
static_assert(offsetof(UIKRigProcessor, Solvers) == 0x000028, "Member 'UIKRigProcessor::Solvers' has a wrong offset!");

// Class IKRig.IKRigSolver
// 0x0000 (0x0028 - 0x0028)
class UIKRigSolver : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRigSolver">();
	}
	static class UIKRigSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRigSolver>();
	}
};
static_assert(alignof(UIKRigSolver) == 0x000008, "Wrong alignment on UIKRigSolver");
static_assert(sizeof(UIKRigSolver) == 0x000028, "Wrong size on UIKRigSolver");

// Class IKRig.IKRig_BodyMoverEffector
// 0x0018 (0x0040 - 0x0028)
class UIKRig_BodyMoverEffector final : public UObject
{
public:
	class FName                                   GoalName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfluenceMultiplier;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_BodyMoverEffector">();
	}
	static class UIKRig_BodyMoverEffector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_BodyMoverEffector>();
	}
};
static_assert(alignof(UIKRig_BodyMoverEffector) == 0x000008, "Wrong alignment on UIKRig_BodyMoverEffector");
static_assert(sizeof(UIKRig_BodyMoverEffector) == 0x000040, "Wrong size on UIKRig_BodyMoverEffector");
static_assert(offsetof(UIKRig_BodyMoverEffector, GoalName) == 0x000028, "Member 'UIKRig_BodyMoverEffector::GoalName' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMoverEffector, BoneName) == 0x000030, "Member 'UIKRig_BodyMoverEffector::BoneName' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMoverEffector, InfluenceMultiplier) == 0x000038, "Member 'UIKRig_BodyMoverEffector::InfluenceMultiplier' has a wrong offset!");

// Class IKRig.IKRig_BodyMover
// 0x0050 (0x0078 - 0x0028)
class UIKRig_BodyMover final : public UIKRigSolver
{
public:
	class FName                                   RootBone;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionAlpha;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionPositiveX;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionNegativeX;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionPositiveY;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionNegativeY;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionPositiveZ;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionNegativeZ;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAlpha;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateXAlpha;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateYAlpha;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateZAlpha;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UIKRig_BodyMoverEffector*>       Effectors;                                         // 0x0060(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_BodyMover">();
	}
	static class UIKRig_BodyMover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_BodyMover>();
	}
};
static_assert(alignof(UIKRig_BodyMover) == 0x000008, "Wrong alignment on UIKRig_BodyMover");
static_assert(sizeof(UIKRig_BodyMover) == 0x000078, "Wrong size on UIKRig_BodyMover");
static_assert(offsetof(UIKRig_BodyMover, RootBone) == 0x000028, "Member 'UIKRig_BodyMover::RootBone' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, PositionAlpha) == 0x000030, "Member 'UIKRig_BodyMover::PositionAlpha' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, PositionPositiveX) == 0x000034, "Member 'UIKRig_BodyMover::PositionPositiveX' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, PositionNegativeX) == 0x000038, "Member 'UIKRig_BodyMover::PositionNegativeX' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, PositionPositiveY) == 0x00003C, "Member 'UIKRig_BodyMover::PositionPositiveY' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, PositionNegativeY) == 0x000040, "Member 'UIKRig_BodyMover::PositionNegativeY' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, PositionPositiveZ) == 0x000044, "Member 'UIKRig_BodyMover::PositionPositiveZ' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, PositionNegativeZ) == 0x000048, "Member 'UIKRig_BodyMover::PositionNegativeZ' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, RotationAlpha) == 0x00004C, "Member 'UIKRig_BodyMover::RotationAlpha' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, RotateXAlpha) == 0x000050, "Member 'UIKRig_BodyMover::RotateXAlpha' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, RotateYAlpha) == 0x000054, "Member 'UIKRig_BodyMover::RotateYAlpha' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, RotateZAlpha) == 0x000058, "Member 'UIKRig_BodyMover::RotateZAlpha' has a wrong offset!");
static_assert(offsetof(UIKRig_BodyMover, Effectors) == 0x000060, "Member 'UIKRig_BodyMover::Effectors' has a wrong offset!");

// Class IKRig.IKRig_LimbEffector
// 0x0010 (0x0038 - 0x0028)
class UIKRig_LimbEffector final : public UObject
{
public:
	class FName                                   GoalName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_LimbEffector">();
	}
	static class UIKRig_LimbEffector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_LimbEffector>();
	}
};
static_assert(alignof(UIKRig_LimbEffector) == 0x000008, "Wrong alignment on UIKRig_LimbEffector");
static_assert(sizeof(UIKRig_LimbEffector) == 0x000038, "Wrong size on UIKRig_LimbEffector");
static_assert(offsetof(UIKRig_LimbEffector, GoalName) == 0x000028, "Member 'UIKRig_LimbEffector::GoalName' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbEffector, BoneName) == 0x000030, "Member 'UIKRig_LimbEffector::BoneName' has a wrong offset!");

// Class IKRig.IKRig_LimbSolver
// 0x0060 (0x0088 - 0x0028)
class UIKRig_LimbSolver final : public UIKRigSolver
{
public:
	class FName                                   RootName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachPrecision;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         HingeRotationAxis;                                 // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxIterations;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLimit;                                      // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRotationAngle;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAveragePull;                                      // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PullDistribution;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachStepAlpha;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTwistCorrection;                            // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         EndBoneForwardAxis;                                // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UIKRig_LimbEffector*                    Effector;                                          // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_LimbSolver">();
	}
	static class UIKRig_LimbSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_LimbSolver>();
	}
};
static_assert(alignof(UIKRig_LimbSolver) == 0x000008, "Wrong alignment on UIKRig_LimbSolver");
static_assert(sizeof(UIKRig_LimbSolver) == 0x000088, "Wrong size on UIKRig_LimbSolver");
static_assert(offsetof(UIKRig_LimbSolver, RootName) == 0x000028, "Member 'UIKRig_LimbSolver::RootName' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, ReachPrecision) == 0x000030, "Member 'UIKRig_LimbSolver::ReachPrecision' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, HingeRotationAxis) == 0x000034, "Member 'UIKRig_LimbSolver::HingeRotationAxis' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, MaxIterations) == 0x000038, "Member 'UIKRig_LimbSolver::MaxIterations' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, bEnableLimit) == 0x00003C, "Member 'UIKRig_LimbSolver::bEnableLimit' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, MinRotationAngle) == 0x000040, "Member 'UIKRig_LimbSolver::MinRotationAngle' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, bAveragePull) == 0x000044, "Member 'UIKRig_LimbSolver::bAveragePull' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, PullDistribution) == 0x000048, "Member 'UIKRig_LimbSolver::PullDistribution' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, ReachStepAlpha) == 0x00004C, "Member 'UIKRig_LimbSolver::ReachStepAlpha' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, bEnableTwistCorrection) == 0x000050, "Member 'UIKRig_LimbSolver::bEnableTwistCorrection' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, EndBoneForwardAxis) == 0x000051, "Member 'UIKRig_LimbSolver::EndBoneForwardAxis' has a wrong offset!");
static_assert(offsetof(UIKRig_LimbSolver, Effector) == 0x000058, "Member 'UIKRig_LimbSolver::Effector' has a wrong offset!");

// Class IKRig.IKRig_FBIKEffector
// 0x0020 (0x0048 - 0x0028)
class UIKRig_FBIKEffector final : public UObject
{
public:
	class FName                                   GoalName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrengthAlpha;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PullChainAlpha;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PinRotation;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexInSolver;                                     // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_FBIKEffector">();
	}
	static class UIKRig_FBIKEffector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_FBIKEffector>();
	}
};
static_assert(alignof(UIKRig_FBIKEffector) == 0x000008, "Wrong alignment on UIKRig_FBIKEffector");
static_assert(sizeof(UIKRig_FBIKEffector) == 0x000048, "Wrong size on UIKRig_FBIKEffector");
static_assert(offsetof(UIKRig_FBIKEffector, GoalName) == 0x000028, "Member 'UIKRig_FBIKEffector::GoalName' has a wrong offset!");
static_assert(offsetof(UIKRig_FBIKEffector, BoneName) == 0x000030, "Member 'UIKRig_FBIKEffector::BoneName' has a wrong offset!");
static_assert(offsetof(UIKRig_FBIKEffector, StrengthAlpha) == 0x000038, "Member 'UIKRig_FBIKEffector::StrengthAlpha' has a wrong offset!");
static_assert(offsetof(UIKRig_FBIKEffector, PullChainAlpha) == 0x00003C, "Member 'UIKRig_FBIKEffector::PullChainAlpha' has a wrong offset!");
static_assert(offsetof(UIKRig_FBIKEffector, PinRotation) == 0x000040, "Member 'UIKRig_FBIKEffector::PinRotation' has a wrong offset!");
static_assert(offsetof(UIKRig_FBIKEffector, IndexInSolver) == 0x000044, "Member 'UIKRig_FBIKEffector::IndexInSolver' has a wrong offset!");

// Class IKRig.IKRig_PBIKBoneSettings
// 0x0050 (0x0078 - 0x0028)
class UIKRig_PBIKBoneSettings final : public UObject
{
public:
	class FName                                   bone;                                              // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationStiffness;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionStiffness;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPBIKLimitType                                X;                                                 // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinX;                                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxX;                                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPBIKLimitType                                Y;                                                 // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinY;                                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxY;                                              // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPBIKLimitType                                Z;                                                 // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinZ;                                              // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZ;                                              // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePreferredAngles;                               // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PreferredAngles;                                   // 0x0060(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_PBIKBoneSettings">();
	}
	static class UIKRig_PBIKBoneSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_PBIKBoneSettings>();
	}
};
static_assert(alignof(UIKRig_PBIKBoneSettings) == 0x000008, "Wrong alignment on UIKRig_PBIKBoneSettings");
static_assert(sizeof(UIKRig_PBIKBoneSettings) == 0x000078, "Wrong size on UIKRig_PBIKBoneSettings");
static_assert(offsetof(UIKRig_PBIKBoneSettings, bone) == 0x000028, "Member 'UIKRig_PBIKBoneSettings::bone' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, RotationStiffness) == 0x000030, "Member 'UIKRig_PBIKBoneSettings::RotationStiffness' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, PositionStiffness) == 0x000034, "Member 'UIKRig_PBIKBoneSettings::PositionStiffness' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, X) == 0x000038, "Member 'UIKRig_PBIKBoneSettings::X' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, MinX) == 0x00003C, "Member 'UIKRig_PBIKBoneSettings::MinX' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, MaxX) == 0x000040, "Member 'UIKRig_PBIKBoneSettings::MaxX' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, Y) == 0x000044, "Member 'UIKRig_PBIKBoneSettings::Y' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, MinY) == 0x000048, "Member 'UIKRig_PBIKBoneSettings::MinY' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, MaxY) == 0x00004C, "Member 'UIKRig_PBIKBoneSettings::MaxY' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, Z) == 0x000050, "Member 'UIKRig_PBIKBoneSettings::Z' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, MinZ) == 0x000054, "Member 'UIKRig_PBIKBoneSettings::MinZ' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, MaxZ) == 0x000058, "Member 'UIKRig_PBIKBoneSettings::MaxZ' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, bUsePreferredAngles) == 0x00005C, "Member 'UIKRig_PBIKBoneSettings::bUsePreferredAngles' has a wrong offset!");
static_assert(offsetof(UIKRig_PBIKBoneSettings, PreferredAngles) == 0x000060, "Member 'UIKRig_PBIKBoneSettings::PreferredAngles' has a wrong offset!");

// Class IKRig.IKRigPBIKSolver
// 0x00A0 (0x00C8 - 0x0028)
class UIKRigPBIKSolver final : public UIKRigSolver
{
public:
	class FName                                   RootBone;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Iterations;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MassMultiplier;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinMassMultiplier;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowStretch;                                     // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPBIKRootBehavior                             RootBehavior;                                      // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartSolveFromInputPose;                          // 0x003E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UIKRig_FBIKEffector*>            Effectors;                                         // 0x0040(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UIKRig_PBIKBoneSettings*>        BoneSettings;                                      // 0x0050(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x68];                                      // 0x0060(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRigPBIKSolver">();
	}
	static class UIKRigPBIKSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRigPBIKSolver>();
	}
};
static_assert(alignof(UIKRigPBIKSolver) == 0x000008, "Wrong alignment on UIKRigPBIKSolver");
static_assert(sizeof(UIKRigPBIKSolver) == 0x0000C8, "Wrong size on UIKRigPBIKSolver");
static_assert(offsetof(UIKRigPBIKSolver, RootBone) == 0x000028, "Member 'UIKRigPBIKSolver::RootBone' has a wrong offset!");
static_assert(offsetof(UIKRigPBIKSolver, Iterations) == 0x000030, "Member 'UIKRigPBIKSolver::Iterations' has a wrong offset!");
static_assert(offsetof(UIKRigPBIKSolver, MassMultiplier) == 0x000034, "Member 'UIKRigPBIKSolver::MassMultiplier' has a wrong offset!");
static_assert(offsetof(UIKRigPBIKSolver, MinMassMultiplier) == 0x000038, "Member 'UIKRigPBIKSolver::MinMassMultiplier' has a wrong offset!");
static_assert(offsetof(UIKRigPBIKSolver, bAllowStretch) == 0x00003C, "Member 'UIKRigPBIKSolver::bAllowStretch' has a wrong offset!");
static_assert(offsetof(UIKRigPBIKSolver, RootBehavior) == 0x00003D, "Member 'UIKRigPBIKSolver::RootBehavior' has a wrong offset!");
static_assert(offsetof(UIKRigPBIKSolver, bStartSolveFromInputPose) == 0x00003E, "Member 'UIKRigPBIKSolver::bStartSolveFromInputPose' has a wrong offset!");
static_assert(offsetof(UIKRigPBIKSolver, Effectors) == 0x000040, "Member 'UIKRigPBIKSolver::Effectors' has a wrong offset!");
static_assert(offsetof(UIKRigPBIKSolver, BoneSettings) == 0x000050, "Member 'UIKRigPBIKSolver::BoneSettings' has a wrong offset!");

// Class IKRig.IKRig_PoleSolverEffector
// 0x0018 (0x0040 - 0x0028)
class UIKRig_PoleSolverEffector final : public UObject
{
public:
	class FName                                   GoalName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_PoleSolverEffector">();
	}
	static class UIKRig_PoleSolverEffector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_PoleSolverEffector>();
	}
};
static_assert(alignof(UIKRig_PoleSolverEffector) == 0x000008, "Wrong alignment on UIKRig_PoleSolverEffector");
static_assert(sizeof(UIKRig_PoleSolverEffector) == 0x000040, "Wrong size on UIKRig_PoleSolverEffector");
static_assert(offsetof(UIKRig_PoleSolverEffector, GoalName) == 0x000028, "Member 'UIKRig_PoleSolverEffector::GoalName' has a wrong offset!");
static_assert(offsetof(UIKRig_PoleSolverEffector, BoneName) == 0x000030, "Member 'UIKRig_PoleSolverEffector::BoneName' has a wrong offset!");
static_assert(offsetof(UIKRig_PoleSolverEffector, Alpha) == 0x000038, "Member 'UIKRig_PoleSolverEffector::Alpha' has a wrong offset!");

// Class IKRig.IKRig_PoleSolver
// 0x0038 (0x0060 - 0x0028)
class UIKRig_PoleSolver final : public UIKRigSolver
{
public:
	class FName                                   RootName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndName;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIKRig_PoleSolverEffector*              Effector;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_PoleSolver">();
	}
	static class UIKRig_PoleSolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_PoleSolver>();
	}
};
static_assert(alignof(UIKRig_PoleSolver) == 0x000008, "Wrong alignment on UIKRig_PoleSolver");
static_assert(sizeof(UIKRig_PoleSolver) == 0x000060, "Wrong size on UIKRig_PoleSolver");
static_assert(offsetof(UIKRig_PoleSolver, RootName) == 0x000028, "Member 'UIKRig_PoleSolver::RootName' has a wrong offset!");
static_assert(offsetof(UIKRig_PoleSolver, EndName) == 0x000030, "Member 'UIKRig_PoleSolver::EndName' has a wrong offset!");
static_assert(offsetof(UIKRig_PoleSolver, Effector) == 0x000038, "Member 'UIKRig_PoleSolver::Effector' has a wrong offset!");

// Class IKRig.IKRig_SetTransformEffector
// 0x0008 (0x0030 - 0x0028)
class UIKRig_SetTransformEffector final : public UObject
{
public:
	bool                                          bEnablePosition;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRotation;                                   // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_SetTransformEffector">();
	}
	static class UIKRig_SetTransformEffector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_SetTransformEffector>();
	}
};
static_assert(alignof(UIKRig_SetTransformEffector) == 0x000008, "Wrong alignment on UIKRig_SetTransformEffector");
static_assert(sizeof(UIKRig_SetTransformEffector) == 0x000030, "Wrong size on UIKRig_SetTransformEffector");
static_assert(offsetof(UIKRig_SetTransformEffector, bEnablePosition) == 0x000028, "Member 'UIKRig_SetTransformEffector::bEnablePosition' has a wrong offset!");
static_assert(offsetof(UIKRig_SetTransformEffector, bEnableRotation) == 0x000029, "Member 'UIKRig_SetTransformEffector::bEnableRotation' has a wrong offset!");
static_assert(offsetof(UIKRig_SetTransformEffector, Alpha) == 0x00002C, "Member 'UIKRig_SetTransformEffector::Alpha' has a wrong offset!");

// Class IKRig.IKRig_SetTransform
// 0x0020 (0x0048 - 0x0028)
class UIKRig_SetTransform final : public UIKRigSolver
{
public:
	class FName                                   Goal;                                              // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RootBone;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIKRig_SetTransformEffector*            Effector;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKRig_SetTransform">();
	}
	static class UIKRig_SetTransform* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKRig_SetTransform>();
	}
};
static_assert(alignof(UIKRig_SetTransform) == 0x000008, "Wrong alignment on UIKRig_SetTransform");
static_assert(sizeof(UIKRig_SetTransform) == 0x000048, "Wrong size on UIKRig_SetTransform");
static_assert(offsetof(UIKRig_SetTransform, Goal) == 0x000028, "Member 'UIKRig_SetTransform::Goal' has a wrong offset!");
static_assert(offsetof(UIKRig_SetTransform, RootBone) == 0x000030, "Member 'UIKRig_SetTransform::RootBone' has a wrong offset!");
static_assert(offsetof(UIKRig_SetTransform, Effector) == 0x000038, "Member 'UIKRig_SetTransform::Effector' has a wrong offset!");

}

