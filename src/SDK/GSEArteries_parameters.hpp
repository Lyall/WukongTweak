#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GSEArteries

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GSEArteries_structs.hpp"
#include "Arteries_structs.hpp"


namespace SDK::Params
{

// Function GSEArteries.GSEArteriesSplineComponent.BindSplineToBoxExtent
// 0x0018 (0x0018 - 0x0000)
struct GSEArteriesSplineComponent_BindSplineToBoxExtent final
{
public:
	struct FVector                                InBoxExtent;                                       // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesSplineComponent_BindSplineToBoxExtent) == 0x000008, "Wrong alignment on GSEArteriesSplineComponent_BindSplineToBoxExtent");
static_assert(sizeof(GSEArteriesSplineComponent_BindSplineToBoxExtent) == 0x000018, "Wrong size on GSEArteriesSplineComponent_BindSplineToBoxExtent");
static_assert(offsetof(GSEArteriesSplineComponent_BindSplineToBoxExtent, InBoxExtent) == 0x000000, "Member 'GSEArteriesSplineComponent_BindSplineToBoxExtent::InBoxExtent' has a wrong offset!");

// Function GSEArteries.GSEArteriesSplineComponent.IsGSArteriesSplineClosed
// 0x0001 (0x0001 - 0x0000)
struct GSEArteriesSplineComponent_IsGSArteriesSplineClosed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesSplineComponent_IsGSArteriesSplineClosed) == 0x000001, "Wrong alignment on GSEArteriesSplineComponent_IsGSArteriesSplineClosed");
static_assert(sizeof(GSEArteriesSplineComponent_IsGSArteriesSplineClosed) == 0x000001, "Wrong size on GSEArteriesSplineComponent_IsGSArteriesSplineClosed");
static_assert(offsetof(GSEArteriesSplineComponent_IsGSArteriesSplineClosed, ReturnValue) == 0x000000, "Member 'GSEArteriesSplineComponent_IsGSArteriesSplineClosed::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesSplineComponent.MakeGSArteriesSplineClosedAsRect
// 0x0008 (0x0008 - 0x0000)
struct GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect final
{
public:
	float                                         CloseDistance;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect) == 0x000004, "Wrong alignment on GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect");
static_assert(sizeof(GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect) == 0x000008, "Wrong size on GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect");
static_assert(offsetof(GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect, CloseDistance) == 0x000000, "Member 'GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect::CloseDistance' has a wrong offset!");
static_assert(offsetof(GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect, ReturnValue) == 0x000004, "Member 'GSEArteriesSplineComponent_MakeGSArteriesSplineClosedAsRect::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesSplineComponent.SetGSArteriesSplineMinUnitLength
// 0x0004 (0x0004 - 0x0000)
struct GSEArteriesSplineComponent_SetGSArteriesSplineMinUnitLength final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesSplineComponent_SetGSArteriesSplineMinUnitLength) == 0x000004, "Wrong alignment on GSEArteriesSplineComponent_SetGSArteriesSplineMinUnitLength");
static_assert(sizeof(GSEArteriesSplineComponent_SetGSArteriesSplineMinUnitLength) == 0x000004, "Wrong size on GSEArteriesSplineComponent_SetGSArteriesSplineMinUnitLength");
static_assert(offsetof(GSEArteriesSplineComponent_SetGSArteriesSplineMinUnitLength, Length) == 0x000000, "Member 'GSEArteriesSplineComponent_SetGSArteriesSplineMinUnitLength::Length' has a wrong offset!");

// Function GSEArteries.GSEArteriesActor.CloseSplineAndBuild
// 0x0008 (0x0008 - 0x0000)
struct GSEArteriesActor_CloseSplineAndBuild final
{
public:
	float                                         CloseDistance;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSEArteriesActor_CloseSplineAndBuild) == 0x000004, "Wrong alignment on GSEArteriesActor_CloseSplineAndBuild");
static_assert(sizeof(GSEArteriesActor_CloseSplineAndBuild) == 0x000008, "Wrong size on GSEArteriesActor_CloseSplineAndBuild");
static_assert(offsetof(GSEArteriesActor_CloseSplineAndBuild, CloseDistance) == 0x000000, "Member 'GSEArteriesActor_CloseSplineAndBuild::CloseDistance' has a wrong offset!");
static_assert(offsetof(GSEArteriesActor_CloseSplineAndBuild, ReturnValue) == 0x000004, "Member 'GSEArteriesActor_CloseSplineAndBuild::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesActor.SetSplineUnitLength
// 0x0004 (0x0004 - 0x0000)
struct GSEArteriesActor_SetSplineUnitLength final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesActor_SetSplineUnitLength) == 0x000004, "Wrong alignment on GSEArteriesActor_SetSplineUnitLength");
static_assert(sizeof(GSEArteriesActor_SetSplineUnitLength) == 0x000004, "Wrong size on GSEArteriesActor_SetSplineUnitLength");
static_assert(offsetof(GSEArteriesActor_SetSplineUnitLength, Length) == 0x000000, "Member 'GSEArteriesActor_SetSplineUnitLength::Length' has a wrong offset!");

// Function GSEArteries.GSEArteriesBoxComponent.GetSurfacePointsClockWise
// 0x0018 (0x0018 - 0x0000)
struct GSEArteriesBoxComponent_GetSurfacePointsClockWise final
{
public:
	bool                                          bBottomSurface;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesBoxComponent_GetSurfacePointsClockWise) == 0x000008, "Wrong alignment on GSEArteriesBoxComponent_GetSurfacePointsClockWise");
static_assert(sizeof(GSEArteriesBoxComponent_GetSurfacePointsClockWise) == 0x000018, "Wrong size on GSEArteriesBoxComponent_GetSurfacePointsClockWise");
static_assert(offsetof(GSEArteriesBoxComponent_GetSurfacePointsClockWise, bBottomSurface) == 0x000000, "Member 'GSEArteriesBoxComponent_GetSurfacePointsClockWise::bBottomSurface' has a wrong offset!");
static_assert(offsetof(GSEArteriesBoxComponent_GetSurfacePointsClockWise, ReturnValue) == 0x000008, "Member 'GSEArteriesBoxComponent_GetSurfacePointsClockWise::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AddLineAlongSpline
// 0x0018 (0x0018 - 0x0000)
struct GSEArteriesFuncLib_AddLineAlongSpline final
{
public:
	class USplineComponent*                       SplineComp;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AddLineAlongSpline) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_AddLineAlongSpline");
static_assert(sizeof(GSEArteriesFuncLib_AddLineAlongSpline) == 0x000018, "Wrong size on GSEArteriesFuncLib_AddLineAlongSpline");
static_assert(offsetof(GSEArteriesFuncLib_AddLineAlongSpline, SplineComp) == 0x000000, "Member 'GSEArteriesFuncLib_AddLineAlongSpline::SplineComp' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddLineAlongSpline, Length) == 0x000008, "Member 'GSEArteriesFuncLib_AddLineAlongSpline::Length' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddLineAlongSpline, ReturnValue) == 0x000010, "Member 'GSEArteriesFuncLib_AddLineAlongSpline::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AddNoiseToPoints
// 0x0100 (0x0100 - 0x0000)
struct GSEArteriesFuncLib_AddNoiseToPoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformNoiseLow;                                 // 0x0020(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseHigh;                                // 0x0080(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         StepYaw;                                           // 0x00E0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepPitch;                                         // 0x00E4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepRoll;                                          // 0x00E8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseRatio;                                        // 0x00EC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x00F0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSEArteriesFuncLib_AddNoiseToPoints) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AddNoiseToPoints");
static_assert(sizeof(GSEArteriesFuncLib_AddNoiseToPoints) == 0x000100, "Wrong size on GSEArteriesFuncLib_AddNoiseToPoints");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, TransformNoiseLow) == 0x000020, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::TransformNoiseLow' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, TransformNoiseHigh) == 0x000080, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::TransformNoiseHigh' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, StepYaw) == 0x0000E0, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::StepYaw' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, StepPitch) == 0x0000E4, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::StepPitch' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, StepRoll) == 0x0000E8, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::StepRoll' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, NoiseRatio) == 0x0000EC, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::NoiseRatio' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddNoiseToPoints, ReturnValue) == 0x0000F0, "Member 'GSEArteriesFuncLib_AddNoiseToPoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AddPerpendicularLinesAlongLine
// 0x0028 (0x0028 - 0x0000)
struct GSEArteriesFuncLib_AddPerpendicularLinesAlongLine final
{
public:
	class UArteriesObject*                        BackBones;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AddPerpendicularLinesAlongLine) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_AddPerpendicularLinesAlongLine");
static_assert(sizeof(GSEArteriesFuncLib_AddPerpendicularLinesAlongLine) == 0x000028, "Wrong size on GSEArteriesFuncLib_AddPerpendicularLinesAlongLine");
static_assert(offsetof(GSEArteriesFuncLib_AddPerpendicularLinesAlongLine, BackBones) == 0x000000, "Member 'GSEArteriesFuncLib_AddPerpendicularLinesAlongLine::BackBones' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddPerpendicularLinesAlongLine, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_AddPerpendicularLinesAlongLine::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddPerpendicularLinesAlongLine, Length) == 0x000018, "Member 'GSEArteriesFuncLib_AddPerpendicularLinesAlongLine::Length' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddPerpendicularLinesAlongLine, ReturnValue) == 0x000020, "Member 'GSEArteriesFuncLib_AddPerpendicularLinesAlongLine::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AddRoofToSimpleRect
// 0x0020 (0x0020 - 0x0000)
struct GSEArteriesFuncLib_AddRoofToSimpleRect final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AddRoofToSimpleRect) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_AddRoofToSimpleRect");
static_assert(sizeof(GSEArteriesFuncLib_AddRoofToSimpleRect) == 0x000020, "Wrong size on GSEArteriesFuncLib_AddRoofToSimpleRect");
static_assert(offsetof(GSEArteriesFuncLib_AddRoofToSimpleRect, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AddRoofToSimpleRect::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddRoofToSimpleRect, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_AddRoofToSimpleRect::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AddRoofToSimpleRect, ReturnValue) == 0x000018, "Member 'GSEArteriesFuncLib_AddRoofToSimpleRect::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedCopyToCornerCatenatePointsBySoftPath
// 0x00A0 (0x00A0 - 0x0000)
struct GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                Sources;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         UnitLength;                                        // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCatOutCorner;                                     // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlongCurveOutNormalOnly;                          // 0x0095(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath) == 0x0000A0, "Wrong size on GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath, Sources) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath::Sources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath, LocalTransform) == 0x000030, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath, UnitLength) == 0x000090, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath::UnitLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath, bCatOutCorner) == 0x000094, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath::bCatOutCorner' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath, bAlongCurveOutNormalOnly) == 0x000095, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath::bAlongCurveOutNormalOnly' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath, ReturnValue) == 0x000098, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerCatenatePointsBySoftPath::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedCopyToCornerPointsBySoftPath
// 0x00A0 (0x00A0 - 0x0000)
struct GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                Sources;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bAsInnerCorner;                                    // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlongCurveOutNormalOnly;                          // 0x0091(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath) == 0x0000A0, "Wrong size on GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath, Sources) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath::Sources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath, LocalTransform) == 0x000030, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath, bAsInnerCorner) == 0x000090, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath::bAsInnerCorner' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath, bAlongCurveOutNormalOnly) == 0x000091, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath::bAlongCurveOutNormalOnly' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath, ReturnValue) == 0x000098, "Member 'GSEArteriesFuncLib_AdvancedCopyToCornerPointsBySoftPath::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedCopyToEndPointsBySoftPath
// 0x00A0 (0x00A0 - 0x0000)
struct GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                Sources;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreDelatZ;                                     // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath) == 0x0000A0, "Wrong size on GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath, Sources) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath::Sources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath, LocalTransform) == 0x000030, "Member 'GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath, bIgnoreDelatZ) == 0x000090, "Member 'GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath::bIgnoreDelatZ' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath, ReturnValue) == 0x000098, "Member 'GSEArteriesFuncLib_AdvancedCopyToEndPointsBySoftPath::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedCopyToPoints
// 0x00A0 (0x00A0 - 0x0000)
struct GSEArteriesFuncLib_AdvancedCopyToPoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Groups;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Sources;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedCopyToPoints) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedCopyToPoints");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedCopyToPoints) == 0x0000A0, "Wrong size on GSEArteriesFuncLib_AdvancedCopyToPoints");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedCopyToPoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPoints, Groups) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedCopyToPoints::Groups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPoints, Sources) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedCopyToPoints::Sources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPoints, LocalTransform) == 0x000030, "Member 'GSEArteriesFuncLib_AdvancedCopyToPoints::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPoints, ReturnValue) == 0x000090, "Member 'GSEArteriesFuncLib_AdvancedCopyToPoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedCopyToPointsBySoftPath
// 0x00A0 (0x00A0 - 0x0000)
struct GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Groups;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                Sources;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCorner;                                     // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCornerAdjacent;                             // 0x0091(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath) == 0x0000A0, "Wrong size on GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath, Groups) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath::Groups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath, Sources) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath::Sources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath, LocalTransform) == 0x000030, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath, bIgnoreCorner) == 0x000090, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath::bIgnoreCorner' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath, bIgnoreCornerAdjacent) == 0x000091, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath::bIgnoreCornerAdjacent' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath, ReturnValue) == 0x000098, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsBySoftPath::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedCopyToPointsByTrSoftPath
// 0x0170 (0x0170 - 0x0000)
struct GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Groups;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBaseTransformedSoftObject>     Sources;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseLow;                                 // 0x0090(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseHigh;                                // 0x00F0(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         EachPathWidth;                                     // 0x0150(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCorner;                                     // 0x0154(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCornerAdjacent;                             // 0x0155(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateMultiPath;                                // 0x0156(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_157[0x1];                                      // 0x0157(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GenPathCount;                                      // 0x0158(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0160(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath) == 0x000170, "Wrong size on GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, Groups) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::Groups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, Sources) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::Sources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, LocalTransform) == 0x000030, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, TransformNoiseLow) == 0x000090, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::TransformNoiseLow' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, TransformNoiseHigh) == 0x0000F0, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::TransformNoiseHigh' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, EachPathWidth) == 0x000150, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::EachPathWidth' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, bIgnoreCorner) == 0x000154, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::bIgnoreCorner' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, bIgnoreCornerAdjacent) == 0x000155, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::bIgnoreCornerAdjacent' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, bGenerateMultiPath) == 0x000156, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::bGenerateMultiPath' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, GenPathCount) == 0x000158, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::GenPathCount' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath, ReturnValue) == 0x000160, "Member 'GSEArteriesFuncLib_AdvancedCopyToPointsByTrSoftPath::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedSmartCopyToPointsByMeshExtents
// 0x0170 (0x0170 - 0x0000)
struct GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Groups;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    MeshSources;                                       // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseLow;                                 // 0x0090(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseHigh;                                // 0x00F0(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EGSATERIES_SAMPLE_AXIS                        SampleAxis;                                        // 0x0150(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepYaw;                                           // 0x0154(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepPitch;                                         // 0x0158(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepRoll;                                          // 0x015C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineNoiseChance;                                   // 0x0160(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResampleScale;                                     // 0x0164(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0168(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents) == 0x000170, "Wrong size on GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, Groups) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::Groups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, MeshSources) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::MeshSources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, LocalTransform) == 0x000030, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, TransformNoiseLow) == 0x000090, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::TransformNoiseLow' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, TransformNoiseHigh) == 0x0000F0, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::TransformNoiseHigh' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, SampleAxis) == 0x000150, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::SampleAxis' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, StepYaw) == 0x000154, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::StepYaw' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, StepPitch) == 0x000158, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::StepPitch' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, StepRoll) == 0x00015C, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::StepRoll' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, LineNoiseChance) == 0x000160, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::LineNoiseChance' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, ResampleScale) == 0x000164, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::ResampleScale' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents, ReturnValue) == 0x000168, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsByMeshExtents::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedSmartCopyToPointsBySoftObjectExtents
// 0x0190 (0x0190 - 0x0000)
struct GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Groups;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                Sources;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                NoiseSources;                                      // 0x0028(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0040(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseLow;                                 // 0x00A0(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseHigh;                                // 0x0100(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EGSATERIES_SAMPLE_AXIS                        SampleAxis;                                        // 0x0160(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepYaw;                                           // 0x0164(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepPitch;                                         // 0x0168(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepRoll;                                          // 0x016C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineTwistChance;                                   // 0x0170(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnitNoiseChane;                                    // 0x0174(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResampleScale;                                     // 0x0178(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationCount;                                    // 0x017C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CurvelyAdjusting;                                  // 0x0180(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0188(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents) == 0x000190, "Wrong size on GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, Groups) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::Groups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, Sources) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::Sources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, NoiseSources) == 0x000028, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::NoiseSources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, LocalTransform) == 0x000040, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, TransformNoiseLow) == 0x0000A0, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::TransformNoiseLow' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, TransformNoiseHigh) == 0x000100, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::TransformNoiseHigh' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, SampleAxis) == 0x000160, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::SampleAxis' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, StepYaw) == 0x000164, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::StepYaw' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, StepPitch) == 0x000168, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::StepPitch' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, StepRoll) == 0x00016C, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::StepRoll' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, LineTwistChance) == 0x000170, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::LineTwistChance' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, UnitNoiseChane) == 0x000174, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::UnitNoiseChane' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, ResampleScale) == 0x000178, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::ResampleScale' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, IterationCount) == 0x00017C, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::IterationCount' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, CurvelyAdjusting) == 0x000180, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::CurvelyAdjusting' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents, ReturnValue) == 0x000188, "Member 'GSEArteriesFuncLib_AdvancedSmartCopyToPointsBySoftObjectExtents::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AdvancedSmartStackToPointsBySoftPath
// 0x01D0 (0x01D0 - 0x0000)
struct GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath final
{
public:
	class AArteriesActor*                         OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedObjectsNum;                                // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Groups;                                            // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, struct FGSArteriesStackRule> SoftPathToRuleMap;                                 // 0x0028(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0080(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseLow;                                 // 0x00E0(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FTransform                             TransformNoiseHigh;                                // 0x0140(0x0060)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        InCustomCornerLocs;                                // 0x01A0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         StepYaw;                                           // 0x01B0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepPitch;                                         // 0x01B4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepRoll;                                          // 0x01B8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x01C0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath) == 0x000010, "Wrong alignment on GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath");
static_assert(sizeof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath) == 0x0001D0, "Wrong size on GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, OwnerActor) == 0x000000, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::OwnerActor' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, Target) == 0x000008, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, ExpectedObjectsNum) == 0x000010, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::ExpectedObjectsNum' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, Groups) == 0x000018, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::Groups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, SoftPathToRuleMap) == 0x000028, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::SoftPathToRuleMap' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, LocalTransform) == 0x000080, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::LocalTransform' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, TransformNoiseLow) == 0x0000E0, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::TransformNoiseLow' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, TransformNoiseHigh) == 0x000140, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::TransformNoiseHigh' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, InCustomCornerLocs) == 0x0001A0, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::InCustomCornerLocs' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, StepYaw) == 0x0001B0, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::StepYaw' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, StepPitch) == 0x0001B4, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::StepPitch' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, StepRoll) == 0x0001B8, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::StepRoll' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath, ReturnValue) == 0x0001C0, "Member 'GSEArteriesFuncLib_AdvancedSmartStackToPointsBySoftPath::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.AggregatePoints
// 0x0028 (0x0028 - 0x0000)
struct GSEArteriesFuncLib_AggregatePoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Groups;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredGroupNum;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_AggregatePoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_AggregatePoints");
static_assert(sizeof(GSEArteriesFuncLib_AggregatePoints) == 0x000028, "Wrong size on GSEArteriesFuncLib_AggregatePoints");
static_assert(offsetof(GSEArteriesFuncLib_AggregatePoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_AggregatePoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AggregatePoints, Groups) == 0x000008, "Member 'GSEArteriesFuncLib_AggregatePoints::Groups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AggregatePoints, DesiredGroupNum) == 0x000018, "Member 'GSEArteriesFuncLib_AggregatePoints::DesiredGroupNum' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_AggregatePoints, ReturnValue) == 0x000020, "Member 'GSEArteriesFuncLib_AggregatePoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.BreakPrimitivesIntoPoints
// 0x0028 (0x0028 - 0x0000)
struct GSEArteriesFuncLib_BreakPrimitivesIntoPoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepRotation;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetUpDirection;                                 // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_BreakPrimitivesIntoPoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_BreakPrimitivesIntoPoints");
static_assert(sizeof(GSEArteriesFuncLib_BreakPrimitivesIntoPoints) == 0x000028, "Wrong size on GSEArteriesFuncLib_BreakPrimitivesIntoPoints");
static_assert(offsetof(GSEArteriesFuncLib_BreakPrimitivesIntoPoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_BreakPrimitivesIntoPoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_BreakPrimitivesIntoPoints, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_BreakPrimitivesIntoPoints::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_BreakPrimitivesIntoPoints, bKeepRotation) == 0x000018, "Member 'GSEArteriesFuncLib_BreakPrimitivesIntoPoints::bKeepRotation' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_BreakPrimitivesIntoPoints, bResetUpDirection) == 0x000019, "Member 'GSEArteriesFuncLib_BreakPrimitivesIntoPoints::bResetUpDirection' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_BreakPrimitivesIntoPoints, ReturnValue) == 0x000020, "Member 'GSEArteriesFuncLib_BreakPrimitivesIntoPoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.CreateGSArteriesPoint
// 0x0020 (0x0020 - 0x0000)
struct GSEArteriesFuncLib_CreateGSArteriesPoint final
{
public:
	struct FVector                                InPosition;                                        // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_CreateGSArteriesPoint) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_CreateGSArteriesPoint");
static_assert(sizeof(GSEArteriesFuncLib_CreateGSArteriesPoint) == 0x000020, "Wrong size on GSEArteriesFuncLib_CreateGSArteriesPoint");
static_assert(offsetof(GSEArteriesFuncLib_CreateGSArteriesPoint, InPosition) == 0x000000, "Member 'GSEArteriesFuncLib_CreateGSArteriesPoint::InPosition' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateGSArteriesPoint, ReturnValue) == 0x000018, "Member 'GSEArteriesFuncLib_CreateGSArteriesPoint::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.CreateNoiseGroup
// 0x0048 (0x0048 - 0x0000)
struct GSEArteriesFuncLib_CreateNoiseGroup final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutGeneralGroup;                                   // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutNoiseGroup;                                     // 0x0028(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseRatio;                                        // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_CreateNoiseGroup) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_CreateNoiseGroup");
static_assert(sizeof(GSEArteriesFuncLib_CreateNoiseGroup) == 0x000048, "Wrong size on GSEArteriesFuncLib_CreateNoiseGroup");
static_assert(offsetof(GSEArteriesFuncLib_CreateNoiseGroup, Target) == 0x000000, "Member 'GSEArteriesFuncLib_CreateNoiseGroup::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateNoiseGroup, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_CreateNoiseGroup::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateNoiseGroup, OutGeneralGroup) == 0x000018, "Member 'GSEArteriesFuncLib_CreateNoiseGroup::OutGeneralGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateNoiseGroup, OutNoiseGroup) == 0x000028, "Member 'GSEArteriesFuncLib_CreateNoiseGroup::OutNoiseGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateNoiseGroup, NoiseRatio) == 0x000038, "Member 'GSEArteriesFuncLib_CreateNoiseGroup::NoiseRatio' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateNoiseGroup, ReturnValue) == 0x000040, "Member 'GSEArteriesFuncLib_CreateNoiseGroup::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.CreateSamplingSurface
// 0x0040 (0x0040 - 0x0000)
struct GSEArteriesFuncLib_CreateSamplingSurface final
{
public:
	class UArteriesObject*                        BackBones;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InPrimGroup;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InDirection;                                       // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_CreateSamplingSurface) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_CreateSamplingSurface");
static_assert(sizeof(GSEArteriesFuncLib_CreateSamplingSurface) == 0x000040, "Wrong size on GSEArteriesFuncLib_CreateSamplingSurface");
static_assert(offsetof(GSEArteriesFuncLib_CreateSamplingSurface, BackBones) == 0x000000, "Member 'GSEArteriesFuncLib_CreateSamplingSurface::BackBones' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateSamplingSurface, InPrimGroup) == 0x000008, "Member 'GSEArteriesFuncLib_CreateSamplingSurface::InPrimGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateSamplingSurface, Length) == 0x000018, "Member 'GSEArteriesFuncLib_CreateSamplingSurface::Length' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateSamplingSurface, InDirection) == 0x000020, "Member 'GSEArteriesFuncLib_CreateSamplingSurface::InDirection' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateSamplingSurface, ReturnValue) == 0x000038, "Member 'GSEArteriesFuncLib_CreateSamplingSurface::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.CreateSlopeSideSamplingSurface
// 0x0028 (0x0028 - 0x0000)
struct GSEArteriesFuncLib_CreateSlopeSideSamplingSurface final
{
public:
	class UArteriesObject*                        BackBones;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InPrimGroup;                                       // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetLength;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_CreateSlopeSideSamplingSurface) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_CreateSlopeSideSamplingSurface");
static_assert(sizeof(GSEArteriesFuncLib_CreateSlopeSideSamplingSurface) == 0x000028, "Wrong size on GSEArteriesFuncLib_CreateSlopeSideSamplingSurface");
static_assert(offsetof(GSEArteriesFuncLib_CreateSlopeSideSamplingSurface, BackBones) == 0x000000, "Member 'GSEArteriesFuncLib_CreateSlopeSideSamplingSurface::BackBones' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateSlopeSideSamplingSurface, InPrimGroup) == 0x000008, "Member 'GSEArteriesFuncLib_CreateSlopeSideSamplingSurface::InPrimGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateSlopeSideSamplingSurface, OffsetLength) == 0x000018, "Member 'GSEArteriesFuncLib_CreateSlopeSideSamplingSurface::OffsetLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_CreateSlopeSideSamplingSurface, ReturnValue) == 0x000020, "Member 'GSEArteriesFuncLib_CreateSlopeSideSamplingSurface::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.FindCornerPoints
// 0x0028 (0x0028 - 0x0000)
struct GSEArteriesFuncLib_FindCornerPoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WithAdjacentPoints;                                // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_FindCornerPoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_FindCornerPoints");
static_assert(sizeof(GSEArteriesFuncLib_FindCornerPoints) == 0x000028, "Wrong size on GSEArteriesFuncLib_FindCornerPoints");
static_assert(offsetof(GSEArteriesFuncLib_FindCornerPoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_FindCornerPoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindCornerPoints, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_FindCornerPoints::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindCornerPoints, WithAdjacentPoints) == 0x000018, "Member 'GSEArteriesFuncLib_FindCornerPoints::WithAdjacentPoints' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindCornerPoints, ReturnValue) == 0x000020, "Member 'GSEArteriesFuncLib_FindCornerPoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.FindDoorFeaturePoints
// 0x0060 (0x0060 - 0x0000)
struct GSEArteriesFuncLib_FindDoorFeaturePoints final
{
public:
	class AArteriesActor*                         OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DoorNum;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnitLength;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorUnitLength;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DoorGroup;                                         // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DoorCatnateGroup;                                  // 0x0030(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RestGroup;                                         // 0x0040(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorCatUnitLength;                                 // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSATERIES_SIDE_SELECT_FEATURE                ESelectSide;                                       // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSATERIES_SIDE_DISTRIBUTION_FEATURE          EDistribute;                                       // 0x0055(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_FindDoorFeaturePoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_FindDoorFeaturePoints");
static_assert(sizeof(GSEArteriesFuncLib_FindDoorFeaturePoints) == 0x000060, "Wrong size on GSEArteriesFuncLib_FindDoorFeaturePoints");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, OwnerActor) == 0x000000, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::OwnerActor' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, Target) == 0x000008, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, DoorNum) == 0x000010, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::DoorNum' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, UnitLength) == 0x000014, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::UnitLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, DoorUnitLength) == 0x000018, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::DoorUnitLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, DoorGroup) == 0x000020, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::DoorGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, DoorCatnateGroup) == 0x000030, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::DoorCatnateGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, RestGroup) == 0x000040, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::RestGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, DoorCatUnitLength) == 0x000050, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::DoorCatUnitLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, ESelectSide) == 0x000054, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::ESelectSide' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, EDistribute) == 0x000055, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::EDistribute' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindDoorFeaturePoints, ReturnValue) == 0x000058, "Member 'GSEArteriesFuncLib_FindDoorFeaturePoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.FindFlatFeaturePoints
// 0x0028 (0x0028 - 0x0000)
struct GSEArteriesFuncLib_FindFlatFeaturePoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFindSlopePoints;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Tolerence;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_FindFlatFeaturePoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_FindFlatFeaturePoints");
static_assert(sizeof(GSEArteriesFuncLib_FindFlatFeaturePoints) == 0x000028, "Wrong size on GSEArteriesFuncLib_FindFlatFeaturePoints");
static_assert(offsetof(GSEArteriesFuncLib_FindFlatFeaturePoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_FindFlatFeaturePoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindFlatFeaturePoints, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_FindFlatFeaturePoints::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindFlatFeaturePoints, bFindSlopePoints) == 0x000018, "Member 'GSEArteriesFuncLib_FindFlatFeaturePoints::bFindSlopePoints' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindFlatFeaturePoints, Tolerence) == 0x00001C, "Member 'GSEArteriesFuncLib_FindFlatFeaturePoints::Tolerence' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindFlatFeaturePoints, ReturnValue) == 0x000020, "Member 'GSEArteriesFuncLib_FindFlatFeaturePoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.FindLeafPoints
// 0x0020 (0x0020 - 0x0000)
struct GSEArteriesFuncLib_FindLeafPoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_FindLeafPoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_FindLeafPoints");
static_assert(sizeof(GSEArteriesFuncLib_FindLeafPoints) == 0x000020, "Wrong size on GSEArteriesFuncLib_FindLeafPoints");
static_assert(offsetof(GSEArteriesFuncLib_FindLeafPoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_FindLeafPoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindLeafPoints, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_FindLeafPoints::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindLeafPoints, ReturnValue) == 0x000018, "Member 'GSEArteriesFuncLib_FindLeafPoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.FindWindowFeaturePoints
// 0x0018 (0x0018 - 0x0000)
struct GSEArteriesFuncLib_FindWindowFeaturePoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WindowNum;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindowUnitLength;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_FindWindowFeaturePoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_FindWindowFeaturePoints");
static_assert(sizeof(GSEArteriesFuncLib_FindWindowFeaturePoints) == 0x000018, "Wrong size on GSEArteriesFuncLib_FindWindowFeaturePoints");
static_assert(offsetof(GSEArteriesFuncLib_FindWindowFeaturePoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_FindWindowFeaturePoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindWindowFeaturePoints, WindowNum) == 0x000008, "Member 'GSEArteriesFuncLib_FindWindowFeaturePoints::WindowNum' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindWindowFeaturePoints, WindowUnitLength) == 0x00000C, "Member 'GSEArteriesFuncLib_FindWindowFeaturePoints::WindowUnitLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_FindWindowFeaturePoints, ReturnValue) == 0x000010, "Member 'GSEArteriesFuncLib_FindWindowFeaturePoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.GenRandSeedStream
// 0x0008 (0x0008 - 0x0000)
struct GSEArteriesFuncLib_GenRandSeedStream final
{
public:
	struct FRandomStream                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_GenRandSeedStream) == 0x000004, "Wrong alignment on GSEArteriesFuncLib_GenRandSeedStream");
static_assert(sizeof(GSEArteriesFuncLib_GenRandSeedStream) == 0x000008, "Wrong size on GSEArteriesFuncLib_GenRandSeedStream");
static_assert(offsetof(GSEArteriesFuncLib_GenRandSeedStream, ReturnValue) == 0x000000, "Member 'GSEArteriesFuncLib_GenRandSeedStream::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.GetNumberOfPoints
// 0x0010 (0x0010 - 0x0000)
struct GSEArteriesFuncLib_GetNumberOfPoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GSEArteriesFuncLib_GetNumberOfPoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_GetNumberOfPoints");
static_assert(sizeof(GSEArteriesFuncLib_GetNumberOfPoints) == 0x000010, "Wrong size on GSEArteriesFuncLib_GetNumberOfPoints");
static_assert(offsetof(GSEArteriesFuncLib_GetNumberOfPoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_GetNumberOfPoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_GetNumberOfPoints, ReturnValue) == 0x000008, "Member 'GSEArteriesFuncLib_GetNumberOfPoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.MakeHoles
// 0x0040 (0x0040 - 0x0000)
struct GSEArteriesFuncLib_MakeHoles final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HoleGroups;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutHoleGroups;                                     // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHoleIteration;                                  // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHoleNum;                                        // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoleIterationChance;                               // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_MakeHoles) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_MakeHoles");
static_assert(sizeof(GSEArteriesFuncLib_MakeHoles) == 0x000040, "Wrong size on GSEArteriesFuncLib_MakeHoles");
static_assert(offsetof(GSEArteriesFuncLib_MakeHoles, Target) == 0x000000, "Member 'GSEArteriesFuncLib_MakeHoles::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MakeHoles, HoleGroups) == 0x000008, "Member 'GSEArteriesFuncLib_MakeHoles::HoleGroups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MakeHoles, OutHoleGroups) == 0x000018, "Member 'GSEArteriesFuncLib_MakeHoles::OutHoleGroups' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MakeHoles, MaxHoleIteration) == 0x000028, "Member 'GSEArteriesFuncLib_MakeHoles::MaxHoleIteration' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MakeHoles, MaxHoleNum) == 0x00002C, "Member 'GSEArteriesFuncLib_MakeHoles::MaxHoleNum' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MakeHoles, HoleIterationChance) == 0x000030, "Member 'GSEArteriesFuncLib_MakeHoles::HoleIterationChance' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MakeHoles, ReturnValue) == 0x000038, "Member 'GSEArteriesFuncLib_MakeHoles::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.MergeAndCleanInstancedMeshToStaticSurface
// 0x0028 (0x0028 - 0x0000)
struct GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface final
{
public:
	class AArteriesActor*                         OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitLandscapeOnly;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RayCastDistance;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerence;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface");
static_assert(sizeof(GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface) == 0x000028, "Wrong size on GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface");
static_assert(offsetof(GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface, OwnerActor) == 0x000000, "Member 'GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface::OwnerActor' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface, Target) == 0x000008, "Member 'GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface, bHitLandscapeOnly) == 0x000010, "Member 'GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface::bHitLandscapeOnly' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface, RayCastDistance) == 0x000014, "Member 'GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface::RayCastDistance' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface, Tolerence) == 0x000018, "Member 'GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface::Tolerence' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface, ReturnValue) == 0x000020, "Member 'GSEArteriesFuncLib_MergeAndCleanInstancedMeshToStaticSurface::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.MergePointsToGrid
// 0x0040 (0x0040 - 0x0000)
struct GSEArteriesFuncLib_MergePointsToGrid final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridSize;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_MergePointsToGrid) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_MergePointsToGrid");
static_assert(sizeof(GSEArteriesFuncLib_MergePointsToGrid) == 0x000040, "Wrong size on GSEArteriesFuncLib_MergePointsToGrid");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToGrid, Target) == 0x000000, "Member 'GSEArteriesFuncLib_MergePointsToGrid::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToGrid, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_MergePointsToGrid::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToGrid, GridSize) == 0x000018, "Member 'GSEArteriesFuncLib_MergePointsToGrid::GridSize' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToGrid, Offset) == 0x000020, "Member 'GSEArteriesFuncLib_MergePointsToGrid::Offset' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToGrid, ReturnValue) == 0x000038, "Member 'GSEArteriesFuncLib_MergePointsToGrid::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.MergePointsToLandscape
// 0x0048 (0x0048 - 0x0000)
struct GSEArteriesFuncLib_MergePointsToLandscape final
{
public:
	class AArteriesActor*                         OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayCastOffset;                                     // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayDistance;                                       // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_MergePointsToLandscape) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_MergePointsToLandscape");
static_assert(sizeof(GSEArteriesFuncLib_MergePointsToLandscape) == 0x000048, "Wrong size on GSEArteriesFuncLib_MergePointsToLandscape");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToLandscape, OwnerActor) == 0x000000, "Member 'GSEArteriesFuncLib_MergePointsToLandscape::OwnerActor' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToLandscape, Target) == 0x000008, "Member 'GSEArteriesFuncLib_MergePointsToLandscape::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToLandscape, InGroup) == 0x000010, "Member 'GSEArteriesFuncLib_MergePointsToLandscape::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToLandscape, RayCastOffset) == 0x000020, "Member 'GSEArteriesFuncLib_MergePointsToLandscape::RayCastOffset' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToLandscape, RayDistance) == 0x000038, "Member 'GSEArteriesFuncLib_MergePointsToLandscape::RayDistance' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToLandscape, ReturnValue) == 0x000040, "Member 'GSEArteriesFuncLib_MergePointsToLandscape::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.MergePointsToPrimitive
// 0x0040 (0x0040 - 0x0000)
struct GSEArteriesFuncLib_MergePointsToPrimitive final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeClose;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_MergePointsToPrimitive) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_MergePointsToPrimitive");
static_assert(sizeof(GSEArteriesFuncLib_MergePointsToPrimitive) == 0x000040, "Wrong size on GSEArteriesFuncLib_MergePointsToPrimitive");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToPrimitive, Target) == 0x000000, "Member 'GSEArteriesFuncLib_MergePointsToPrimitive::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToPrimitive, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_MergePointsToPrimitive::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToPrimitive, Offset) == 0x000018, "Member 'GSEArteriesFuncLib_MergePointsToPrimitive::Offset' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToPrimitive, bMakeClose) == 0x000030, "Member 'GSEArteriesFuncLib_MergePointsToPrimitive::bMakeClose' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToPrimitive, ReturnValue) == 0x000038, "Member 'GSEArteriesFuncLib_MergePointsToPrimitive::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.MergePointsToStaticSurface
// 0x0048 (0x0048 - 0x0000)
struct GSEArteriesFuncLib_MergePointsToStaticSurface final
{
public:
	class AArteriesActor*                         OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayCastOffset;                                     // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayDistance;                                       // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_MergePointsToStaticSurface) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_MergePointsToStaticSurface");
static_assert(sizeof(GSEArteriesFuncLib_MergePointsToStaticSurface) == 0x000048, "Wrong size on GSEArteriesFuncLib_MergePointsToStaticSurface");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToStaticSurface, OwnerActor) == 0x000000, "Member 'GSEArteriesFuncLib_MergePointsToStaticSurface::OwnerActor' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToStaticSurface, Target) == 0x000008, "Member 'GSEArteriesFuncLib_MergePointsToStaticSurface::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToStaticSurface, InGroup) == 0x000010, "Member 'GSEArteriesFuncLib_MergePointsToStaticSurface::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToStaticSurface, RayCastOffset) == 0x000020, "Member 'GSEArteriesFuncLib_MergePointsToStaticSurface::RayCastOffset' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToStaticSurface, RayDistance) == 0x000038, "Member 'GSEArteriesFuncLib_MergePointsToStaticSurface::RayDistance' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_MergePointsToStaticSurface, ReturnValue) == 0x000040, "Member 'GSEArteriesFuncLib_MergePointsToStaticSurface::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.RayCastDown
// 0x0050 (0x0050 - 0x0000)
struct GSEArteriesFuncLib_RayCastDown final
{
public:
	class AArteriesActor*                         OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        BackBones;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayCastOffset;                                     // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayCastDistance;                                   // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndOffsetLength;                                   // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitLandscapeOnly;                                 // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_RayCastDown) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_RayCastDown");
static_assert(sizeof(GSEArteriesFuncLib_RayCastDown) == 0x000050, "Wrong size on GSEArteriesFuncLib_RayCastDown");
static_assert(offsetof(GSEArteriesFuncLib_RayCastDown, OwnerActor) == 0x000000, "Member 'GSEArteriesFuncLib_RayCastDown::OwnerActor' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_RayCastDown, BackBones) == 0x000008, "Member 'GSEArteriesFuncLib_RayCastDown::BackBones' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_RayCastDown, InGroup) == 0x000010, "Member 'GSEArteriesFuncLib_RayCastDown::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_RayCastDown, RayCastOffset) == 0x000020, "Member 'GSEArteriesFuncLib_RayCastDown::RayCastOffset' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_RayCastDown, RayCastDistance) == 0x000038, "Member 'GSEArteriesFuncLib_RayCastDown::RayCastDistance' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_RayCastDown, EndOffsetLength) == 0x00003C, "Member 'GSEArteriesFuncLib_RayCastDown::EndOffsetLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_RayCastDown, bHitLandscapeOnly) == 0x000040, "Member 'GSEArteriesFuncLib_RayCastDown::bHitLandscapeOnly' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_RayCastDown, ReturnValue) == 0x000048, "Member 'GSEArteriesFuncLib_RayCastDown::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.ResampleAsMidPoints
// 0x0010 (0x0010 - 0x0000)
struct GSEArteriesFuncLib_ResampleAsMidPoints final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_ResampleAsMidPoints) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_ResampleAsMidPoints");
static_assert(sizeof(GSEArteriesFuncLib_ResampleAsMidPoints) == 0x000010, "Wrong size on GSEArteriesFuncLib_ResampleAsMidPoints");
static_assert(offsetof(GSEArteriesFuncLib_ResampleAsMidPoints, Target) == 0x000000, "Member 'GSEArteriesFuncLib_ResampleAsMidPoints::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResampleAsMidPoints, ReturnValue) == 0x000008, "Member 'GSEArteriesFuncLib_ResampleAsMidPoints::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.ResampleEachPrimsByLengths
// 0x0030 (0x0030 - 0x0000)
struct GSEArteriesFuncLib_ResampleEachPrimsByLengths final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 SegmentLengthSets;                                 // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          ByEdge;                                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSegments;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArteriesTangentOutputType                    OutputType;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_ResampleEachPrimsByLengths) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_ResampleEachPrimsByLengths");
static_assert(sizeof(GSEArteriesFuncLib_ResampleEachPrimsByLengths) == 0x000030, "Wrong size on GSEArteriesFuncLib_ResampleEachPrimsByLengths");
static_assert(offsetof(GSEArteriesFuncLib_ResampleEachPrimsByLengths, Target) == 0x000000, "Member 'GSEArteriesFuncLib_ResampleEachPrimsByLengths::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResampleEachPrimsByLengths, SegmentLengthSets) == 0x000008, "Member 'GSEArteriesFuncLib_ResampleEachPrimsByLengths::SegmentLengthSets' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResampleEachPrimsByLengths, ByEdge) == 0x000018, "Member 'GSEArteriesFuncLib_ResampleEachPrimsByLengths::ByEdge' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResampleEachPrimsByLengths, NumSegments) == 0x00001C, "Member 'GSEArteriesFuncLib_ResampleEachPrimsByLengths::NumSegments' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResampleEachPrimsByLengths, OutputType) == 0x000020, "Member 'GSEArteriesFuncLib_ResampleEachPrimsByLengths::OutputType' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResampleEachPrimsByLengths, ReturnValue) == 0x000028, "Member 'GSEArteriesFuncLib_ResampleEachPrimsByLengths::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.ResizePrimitive2D
// 0x0028 (0x0028 - 0x0000)
struct GSEArteriesFuncLib_ResizePrimitive2D final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InGroup;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInwards;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_ResizePrimitive2D) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_ResizePrimitive2D");
static_assert(sizeof(GSEArteriesFuncLib_ResizePrimitive2D) == 0x000028, "Wrong size on GSEArteriesFuncLib_ResizePrimitive2D");
static_assert(offsetof(GSEArteriesFuncLib_ResizePrimitive2D, Target) == 0x000000, "Member 'GSEArteriesFuncLib_ResizePrimitive2D::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResizePrimitive2D, InGroup) == 0x000008, "Member 'GSEArteriesFuncLib_ResizePrimitive2D::InGroup' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResizePrimitive2D, Distance) == 0x000018, "Member 'GSEArteriesFuncLib_ResizePrimitive2D::Distance' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResizePrimitive2D, bInwards) == 0x00001C, "Member 'GSEArteriesFuncLib_ResizePrimitive2D::bInwards' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ResizePrimitive2D, ReturnValue) == 0x000020, "Member 'GSEArteriesFuncLib_ResizePrimitive2D::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.ScalizeGridPrimitive
// 0x0018 (0x0018 - 0x0000)
struct GSEArteriesFuncLib_ScalizeGridPrimitive final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnitLength;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArteriesObject*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_ScalizeGridPrimitive) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_ScalizeGridPrimitive");
static_assert(sizeof(GSEArteriesFuncLib_ScalizeGridPrimitive) == 0x000018, "Wrong size on GSEArteriesFuncLib_ScalizeGridPrimitive");
static_assert(offsetof(GSEArteriesFuncLib_ScalizeGridPrimitive, Target) == 0x000000, "Member 'GSEArteriesFuncLib_ScalizeGridPrimitive::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ScalizeGridPrimitive, UnitLength) == 0x000008, "Member 'GSEArteriesFuncLib_ScalizeGridPrimitive::UnitLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_ScalizeGridPrimitive, ReturnValue) == 0x000010, "Member 'GSEArteriesFuncLib_ScalizeGridPrimitive::ReturnValue' has a wrong offset!");

// Function GSEArteries.GSEArteriesFuncLib.SmartResampleBySourceExtent
// 0x0030 (0x0030 - 0x0000)
struct GSEArteriesFuncLib_SmartResampleBySourceExtent final
{
public:
	class UArteriesObject*                        Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                InSources;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EGSATERIES_SAMPLE_AXIS                        InAxis;                                            // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinResampleLength;                                 // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxResampleLength;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResampleScale;                                     // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArteriesObject*                        ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GSEArteriesFuncLib_SmartResampleBySourceExtent) == 0x000008, "Wrong alignment on GSEArteriesFuncLib_SmartResampleBySourceExtent");
static_assert(sizeof(GSEArteriesFuncLib_SmartResampleBySourceExtent) == 0x000030, "Wrong size on GSEArteriesFuncLib_SmartResampleBySourceExtent");
static_assert(offsetof(GSEArteriesFuncLib_SmartResampleBySourceExtent, Target) == 0x000000, "Member 'GSEArteriesFuncLib_SmartResampleBySourceExtent::Target' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_SmartResampleBySourceExtent, InSources) == 0x000008, "Member 'GSEArteriesFuncLib_SmartResampleBySourceExtent::InSources' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_SmartResampleBySourceExtent, InAxis) == 0x000018, "Member 'GSEArteriesFuncLib_SmartResampleBySourceExtent::InAxis' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_SmartResampleBySourceExtent, MinResampleLength) == 0x00001C, "Member 'GSEArteriesFuncLib_SmartResampleBySourceExtent::MinResampleLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_SmartResampleBySourceExtent, MaxResampleLength) == 0x000020, "Member 'GSEArteriesFuncLib_SmartResampleBySourceExtent::MaxResampleLength' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_SmartResampleBySourceExtent, ResampleScale) == 0x000024, "Member 'GSEArteriesFuncLib_SmartResampleBySourceExtent::ResampleScale' has a wrong offset!");
static_assert(offsetof(GSEArteriesFuncLib_SmartResampleBySourceExtent, ReturnValue) == 0x000028, "Member 'GSEArteriesFuncLib_SmartResampleBySourceExtent::ReturnValue' has a wrong offset!");

}

