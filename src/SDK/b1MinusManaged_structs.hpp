#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: b1MinusManaged

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "GSEMinusProtobufDB_structs.hpp"
#include "SlateCore_structs.hpp"
#include "GameplayCameras_structs.hpp"
#include "Engine_structs.hpp"
#include "b1_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Calliope_structs.hpp"
#include "AsyncLoadingScreen_structs.hpp"
#include "GSEngineExtent_structs.hpp"
#include "InputCore_structs.hpp"
#include "TressFX_structs.hpp"
#include "MovieScene_structs.hpp"
#include "LevelSequence_structs.hpp"
#include "UMG_structs.hpp"
#include "Slate_structs.hpp"
#include "GSAnimationKeyBlender_structs.hpp"


namespace SDK
{

// Enum b1-Managed.AssetExportMode
// NumValues: 0x0005
enum class EAssetExportMode : uint8
{
	INCREMENT                                = 0,
	COMPLETELY                               = 1,
	CUSTOM_NAME                              = 2,
	ONLY_JSON_DATA                           = 3,
	AssetExportMode_MAX                      = 4,
};

// Enum b1-Managed.DispLibDBCCustomEventType
// NumValues: 0x0004
enum class EDispLibDBCCustomEventType : uint8
{
	None                                     = 0,
	Free_One                                 = 1,
	Free_Two                                 = 2,
	DispLibDBCCustomEventType_MAX            = 3,
};

// Enum b1-Managed.TreeImposterSceneShotName
// NumValues: 0x0006
enum class ETreeImposterSceneShotName : uint8
{
	BaseColor                                = 0,
	NormalWS                                 = 1,
	Specular                                 = 2,
	Roughness                                = 3,
	OpacityMask                              = 4,
	TreeImposterSceneShotName_MAX            = 5,
};

// Enum b1-Managed.SceneInteractorType
// NumValues: 0x0005
enum class ESceneInteractorType : uint8
{
	NONE                                     = 0,
	HALF_CIRCLE                              = 1,
	CIRCLE                                   = 2,
	MOVING_RECT                              = 3,
	SceneInteractorType_MAX                  = 4,
};

// Enum b1-Managed.DispLibSocketSearchMode
// NumValues: 0x0005
enum class EDispLibSocketSearchMode : uint8
{
	OnlyOriginSocket                         = 0,
	OnlyInterfaceSocket                      = 1,
	OriginSocketPrecedence                   = 2,
	InterfaceSocketPrecedence                = 3,
	DispLibSocketSearchMode_MAX              = 4,
};

// Enum b1-Managed.DispLibDBCAnimNotifyTarget
// NumValues: 0x0004
enum class EDispLibDBCAnimNotifyTarget : uint8
{
	None                                     = 0,
	Self                                     = 1,
	EnemyTarget                              = 2,
	DispLibDBCAnimNotifyTarget_MAX           = 3,
};

// Enum b1-Managed.DispLibMaterialParamsInheritMode
// NumValues: 0x0005
enum class EDispLibMaterialParamsInheritMode : uint8
{
	NoInherit                                = 0,
	InheritAllSameNameParams                 = 1,
	InheritOverrideSameNameParams            = 2,
	CustomInheritParamsNameArray             = 3,
	DispLibMaterialParamsInheritMode_MAX     = 4,
};

// Enum b1-Managed.DispLibDBCRequesterIdentity
// NumValues: 0x0007
enum class EDispLibDBCRequesterIdentity : uint8
{
	Notify                                   = 0,
	NotifyState                              = 1,
	UENativeComp                             = 2,
	GSECS_BUSComp                            = 3,
	GSECS_BWSComp                            = 4,
	DBCDataAsset                             = 5,
	DispLibDBCRequesterIdentity_MAX          = 6,
};

// Enum b1-Managed.DispLibDBCAdvProcessReleaseParameterControlMode
// NumValues: 0x0003
enum class EDispLibDBCAdvProcessReleaseParameterControlMode : uint8
{
	OnEventRealEnd                           = 0,
	OnParamSelfEndStageOver                  = 1,
	DispLibDBCAdvProcessReleaseParameterControlMode_MAX = 2,
};

// Enum b1-Managed.DispLibDBCAdvProcessScalarMode
// NumValues: 0x0005
enum class EDispLibDBCAdvProcessScalarMode : uint8
{
	Standard                                 = 0,
	RandomOnSpawn                            = 1,
	Random                                   = 2,
	UCurve                                   = 3,
	DispLibDBCAdvProcessScalarMode_MAX       = 4,
};

// Enum b1-Managed.DispLibDBCAdvProcessModifyNiagaraParamUtilMode
// NumValues: 0x0007
enum class EDispLibDBCAdvProcessModifyNiagaraParamUtilMode : uint8
{
	Standard                                 = 0,
	RandomOnSpawn                            = 1,
	Random                                   = 2,
	TimedUCurve                              = 3,
	SpecAtt                                  = 4,
	SpecAttUCurve                            = 5,
	DispLibDBCAdvProcessModifyNiagaraParamUtilMode_MAX = 6,
};

// Enum b1-Managed.DispLibDBCSpecialAttritubeTpye
// NumValues: 0x0002
enum class EDispLibDBCSpecialAttritubeTpye : uint8
{
	Velocity                                 = 0,
	DispLibDBCSpecialAttritubeTpye_MAX       = 1,
};

// Enum b1-Managed.DispLibDBCAdvProcessFLinearColorMode
// NumValues: 0x0005
enum class EDispLibDBCAdvProcessFLinearColorMode : uint8
{
	Standard                                 = 0,
	RandomAlphaOnSpawn                       = 1,
	RandomAlpha                              = 2,
	UCurve                                   = 3,
	DispLibDBCAdvProcessFLinearColorMode_MAX = 4,
};

// Enum b1-Managed.DispLibDBCPCurvePointScalarMode
// NumValues: 0x0008
enum class EDispLibDBCPCurvePointScalarMode : uint8
{
	DirectSet                                = 0,
	CacheCurValue                            = 1,
	ParamInitialValue                        = 2,
	OnSpawn_ValueMultiplyRandom_0_1          = 3,
	OnSpawn_ValueMultiplyRandom_N1_1         = 4,
	ValueMultiplyRandom_0_1                  = 5,
	ValueMultiplyRandom_N1_1                 = 6,
	DispLibDBCPCurvePointScalarMode_MAX      = 7,
};

// Enum b1-Managed.DispLibDBCPCurvePointColorMode
// NumValues: 0x0008
enum class EDispLibDBCPCurvePointColorMode : uint8
{
	DirectSet                                = 0,
	CacheCurValue                            = 1,
	ParamInitialValue                        = 2,
	OnSpawn_ValueMultiplyRandom_0_1          = 3,
	OnSpawn_ValueMultiplyRandom_N1_1         = 4,
	ValueMultiplyRandom_0_1                  = 5,
	ValueMultiplyRandom_N1_1                 = 6,
	DispLibDBCPCurvePointColorMode_MAX       = 7,
};

// Enum b1-Managed.DispLibDBCScalarNoiseMode
// NumValues: 0x0004
enum class EDispLibDBCScalarNoiseMode : uint8
{
	NoNoise                                  = 0,
	Sin                                      = 1,
	PerlinNoise                              = 2,
	DispLibDBCScalarNoiseMode_MAX            = 3,
};

// Enum b1-Managed.DispLibDBCAxisMode
// NumValues: 0x0018
enum class EDispLibDBCAxisMode : uint8
{
	WS_X                                     = 0,
	WS_Y                                     = 1,
	WS_Z                                     = 2,
	WS_N_X                                   = 3,
	WS_N_Y                                   = 4,
	WS_N_Z                                   = 5,
	Bone_X                                   = 6,
	Bone_Y                                   = 7,
	Bone_Z                                   = 8,
	Bone_N_X                                 = 9,
	Bone_N_Y                                 = 10,
	Bone_N_Z                                 = 11,
	Owner_X                                  = 12,
	Owner_Y                                  = 13,
	Owner_Z                                  = 14,
	Owner_N_X                                = 15,
	Owner_N_Y                                = 16,
	Owner_N_Z                                = 17,
	Bone_Velocity                            = 18,
	Bone_N_Velocity                          = 19,
	Owner_Velocity                           = 20,
	Owner_N_Velocity                         = 21,
	Zero                                     = 22,
	DispLibDBCAxisMode_MAX                   = 23,
};

// Enum b1-Managed.DispLibDBCWindMotorMode
// NumValues: 0x0006
enum class EDispLibDBCWindMotorMode : uint8
{
	NoWind                                   = 0,
	LocalDirectionalWind                     = 1,
	LocalOmniWind                            = 2,
	LocalVortexWind                          = 3,
	LocalAbsorbWind                          = 4,
	DispLibDBCWindMotorMode_MAX              = 5,
};

// Enum b1-Managed.DispLibDBCEndMode
// NumValues: 0x0004
enum class EDispLibDBCEndMode : uint8
{
	AutoRelease                              = 0,
	FixDuration                              = 1,
	ProcedureNotity                          = 2,
	DispLibDBCEndMode_MAX                    = 3,
};

// Enum b1-Managed.DispLibDBCSnapGroundRotationMode
// NumValues: 0x0003
enum class EDispLibDBCSnapGroundRotationMode : uint8
{
	HitPointNormalProjected                  = 0,
	CompXAxis                                = 1,
	DispLibDBCSnapGroundRotationMode_MAX     = 2,
};

// Enum b1-Managed.DispLibSystemActiveMode
// NumValues: 0x0004
enum class EDispLibSystemActiveMode : uint8
{
	NormalActive                             = 0,
	RefuseNewRequest                         = 1,
	Deactive                                 = 2,
	DispLibSystemActiveMode_MAX              = 3,
};

// Enum b1-Managed.DispLibDBCEffectDestroyTiming
// NumValues: 0x0003
enum class EDispLibDBCEffectDestroyTiming : uint8
{
	OnEndDispStageEnd                        = 0,
	OnEndDispStageStart                      = 1,
	DispLibDBCEffectDestroyTiming_MAX        = 2,
};

// Enum b1-Managed.DispLibDBCCompsFilterMode
// NumValues: 0x0004
enum class EDispLibDBCCompsFilterMode : uint8
{
	AllComps                                 = 0,
	ByTags                                   = 1,
	ByExcludeTags                            = 2,
	DispLibDBCCompsFilterMode_MAX            = 3,
};

// Enum b1-Managed.DispLibDBCNiagaraFilterMode
// NumValues: 0x0008
enum class EDispLibDBCNiagaraFilterMode : uint8
{
	AllNiagara                               = 0,
	ByName                                   = 1,
	ByExcludeName                            = 2,
	ByTags                                   = 3,
	ByExcludeTags                            = 4,
	BySystemAsset                            = 5,
	ByExcludeSystemAsset                     = 6,
	DispLibDBCNiagaraFilterMode_MAX          = 7,
};

// Enum b1-Managed.DispLibDBCMaterialsFilterMode
// NumValues: 0x0008
enum class EDispLibDBCMaterialsFilterMode : uint8
{
	AllMats                                  = 0,
	BySlotNames                              = 1,
	ByExcludeSlotNames                       = 2,
	ByIndexes                                = 3,
	ByExcludeIndexes                         = 4,
	ByUMaterial                              = 5,
	ByExcludeUMaterial                       = 6,
	DispLibDBCMaterialsFilterMode_MAX        = 7,
};

// Enum b1-Managed.DispLibDBCLightMode
// NumValues: 0x0003
enum class EDispLibDBCLightMode : uint8
{
	PointLight                               = 0,
	SpotLight                                = 1,
	DispLibDBCLightMode_MAX                  = 2,
};

// Enum b1-Managed.DispLibDBCEndReason
// NumValues: 0x0006
enum class EDispLibDBCEndReason : uint8
{
	StandardEnd                              = 0,
	Break                                    = 1,
	MainCompDeath                            = 2,
	MinorCompDeath                           = 3,
	ForceStop                                = 4,
	DispLibDBCEndReason_MAX                  = 5,
};

// Enum b1-Managed.DispLibDBCEndStageMode
// NumValues: 0x0003
enum class EDispLibDBCEndStageMode : uint8
{
	CommonEnd                                = 0,
	EndImmediately                           = 1,
	DispLibDBCEndStageMode_MAX               = 2,
};

// Enum b1-Managed.DispLibDBCFollowTriggerMode
// NumValues: 0x0006
enum class EDispLibDBCFollowTriggerMode : uint8
{
	None                                     = 0,
	OnEndStageBegin                          = 1,
	AfterEndStage                            = 2,
	OnBreakBegin                             = 3,
	AfterBreak                               = 4,
	DispLibDBCFollowTriggerMode_MAX          = 5,
};

// Enum b1-Managed.DispLibAdvanceNiagaraDispLogicMode
// NumValues: 0x0008
enum class EDispLibAdvanceNiagaraDispLogicMode : uint8
{
	Custom                                   = 0,
	StandardDirBeHit                         = 1,
	StandardInteraction                      = 2,
	PlanePostProcess                         = 3,
	TinyOffsetBeHit                          = 4,
	MatchingToNearestSocket                  = 5,
	DBCMergedSystem                          = 6,
	DispLibAdvanceNiagaraDispLogicMode_MAX   = 7,
};

// Enum b1-Managed.DispLibAttachConstraintMode
// NumValues: 0x0007
enum class EDispLibAttachConstraintMode : uint8
{
	Fixed                                    = 0,
	FixedTime                                = 1,
	RootVelocityThreshold                    = 2,
	AttachedSocketVelocityThreshold          = 3,
	AttachedSocketVelocityAndTorsionThreshold = 4,
	AttachedSocketDistanceACCAndTorsionThreshold = 5,
	DispLibAttachConstraintMode_MAX          = 6,
};

// Enum b1-Managed.DispLibDBCCustomEventTriggerMode
// NumValues: 0x0003
enum class EDispLibDBCCustomEventTriggerMode : uint8
{
	Standard                                 = 0,
	Immediate                                = 1,
	DispLibDBCCustomEventTriggerMode_MAX     = 2,
};

// Enum b1-Managed.DispLibCollisionProfileNames
// NumValues: 0x0008
enum class EDispLibCollisionProfileNames : uint8
{
	NoCollision                              = 0,
	BlockAll                                 = 1,
	OverlapAll                               = 2,
	BlockAllDynamic                          = 3,
	GroundBrick                              = 4,
	Rock_Big                                 = 5,
	Rock_Small                               = 6,
	DispLibCollisionProfileNames_MAX         = 7,
};

// Enum b1-Managed.DispLibDBCNiagaraForceVisibleStateMode
// NumValues: 0x0004
enum class EDispLibDBCNiagaraForceVisibleStateMode : uint8
{
	ImmdSetCompVisibleState                  = 0,
	None                                     = 1,
	SetNiagaraParam                          = 2,
	DispLibDBCNiagaraForceVisibleStateMode_MAX = 3,
};

// Enum b1-Managed.DispLibDBCPauseMode
// NumValues: 0x0007
enum class EDispLibDBCPauseMode : uint8
{
	Pause                                    = 0,
	None                                     = 1,
	GotoEndDispStage                         = 2,
	RealEndAndNoEndDispStage                 = 3,
	PauseAndHide                             = 4,
	ForceDestory                             = 5,
	DispLibDBCPauseMode_MAX                  = 6,
};

// Enum b1-Managed.DispLibDBCActorGroup
// NumValues: 0x0007
enum class EDispLibDBCActorGroup : uint8
{
	None                                     = 0,
	BattleUnit                               = 1,
	Interact                                 = 2,
	Projectile                               = 3,
	EquipPreview                             = 4,
	DLDWorld                                 = 5,
	DispLibDBCActorGroup_MAX                 = 6,
};

// Enum b1-Managed.DispLibDBCModNiagaraParamsPauseMode
// NumValues: 0x0005
enum class EDispLibDBCModNiagaraParamsPauseMode : uint8
{
	Pause                                    = 0,
	None                                     = 1,
	GotoEndDispStage                         = 2,
	RealEndAndNoEndDispStage                 = 3,
	DispLibDBCModNiagaraParamsPauseMode_MAX  = 4,
};

// Enum b1-Managed.DispLibDBCNiagaraScalabilityPoolMode
// NumValues: 0x0004
enum class EDispLibDBCNiagaraScalabilityPoolMode : uint8
{
	GlobalSameDataAssets                     = 0,
	GlobalSameNiagaraSystem                  = 1,
	PreSourceOwnerSameNiagaraSystem          = 2,
	DispLibDBCNiagaraScalabilityPoolMode_MAX = 3,
};

// Enum b1-Managed.DispLibDBCNiagaraScalabilityKillMode
// NumValues: 0x0004
enum class EDispLibDBCNiagaraScalabilityKillMode : uint8
{
	IntoEndDispStage                         = 0,
	ForceNoEndDispStage                      = 1,
	ReuseByReset                             = 2,
	DispLibDBCNiagaraScalabilityKillMode_MAX = 3,
};

// Enum b1-Managed.PoleDrinkConditionType
// NumValues: 0x0002
enum class EPoleDrinkConditionType : uint8
{
	HasTalent                                = 0,
	PoleDrinkConditionType_MAX               = 1,
};

// Enum b1-Managed.TeleportPointType
// NumValues: 0x0002
enum class ETeleportPointType : uint8
{
	CachedInteractItem                       = 0,
	TeleportPointType_MAX                    = 1,
};

// Enum b1-Managed.BANItemTeleportType
// NumValues: 0x0003
enum class EBANItemTeleportType : uint8
{
	TeleportTargetRebirthPointId             = 0,
	RebirthPointTeleport                     = 1,
	BANItemTeleportType_MAX                  = 2,
};

// Enum b1-Managed.AnimalDistributionSpawnTendency
// NumValues: 0x0003
enum class EAnimalDistributionSpawnTendency : uint8
{
	Concentrated                             = 0,
	Random                                   = 1,
	AnimalDistributionSpawnTendency_MAX      = 2,
};

// Enum b1-Managed.AnimalSpawnPosType
// NumValues: 0x0003
enum class EAnimalSpawnPosType : uint8
{
	EQS_Runtime                              = 0,
	PresetPointset                           = 1,
	AnimalSpawnPosType_MAX                   = 2,
};

// Enum b1-Managed.AnimalSpawnRotType
// NumValues: 0x0002
enum class EAnimalSpawnRotType : uint8
{
	RandomYaw                                = 0,
	AnimalSpawnRotType_MAX                   = 1,
};

// Enum b1-Managed.AreaUnitFilterType
// NumValues: 0x0007
enum class EAreaUnitFilterType : uint8
{
	All                                      = 0,
	Player                                   = 1,
	LocalPlayer                              = 2,
	WukongOnly                               = 3,
	SpecifiedResID                           = 4,
	WukongTeam                               = 5,
	AreaUnitFilterType_MAX                   = 6,
};

// Enum b1-Managed.AreaAbilityType
// NumValues: 0x0003
enum class EAreaAbilityType : uint8
{
	Default                                  = 0,
	PlayDialogue                             = 8,
	AreaAbilityType_MAX                      = 9,
};

// Enum b1-Managed.AreaType
// NumValues: 0x0003
enum class EAreaType : uint8
{
	SimpleTrigger                            = 0,
	Volume                                   = 1,
	AreaType_MAX                             = 2,
};

// Enum b1-Managed.EGSForceFightCondition
// NumValues: 0x0004
enum class EGSForceFightCondition : uint8
{
	EnterCollisionArea                       = 0,
	LeaveCollisionArea                       = 1,
	ObserveUnitsConditions                   = 2,
	EGSForceFightCondition_MAX               = 3,
};

// Enum b1-Managed.EGSForceFightTargetType
// NumValues: 0x0005
enum class EGSForceFightTargetType : uint8
{
	None                                     = 0,
	KeepCurrentAndStalemate                  = 1,
	CollisionOverlappedUnit                  = 2,
	SelectedTargetUnit                       = 3,
	EGSForceFightTargetType_MAX              = 4,
};

// Enum b1-Managed.EGSForceFightTriggerUnitType
// NumValues: 0x0004
enum class EGSForceFightTriggerUnitType : uint8
{
	Default                                  = 0,
	TriggerConditionUnit                     = 1,
	TriggerConditionUnitEnemy                = 2,
	EGSForceFightTriggerUnitType_MAX         = 3,
};

// Enum b1-Managed.EGSForceFightUnitFilterType
// NumValues: 0x0004
enum class EGSForceFightUnitFilterType : uint8
{
	None                                     = 0,
	WhiteListFilter                          = 1,
	BlackListFilter                          = 2,
	EGSForceFightUnitFilterType_MAX          = 3,
};

// Enum b1-Managed.EGSForceFightUnitType
// NumValues: 0x0004
enum class EGSForceFightUnitType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	PlayerTeam                               = 2,
	EGSForceFightUnitType_MAX                = 3,
};

// Enum b1-Managed.EnvironmentItemStateMachineAbilityType
// NumValues: 0x0003
enum class EnvironmentItemStateMachineAbilityType : uint8
{
	Default                                  = 0,
	PlayDialogue                             = 2,
	EnvironmentItemStateMachineAbilityType_MAX = 3,
};

// Enum b1-Managed.TriggerUnitFilter
// NumValues: 0x0005
enum class ETriggerUnitFilter : uint8
{
	WuKongOnly                               = 0,
	WuKongTeam                               = 1,
	SpecifiedResID                           = 2,
	All                                      = 3,
	TriggerUnitFilter_MAX                    = 4,
};

// Enum b1-Managed.EFXAnimalSpeedType
// NumValues: 0x0002
enum class EFXAnimalSpeedType : uint8
{
	Normal                                   = 0,
	EFXAnimalSpeedType_MAX                   = 1,
};

// Enum b1-Managed.EFXAnimalMoveType
// NumValues: 0x0003
enum class EFXAnimalMoveType : uint8
{
	NormalMove                               = 0,
	SplineMove                               = 1,
	EFXAnimalMoveType_MAX                    = 2,
};

// Enum b1-Managed.EFXAnimalSpawnMomentType
// NumValues: 0x0003
enum class EFXAnimalSpawnMomentType : uint8
{
	SpawnAtBegin                             = 0,
	SpawnAtEscape                            = 1,
	EFXAnimalSpawnMomentType_MAX             = 2,
};

// Enum b1-Managed.PerformerParamType
// NumValues: 0x0004
enum class EPerformerParamType : uint8
{
	None                                     = 0,
	Overlap                                  = 1,
	Performer                                = 2,
	PerformerParamType_MAX                   = 3,
};

// Enum b1-Managed.TaskCollectionState
// NumValues: 0x0004
enum class ETaskCollectionState : uint8
{
	Default                                  = 0,
	Activated                                = 1,
	Finished                                 = 2,
	TaskCollectionState_MAX                  = 3,
};

// Enum b1-Managed.SplineFlyUnitType
// NumValues: 0x0004
enum class ESplineFlyUnitType : uint8
{
	Monster                                  = 0,
	Player                                   = 1,
	TransitionPlayer                         = 2,
	SplineFlyUnitType_MAX                    = 3,
};

// Enum b1-Managed.TransformBySplineRotateType
// NumValues: 0x0006
enum class ETransformBySplineRotateType : uint8
{
	RotateToSplineTangentByTargetSide        = 0,
	RotateToSplineTangentByCurSide           = 1,
	RotateToSplineTangent                    = 2,
	RotateToTarget                           = 3,
	EnumMax                                  = 4,
	TransformBySplineRotateType_MAX          = 5,
};

// Enum b1-Managed.FoliageInteractSoundPriority
// NumValues: 0x0005
enum class EFoliageInteractSoundPriority : uint8
{
	Default                                  = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	FoliageInteractSoundPriority_MAX         = 4,
};

// Enum b1-Managed.ChargeSkillEndEventType
// NumValues: 0x0005
enum class EChargeSkillEndEventType : uint8
{
	ChargeEnd                                = 0,
	TimeOut                                  = 1,
	StaminaOver                              = 2,
	PELevelGrowUp                            = 3,
	ChargeSkillEndEventType_MAX              = 4,
};

// Enum b1-Managed.TriggerEventReturnType
// NumValues: 0x0004
enum class ETriggerEventReturnType : uint8
{
	NotTriggered                             = 0,
	TriggerSucceeded                         = 1,
	TriggerFailed                            = 2,
	TriggerEventReturnType_MAX               = 3,
};

// Enum b1-Managed.MovieTriggerType
// NumValues: 0x0008
enum class EMovieTriggerType : uint8
{
	None                                     = 0,
	Overlap                                  = 1,
	Interactor                               = 2,
	Unit                                     = 3,
	NPC                                      = 4,
	Spawner                                  = 5,
	TaskStage                                = 6,
	MovieTriggerType_MAX                     = 7,
};

// Enum b1-Managed.MovieRelationType
// NumValues: 0x0006
enum class EMovieRelationType : uint8
{
	None                                     = 0,
	Actor                                    = 1,
	Location                                 = 2,
	Monster                                  = 3,
	ManualLocation                           = 4,
	MovieRelationType_MAX                    = 5,
};

// Enum b1-Managed.SGI_Global
// NumValues: 0x002D
enum class ESGI_Global : uint8
{
	WaitGameStart                            = 0,
	MainMenu                                 = 1,
	InBattleWaitingStartNewGame              = 2,
	WXLogin                                  = 3,
	WaittingSelectLevel820Demo               = 4,
	InBattleStandAlone                       = 5,
	InBattleParty                            = 6,
	InBattleOnLineClient                     = 7,
	InBattleOnLineLS                         = 8,
	InBattleOnLineDS                         = 9,
	OpenMainMenuLevel                        = 10,
	SubG_GI_Loading_StartUp                  = 11,
	SubG_GI_Loading_StartNewGame             = 12,
	SubG_GI_Loading_Teleport                 = 13,
	SubG_GI_Loading_GameLevelPass            = 14,
	SubG_GI_Loading_ToiletStandAlone         = 15,
	SubG_GI_Loading_ToiletListenServer       = 16,
	SubG_GI_Loading_ToiletDedicateServer     = 17,
	SubG_GI_Loading_ToiletClient             = 18,
	SubG_GI_Loading_UnKnowLevelTravel        = 19,
	SubG_GI_Loading_BackToMainMenu           = 20,
	SubG_GI_Loading_InitWXLogin              = 21,
	SubG_GI_Loading_PostWXLoginFinish        = 22,
	SubG_GI_Loading_ReplayBattle             = 23,
	SubG_GI_Loading_HandleDisConnect         = 24,
	SubG_GI_Loading_BackToStandAlone         = 25,
	SubG_GI_Loading_StartNewGamePlus         = 26,
	SubG_GI_Loading_SaveArchiveAndWaitFinish = 27,
	SubG_GI_Loading_820DemoStartUp           = 28,
	SubG_GI_Loading_820DemoReSetGameData     = 29,
	SubG_GI_Loading_PreEnterMainMenu         = 30,
	SubG_GI_Loading_TravelLevel              = 31,
	SubG_GI_Loading_SetConfigAndPrecompilePSO = 32,
	SubG_GI_Loading_TravelToNextChapter      = 33,
	SubG_GI_Loading_PreviewSequence          = 34,
	SubG_GI_Loading_ServerLogin              = 35,
	SubG_GI_Loading_PartyRoomServer          = 36,
	SubG_GI_Loading_PartyRoomClient          = 37,
	AsClientInGame                           = 38,
	AsListenServerInGame                     = 39,
	SubG_GI_Global_WXLogin                   = 40,
	SubG_GI_Global_BenchMark                 = 41,
	InBenchMark                              = 42,
	SubG_GI_Loading_CheckGSSdkServerConfig   = 43,
	SGI_MAX                                  = 44,
};

// Enum b1-Managed.EGI_Global
// NumValues: 0x001C
enum class EGI_Global : uint8
{
	WXLogin                                  = 0,
	ToiletStandAlone                         = 1,
	StartUp                                  = 2,
	LoadArchive                              = 3,
	StartNewGame                             = 4,
	GameLevelPassFinal                       = 5,
	GameLevelPass                            = 6,
	ToiletListenServer                       = 7,
	ToiletDedicateServer                     = 8,
	ToiletClient                             = 9,
	UnKnowLevelTravel                        = 10,
	BackToMainMenu                           = 11,
	WXLoginSuccess                           = 12,
	ReplayBattle                             = 13,
	TravelToNextChapter                      = 14,
	PreviewSeq                               = 15,
	PartyRoomServer                          = 16,
	PartyRoomClient                          = 17,
	ClientDisconnect                         = 18,
	BackToStandAlone                         = 19,
	QuickMonsterTeleport                     = 20,
	StartNewGamePlus                         = 21,
	Demo820ReSetData                         = 22,
	BackToMainMenuByPlayGo                   = 23,
	ReadArchiveFailed                        = 24,
	BenchMark                                = 25,
	GMLevelTravel                            = 26,
	EGI_MAX                                  = 27,
};

// Enum b1-Managed.CGI_Global
// NumValues: 0x0002
enum class ECGI_Global : uint8
{
	IsIgnoreWXLogin                          = 0,
	CGI_MAX                                  = 1,
};

// Enum b1-Managed.SGI_Loading
// NumValues: 0x0082
enum class ESGI_Loading : uint8
{
	GSGShowWXlogin                           = 0,
	WaitMatchStart                           = 1,
	FillIsInToilet                           = 2,
	LoadCharacterViewLevel                   = 3,
	LoadChapterViewLevel                     = 4,
	InitDispLibWorld                         = 5,
	ECSWorldBeginPlay                        = 6,
	GSGBtlOnBattleStart                      = 7,
	CreateNewRoleData                        = 8,
	GSGEnterBattleLevel                      = 9,
	ServerBattleReady                        = 10,
	GSGShowBattleUI                          = 11,
	GSGShowLoginUI                           = 12,
	GSGRecoverMuseum                         = 13,
	LoadingUIFadeAway                        = 14,
	LoadingUIFadeIn                          = 15,
	WaitReplayPlayerSpawn                    = 16,
	ShowReplayUI                             = 17,
	UnlockScopeReplayScrubComplete           = 18,
	WaitTick                                 = 19,
	LoginByRoleData                          = 20,
	WaitGSLoginSuccess                       = 21,
	PlayerDataInitPreEnterLevel              = 22,
	GSGEnterLevel                            = 23,
	GSGExitLevel                             = 24,
	ECSWorldReset                            = 25,
	PauseGame                                = 26,
	ResumeGame                               = 27,
	InitNewArchiveData                       = 28,
	LoadingUIWaitUserInput                   = 29,
	LoadingUILinearTime                      = 30,
	ReadLatestArchive                        = 31,
	FillLoginRoleData                        = 32,
	OpenLevelByName                          = 33,
	Reset820DemoGameData                     = 34,
	ResetGameInstanceData                    = 35,
	CacheArchiveDataForClient                = 36,
	OpenLevelStartUp                         = 37,
	OpenLevelDefaultBattle                   = 38,
	OpenLevelByIdInContext                   = 39,
	GSGOnBattleStart                         = 40,
	GSGOnBattleDestroy                       = 41,
	GSGBtlOnBattleDestroy                    = 42,
	MarkNewGameplusReady                     = 43,
	StartNewGamePlus                         = 44,
	WaitPlayerCameraBlend                    = 45,
	WaitLevelStreamingLoad                   = 46,
	UnrealTravelToServer                     = 47,
	WaitLocalPlayerFillLoginOption           = 48,
	WaitLocalPlayerStartPlay                 = 49,
	InitLocalPlayerContainer                 = 50,
	WaitPostLoadMap                          = 51,
	WaitPostLoadMapClient                    = 52,
	FillLocalBPCRoleData                     = 53,
	WaitFirstPlayerLogin                     = 54,
	WaitAllAssetLoadFinsh                    = 55,
	WaitImportantAssetLoadFinsh              = 56,
	WaitCheck820DemoGameVersion              = 57,
	ResetNewGameplusArchive                  = 58,
	WaitStartGamePsoPrecompileFinish         = 59,
	FirstStartGameSettings                   = 60,
	ShowAgreementPolicyInStartGame           = 61,
	ShowLogoInStartGame                      = 62,
	ShowGameDisclaimerInStartGame            = 63,
	ShowArchiveMarkInStartGame               = 64,
	MarkFirstStartGameFlag                   = 65,
	CheckGSSdkServerConfig                   = 66,
	MarkCanFinishLoopMovie                   = 67,
	ShowHealthyGamingAdviceInStartGame       = 68,
	TeleportTemplateBegin                    = 69,
	TeleportTemplateEnd                      = 70,
	PlayerTeleportToTemplatetargetPos        = 71,
	LoadingUIBeginFadeAway                   = 72,
	SubG_GI_Loading_BattleLevelTravel        = 73,
	SubG_GI_Loading_ClientEnvInit            = 74,
	SubG_GI_Loading_HideLoadingUI            = 75,
	SubG_GI_Loading_GSLogin                  = 76,
	SubG_GI_Loading_ReStartGSLogin           = 77,
	SubG_GI_Loading_SaveArchiveAndWaitFinish = 78,
	RequestTemplateTravelLevelBegin          = 79,
	RequestTemplateTravelLevelEnd            = 80,
	RequestTemplatePreSaveArchive            = 81,
	RequestTemplatePostSaveArchiveFinish     = 82,
	RequestTemplatePreLeaveLevel             = 83,
	SubG_GI_Loading_PostLeaveLevel           = 84,
	RequestTemplateOpenLevel                 = 85,
	SubG_GI_Loading_PreEnterLevel            = 86,
	RequestTemplatePostEnterLevelFinish      = 87,
	RequestTemplatePostGSLoginFinish         = 88,
	LockSaveArchiveByTravelLevel             = 89,
	ReleaseSaveArchiveByTravelLevel          = 90,
	SubG_GI_Loading_ResetGameInstanceDataAndSaveArchive = 91,
	RequestTemplateLoadArchiveData           = 92,
	RequestTemplateCreateArchiveData         = 93,
	RequestTemplatePerformActionsFromArchive = 94,
	SubG_GI_Loading_HandleArchiveInTravelLevel = 95,
	CheckArchiveDataIsValid                  = 96,
	SaveArchiveInTravelLevel                 = 97,
	OpenLoadingScreen                        = 98,
	PrepareFadeAway                          = 99,
	RequestFadeAway                          = 100,
	CloseLoadingScreen                       = 101,
	SpawnPlayerPawnWithOutECSBeginPlay       = 102,
	TriggerTeleportAndWaitFinish             = 103,
	PausePsoCachePrecompile                  = 104,
	ResumePsoCachePrecompile                 = 105,
	WaitPsoCachePrecompileFinish             = 106,
	AdjustPSOCachePrecompileBatch            = 107,
	SetPSOCacheUsageMask                     = 108,
	PreLogin                                 = 109,
	PostLogin                                = 110,
	WaitGamePlayerInit                       = 111,
	SpawnCharacterForClient                  = 112,
	InitClientPlayerContainer                = 113,
	ChangeGameDefaultMap                     = 114,
	CheckGSSdkUserConfig                     = 115,
	EngineHandleDisconnect                   = 116,
	ShowMessageBoxAndWaitConfirm             = 117,
	TriggerBackToStandAlone                  = 118,
	NextChapterReqAndArchive                 = 119,
	GMRecordRebirthPos                       = 120,
	NetConectionFailurePreprocess            = 121,
	InitCollectionSpawnActorState            = 122,
	SaveArchiveAndWaitFinish                 = 123,
	PostSeamlessLevelTravel                  = 124,
	LoadCommLevel                            = 125,
	QuitGame                                 = 126,
	WaitUntilGameStateInit                   = 127,
	PlayGoDownloadIncompleteImpl             = 128,
	SGI_MAX                                  = 129,
};

// Enum b1-Managed.EGI_Loading
// NumValues: 0x0003
enum class EGI_Loading : uint8
{
	Finish                                   = 0,
	Error                                    = 1,
	EGI_MAX                                  = 2,
};

// Enum b1-Managed.CGI_Loading
// NumValues: 0x002A
enum class ECGI_Loading : uint8
{
	HasArchive                               = 0,
	IsInStartUpLevel                         = 1,
	IsInBattleLevel                          = 2,
	IsInDefaultBattleLevel                   = 3,
	HasArchiveIdInContext                    = 4,
	IsInServer                               = 5,
	IsInDedicateServer                       = 6,
	IsInListenServer                         = 7,
	IsStandAlone                             = 8,
	IsInNetClient                            = 9,
	IsInPIEClient                            = 10,
	TravelUrlIsListen                        = 11,
	TravelUrlHasHost                         = 12,
	IsEnableLoadingUserInput                 = 13,
	HasPlayerLoginBtlSvr                     = 14,
	IsInToilet                               = 15,
	IsInContextLevel                         = 16,
	TeleportNeedLevelTravel                  = 17,
	SwitchTeleportType                       = 18,
	IsReplayWorldLoadFinish                  = 19,
	PlayerGameStateCheck                     = 20,
	IsInPreviewSeqContext                    = 21,
	NeedSwitchPlayerGameMode                 = 22,
	MonsterTeleportArchiveExist              = 23,
	BattleLevelTravelNeedWaitCameraBlend     = 24,
	IsInMap                                  = 25,
	OpenSeamlessLevelTravel                  = 26,
	IsNeedPostLeaveLevel                     = 27,
	IsNeedPreEnterLevel                      = 28,
	IsNeedResetGameInstanceData              = 29,
	CheckGlobalTravelMode                    = 30,
	IsNeedOpenLoadingScreen                  = 31,
	IsNeedCloseLoadingScreen                 = 32,
	IsFirstStartGame                         = 33,
	CheckGMFlagsSupportUnknownTravel         = 34,
	IsDriverVersionMismatch                  = 35,
	IsPlayGoDownloadIncomplete               = 36,
	SwitchFillContextArchiveDataType         = 37,
	IsNeedPreStartGameProcess                = 38,
	SwitchSaveArchiveDegree                  = 39,
	DetermineTravelLevelByHandlingArchive    = 40,
	CGI_MAX                                  = 41,
};

// Enum b1-Managed.SPS_Transaction
// NumValues: 0x0002
enum class ESPS_Transaction : uint8
{
	TransactionTask                          = 0,
	SPS_MAX                                  = 1,
};

// Enum b1-Managed.EPS_Transaction
// NumValues: 0x0003
enum class EPS_Transaction : uint8
{
	TaskFinish                               = 0,
	TaskAbort                                = 1,
	EPS_MAX                                  = 2,
};

// Enum b1-Managed.CPS_Transaction
// NumValues: 0x0002
enum class ECPS_Transaction : uint8
{
	TaskCondition                            = 0,
	CPS_MAX                                  = 1,
};

// Enum b1-Managed.CalliopeFSMType
// NumValues: 0x0004
enum class ECalliopeFSMType : uint8
{
	GI_Global                                = 0,
	GI_Loading                               = 1,
	PS_Transaction                           = 2,
	CalliopeFSMType_MAX                      = 3,
};

// Enum b1-Managed.EGI_Global_IsIgnoreWXLogin_Result
// NumValues: 0x0003
enum class EGI_Global_IsIgnoreWXLogin_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Global_IsIgnoreWXLogin_MAX           = 2,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Global_BenchMark_Return
// NumValues: 0x0003
enum class EGI_Global_SubG_GI_Global_BenchMark_Return : uint8
{
	BenchMark                                = 0,
	Finish                                   = 1,
	EGI_Global_SubG_GI_Global_BenchMark_MAX  = 2,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Global_WXLogin_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Global_WXLogin_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Global_WXLogin_MAX    = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_820DemoReSetGameData_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_820DemoReSetGameData_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_820DemoReSetGameData_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_820DemoStartUp_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_820DemoStartUp_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_820DemoStartUp_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_BackToMainMenu_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_BackToMainMenu_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_BackToMainMenu_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_BackToStandAlone_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_BackToStandAlone_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_BackToStandAlone_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_CheckGSSdkServerConfig_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_CheckGSSdkServerConfig_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_CheckGSSdkServerConfig_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_GameLevelPass_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_GameLevelPass_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_GameLevelPass_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_HandleDisConnect_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_HandleDisConnect_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_HandleDisConnect_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_InitWXLogin_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_InitWXLogin_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_InitWXLogin_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_PartyRoomClient_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_PartyRoomClient_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_PartyRoomClient_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_PartyRoomServer_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_PartyRoomServer_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_PartyRoomServer_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_PostWXLoginFinish_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_PostWXLoginFinish_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_PostWXLoginFinish_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_PreEnterMainMenu_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_PreEnterMainMenu_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_PreEnterMainMenu_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_PreviewSequence_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_PreviewSequence_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_PreviewSequence_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_ReplayBattle_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_ReplayBattle_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_ReplayBattle_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_SaveArchiveAndWaitFinish_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_SaveArchiveAndWaitFinish_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_SaveArchiveAndWaitFinish_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_ServerLogin_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_ServerLogin_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_ServerLogin_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_SetConfigAndPrecompilePSO_Return
// NumValues: 0x0004
enum class EGI_Global_SubG_GI_Loading_SetConfigAndPrecompilePSO_Return : uint8
{
	GameIntent                               = 0,
	MainMenu                                 = 1,
	PrologueChapter                          = 2,
	EGI_Global_SubG_GI_Loading_SetConfigAndPrecompilePSO_MAX = 3,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_StartNewGame_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_StartNewGame_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_StartNewGame_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_StartNewGamePlus_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_StartNewGamePlus_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_StartNewGamePlus_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_StartUp_Return
// NumValues: 0x0003
enum class EGI_Global_SubG_GI_Loading_StartUp_Return : uint8
{
	FinishWithArchive                        = 0,
	FinishWithOutArchive                     = 1,
	EGI_Global_SubG_GI_Loading_StartUp_MAX   = 2,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_Teleport_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_Teleport_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_Teleport_MAX  = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_ToiletClient_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_ToiletClient_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_ToiletClient_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_ToiletDedicateServer_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_ToiletDedicateServer_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_ToiletDedicateServer_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_ToiletListenServer_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_ToiletListenServer_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_ToiletListenServer_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_ToiletStandAlone_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_ToiletStandAlone_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_ToiletStandAlone_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_TravelLevel_Return
// NumValues: 0x0004
enum class EGI_Global_SubG_GI_Loading_TravelLevel_Return : uint8
{
	Finish                                   = 0,
	ClientDisconnect                         = 1,
	ReadArchiveFailed                        = 2,
	EGI_Global_SubG_GI_Loading_TravelLevel_MAX = 3,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_TravelToNextChapter_Return
// NumValues: 0x0002
enum class EGI_Global_SubG_GI_Loading_TravelToNextChapter_Return : uint8
{
	Finish                                   = 0,
	EGI_Global_SubG_GI_Loading_TravelToNextChapter_MAX = 1,
};

// Enum b1-Managed.EGI_Global_SubG_GI_Loading_UnKnowLevelTravel_Return
// NumValues: 0x0006
enum class EGI_Global_SubG_GI_Loading_UnKnowLevelTravel_Return : uint8
{
	FinishInWXLogin                          = 0,
	FinishInStartUp                          = 1,
	FinishInStandAlone                       = 2,
	FinishInLS                               = 3,
	FinishInClient                           = 4,
	EGI_Global_SubG_GI_Loading_UnKnowLevelTravel_MAX = 5,
};

// Enum b1-Managed.EGI_Loading_BattleLevelTravelNeedWaitCameraBlend_Result
// NumValues: 0x0003
enum class EGI_Loading_BattleLevelTravelNeedWaitCameraBlend_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_BattleLevelTravelNeedWaitCameraBlend_MAX = 2,
};

// Enum b1-Managed.EGI_Loading_CheckGlobalTravelMode_Result
// NumValues: 0x0005
enum class EGI_Loading_CheckGlobalTravelMode_Result : uint8
{
	MainMenu                                 = 0,
	StandAlone                               = 1,
	ListenServer                             = 2,
	Client                                   = 3,
	EGI_Loading_CheckGlobalTravelMode_MAX    = 4,
};

// Enum b1-Managed.EGI_Loading_CheckGMFlagsSupportUnknownTravel_Result
// NumValues: 0x0003
enum class EGI_Loading_CheckGMFlagsSupportUnknownTravel_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_CheckGMFlagsSupportUnknownTravel_MAX = 2,
};

// Enum b1-Managed.EGI_Loading_HasArchive_Result
// NumValues: 0x0003
enum class EGI_Loading_HasArchive_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_HasArchive_MAX               = 2,
};

// Enum b1-Managed.EGI_Loading_HasArchiveIdInContext_Result
// NumValues: 0x0003
enum class EGI_Loading_HasArchiveIdInContext_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_HasArchiveIdInContext_MAX    = 2,
};

// Enum b1-Managed.EGI_Loading_IsDriverVersionMismatch_Result
// NumValues: 0x0003
enum class EGI_Loading_IsDriverVersionMismatch_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsDriverVersionMismatch_MAX  = 2,
};

// Enum b1-Managed.EGI_Loading_IsEnableLoadingUserInput_Result
// NumValues: 0x0003
enum class EGI_Loading_IsEnableLoadingUserInput_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsEnableLoadingUserInput_MAX = 2,
};

// Enum b1-Managed.EGI_Loading_IsInBattleLevel_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInBattleLevel_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInBattleLevel_MAX          = 2,
};

// Enum b1-Managed.EGI_Loading_IsInContextLevel_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInContextLevel_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInContextLevel_MAX         = 2,
};

// Enum b1-Managed.EGI_Loading_IsInDedicateServer_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInDedicateServer_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInDedicateServer_MAX       = 2,
};

// Enum b1-Managed.EGI_Loading_IsInDefaultBattleLevel_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInDefaultBattleLevel_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInDefaultBattleLevel_MAX   = 2,
};

// Enum b1-Managed.EGI_Loading_IsInListenServer_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInListenServer_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInListenServer_MAX         = 2,
};

// Enum b1-Managed.EGI_Loading_IsInMap_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInMap_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInMap_MAX                  = 2,
};

// Enum b1-Managed.EGI_Loading_IsInNetClient_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInNetClient_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInNetClient_MAX            = 2,
};

// Enum b1-Managed.EGI_Loading_IsInPIEClient_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInPIEClient_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInPIEClient_MAX            = 2,
};

// Enum b1-Managed.EGI_Loading_IsInServer_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInServer_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInServer_MAX               = 2,
};

// Enum b1-Managed.EGI_Loading_IsInStartUpLevel_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInStartUpLevel_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInStartUpLevel_MAX         = 2,
};

// Enum b1-Managed.EGI_Loading_IsInToilet_Result
// NumValues: 0x0003
enum class EGI_Loading_IsInToilet_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsInToilet_MAX               = 2,
};

// Enum b1-Managed.EGI_Loading_IsNeedPreStartGameProcess_Result
// NumValues: 0x0003
enum class EGI_Loading_IsNeedPreStartGameProcess_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsNeedPreStartGameProcess_MAX = 2,
};

// Enum b1-Managed.EGI_Loading_IsNeedResetGameInstanceData_Result
// NumValues: 0x0003
enum class EGI_Loading_IsNeedResetGameInstanceData_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsNeedResetGameInstanceData_MAX = 2,
};

// Enum b1-Managed.EGI_Loading_IsPlayGoDownloadIncomplete_Result
// NumValues: 0x0003
enum class EGI_Loading_IsPlayGoDownloadIncomplete_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsPlayGoDownloadIncomplete_MAX = 2,
};

// Enum b1-Managed.EGI_Loading_IsReplayWorldLoadFinish_Result
// NumValues: 0x0003
enum class EGI_Loading_IsReplayWorldLoadFinish_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsReplayWorldLoadFinish_MAX  = 2,
};

// Enum b1-Managed.EGI_Loading_IsStandAlone_Result
// NumValues: 0x0003
enum class EGI_Loading_IsStandAlone_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_IsStandAlone_MAX             = 2,
};

// Enum b1-Managed.EGI_Loading_MonsterTeleportArchiveExist_Result
// NumValues: 0x0003
enum class EGI_Loading_MonsterTeleportArchiveExist_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_MonsterTeleportArchiveExist_MAX = 2,
};

// Enum b1-Managed.EGI_Loading_NeedSwitchPlayerGameMode_Result
// NumValues: 0x0003
enum class EGI_Loading_NeedSwitchPlayerGameMode_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_NeedSwitchPlayerGameMode_MAX = 2,
};

// Enum b1-Managed.EGI_Loading_OpenSeamlessLevelTravel_Result
// NumValues: 0x0003
enum class EGI_Loading_OpenSeamlessLevelTravel_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_OpenSeamlessLevelTravel_MAX  = 2,
};

// Enum b1-Managed.EGI_Loading_PlayerGameStateCheck_Result
// NumValues: 0x0003
enum class EGI_Loading_PlayerGameStateCheck_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_PlayerGameStateCheck_MAX     = 2,
};

// Enum b1-Managed.EGI_Loading_SwitchTeleportType_Result
// NumValues: 0x0005
enum class EGI_Loading_SwitchTeleportType_Result : uint8
{
	TeleportToSameLevel                      = 0,
	TravelLevelToSamePlayerGameMode          = 1,
	TravelLevelToParty                       = 2,
	TravelLevelToConsole                     = 3,
	EGI_Loading_SwitchTeleportType_MAX       = 4,
};

// Enum b1-Managed.EGI_Loading_TeleportNeedLevelTravel_Result
// NumValues: 0x0003
enum class EGI_Loading_TeleportNeedLevelTravel_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_TeleportNeedLevelTravel_MAX  = 2,
};

// Enum b1-Managed.EGI_Loading_TravelUrlHasHost_Result
// NumValues: 0x0003
enum class EGI_Loading_TravelUrlHasHost_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_TravelUrlHasHost_MAX         = 2,
};

// Enum b1-Managed.EGI_Loading_TravelUrlIsListen_Result
// NumValues: 0x0003
enum class EGI_Loading_TravelUrlIsListen_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EGI_Loading_TravelUrlIsListen_MAX        = 2,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_BattleLevelTravel_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_BattleLevelTravel_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_BattleLevelTravel_MAX = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_ClientEnvInit_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_ClientEnvInit_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_ClientEnvInit_MAX = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_GSLogin_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_GSLogin_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_GSLogin_MAX  = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_HandleArchiveInTravelLevel_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_HandleArchiveInTravelLevel_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_HandleArchiveInTravelLevel_MAX = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_HideLoadingUI_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_HideLoadingUI_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_HideLoadingUI_MAX = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_PostLeaveLevel_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_PostLeaveLevel_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_PostLeaveLevel_MAX = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_PreEnterLevel_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_PreEnterLevel_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_PreEnterLevel_MAX = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_ResetGameInstanceDataAndSaveArchive_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_ResetGameInstanceDataAndSaveArchive_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_ResetGameInstanceDataAndSaveArchive_MAX = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_ReStartGSLogin_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_ReStartGSLogin_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_ReStartGSLogin_MAX = 1,
};

// Enum b1-Managed.EGI_Loading_SubG_GI_Loading_SaveArchiveAndWaitFinish_Return
// NumValues: 0x0002
enum class EGI_Loading_SubG_GI_Loading_SaveArchiveAndWaitFinish_Return : uint8
{
	Finish                                   = 0,
	EGI_Loading_SubG_GI_Loading_SaveArchiveAndWaitFinish_MAX = 1,
};

// Enum b1-Managed.EPS_Transaction_TaskCondition_Result
// NumValues: 0x0003
enum class EPS_Transaction_TaskCondition_Result : uint8
{
	True                                     = 0,
	False                                    = 1,
	EPS_Transaction_TaskCondition_MAX        = 2,
};

// Enum b1-Managed.InputMappingContextTagV2
// NumValues: 0x001C
enum class EInputMappingContextTagV2 : uint8
{
	None                                     = 0,
	Move                                     = 1,
	Camera                                   = 2,
	Skill                                    = 3,
	Chord                                    = 4,
	Interact                                 = 5,
	Ride                                     = 6,
	UI                                       = 7,
	GSUI_TOP                                 = 8,
	Battle_UI                                = 9,
	Battle_UI_Release                        = 10,
	Battle_UI_Skip                           = 11,
	Replay                                   = 12,
	GM_Temp                                  = 13,
	Unfreeze                                 = 14,
	SprintAndDodge                           = 15,
	SpellAndUseItem                          = 16,
	LoadingScreen                            = 17,
	Cloud                                    = 18,
	ShepherdDebug                            = 19,
	InteractSkip                             = 20,
	TakePhoto                                = 21,
	CricketBattle                            = 22,
	RemoteCamera                             = 23,
	BattleTriggerUI                          = 24,
	Vigor                                    = 25,
	GM                                       = 26,
	InputMappingContextTagV2_MAX             = 27,
};

// Enum b1-Managed.InputMappingContextLevelInfoType
// NumValues: 0x0004
enum class EInputMappingContextLevelInfoType : uint8
{
	None                                     = 0,
	OnlyAppliedToLevels                      = 1,
	NotAppliedToLevels                       = 2,
	InputMappingContextLevelInfoType_MAX     = 3,
};

// Enum b1-Managed.InputMappingContextMode
// NumValues: 0x0006
enum class EInputMappingContextMode : uint8
{
	UIOnly                                   = 0,
	GameOnly                                 = 1,
	UIAndGame                                = 2,
	Replay                                   = 3,
	All                                      = 4,
	InputMappingContextMode_MAX              = 5,
};

// Enum b1-Managed.EGSInputModeChangeReason
// NumValues: 0x0011
enum class EGSInputModeChangeReason : uint8
{
	Unknown                                  = 0,
	Init                                     = 1,
	UI                                       = 2,
	GM                                       = 3,
	MiniGM                                   = 4,
	ReportBug                                = 5,
	ExceptionPanel                           = 6,
	DataValidate                             = 7,
	WXLogin                                  = 8,
	BP_GMActor_GMPanel                       = 9,
	BP_GMActor_ZBBPanel                      = 10,
	BP_GMActor_OCEAN                         = 11,
	Reset                                    = 12,
	PreLoadMap                               = 13,
	Replay                                   = 14,
	LoadingScreenPreview                     = 15,
	EGSInputModeChangeReason_MAX             = 16,
};

// Enum b1-Managed.GlobalTravelLevelType
// NumValues: 0x0013
enum class EGlobalTravelLevelType : uint8
{
	None                                     = 0,
	Unknown                                  = 1,
	Generic                                  = 2,
	StartNewGame                             = 3,
	StartNewGamePlus                         = 4,
	BackToMainMenu                           = 5,
	ReadArchive                              = 6,
	GMTravel                                 = 7,
	Online                                   = 8,
	GameLevelPass                            = 9,
	GameIntent                               = 10,
	WXLoginFinish                            = 11,
	SetConfigFinish                          = 12,
	BackToMainMenuByPlayGo                   = 13,
	Nianhui                                  = 14,
	BenchMark                                = 15,
	SeamlessStartNewGame                     = 16,
	BackToMainMenuFullBlack                  = 17,
	GlobalTravelLevelType_MAX                = 18,
};

// Enum b1-Managed.TargetLevelNetType
// NumValues: 0x0006
enum class ETargetLevelNetType : uint8
{
	MainMenu                                 = 0,
	StandAlone                               = 1,
	ListenServer                             = 2,
	Client                                   = 3,
	Other                                    = 4,
	TargetLevelNetType_MAX                   = 5,
};

// Enum b1-Managed.MovieConditionQueryType
// NumValues: 0x0003
enum class EMovieConditionQueryType : uint8
{
	AllLevelSwitchStateFinish                = 0,
	GroupUnitBirthFinish                     = 1,
	MovieConditionQueryType_MAX              = 2,
};

// Enum b1-Managed.ChildActorFilterType
// NumValues: 0x0006
enum class EChildActorFilterType : uint8
{
	Socket                                   = 0,
	ResId                                    = 1,
	NickName                                 = 2,
	Buff                                     = 3,
	All                                      = 4,
	ChildActorFilterType_MAX                 = 5,
};

// Enum b1-Managed.ChildActorActionType
// NumValues: 0x0005
enum class EChildActorActionType : uint8
{
	CastSkill                                = 0,
	AddBuff                                  = 1,
	RemoveBuff                               = 2,
	SpawnSocketAttachTamer                   = 3,
	ChildActorActionType_MAX                 = 4,
};

// Enum b1-Managed.BattleCoopReason
// NumValues: 0x0002
enum class EBattleCoopReason : uint8
{
	UnitDead                                 = 0,
	BattleCoopReason_MAX                     = 1,
};

// Enum b1-Managed.DistributionType
// NumValues: 0x0003
enum class EDistributionType : uint8
{
	SenderToAllMembers                       = 0,
	SenderToOtherMembers                     = 1,
	DistributionType_MAX                     = 2,
};

// Enum b1-Managed.SocketMatchTamerType
// NumValues: 0x0003
enum class ESocketMatchTamerType : uint8
{
	Prefix                                   = 0,
	Full                                     = 1,
	SocketMatchTamerType_MAX                 = 2,
};

// Enum b1-Managed.EBGMDisableType
// NumValues: 0x0007
enum class EBGMDisableType : uint8
{
	None                                     = 0,
	BossBattleBGM                            = 1,
	EliteBattleBGM                           = 2,
	MonsterBattleBGM                         = 3,
	WanderBGM                                = 4,
	TransMusic                               = 32,
	EBGMDisableType_MAX                      = 33,
};

// Enum b1-Managed.EBGMPriority
// NumValues: 0x0005
enum class EBGMPriority : uint8
{
	BossBattleBGM                            = 0,
	EliteBattleBGM                           = 1,
	MonsterBattleBGM                         = 2,
	WanderBGM                                = 3,
	EBGMPriority_MAX                         = 4,
};

// Enum b1-Managed.GroupPatrolType
// NumValues: 0x0004
enum class EGroupPatrolType : uint8
{
	None                                     = 0,
	Leader                                   = 1,
	Member                                   = 2,
	GroupPatrolType_MAX                      = 3,
};

// Enum b1-Managed.EGSGroupSplinePatrolType
// NumValues: 0x0003
enum class EGSGroupSplinePatrolType : uint8
{
	Loop                                     = 0,
	Single                                   = 1,
	EGSGroupSplinePatrolType_MAX             = 2,
};

// Enum b1-Managed.MontageBindReason
// NumValues: 0x0010
enum class EMontageBindReason : uint8
{
	Default                                  = 0,
	NormalSkill                              = 1,
	MagicallyChange                          = 2,
	ChargeSkill                              = 3,
	ManualSplineMove                         = 4,
	FollowPartnerIdleDodge                   = 5,
	FollowPartnerIdleWaiting                 = 6,
	Patrol                                   = 7,
	SummonBehavior                           = 8,
	Born                                     = 9,
	LifeSavingHairPrepare                    = 10,
	LifeSavingHair                           = 11,
	EngageSkill                              = 12,
	InteractCricket                          = 13,
	Interact                                 = 14,
	MontageBindReason_MAX                    = 15,
};

// Enum b1-Managed.ServantSearchTargetType
// NumValues: 0x0006
enum class EServantSearchTargetType : uint8
{
	None                                     = 0,
	CatchPlayer                              = 1,
	SyncMaster                               = 2,
	ByPerception                             = 3,
	SyncSummoner                             = 4,
	ServantSearchTargetType_MAX              = 5,
};

// Enum b1-Managed.SummonType
// NumValues: 0x0006
enum class ESummonType : uint8
{
	Normal                                   = 0,
	PhantomRush                              = 1,
	Hatch                                    = 2,
	MonsterSpawn                             = 3,
	NeutralAnimSpawn                         = 4,
	SummonType_MAX                           = 5,
};

// Enum b1-Managed.ServantType
// NumValues: 0x0008
enum class EServantType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Dummy                                    = 2,
	Clone                                    = 3,
	PhantomRush                              = 4,
	MonsterSpawn                             = 5,
	NeutralAnimSpawn                         = 6,
	ServantType_MAX                          = 7,
};

// Enum b1-Managed.EndingCreditsAction
// NumValues: 0x0003
enum class EndingCreditsAction : uint8
{
	Open                                     = 0,
	OpenBackground                           = 1,
	EndingCreditsAction_MAX                  = 2,
};

// Enum b1-Managed.MapSymbolLevel
// NumValues: 0x000D
enum class EMapSymbolLevel : uint8
{
	EnumMin                                  = 0,
	CrossFocus                               = 1,
	Player                                   = 2,
	Npc                                      = 3,
	RebirthPoint                             = 4,
	Stupa                                    = 5,
	GodTower                                 = 6,
	StrongHold                               = 7,
	CaveEntrance                             = 8,
	Challenge                                = 9,
	Desc                                     = 10,
	EnumMax                                  = 11,
	MapSymbolLevel_MAX                       = 12,
};

// Enum b1-Managed.PostProcessSource
// NumValues: 0x0006
enum class EPostProcessSource : uint8
{
	None                                     = 0,
	Buff                                     = 1,
	AnimNotify                               = 2,
	ReservedAfterReset                       = 3,
	IntervalTrigger                          = 4,
	PostProcessSource_MAX                    = 5,
};

// Enum b1-Managed.TransactionType
// NumValues: 0x0003
enum class ETransactionType : uint8
{
	Interact                                 = 0,
	InteractAction                           = 1,
	TransactionType_MAX                      = 2,
};

// Enum b1-Managed.TransactionState
// NumValues: 0x0005
enum class ETransactionState : uint8
{
	Starting                                 = 0,
	Runing                                   = 1,
	Aborted                                  = 2,
	Finished                                 = 3,
	TransactionState_MAX                     = 4,
};

// Enum b1-Managed.TransactionTaskState
// NumValues: 0x0005
enum class ETransactionTaskState : uint8
{
	Init                                     = 0,
	Runing                                   = 1,
	Aborted                                  = 2,
	Finished                                 = 3,
	TransactionTaskState_MAX                 = 4,
};

// Enum b1-Managed.TransactionAbortReason
// NumValues: 0x0003
enum class ETransactionAbortReason : uint8
{
	Unknow                                   = 0,
	PlayerLogOut                             = 1,
	TransactionAbortReason_MAX               = 2,
};

// Enum b1-Managed.TransactionTaskType
// NumValues: 0x000D
enum class ETransactionTaskType : uint8
{
	Interact_RequestInteractObjLock          = 0,
	Interact_TriggerPreInteract              = 1,
	Interact_Input                           = 2,
	Interact_MatchPos                        = 3,
	Interact_PlaySound                       = 4,
	Interact_HandleInteractCamera            = 5,
	Interact_ProcessActionLock               = 6,
	Interact_DoInteractActionAndWait         = 7,
	Interact_TriggerBeInteract               = 8,
	Interact_ProcessActionUnLock             = 9,
	Interact_ResetCamera                     = 10,
	Interact_RequestInteractObjUnLock        = 11,
	Interact_MAX                             = 12,
};

// Enum b1-Managed.LevelLoadState
// NumValues: 0x0004
enum class ELevelLoadState : uint8
{
	Auto                                     = 0,
	Load                                     = 1,
	Unload                                   = 2,
	LevelLoadState_MAX                       = 3,
};

// Enum b1-Managed.SequenceBlendInMatchPositionType
// NumValues: 0x0005
enum class ESequenceBlendInMatchPositionType : uint8
{
	None                                     = 0,
	OnePoint                                 = 1,
	TwoPoint                                 = 2,
	Ori2PointA                               = 3,
	SequenceBlendInMatchPositionType_MAX     = 4,
};

// Enum b1-Managed.CheckConditionType
// NumValues: 0x000A
enum class ECheckConditionType : uint8
{
	None                                     = 0,
	AITarget                                 = 1,
	HpLow                                    = 2,
	InRange                                  = 3,
	HasBuff                                  = 4,
	InAbnormalState                          = 5,
	BreakPart                                = 101,
	Beatback                                 = 102,
	CastSkill                                = 103,
	CheckConditionType_MAX                   = 104,
};

// Enum b1-Managed.EAICheckDistanceType
// NumValues: 0x0005
enum class EAICheckDistanceType : uint8
{
	LocationDistanceXY                       = 0,
	LocationDistance                         = 1,
	ZDistance                                = 2,
	NavigationDistance                       = 3,
	EAICheckDistanceType_MAX                 = 4,
};

// Enum b1-Managed.EAICheckTarget
// NumValues: 0x0005
enum class EAICheckTarget : uint8
{
	CachedScencItem                          = 0,
	CurLockTarget                            = 1,
	FirstLocalPlayer                         = 2,
	EQSTarget                                = 3,
	EAICheckTarget_MAX                       = 4,
};

// Enum b1-Managed.AttackStyle
// NumValues: 0x0004
enum class EAttackStyle : uint8
{
	Heavy                                    = 0,
	Prop                                     = 1,
	Poke                                     = 2,
	AttackStyle_MAX                          = 3,
};

// Enum b1-Managed.ComboTargetType
// NumValues: 0x0004
enum class EComboTargetType : uint8
{
	None                                     = 0,
	CurrentAITarget                          = 1,
	Player                                   = 2,
	ComboTargetType_MAX                      = 3,
};

// Enum b1-Managed.ZatoichiSkillSourceType
// NumValues: 0x0007
enum class EZatoichiSkillSourceType : uint8
{
	None                                     = 0,
	UseWithSkillCategory                     = 1,
	UseWithGroupAI                           = 2,
	UseWithSurpriseSkilll                    = 3,
	UseWithAvoidObstacle                     = 4,
	UseWithStalemateSkill                    = 5,
	ZatoichiSkillSourceType_MAX              = 6,
};

// Enum b1-Managed.SpawnWaveLocalSpaceType
// NumValues: 0x0003
enum class ESpawnWaveLocalSpaceType : uint8
{
	LocalPlayer                              = 0,
	LocalController                          = 1,
	SpawnWaveLocalSpaceType_MAX              = 2,
};

// Enum b1-Managed.WaveStopActionType
// NumValues: 0x0003
enum class EWaveStopActionType : uint8
{
	DestroyAllSpawnedUnits                   = 0,
	SpawnedUnitsReturnHome                   = 1,
	WaveStopActionType_MAX                   = 2,
};

// Enum b1-Managed.CircusMemberType
// NumValues: 0x0007
enum class ECircusMemberType : uint8
{
	Unknown                                  = 0,
	Tamer                                    = 1,
	InteractiveObj                           = 2,
	SpawnWaves                               = 3,
	Overlap                                  = 4,
	JJSObstacle                              = 5,
	CircusMemberType_MAX                     = 6,
};

// Enum b1-Managed.Type_CheckCompProfileName_Bullet
// NumValues: 0x0002
enum class EType_CheckCompProfileName_Bullet : uint8
{
	NormalBullet                             = 0,
	Type_CheckCompProfileName_MAX            = 1,
};

// Enum b1-Managed.Type_CheckCompProfileName_MagicField
// NumValues: 0x0003
enum class EType_CheckCompProfileName_MagicField : uint8
{
	NormalMagicField                         = 0,
	JustCheckPhysicsBody                     = 1,
	Type_CheckCompProfileName_MAX            = 2,
};

// Enum b1-Managed.ProjectileAbilityType
// NumValues: 0x0009
enum class EProjectileAbilityType : uint8
{
	Default                                  = 0,
	DynamicScale                             = 2,
	LaserBullet                              = 4,
	ProceduralEnvInteract                    = 8,
	BulletMatMerge                           = 16,
	DestructibleBullet                       = 32,
	ThrowUpDeadUnit                          = 64,
	WindBrokenAudio                          = 128,
	ProjectileAbilityType_MAX                = 129,
};

// Enum b1-Managed.ProjectileDisableAbilityType
// NumValues: 0x0004
enum class EProjectileDisableAbilityType : uint8
{
	Default                                  = 0,
	SweepCheck                               = 2,
	Audio                                    = 4,
	ProjectileDisableAbilityType_MAX         = 5,
};

// Enum b1-Managed.ProjectileSpecificFlags
// NumValues: 0x0005
enum class EProjectileSpecificFlags : uint8
{
	None                                     = 0,
	Flame                                    = 2,
	Poison                                   = 4,
	WeakGuardianCircle                       = 8,
	ProjectileSpecificFlags_MAX              = 9,
};

// Enum b1-Managed.DonutBulletAudioLocationType
// NumValues: 0x0005
enum class EDonutBulletAudioLocationType : uint8
{
	None                                     = 0,
	InnerBorder                              = 1,
	OuterBorder                              = 2,
	Between                                  = 3,
	DonutBulletAudioLocationType_MAX         = 4,
};

// Enum b1-Managed.MagicFieldOverlapType
// NumValues: 0x0003
enum class EMagicFieldOverlapType : uint8
{
	Normal                                   = 0,
	NegativeOverlap                          = 1,
	MagicFieldOverlapType_MAX                = 2,
};

// Enum b1-Managed.BuffControlCondition
// NumValues: 0x0004
enum class EBuffControlCondition : uint8
{
	EnterCollisionArea                       = 0,
	StayCollisionArea                        = 1,
	LeaveCollisionArea                       = 2,
	BuffControlCondition_MAX                 = 3,
};

// Enum b1-Managed.BuffTarget
// NumValues: 0x0004
enum class EBuffTarget : uint8
{
	Player                                   = 0,
	OtherUnit                                = 1,
	SceneUnit                                = 2,
	BuffTarget_MAX                           = 3,
};

// Enum b1-Managed.ConditionsTarget
// NumValues: 0x0004
enum class EConditionsTarget : uint8
{
	Player                                   = 0,
	FindByTag                                = 1,
	ManualSelect                             = 2,
	ConditionsTarget_MAX                     = 3,
};

// Enum b1-Managed.GateStateMachineType
// NumValues: 0x0003
enum class EGateStateMachineType : uint8
{
	None                                     = 0,
	Destructible                             = 1,
	GateStateMachineType_MAX                 = 2,
};

// Enum b1-Managed.CameraType
// NumValues: 0x0005
enum class b1MinusManaged::ECameraType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Cine                                     = 2,
	Rail                                     = 3,
	Crane                                    = 4,
};

// Enum b1-Managed.QuestActorType
// NumValues: 0x000B
enum class EQuestActorType : uint8
{
	None                                     = 0,
	Overlap                                  = 1,
	DynamicObstacle                          = 2,
	Spawn                                    = 3,
	Checker                                  = 4,
	CovertTimer                              = 5,
	HLMQuest                                 = 6,
	PlayerChecker                            = 7,
	SpawnWaves                               = 8,
	BirthDecideArea                          = 9,
	QuestActorType_MAX                       = 10,
};

// Enum b1-Managed.SpawnWaveType
// NumValues: 0x0003
enum class ESpawnWaveType : uint8
{
	SpawnSequence                            = 0,
	SpawnInfinite                            = 1,
	SpawnWaveType_MAX                        = 2,
};

// Enum b1-Managed.SpawnType
// NumValues: 0x0003
enum class ESpawnType : uint8
{
	Weapon                                   = 0,
	Character                                = 1,
	SpawnType_MAX                            = 2,
};

// Enum b1-Managed.SpawnRule
// NumValues: 0x0004
enum class ESpawnRule : uint8
{
	Random                                   = 0,
	RandomLeast                              = 1,
	First                                    = 2,
	SpawnRule_MAX                            = 3,
};

// Enum b1-Managed.AbnromalDispActionType
// NumValues: 0x0007
enum class EAbnromalDispActionType : uint8
{
	AccProcess                               = 0,
	FinalBegin                               = 1,
	FinalLoop                                = 2,
	HitExt                                   = 3,
	DeadKeep                                 = 4,
	DeadDisappear                            = 5,
	AbnromalDispActionType_MAX               = 6,
};

// Enum b1-Managed.AiConversationFactType
// NumValues: 0x0004
enum class EAiConversationFactType : uint8
{
	FactType_Int                             = 0,
	FactType_Bool                            = 1,
	FactType_String                          = 2,
	FactType_MAX                             = 3,
};

// Enum b1-Managed.FallDyingState
// NumValues: 0x0008
enum class EFallDyingState : uint8
{
	Min                                      = 0,
	Alive                                    = 1,
	FallDyingBegin                           = 2,
	FallDyingWaiting                         = 3,
	FallDyingWaitSelfSave                    = 4,
	FallDyingSelfSaving                      = 5,
	RealDead                                 = 6,
	FallDyingState_MAX                       = 7,
};

// Enum b1-Managed.MultiTargetConditionType
// NumValues: 0x0006
enum class EMultiTargetConditionType : uint8
{
	None                                     = 0,
	HasBuff                                  = 1,
	HasState                                 = 2,
	HasSimpleState                           = 3,
	HPPercentInRange                         = 4,
	MultiTargetConditionType_MAX             = 5,
};

// Enum b1-Managed.TransMusicConfig
// NumValues: 0x0004
enum class ETransMusicConfig : uint8
{
	ByQuality                                = 0,
	Enable                                   = 1,
	Disable                                  = 2,
	TransMusicConfig_MAX                     = 3,
};

// Enum b1-Managed.EOSS_CharacterType
// NumValues: 0x0005
enum class EOSS_CharacterType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Monster                                  = 2,
	AiPartner                                = 3,
	EOSS_MAX                                 = 4,
};

// Enum b1-Managed.ArchiveSaveSource
// NumValues: 0x000F
enum class EArchiveSaveSource : uint8
{
	ArchiveSaveV1                            = 1,
	RoleDataMerge                            = 2,
	PushTaskStageSuccess                     = 3,
	PlayerDead                               = 4,
	BossOrEliteDead                          = 5,
	SeqPlayFinished                          = 6,
	BackToMainMenu                           = 7,
	TeleportFinish                           = 8,
	Console                                  = 9,
	Interact                                 = 10,
	NewGamePlus                              = 11,
	ReSet820Data                             = 12,
	TravelLevel                              = 13,
	ExitGame                                 = 14,
	ArchiveSaveSource_MAX                    = 15,
};

// Enum b1-Managed.TeleportTypeV2
// NumValues: 0x0008
enum class ETeleportTypeV2 : uint8
{
	SimpleLevelIdAndTransform                = 0,
	RebirthPoint                             = 1,
	TeleportNamedPoint                       = 2,
	Dream                                    = 3,
	NextChapter                              = 4,
	RebirthPointTeleportOnly                 = 5,
	PrologueCompleted                        = 6,
	TeleportTypeV2_MAX                       = 7,
};

// Enum b1-Managed.EUIPageID
// NumValues: 0x0063
enum class EUIPageID : uint8
{
	MIN                                      = 0,
	Managed                                  = 1,
	BattleMainCon                            = 2,
	Story                                    = 3,
	TeamInfo                                 = 4,
	BloodBarList                             = 5,
	Interact                                 = 6,
	ShrineMain                               = 7,
	FallDying                                = 8,
	Death                                    = 9,
	TPSReticle                               = 10,
	Name                                     = 11,
	RoleMain                                 = 12,
	Background                               = 13,
	EquipMain                                = 14,
	BagMain                                  = 15,
	MDropMain                                = 16,
	DropSpecial                              = 17,
	BlackOut                                 = 18,
	StartGameManaged                         = 19,
	StartGame                                = 20,
	AgeTips                                  = 21,
	Archives                                 = 22,
	SelectChapter                            = 23,
	Defeated                                 = 24,
	Shop                                     = 25,
	EquipShop                                = 26,
	Confirm                                  = 27,
	ConfirmThree                             = 28,
	TalentMain                               = 29,
	LearnTalent                              = 30,
	LearnLegacyTalent                        = 31,
	MapTips                                  = 32,
	Setting                                  = 33,
	InitSetting                              = 34,
	SettingInputKeyBoard                     = 35,
	SettingScreenDetail                      = 36,
	BrightnessSetting                        = 37,
	HDRSetting                               = 38,
	CommTips                                 = 39,
	CommTipsBlock                            = 40,
	SoakingMain                              = 41,
	Award                                    = 42,
	MedicineRecipe                           = 43,
	Alchemy                                  = 44,
	CommSkip                                 = 45,
	WeaponBuild                              = 46,
	RoleWeaponBuild                          = 47,
	EquipBuild                               = 48,
	AnimShowBlock                            = 49,
	SimpleTips                               = 50,
	NpcInteract                              = 51,
	CollectionMain                           = 52,
	ChapterAward                             = 53,
	ChapterMovie                             = 54,
	TravelNotesMain                          = 55,
	PastMemory                               = 56,
	RoleMeditationPointMain                  = 57,
	SeqMediaPlayer                           = 58,
	SaveTips                                 = 59,
	Login                                    = 60,
	LoginNotice                              = 61,
	AgreementPolicy                          = 62,
	Farm                                     = 63,
	TransGuide                               = 64,
	GuideNormal                              = 65,
	GuideQuest                               = 66,
	GuidePopbox                              = 67,
	TakePhoto                                = 68,
	AchieveTips                              = 69,
	QTEInteract                              = 70,
	EndCredits                               = 71,
	SoulSkillCollect                         = 72,
	SoulSkillStrength                        = 73,
	BenchMark                                = 74,
	HuluStrength                             = 75,
	WineStrength                             = 76,
	GuideMain                                = 77,
	EditionAward                             = 78,
	ShaderCompiling                          = 79,
	PlayGoProgressRaw                        = 80,
	PlayGoProgressNormal                     = 81,
	SoundtrackV2                             = 82,
	SeqLogo                                  = 83,
	NewGamePlusGuide                         = 84,
	LoadingAdaptor                           = 85,
	ShaderCompilingConfirm                   = 86,
	MiniGM                                   = 87,
	GMConfirm                                = 88,
	GMCommTips                               = 89,
	ReportBugPanel                           = 90,
	UITexConfigCheck                         = 91,
	HexRoomTest                              = 92,
	GuiqiangTest                             = 93,
	HatumTestUI                              = 94,
	EllenTest                                = 95,
	GMDisplayUIText                          = 96,
	EnumMax                                  = 97,
	EUIPageID_MAX                            = 98,
};

// Enum b1-Managed.DetectedElementType
// NumValues: 0x0022
enum class EDetectedElementType : uint8
{
	None                                     = 0,
	SimpleState                              = 1,
	UnitState                                = 2,
	HasBuff                                  = 3,
	UnitAttr                                 = 4,
	UnitActived                              = 5,
	UnitInActived                            = 6,
	AbnormalState                            = 7,
	FsmState                                 = 8,
	SkillCoolDown                            = 9,
	DistanceFromTarget                       = 10,
	SkillCanCast                             = 11,
	CustomFsmState                           = 12,
	LastBeAttackedStiffLevel                 = 13,
	DistanceFromMaster                       = 14,
	ActorYawRotation                         = 15,
	GlobalCastSkillCount                     = 16,
	DurCastSkill                             = 17,
	CurrentBeAttackedStiffLevel              = 18,
	CurSkillCostDmgNum                       = 19,
	SocketUnitsDead                          = 20,
	DistanceFromNearestPlayer                = 21,
	SpecifyResIdUnitsDead                    = 22,
	FamilySpecifyUnitAttr                    = 23,
	Random                                   = 24,
	FamilyUnitAliveNum                       = 25,
	TargetInAngleRange                       = 26,
	CompareBuffLayer                         = 27,
	CompareGamePlusCount                     = 28,
	CheckSurfaceType                         = 29,
	HasStoryCanTalkInThisLevel               = 30,
	StoryInCollingOffPeriod                  = 31,
	PlayerLeisureOverTime                    = 32,
	DetectedElementType_MAX                  = 33,
};

// Enum b1-Managed.ResetActorReason
// NumValues: 0x0009
enum class EResetActorReason : uint8
{
	None                                     = 0,
	Rebirth                                  = 1,
	InteractRebirthPoint                     = 2,
	NewSpawn                                 = 3,
	LevelStreaming                           = 4,
	MaxHeightOffset                          = 5,
	ReturnHome                               = 6,
	GameLevelPass                            = 7,
	ResetActorReason_MAX                     = 8,
};

// Enum b1-Managed.ScrollConsumeType
// NumValues: 0x0004
enum class EScrollConsumeType : uint8
{
	Normal                                   = 0,
	NotConsumed                              = 1,
	CanScroll                                = 2,
	ScrollConsumeType_MAX                    = 3,
};

// Enum b1-Managed.ClientTamerInitNetState
// NumValues: 0x0003
enum class EClientTamerInitNetState : uint8
{
	Dead                                     = 0,
	UnLoaded                                 = 1,
	ClientTamerInitNetState_MAX              = 2,
};

// Enum b1-Managed.AutoMoveMode
// NumValues: 0x0004
enum class EAutoMoveMode : uint8
{
	AttackMove                               = 0,
	ForcedMove                               = 1,
	SimpleMove                               = 2,
	AutoMoveMode_MAX                         = 3,
};

// Enum b1-Managed.DropReason
// NumValues: 0x0007
enum class EDropReason : uint8
{
	None                                     = 0,
	UnitDead                                 = 1,
	Collection                               = 2,
	Destruction                              = 3,
	Challenge                                = 4,
	DropItemMgr                              = 5,
	DropReason_MAX                           = 6,
};

// Enum b1-Managed.ContinueBehaviorType
// NumValues: 0x0005
enum class EContinueBehaviorType : uint8
{
	None                                     = 0,
	Skill                                    = 1,
	Beatback                                 = 2,
	AnimationSyncing                         = 3,
	ContinueBehaviorType_MAX                 = 4,
};

// Enum b1-Managed.LockTargetType
// NumValues: 0x0005
enum class ELockTargetType : uint8
{
	Actor                                    = 0,
	SceneComp                                = 1,
	SkeletonSocket                           = 2,
	Point                                    = 3,
	LockTargetType_MAX                       = 4,
};

// Enum b1-Managed.LockTargetWayType
// NumValues: 0x0007
enum class ELockTargetWayType : uint8
{
	Auto                                     = 0,
	Manual                                   = 1,
	Skill                                    = 2,
	Combo                                    = 3,
	AimOffset                                = 4,
	MoveTo                                   = 5,
	LockTargetWayType_MAX                    = 6,
};

// Enum b1-Managed.TargetSourceType
// NumValues: 0x002D
enum class ETargetSourceType : uint8
{
	None                                     = 0,
	CameraLockUpdate                         = 1,
	SwitchTarget_TransUnit                   = 2,
	SwitchTarget_PhantomRush                 = 3,
	Target_AIPerception                      = 4,
	Target_ByTaunter                         = 5,
	Target_ByHatred                          = 6,
	Target_AwakePartner                      = 7,
	Target_SelectByEQS                       = 8,
	Target_CQGAssignTarget                   = 9,
	Target_SeqAssignTarget                   = 10,
	Target_SwitchTaget                       = 11,
	Target_RangeSearch                       = 12,
	Target_AutoTest                          = 13,
	Target_CPGAssignTarget                   = 14,
	Target_CMGAssignTarget                   = 15,
	Target_BattleTriggerBoxAssignTarget      = 16,
	Target_ForceFightAssignTarget            = 17,
	Target_ActionBoxAssignTarget             = 18,
	Target_TeamBoxAssignTarget               = 19,
	Target_AnimSyncAssignTarget              = 20,
	Target_AssociaAssignTarget               = 21,
	Target_BirthCatchPlayer                  = 22,
	Target_BirthCatchMasterTarget            = 23,
	Target_BirthCatchSummonerTarget          = 24,
	Target_AssignPlayerAsTarget              = 25,
	Target_MonsterTransAssignTarget          = 26,
	Target_BeAttackedAssignAttackerAsTarget  = 27,
	Target_SummonAssignMasterTarget          = 28,
	Target_FindByPlayerLockTarget            = 29,
	Target_FindByHostileToPlayer             = 30,
	Target_FindByMasterLock                  = 31,
	Target_FamilyAssignTarget                = 32,
	Target_MagicFieldSetOverlapActorAsMasterTarget = 33,
	Target_ForceCameraLock                   = 34,
	Target_AIStrongPerception                = 35,
	AO_AORangeFind                           = 36,
	AO_SetByTarget                           = 37,
	Combo_NormalUse                          = 38,
	Combo_Update                             = 39,
	SkillBase_NormalUse                      = 40,
	SkillBase_SetByCombo                     = 41,
	SkillBase_SetByAI                        = 42,
	Target_AutoMoveTo                        = 43,
	TargetSourceType_MAX                     = 44,
};

// Enum b1-Managed.Birth_AbnormalStateImmueType
// NumValues: 0x0006
enum class EBirth_AbnormalStateImmueType : uint8
{
	None                                     = 0,
	FreezeImmue                              = 1,
	BurnImmue                                = 2,
	PoisonImmue                              = 3,
	ThunderImmue                             = 4,
	Birth_MAX                                = 5,
};

// Enum b1-Managed.AbnormalStateType
// NumValues: 0x0009
enum class EAbnormalStateType : uint8
{
	None                                     = 0,
	Abnormal_Freeze                          = 1,
	Abnormal_Burn                            = 2,
	Abnormal_Poison                          = 3,
	Abnormal_Thunder                         = 4,
	Abnormal_Yin                             = 5,
	Abnormal_Yang                            = 6,
	EnumMax                                  = 7,
	AbnormalStateType_MAX                    = 8,
};

// Enum b1-Managed.AccAbnormalValueType
// NumValues: 0x0003
enum class EAccAbnormalValueType : uint8
{
	IncreaseByValue                          = 0,
	IncreaseByINV10000                       = 1,
	AccAbnormalValueType_MAX                 = 2,
};

// Enum b1-Managed.CollisionBodyType
// NumValues: 0x0003
enum class ECollisionBodyType : uint8
{
	CollisionBody_CapsuleComp                = 1,
	CollisionBody_SkeletalMeshComp           = 2,
	CollisionBody_MAX                        = 3,
};

// Enum b1-Managed.CollisionProfileUniqueIDType
// NumValues: 0x0002
enum class ECollisionProfileUniqueIDType : uint8
{
	PhysicalMove                             = 0,
	CollisionProfileUniqueIDType_MAX         = 1,
};

// Enum b1-Managed.MatPainterType
// NumValues: 0x0003
enum class EMatPainterType : uint8
{
	Point                                    = 0,
	Line                                     = 1,
	MatPainterType_MAX                       = 2,
};

// Enum b1-Managed.FlowActorType
// NumValues: 0x0006
enum class EFlowActorType : uint8
{
	None                                     = 0,
	Overlap                                  = 2,
	DynamicObstacle                          = 3,
	Spawn                                    = 4,
	Checker                                  = 5,
	FlowActorType_MAX                        = 6,
};

// Enum b1-Managed.RebirthType
// NumValues: 0x0005
enum class ERebirthType : uint8
{
	RebirthPoint                             = 0,
	Quick                                    = 1,
	SelfRescue                               = 2,
	EnumMax                                  = 3,
	RebirthType_MAX                          = 4,
};

// Enum b1-Managed.TouchIKType
// NumValues: 0x0009
enum class ETouchIKType : uint8
{
	LeftHand                                 = 0,
	RightHand                                = 1,
	LeftFoot                                 = 2,
	RightFoot                                = 3,
	Head                                     = 4,
	Tail                                     = 5,
	Weapon                                   = 6,
	EnumMax                                  = 7,
	TouchIKType_MAX                          = 8,
};

// Enum b1-Managed.EBGW_TextureSysMemMask
// NumValues: 0x0007
enum class EBGW_TextureSysMemMask : uint8
{
	None                                     = 0,
	SystemUI                                 = 1,
	Vfx_NonStreamed                          = 2,
	LandScape                                = 4,
	GrayBox_HeightMap                        = 8,
	Vfx_Atlas                                = 16,
	EBGW_MAX                                 = 17,
};

// Enum b1-Managed.TeleportReason
// NumValues: 0x0004
enum class ETeleportReason : uint8
{
	None                                     = 0,
	Rebirth                                  = 1,
	RebirthPointManual                       = 2,
	TeleportReason_MAX                       = 3,
};

// Enum b1-Managed.UnitTagType
// NumValues: 0x0009
enum class EUnitTagType : uint8
{
	NormalMonster                            = 0,
	SmallMonster                             = 1,
	Boss                                     = 2,
	ClonedWukong                             = 3,
	Wukong                                   = 4,
	TransitionPlayer                         = 5,
	JSDS                                     = 6,
	YangJian                                 = 7,
	UnitTagType_MAX                          = 8,
};

// Enum b1-Managed.UnitCompNeedLevel
// NumValues: 0x0007
enum class EUnitCompNeedLevel : uint8
{
	Unused                                   = 0,
	DebugAndTest                             = 1,
	OnlyTest                                 = 2,
	OnlyDebug                                = 3,
	Alter                                    = 4,
	Need                                     = 5,
	UnitCompNeedLevel_MAX                    = 6,
};

// Enum b1-Managed.DestructibleMassLevel
// NumValues: 0x0007
enum class EDestructibleMassLevel : uint8
{
	Basic                                    = 0,
	WalkDestroy                              = 1,
	RunDestroy                               = 2,
	SprintDestroy                            = 3,
	GiantDestroy                             = 4,
	Indestructible                           = 5,
	DestructibleMassLevel_MAX                = 6,
};

// Enum b1-Managed.DestructibleStrengthLevel
// NumValues: 0x0006
enum class EDestructibleStrengthLevel : uint8
{
	LightHitDestroy                          = 0,
	MediumHitDestroy                         = 1,
	HeavyHitDestroy                          = 2,
	SpecialHitDestroy                        = 3,
	Indestructible                           = 99,
	DestructibleStrengthLevel_MAX            = 100,
};

// Enum b1-Managed.InteractConstraint
// NumValues: 0x0011
enum class EInteractConstraint : uint8
{
	None                                     = 0,
	TransForming                             = 1,
	NotFocusEnough                           = 2,
	Busy                                     = 3,
	OtherIsUsing                             = 4,
	EnemyAround                              = 5,
	CD                                       = 6,
	Dead                                     = 7,
	NpcHide                                  = 8,
	ConfigMiss                               = 9,
	ItemRequireCondition                     = 10,
	Restriction                              = 11,
	SplineMoving                             = 12,
	Interacting                              = 13,
	CricketIdle                              = 14,
	Other                                    = 15,
	InteractConstraint_MAX                   = 16,
};

// Enum b1-Managed.InteractiveObjectMaterial
// NumValues: 0x0005
enum class EInteractiveObjectMaterial : uint8
{
	Default                                  = 0,
	Wood                                     = 1,
	Stone                                    = 2,
	Steel                                    = 3,
	InteractiveObjectMaterial_MAX            = 4,
};

// Enum b1-Managed.SPAWN_METHOD
// NumValues: 0x0004
enum class ESPAWN_METHOD : uint8
{
	SPAWN_ON_START                           = 0,
	SPAWN_ON_WAVE                            = 1,
	SPAWN_ON_TRIGGER_RANGE                   = 2,
	SPAWN_ON_MAX                             = 3,
};

// Enum b1-Managed.SPAWN_BASE_LOCATION
// NumValues: 0x0004
enum class ESPAWN_BASE_LOCATION : uint8
{
	BASE_ON_DEFAULT                          = 0,
	BASE_ON_SPECIFIC_WAVE_DEAD               = 1,
	BASE_ON_PLAYER                           = 2,
	BASE_ON_MAX                              = 3,
};

// Enum b1-Managed.SPAWN_CONDITION
// NumValues: 0x0005
enum class ESPAWN_CONDITION : uint8
{
	SPAWN_ON_DEFALUT                         = 0,
	SPAWN_ON_ALL_DEAD                        = 1,
	SPAWN_ON_DEAD_PERCENTAGE                 = 2,
	SPAWN_ON_RANDOM                          = 3,
	SPAWN_ON_MAX                             = 4,
};

// Enum b1-Managed.EBGUBulletDispReason
// NumValues: 0x0007
enum class EBGUBulletDispReason : uint8
{
	None                                     = 0,
	Spawn                                    = 1,
	HitChr                                   = 2,
	HitSceneItem                             = 3,
	LifeOver                                 = 4,
	BeHit                                    = 5,
	EBGUBulletDispReason_MAX                 = 6,
};

// Enum b1-Managed.EBGUBulletDestroyReason
// NumValues: 0x000B
enum class EBGUBulletDestroyReason : uint8
{
	None                                     = 0,
	HitItemDestroy                           = 1,
	HitCharacterDestroy                      = 2,
	TimeOutDestroy                           = 3,
	SpeedLowDestroy                          = 4,
	FlyBackDestroy                           = 5,
	FarthestDistOutDestroy                   = 6,
	EffectDestroy                            = 7,
	AttachedParentNotValid                   = 8,
	LevelSequenceDestroy                     = 9,
	EBGUBulletDestroyReason_MAX              = 10,
};

// Enum b1-Managed.EGSSceneActorActivationType
// NumValues: 0x0007
enum class EGSSceneActorActivationType : uint8
{
	PhysicsSimulation                        = 0,
	EmitterActivation                        = 1,
	TickEnable                               = 2,
	BGUActorActivation                       = 3,
	HiddenInGame                             = 4,
	ActorCollision                           = 5,
	EGSSceneActorActivationType_MAX          = 6,
};

// Enum b1-Managed.TargetActionType
// NumValues: 0x0004
enum class ETargetActionType : uint8
{
	WakeUp                                   = 0,
	TriggerEffectByID                        = 1,
	AddBuffByID                              = 2,
	TargetActionType_MAX                     = 3,
};

// Enum b1-Managed.SceneObjTransitionEvent
// NumValues: 0x000C
enum class ESceneObjTransitionEvent : uint8
{
	OnSpawn                                  = 0,
	Eliminate                                = 1,
	OnReset                                  = 2,
	NextState                                = 3,
	JumpToState0                             = 4,
	JumpToState1                             = 5,
	JumpToState2                             = 6,
	JumpToState3                             = 7,
	JumpToState4                             = 8,
	JumpToState5                             = 9,
	JumpToState6                             = 10,
	SceneObjTransitionEvent_MAX              = 11,
};

// Enum b1-Managed.SceneObjTransitionState
// NumValues: 0x0009
enum class ESceneObjTransitionState : uint8
{
	State0                                   = 0,
	State1                                   = 1,
	State2                                   = 2,
	State3                                   = 3,
	State4                                   = 4,
	State5                                   = 5,
	State6                                   = 6,
	Eliminated                               = 7,
	SceneObjTransitionState_MAX              = 8,
};

// Enum b1-Managed.SceneObjControllerType
// NumValues: 0x0008
enum class ESceneObjControllerType : uint8
{
	Base                                     = 0,
	CharacterActiveState                     = 1,
	TriggerState                             = 2,
	ActorCallState                           = 3,
	TriggerBox                               = 4,
	RebirthPointActiveState                  = 5,
	DynamicObstacleState                     = 6,
	SceneObjControllerType_MAX               = 7,
};

// Enum b1-Managed.EABPMoveMode
// NumValues: 0x000F
enum class EABPMoveMode : uint8
{
	None                                     = 0,
	Locomotion_Simple4Dir                    = 1,
	Locomotion_Paragon4Dir                   = 2,
	Locomotion_Simple8Dir                    = 3,
	MotionMatching                           = 4,
	CarMove                                  = 5,
	Locomotion_Player8Dir                    = 6,
	SimpleFlyControl                         = 7,
	PlayerLocomotion                         = 8,
	ComplexFlyControl                        = 9,
	MonsterLocomotion                        = 10,
	AdvancedMonsterLocomotion                = 11,
	QuadrupedLocomotion                      = 12,
	CloudLocomotion                          = 13,
	EABPMoveMode_MAX                         = 14,
};

// Enum b1-Managed.AttackOffsetType
// NumValues: 0x0003
enum class EAttackOffsetType : uint8
{
	AttackOffset_None                        = 0,
	AttackOffset_WorldRotOffset              = 1,
	AttackOffset_MAX                         = 2,
};

// Enum b1-Managed.AimToType
// NumValues: 0x0003
enum class EAimToType : uint8
{
	None                                     = 0,
	Target                                   = 1,
	AimToType_MAX                            = 2,
};

// Enum b1-Managed.SlowIKType
// NumValues: 0x0008
enum class ESlowIKType : uint8
{
	None                                     = 0,
	RightHand_WithWeaponR                    = 1,
	LeftHand_WithWeaponR                     = 2,
	LeftHand_WithWeaponL                     = 3,
	RightHand_WithWeaponL                    = 4,
	DoubleHand_WithWeaponR                   = 5,
	DoubleHand_WithWeaponL                   = 6,
	SlowIKType_MAX                           = 7,
};

// Enum b1-Managed.BuffSourceType
// NumValues: 0x004B
enum class EBuffSourceType : uint8
{
	GM                                       = 0,
	AutoTest                                 = 1,
	BAIT                                     = 2,
	MFOverlapEvent                           = 3,
	BuffTrigger                              = 4,
	AI                                       = 5,
	AbnormalState                            = 6,
	Notify                                   = 7,
	ProjectilBasic                           = 8,
	AssociationUnit                          = 9,
	AttackFeedback                           = 10,
	Armor                                    = 11,
	BeImmobilized                            = 12,
	BehaviorGraph                            = 13,
	Birth                                    = 14,
	SpawnInfoBirth                           = 15,
	ChargeSkill                              = 16,
	CliffFall                                = 17,
	DestructibleBullet                       = 18,
	EquipFabao                               = 19,
	GroupAI                                  = 20,
	HardMove                                 = 21,
	IronBody                                 = 22,
	Jump                                     = 23,
	MonsterTrans                             = 24,
	NPCShow                                  = 25,
	PartMgr                                  = 26,
	Patrol                                   = 27,
	Performer                                = 28,
	PhantomRush                              = 29,
	PhysicalMove                             = 30,
	AIInteract                               = 31,
	PlayerInteract                           = 32,
	PlayerItem                               = 33,
	PlayerTrans                              = 34,
	PreciseDodge                             = 35,
	SkillInsts                               = 36,
	Stamina                                  = 37,
	SummonBehavior                           = 38,
	Talent                                   = 39,
	UnitItem                                 = 40,
	CMG                                      = 41,
	CPG                                      = 42,
	CQG                                      = 43,
	AddBuffEffect                            = 44,
	BattleTrigger                            = 45,
	TaskManager                              = 46,
	EnvironmentSurfaceEffect                 = 47,
	MagicSection                             = 48,
	SmartCastSkill                           = 49,
	InputAction                              = 50,
	SpiderSilkEntangle                       = 51,
	VigourDropper                            = 52,
	SealingSpell                             = 53,
	AnimationSync                            = 54,
	Default                                  = 55,
	IntervalTrigger                          = 56,
	DumperTruckTrigger                       = 57,
	BossRoom                                 = 58,
	Detonate                                 = 59,
	ManualSplineMove                         = 60,
	PotentialEnergy                          = 61,
	SkillInputAssist                         = 62,
	TransitionPhase                          = 63,
	GCFSMTravelLevel                         = 64,
	SummonDesc                               = 65,
	CostAttrByBuff                           = 66,
	CloudMove                                = 67,
	LifeSaving                               = 68,
	MagicallyChange                          = 69,
	BuffRule                                 = 70,
	BeAttacked                               = 71,
	Trans2DaSheng                            = 72,
	FollowPartner                            = 73,
	BuffSourceType_MAX                       = 74,
};

// Enum b1-Managed.PlayerCameraMode
// NumValues: 0x0004
enum class EPlayerCameraMode : uint8
{
	AutoTrail                                = 0,
	LockDarkSoul                             = 1,
	LockDMC                                  = 2,
	PlayerCameraMode_MAX                     = 3,
};

// Enum b1-Managed.PlayerFreeCameraType
// NumValues: 0x0005
enum class EPlayerFreeCameraType : uint8
{
	None                                     = 0,
	AutoTrail                                = 1,
	G4Mode                                   = 2,
	SeqMatch                                 = 3,
	PlayerFreeCameraType_MAX                 = 4,
};

// Enum b1-Managed.DefaultCamArmMode
// NumValues: 0x0006
enum class EDefaultCamArmMode : uint8
{
	Default                                  = 0,
	Close                                    = 1,
	Normal                                   = 2,
	Far                                      = 3,
	Free                                     = 4,
	DefaultCamArmMode_MAX                    = 5,
};

// Enum b1-Managed.CameraParamType
// NumValues: 0x0017
enum class ECameraParamType : uint8
{
	ArmLocationX                             = 0,
	ArmLocationY                             = 1,
	ArmLocationZ                             = 2,
	ArmSocketOffsetX                         = 3,
	ArmSocketOffsetY                         = 4,
	ArmSocketOffsetZ                         = 5,
	ArmLength                                = 6,
	ControllerPitch                          = 7,
	ControllerRoll                           = 8,
	ControllerYaw                            = 9,
	DmcActorLocationX                        = 10,
	DmcActorLocationY                        = 11,
	DmcActorLocationZ                        = 12,
	DmcActorPitch                            = 13,
	DmcActorRoll                             = 14,
	DmcActorYaw                              = 15,
	DmcArmLength                             = 16,
	PlayerPosition2D                         = 17,
	PlayerPositionZ                          = 18,
	TargetPosition2D                         = 19,
	TargetPositionZ                          = 20,
	EnumMax                                  = 21,
	CameraParamType_MAX                      = 22,
};

// Enum b1-Managed.ResetSpringArmRotationWay
// NumValues: 0x0005
enum class EResetSpringArmRotationWay : uint8
{
	None                                     = 0,
	Reset2PlayerRotation                     = 1,
	Reset2NearestRotation                    = 2,
	UseCustomRotation                        = 3,
	ResetSpringArmRotationWay_MAX            = 4,
};

// Enum b1-Managed.RenderTargetType
// NumValues: 0x0005
enum class ERenderTargetType : uint8
{
	None                                     = 0,
	BeAttacked                               = 1,
	TTTB                                     = 2,
	Shelter                                  = 3,
	RenderTargetType_MAX                     = 4,
};

// Enum b1-Managed.NeutralAnimalType
// NumValues: 0x0004
enum class ENeutralAnimalType : uint8
{
	None                                     = 0,
	Battle                                   = 1,
	Escape                                   = 2,
	NeutralAnimalType_MAX                    = 3,
};

// Enum b1-Managed.UnitGuidType
// NumValues: 0x0003
enum class EUnitGuidType : uint8
{
	Random                                   = 0,
	Fixed                                    = 1,
	UnitGuidType_MAX                         = 2,
};

// Enum b1-Managed.PartnerAssistState
// NumValues: 0x0005
enum class EPartnerAssistState : uint8
{
	None                                     = 0,
	PassiveWithOutAtk                        = 1,
	Passive                                  = 2,
	Active                                   = 3,
	PartnerAssistState_MAX                   = 4,
};

// Enum b1-Managed.TWVectorUseType
// NumValues: 0x0006
enum class ETWVectorUseType : uint8
{
	UsePredefinedVectorSlot0                 = 0,
	UsePredefinedVectorSlot1                 = 1,
	UsePredefinedVectorSlot2                 = 2,
	UsePredefinedVectorSlot3                 = 3,
	UseVectorBase                            = 4,
	TWVectorUseType_MAX                      = 5,
};

// Enum b1-Managed.RotTypeInSmallAngle
// NumValues: 0x0003
enum class ERotTypeInSmallAngle : uint8
{
	None                                     = 0,
	SimpleRotate                             = 1,
	RotTypeInSmallAngle_MAX                  = 2,
};

// Enum b1-Managed.RotTypeInLargeAngle
// NumValues: 0x0004
enum class ERotTypeInLargeAngle : uint8
{
	None                                     = 0,
	AMMatryoshka                             = 1,
	AMAdditive                               = 2,
	RotTypeInLargeAngle_MAX                  = 3,
};

// Enum b1-Managed.ProjectileBornDirType
// NumValues: 0x000A
enum class EProjectileBornDirType : uint8
{
	None                                     = 0,
	UseSlotDir                               = 1,
	LookAtTargetPos                          = 2,
	XYLineFromOwner                          = 3,
	UseEffectNormal                          = 4,
	BaseActorRot                             = 5,
	UsePointSetCached                        = 6,
	UseEffectCasterRot                       = 7,
	LineFromSpawner                          = 8,
	ProjectileBornDirType_MAX                = 9,
};

// Enum b1-Managed.ProjectilePosOffsetSpace
// NumValues: 0x0004
enum class EProjectilePosOffsetSpace : uint8
{
	WorldSpace                               = 0,
	BaseActorLocalSpace                      = 1,
	SocketLocalSpace                         = 2,
	ProjectilePosOffsetSpace_MAX             = 3,
};

// Enum b1-Managed.ProjectilePosOffsetType
// NumValues: 0x0005
enum class EProjectilePosOffsetType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	RangeOffset                              = 2,
	RandomOffset                             = 3,
	ProjectilePosOffsetType_MAX              = 4,
};

// Enum b1-Managed.ProjectileBaseType
// NumValues: 0x000E
enum class EProjectileBaseType : uint8
{
	None                                     = 0,
	ProjectileSpawner                        = 1,
	EffectCaster                             = 2,
	EffectTarget                             = 3,
	CurTarget_ProjectileSpawner              = 4,
	UsePointSetCached                        = 5,
	UseEffectPosition                        = 6,
	UseSkillBaseTarget                       = 7,
	SceneItemCached                          = 8,
	EffectRootCaster                         = 9,
	UseEQSPoint                              = 10,
	MutilTarget                              = 11,
	LocalPlayer                              = 12,
	ProjectileBaseType_MAX                   = 13,
};

// Enum b1-Managed.RangePointSetType
// NumValues: 0x0003
enum class ERangePointSetType : uint8
{
	CircleRandom                             = 0,
	DonutRandom                              = 1,
	RangePointSetType_MAX                    = 2,
};

// Enum b1-Managed.ProjectileType
// NumValues: 0x0004
enum class EProjectileType : uint8
{
	None                                     = 0,
	Bullet                                   = 1,
	MagicField                               = 2,
	ProjectileType_MAX                       = 3,
};

// Enum b1-Managed.TurnSkillType
// NumValues: 0x0005
enum class ETurnSkillType : uint8
{
	LeftSmall                                = 0,
	RightSmall                               = 1,
	LeftBig                                  = 2,
	RightBig                                 = 3,
	TurnSkillType_MAX                        = 4,
};

// Enum b1-Managed.DamageCalcType
// NumValues: 0x0004
enum class EDamageCalcType : uint8
{
	Normal                                   = 0,
	ElemDot                                  = 1,
	HPMaxRatioAbs                            = 2,
	DamageCalcType_MAX                       = 3,
};

// Enum b1-Managed.DamageReason
// NumValues: 0x0006
enum class EDamageReason : uint8
{
	None                                     = 0,
	Buff                                     = 1,
	Skill                                    = 2,
	FallDmg                                  = 3,
	DeadZone                                 = 4,
	DamageReason_MAX                         = 5,
};

// Enum b1-Managed.AttackerArea
// NumValues: 0x0005
enum class EAttackerArea : uint8
{
	Forward                                  = 0,
	LeftSide                                 = 1,
	RightSide                                = 2,
	Backward                                 = 3,
	AttackerArea_MAX                         = 4,
};

// Enum b1-Managed.EllipsisType
// NumValues: 0x0007
enum class EllipsisType : uint8
{
	None                                     = 0,
	NoHitAction                              = 1,
	NoAttackerArea                           = 2,
	BothNoAttackerAreaNHitAction             = 3,
	NoGears                                  = 4,
	NoDepot                                  = 5,
	EllipsisType_MAX                         = 6,
};

// Enum b1-Managed.DeadEllipsisType
// NumValues: 0x0008
enum class EDeadEllipsisType : uint8
{
	None                                     = 0,
	NoAbnormalState                          = 1,
	NoHitAction                              = 2,
	NoAttackerArea                           = 3,
	BothNoAttackerAreaNHitAction             = 4,
	NoGears                                  = 5,
	NoDepot                                  = 6,
	DeadEllipsisType_MAX                     = 7,
};

// Enum b1-Managed.EGSHairType
// NumValues: 0x0003
enum class EGSHairType : uint8
{
	TressFX                                  = 0,
	HairStrands                              = 1,
	EGSHairType_MAX                          = 2,
};

// Enum b1-Managed.PatrolType
// NumValues: 0x0008
enum class EPatrolType : uint8
{
	None                                     = 0,
	Random                                   = 1,
	Spline                                   = 2,
	Leisure                                  = 3,
	Follow                                   = 4,
	Group                                    = 5,
	MultiSpline                              = 6,
	PatrolType_MAX                           = 7,
};

// Enum b1-Managed.PhysAnimType
// NumValues: 0x000B
enum class EPhysAnimType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	BeAttack                                 = 2,
	PhysicBlend                              = 3,
	BeCatchThrow                             = 4,
	PhysicsSimulationMove                    = 5,
	DeathPhysicBlend                         = 6,
	DATA_MAX                                 = 7,
	Death                                    = 8,
	ThrowUpDeath                             = 9,
	PhysAnimType_MAX                         = 10,
};

// Enum b1-Managed.PointsGenType
// NumValues: 0x0006
enum class EPointsGenType : uint8
{
	ByEQS_Async                              = 0,
	ByEQS_Sync                               = 1,
	BySocket                                 = 2,
	BySceneItem                              = 3,
	ExplodeLineTrace                         = 4,
	PointsGenType_MAX                        = 5,
};

// Enum b1-Managed.CastSkillSourceType
// NumValues: 0x002D
enum class ECastSkillSourceType : uint8
{
	Default                                  = 0,
	Blueprint                                = 1,
	PersonalTest                             = 2,
	Notify                                   = 3,
	QA                                       = 4,
	SkillPreview                             = 5,
	BT                                       = 6,
	AI_GOAP                                  = 7,
	AI_Combo                                 = 8,
	AI_Score                                 = 9,
	AI_ReturnHome                            = 10,
	AI_OnFight                               = 11,
	AI_Born                                  = 12,
	GroupAI                                  = 13,
	OnFightTrigger                           = 14,
	AIInteract                               = 15,
	ChargeSkill                              = 16,
	CloudMove                                = 17,
	DodgeSkill                               = 18,
	FaBaoSkill                               = 19,
	GlideMove                                = 20,
	GM                                       = 21,
	HardMove                                 = 22,
	Intimidate                               = 23,
	MagicallyChange                          = 24,
	PhantomRush                              = 25,
	PlayerItem                               = 26,
	PlayerTrans                              = 27,
	PreciseDodge                             = 28,
	Rebirth                                  = 29,
	BornSkill                                = 30,
	PhaseTransition                          = 31,
	SmartCastSkill                           = 32,
	SummonBehavior                           = 33,
	CBG                                      = 34,
	CPG                                      = 35,
	CQG                                      = 36,
	ComboDebug                               = 37,
	Interact                                 = 38,
	Teleport                                 = 39,
	SummonBorn                               = 40,
	Trans                                    = 41,
	TransitionPhase                          = 42,
	TurnSkill                                = 43,
	CastSkillSourceType_MAX                  = 44,
};

// Enum b1-Managed.MapCatFlag
// NumValues: 0x0011
enum class EMapCatFlag : uint8
{
	CAT_NONE                                 = 0,
	CAT_N                                    = 1,
	CAT_S                                    = 2,
	CAT_NS                                   = 3,
	CAT_W                                    = 4,
	CAT_NW                                   = 5,
	CAT_SW                                   = 6,
	CAT_NSW                                  = 7,
	CAT_E                                    = 8,
	CAT_NE                                   = 9,
	CAT_SE                                   = 10,
	CAT_NSE                                  = 11,
	CAT_WE                                   = 12,
	CAT_NWE                                  = 13,
	CAT_SWE                                  = 14,
	CAT_NSWE                                 = 15,
	CAT_MAX                                  = 16,
};

// Enum b1-Managed.PointBlockLocFlag
// NumValues: 0x000B
enum class EPointBlockLocFlag : uint8
{
	PBL_NONE                                 = 0,
	PBL_N                                    = 1,
	PBL_S                                    = 2,
	PBL_W                                    = 4,
	PBL_NW                                   = 5,
	PBL_SW                                   = 6,
	PBL_E                                    = 8,
	PBL_NE                                   = 9,
	PBL_SE                                   = 10,
	PBL_NSWE                                 = 15,
	PBL_MAX                                  = 16,
};

// Enum b1-Managed.ProceduralMapType
// NumValues: 0x0004
enum class EProceduralMapType : uint8
{
	PROCEDURAL_DUNGEON                       = 0,
	PROCEDURAL_WILDERNESS_LINEAR             = 1,
	PROCEDURAL_DEMO_MAP                      = 2,
	PROCEDURAL_MAX                           = 3,
};

// Enum b1-Managed.AnimMode
// NumValues: 0x0006
enum class EAnimMode : uint8
{
	DefaultAnim                              = 0,
	PatrolAnim                               = 1,
	EQSRunAnim                               = 2,
	ShieldAnim                               = 3,
	PowerStorageAnim                         = 4,
	AnimMode_MAX                             = 5,
};

// Enum b1-Managed.InputTipsType
// NumValues: 0x0058
enum class EInputTipsType : uint8
{
	Min                                      = 0,
	Obs_Mode                                 = 10,
	TalentMain_Select                        = 20,
	TalentMain_ResetSelect                   = 21,
	Talent_Reset                             = 22,
	SpellConfig_Select                       = 30,
	SpellConfig_SelectNotSet                 = 31,
	Equip_EquipSlot                          = 40,
	Equip_QuickItemSlot_HadConfig            = 41,
	Equip_QuickItemSlot_NotConfig            = 42,
	Equip_AccessorySlot_HadConfig            = 43,
	Equip_AccessorySlot_NotConfig            = 44,
	Equip_Accessory_HadConfig                = 45,
	Equip_Accessory_NotConfig                = 46,
	Equip_Accessory_CurConfig                = 47,
	Equip_Min_CanEnterTPMode                 = 48,
	Equip_EquipSlot_CanEnterTPMode           = 49,
	Equip_QuickItemSlot_HadConfig_CanEnterTPMode = 50,
	Equip_QuickItemSlot_NotConfig_CanEnterTPMode = 51,
	Equip_AccessorySlot_HadConfig_CanEnterTPMode = 52,
	Equip_AccessorySlot_NotConfig_CanEnterTPMode = 53,
	Bag_CanUse                               = 60,
	Bag_CantUse                              = 61,
	Bag_HadConfig                            = 62,
	Bag_SlotNotConfig                        = 63,
	Bag_SlotHadConfig                        = 64,
	Bag_ItemConfiging_NotConfig              = 65,
	Bag_ItemConfiging_HadConfig              = 66,
	Bag_ItemConfiging_CurConfig              = 67,
	Shop_CanBuy                              = 80,
	Shop_CantBuy                             = 81,
	Shop_Sell                                = 82,
	Shop_SecConfirm                          = 83,
	WeaponBuild_CanShowTree                  = 90,
	WeaponBuild_CantShowTree                 = 91,
	WeaponBuild_ShowTree                     = 92,
	Soaking_MainPage_Wine                    = 100,
	Soaking_WineList_NotConfig               = 101,
	Soaking_WineList_CurConfig               = 102,
	Soaking_MainPage_WineItemSlot_NotConfig  = 103,
	Soaking_MainPage_WineItemSlot_HadConfig  = 104,
	Soaking_WineItemList_HadConfig           = 105,
	Soaking_WineItemList_NotConfig           = 106,
	Soaking_WineItemList_CurConfig           = 107,
	Medicine_Interact                        = 120,
	Medicine_Shrine                          = 121,
	Medicine_Interact_Sort                   = 122,
	Medicine_Shrine_Sort                     = 123,
	Alchemy_Tips                             = 130,
	TravelNotes_Unfold                       = 140,
	TravelNotes_Fold                         = 141,
	ChapterAward_CameraRoam                  = 150,
	ChapterAward_CameraRoam_Start            = 151,
	ChapterAward_CameraRoam_Middle           = 152,
	ChapterAward_CameraRoam_End              = 153,
	Learn_DSTalent_Menu_LeftFocusCanSwitch   = 160,
	Learn_DSTalent_RebirthPoint_LeftFocusCanSwitch = 161,
	Learn_DSTalent_Menu_LeftFocusCantSwitch  = 162,
	Learn_DSTalent_RebirthPoint_LeftFocusCantSwitch = 163,
	Learn_DSTalent_Menu_RightFocus           = 164,
	Learn_DSTalent_RebirthPoint_RightFocus   = 165,
	Farm_Can_Collect                         = 180,
	Farm_Cant_Collect                        = 181,
	Farm_LongPress_Button                    = 182,
	Farm_Output_Info                         = 183,
	Farm_Seed_Info                           = 184,
	SoulSkill_Item                           = 190,
	SoulSkill_LongPress                      = 191,
	BenchMark_Report                         = 200,
	Archive_LoadArchive                      = 210,
	Setting_BenchMark                        = 220,
	Setting_Main                             = 221,
	Setting_Exit                             = 222,
	Setting_Normal_Confirm                   = 223,
	Setting_Normal                           = 224,
	Setting_BenchMark_Quality_Confirm        = 225,
	Setting_BenchMark_Quality                = 226,
	Setting_BenchMark_Confirm                = 227,
	Setting_Quality_Confirm                  = 228,
	Setting_Quality                          = 229,
	Setting_NoConfirm                        = 230,
	Setting_Confirm                          = 231,
	EditionAward_Item                        = 240,
	EditionAward_LongPress                   = 241,
	MeditationPoint_CanPlay                  = 250,
	MeditationPoint_CantPlay                 = 251,
	MeditationPoint_Playing                  = 252,
	InputTipsType_MAX                        = 253,
};

// Enum b1-Managed.BlockCounterType
// NumValues: 0x0003
enum class EBlockCounterType : uint8
{
	AddCountAfterBounced                     = 0,
	AddCountAfterBlock                       = 1,
	BlockCounterType_MAX                     = 2,
};

// Enum b1-Managed.BlockAMSelectMode
// NumValues: 0x0003
enum class EBlockAMSelectMode : uint8
{
	SequenceSelectMode                       = 0,
	RandomSelectMode                         = 1,
	BlockAMSelectMode_MAX                    = 2,
};

// Enum b1-Managed.ProjectileSpawnerType
// NumValues: 0x0004
enum class EProjectileSpawnerType : uint8
{
	EffectCaster                             = 0,
	EffectTarget                             = 1,
	EffectRootCaster                         = 2,
	ProjectileSpawnerType_MAX                = 3,
};

// Enum b1-Managed.LevelTag
// NumValues: 0x0005
enum class ELevelTag : uint8
{
	None                                     = 0,
	Party                                    = 1,
	SupportRide                              = 2,
	SupportOpenMap                           = 3,
	LevelTag_MAX                             = 4,
};

// Enum b1-Managed.KillUnitMapCond
// NumValues: 0x0005
enum class EKillUnitMapCond : uint8
{
	Crit                                     = 0,
	NoCodition                               = 1,
	Unparalleled                             = 2,
	PerfectChargeDamage                      = 3,
	KillUnitMapCond_MAX                      = 4,
};

// Enum b1-Managed.KillUnitMapResult
// NumValues: 0x0004
enum class EKillUnitMapResult : uint8
{
	HeadShot                                 = 0,
	RandomCut                                = 1,
	Boom                                     = 2,
	KillUnitMapResult_MAX                    = 3,
};

// Enum b1-Managed.InteractInfoTemplateType
// NumValues: 0x0007
enum class EInteractInfoTemplateType : uint8
{
	Humankind                                = 0,
	InteractInfoTemplateType_1               = 1,
	InteractInfoTemplateType_2               = 2,
	InteractInfoTemplateType_3               = 3,
	InteractInfoTemplateType_4               = 4,
	InteractInfoTemplateType_5               = 5,
	InteractInfoTemplateType_MAX             = 6,
};

// Enum b1-Managed.EGSInputChangeType
// NumValues: 0x0004
enum class EGSInputChangeType : uint8
{
	All                                      = 0,
	Gamepad                                  = 1,
	KeyboardMouse                            = 2,
	EGSInputChangeType_MAX                   = 3,
};

// Enum b1-Managed.EGSInputTab
// NumValues: 0x0005
enum class EGSInputTab : uint8
{
	Comm                                     = 0,
	Battle                                   = 1,
	System                                   = 2,
	Other                                    = 3,
	EGSInputTab_MAX                          = 4,
};

// Enum b1-Managed.EGSKeyMappingType
// NumValues: 0x0004
enum class EGSKeyMappingType : uint8
{
	Comm                                     = 0,
	Move                                     = 1,
	Spell                                    = 2,
	EGSKeyMappingType_MAX                    = 3,
};

// Enum b1-Managed.CustomizedKeyUnlockCondition
// NumValues: 0x0007
enum class ECustomizedKeyUnlockCondition : uint8
{
	AlwaysShow                               = 0,
	MagicArtifact                            = 1,
	VigorSkill                               = 2,
	Cloud                                    = 3,
	PropStance                               = 4,
	PokeStance                               = 5,
	CustomizedKeyUnlockCondition_MAX         = 6,
};

// Enum b1-Managed.DropItemPerfromType
// NumValues: 0x0005
enum class EDropItemPerfromType : uint8
{
	WithOutPick                              = 0,
	Standard                                 = 1,
	WithDropAnim                             = 2,
	FixedPoint                               = 3,
	DropItemPerfromType_MAX                  = 4,
};

// Enum b1-Managed.AiBreakInteractionType
// NumValues: 0x0005
enum class EAiBreakInteractionType : uint8
{
	Battle                                   = 0,
	PlayerFaraway                            = 1,
	PlayerLeaveInteractArea                  = 2,
	Other                                    = 3,
	AiBreakInteractionType_MAX               = 4,
};

// Enum b1-Managed.UnitDynamicObstaclePerformAMType
// NumValues: 0x0004
enum class EUnitDynamicObstaclePerformAMType : uint8
{
	OnlyFront                                = 0,
	FrontAndBehind                           = 1,
	FourDir                                  = 2,
	UnitDynamicObstaclePerformAMType_MAX     = 3,
};

// Enum b1-Managed.HitAltFxAnimalRotType
// NumValues: 0x0007
enum class EHitAltFxAnimalRotType : uint8
{
	CamDir_Fwd                               = 0,
	CamDir_Bwd                               = 1,
	CamDir_Right                             = 2,
	CamDir_Left                              = 3,
	RotToPlayer                              = 4,
	RotToPlayerSurround                      = 5,
	HitAltFxAnimalRotType_MAX                = 6,
};

// Enum b1-Managed.EIDType_Outlaw
// NumValues: 0x0005
enum class EIDType_Outlaw : uint8
{
	Projectile                               = 0,
	SkillEffect                              = 1,
	Buff                                     = 2,
	Summon                                   = 3,
	EIDType_MAX                              = 4,
};

// Enum b1-Managed.EEQCType
// NumValues: 0x0005
enum class EEQCType : uint8
{
	None                                     = 0,
	Target                                   = 1,
	Player                                   = 2,
	Querier                                  = 3,
	EEQCType_MAX                             = 4,
};

// Enum b1-Managed.AbnromalDispActionType_FreezeExt
// NumValues: 0x0004
enum class EAbnromalDispActionType_FreezeExt : uint8
{
	Broken                                   = 0,
	AutoRelease                              = 1,
	ShakeFreeze                              = 2,
	AbnromalDispActionType_MAX               = 3,
};

// Enum b1-Managed.AssociationUnitSpawnType
// NumValues: 0x0003
enum class EAssociationUnitSpawnType : uint8
{
	BySceneItem                              = 0,
	ByEQS                                    = 1,
	AssociationUnitSpawnType_MAX             = 2,
};

// Enum b1-Managed.AssociationUnitActiveType
// NumValues: 0x0003
enum class EAssociationUnitActiveType : uint8
{
	ActiveImmediately                        = 0,
	NoActive                                 = 1,
	AssociationUnitActiveType_MAX            = 2,
};

// Enum b1-Managed.PlayerTransEndType
// NumValues: 0x0012
enum class EPlayerTransEndType : uint8
{
	None                                     = 0,
	CastSpell                                = 1,
	ManualEndRide                            = 2,
	BeatBack                                 = 3,
	EnergyEmpty                              = 4,
	RebirthTransBack                         = 5,
	CPGTransBack                             = 6,
	HpTransBack                              = 7,
	Simplestate                              = 8,
	CantRide                                 = 9,
	CantTrans                                = 10,
	Buff                                     = 11,
	TriggerBoxForceTransBack                 = 12,
	SkillEffect                              = 13,
	CMGTransBack                             = 14,
	SettingransBack                          = 15,
	Plot                                     = 16,
	PlayerTransEndType_MAX                   = 17,
};

// Enum b1-Managed.PlayerTransBeginType
// NumValues: 0x000B
enum class EPlayerTransBeginType : uint8
{
	None                                     = 0,
	CastSpell                                = 1,
	AddBuff                                  = 2,
	BianChan                                 = 3,
	Ride                                     = 4,
	ReadArchive                              = 5,
	SkillEffect                              = 6,
	Plot                                     = 7,
	RebirthPoint                             = 8,
	Sequence                                 = 9,
	PlayerTransBeginType_MAX                 = 10,
};

// Enum b1-Managed.AimType
// NumValues: 0x0004
enum class EAimType : uint8
{
	NONE                                     = 0,
	AIM_TO_CUR_TARGET                        = 1,
	XYLineFromOwner                          = 2,
	AimType_MAX                              = 3,
};

// Enum b1-Managed.DamageNumberType
// NumValues: 0x0006
enum class EDamageNumberType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Critical                                 = 2,
	RecoveryHP                               = 3,
	Backstap                                 = 4,
	DamageNumberType_MAX                     = 5,
};

// Enum b1-Managed.BeAttackedBlendType
// NumValues: 0x0006
enum class EBeAttackedBlendType : uint8
{
	None                                     = 0,
	Physics                                  = 1,
	AdditiveAnim                             = 2,
	MatJitter                                = 4,
	Scar                                     = 8,
	BeAttackedBlendType_MAX                  = 9,
};

// Enum b1-Managed.EBGUSimpleState
// NumValues: 0x009F
enum class EBGUSimpleState : uint8
{
	Normal                                   = 0,
	ImmueDamage                              = 1,
	CantAttack                               = 2,
	CantMove                                 = 3,
	CancelLifeSavingCD                       = 4,
	IgnoreTargetElemDef                      = 5,
	IgnoreAllInput                           = 6,
	CanHitBullet                             = 7,
	PEClearProtect                           = 8,
	Immobilizing                             = 9,
	ImmueDmgExceptElementDmg                 = 10,
	ImmueFreezeAcc                           = 11,
	BanInputButCamera                        = 12,
	CanBlendToDeadAM                         = 13,
	ImmueFrozenBrokenAM                      = 14,
	CantBeDead                               = 15,
	CantPlayShakeFreezeAM                    = 16,
	ImmueStiff                               = 17,
	ImmueImmobilizing                        = 18,
	ImmueAnimationSyncing                    = 19,
	ForbidLifeSavingHair                     = 20,
	BreakPart2Weak                           = 22,
	ImmueBurnAcc                             = 23,
	ImmuePoisonAcc                           = 24,
	ImmueThunderAcc                          = 25,
	CantSweepUnit                            = 26,
	UseCarMontageMoveMode                    = 27,
	CantBeSweepChecked                       = 28,
	ImmueDeadZone                            = 29,
	CantBeLock                               = 30,
	StaminaDepleted                          = 31,
	SeduceAttack                             = 32,
	CancelSkillCD                            = 33,
	MoveSlowly                               = 35,
	CantBeBaseTarget                         = 38,
	SkillSuperArmor                          = 39,
	StaminaLock                              = 40,
	HRCounterattackProtectOneFrame           = 42,
	BreakSkillSuperArmor                     = 43,
	Silent                                   = 44,
	BounceAttack                             = 45,
	CanForceAttackInChargeSkill              = 47,
	CanTriggerBeHitAdditiveAnim              = 48,
	DynamicUpperBodyMode                     = 50,
	DynamicLeftArmMode                       = 51,
	DynamicRightArmMode                      = 52,
	LockStateWalking                         = 53,
	FlyControlMode                           = 54,
	TPSMode                                  = 55,
	PlayerInSeq                              = 56,
	ImmueAttackPerformEffect                 = 57,
	DisableFreezeFrame                       = 58,
	ImmueBeAttackedPerformEffect             = 59,
	KeepMMRunning                            = 61,
	CanDefeatTTTB                            = 62,
	Mute                                     = 63,
	LockRotation                             = 64,
	Imperceptible                            = 66,
	IgnoreHostile                            = 68,
	InPhaseTransition                        = 69,
	InPointAttraction                        = 71,
	ForcePerformance                         = 72,
	PlayerCantLock                           = 73,
	CanTriggerBlockNormal                    = 74,
	ForceSkill                               = 75,
	BreakBlock                               = 76,
	InAnimationSyncing                       = 77,
	CanTriggerBlockInSPState                 = 78,
	BreakBlock2Weak                          = 79,
	InTTTB                                   = 80,
	MontageSectionJumpApproved               = 81,
	Frozen                                   = 82,
	FreezeImmue                              = 83,
	BurnImmue                                = 84,
	PoisonImmue                              = 85,
	ThunderImmue                             = 86,
	PhysicsSimulationMoveMode                = 87,
	PhantomRush                              = 88,
	BreakImmobilize2Weak                     = 89,
	BeTaunted                                = 90,
	SplineFlyWaiting                         = 91,
	PlayerDeadNoPunish                       = 92,
	SpiderSilkyHardMoving                    = 93,
	FrozenMoving                             = 94,
	MuddyMoving                              = 95,
	WinddyMoving                             = 96,
	ImmuneNeutral                            = 97,
	ImmunePositive                           = 98,
	ImmuneNegative                           = 99,
	InUpdraft                                = 100,
	Interacting                              = 101,
	CantShowBlood                            = 102,
	PendingDeathInAnimationSyncing           = 103,
	IgnoreSpell                              = 104,
	IgnoreRollSkill                          = 105,
	IgnoreUnitTransSkill                     = 107,
	IgnoreSpinLightInput                     = 108,
	IgnoreInteractInput                      = 109,
	IgnoreMoveInput                          = 110,
	IgnoreJumpInput                          = 111,
	IgnoreLightAttackInput                   = 112,
	IgnoreHeavyAttackInput                   = 113,
	YinImmue                                 = 114,
	YangImmue                                = 115,
	CommonDamageImmue                        = 116,
	StrongDamageImmue                        = 117,
	IgnoreAlignCapsule2Surface               = 118,
	WithinOceanSea                           = 119,
	NoAutoTransformBack                      = 120,
	DeadUseFixCamera                         = 121,
	IgnoreMoveBackInput                      = 123,
	IgnoreXAxisMoveInput                     = 124,
	DisableAutoRecoverFreeze                 = 125,
	DisableAutoRecoverBurn                   = 126,
	DisableAutoRecoverPoison                 = 127,
	DisableAutoRecoverThunder                = 128,
	DisableAutoRecoverYin                    = 129,
	DisableAutoRecoverYang                   = 130,
	CantHatredTick                           = 133,
	Berserk                                  = 134,
	IgnoreBattleInfoInUnitBar                = 135,
	CantTransBack                            = 136,
	TransEnergyLock                          = 137,
	PELock                                   = 138,
	DamageTransfer                           = 139,
	RidingExitingStatus                      = 140,
	CantTrans                                = 141,
	BanLegacyTalent                          = 142,
	CloudMove                                = 143,
	CricketIdle                              = 144,
	DisableImmobilizedBreakAnim              = 145,
	EnableSpecialImmobilizedBreakAnim        = 146,
	FabaoEnergyLock                          = 147,
	VigorEnergyLock                          = 148,
	CantGainFabaoEnergy                      = 149,
	CantGainVigorEnergy                      = 150,
	InteractCricketLoop                      = 151,
	InInteractAnimationSyncing               = 152,
	RefuseAttackRotation                     = 153,
	RefuseAMScale                            = 154,
	DisableHRCounterAttack                   = 155,
	DisableDamageNumUI                       = 156,
	Camouflage                               = 157,
	CantShowLock                             = 158,
	PreAnimationSyncing                      = 159,
	IgnoreVigorSkill                         = 160,
	CantInVigorSkill                         = 161,
	CantInteract                             = 162,
	Sentry                                   = 163,
	LockMP                                   = 164,
	CantBeAutoLockTarget                     = 165,
	CantShowDamageUI                         = 166,
	TargetCantShowLock                       = 167,
	CantTriggerPreciseDodge                  = 168,
	BanTrans2DaSheng                         = 169,
	CantCastFaBao                            = 170,
	CantTransInSeq                           = 171,
	EnumMax                                  = 172,
	EBGUSimpleState_MAX                      = 173,
};

// Enum b1-Managed.EBGUUnitState
// NumValues: 0x002F
enum class EBGUUnitState : uint8
{
	None                                     = 0,
	Attacking                                = 1,
	AttackMoving                             = 2,
	AttackRotation                           = 3,
	Beatback                                 = 4,
	InComboWindow                            = 5,
	Dead                                     = 6,
	SideWalking                              = 7,
	Sprinting                                = 8,
	Walking                                  = 9,
	AtkComboKeyCache                         = 10,
	DodgeComboKeyCache                       = 11,
	MagicKeyCache                            = 12,
	InDodgeWindow                            = 13,
	InMagicWindow                            = 14,
	HRCounterattacking                       = 15,
	ShooterMode                              = 16,
	BMMoveAttack                             = 17,
	AttackAlignUpperBodyToSlope              = 18,
	AttackAlignWholeBodyToSlope              = 19,
	JumpMoving                               = 20,
	FloatingHit                              = 21,
	GlideMoving                              = 22,
	InMoveWindow                             = 23,
	BlockBeatBack                            = 24,
	PerfectBlockBeatBack                     = 25,
	BlockBounced                             = 26,
	FreezeAccProtect                         = 27,
	ImpactActionPlaying                      = 28,
	BlindStiff                               = 29,
	Teleporting                              = 30,
	InAbortWindow                            = 31,
	InAnimationSyncDeathWindow               = 32,
	JumpWindow                               = 33,
	PhasePerformance                         = 34,
	LifeSavingHair_FakeDead                  = 35,
	LifeSavingHair_Rebirth                   = 36,
	VigorKeyCache                            = 37,
	InVigorWindow                            = 38,
	ItemSkillKeyCache                        = 39,
	InItemSkillWindow                        = 40,
	LifeSavingHairBlocking                   = 41,
	InInteractWindow                         = 42,
	InCloudWindow                            = 43,
	InChapterClearWorkFlow                   = 44,
	EnumMax                                  = 45,
	EBGUUnitState_MAX                        = 46,
};

// Enum b1-Managed.EBUStateTrigger
// NumValues: 0x0048
enum class EBUStateTrigger : uint8
{
	None                                     = 0,
	Die                                      = 1,
	Rebirth                                  = 2,
	CastSkillSuccess                         = 3,
	AttackStateBegin                         = 4,
	AttackRotationBegin                      = 5,
	SkillBreak                               = 6,
	Beatback                                 = 7,
	EnterComboWindow                         = 8,
	AtkRebounding                            = 9,
	UnitInputWalkPressed                     = 10,
	UnitInputWalkRelease                     = 11,
	UnitInputSprintPressed                   = 12,
	UnitInputSprintRelease                   = 13,
	BreakSprint                              = 14,
	EnableMoveInSkill                        = 15,
	EnterAtkComboKeyCache                    = 16,
	EnterDodgeComboKeyCache                  = 17,
	EnterDodgeWindow                         = 18,
	EnterMagicKeyCache                       = 19,
	EnterMagicWindow                         = 20,
	HRCounterattackBegin                     = 21,
	ShooterModeTrigger                       = 22,
	ShooterModeClear                         = 23,
	BMMoveAttackTrigger                      = 24,
	BMMoveAttackClear                        = 25,
	AttackAlignUpperBodyToSlopeBegin         = 26,
	AttackAlignWholeBodyToSlopeBegin         = 27,
	JumpMovingStart                          = 28,
	JumpMovingStop                           = 29,
	ShootModeTigger                          = 30,
	ShootModeClear                           = 31,
	AIInputSprint                            = 32,
	AIInputRun                               = 33,
	AIInputWalk                              = 34,
	BeginFloatingHit                         = 35,
	EndFloatingHit                           = 36,
	EnterGlideMove                           = 37,
	EndGlideMove                             = 38,
	EnterMoveWindow                          = 39,
	EnterBlockBeatBack                       = 70,
	EnterPerfectBlockBeatBack                = 71,
	EnterBlockBounced                        = 72,
	LeaveAllBlockState                       = 73,
	FreezeAccProtectBegin                    = 74,
	EnableImpactAction                       = 75,
	EnterBlindStiff                          = 76,
	TeleportBegin                            = 77,
	TeleportEnd                              = 78,
	EnterAbortWindow                         = 79,
	EnterAnimationSyncDeathWindow            = 80,
	EnterJumpWindow                          = 81,
	ExitJumpWindow                           = 82,
	StartJump                                = 83,
	StartMoveInMoveWindow                    = 84,
	EnterPhasePerformance                    = 85,
	ExitPhasePerformance                     = 86,
	Enter_LifeSavingHair_FakeDead            = 87,
	Enter_LifeSavingHair_Rebirth             = 88,
	Exit_LifeSavingHair                      = 89,
	EnterVigorKeyCache                       = 90,
	EnterVigorWindow                         = 91,
	EnterItemSkillKeyCache                   = 92,
	EnterItemSkillWindow                     = 93,
	EnterLifeSavingHairBlocking              = 94,
	ExitLifeSavingHairBlocking               = 95,
	EnterInteractWindow                      = 96,
	EnterCloudWindow                         = 97,
	EnterChapterClearWorkFlow                = 98,
	ExitChapterClearWorkFlow                 = 99,
	EnumMax                                  = 100,
	EBUStateTrigger_MAX                      = 101,
};

// Enum b1-Managed.CastSkillResult
// NumValues: 0x0009
enum class ECastSkillResult : uint8
{
	CSR_OK                                   = 0,
	CSR_CAST_CHR_FAILED                      = 1,
	CSR_FIND_NO_SKILLDESC                    = 2,
	CSR_FIND_NO_UNITDESC                     = 3,
	CSR_FIND_NO_SKILLMONTAGE                 = 4,
	CSR_FIND_NO_ANIMINST                     = 5,
	CSR_CAN_CAST_SKILL_CHECK_FAILED          = 6,
	CSR_OTHER                                = 7,
	CSR_MAX                                  = 8,
};

// Enum b1-Managed.EBPBuffID
// NumValues: 0x0011
enum class EBPBuffID : uint8
{
	NoneBuff                                 = 0,
	SmallStunBuff                            = 200,
	BigStunBuff                              = 201,
	SkillCastingBuff                         = 202,
	ShieldDefenceBuff                        = 203,
	SpawnDoingBuff                           = 206,
	TianjiangEnterAIStage2                   = 208,
	FightBackBuff                            = 209,
	ImmueStiffBuff                           = 210,
	SuperImmueStiffBuff                      = 211,
	InvincibleBuff                           = 212,
	ImmueDamage                              = 213,
	DemoChangeCharacter                      = 216,
	DemoFTXDInvincibleBuff                   = 218,
	DemoTianJiangInterQTEBuff                = 219,
	EnumMax                                  = 255,
	EBPBuffID_MAX                            = 256,
};

// Enum b1-Managed.EBGUMoveAIType
// NumValues: 0x0005
enum class EBGUMoveAIType : uint8
{
	None                                     = 0,
	KeepFacingTarget                         = 1,
	Flock                                    = 2,
	FacingVelocity                           = 3,
	EBGUMoveAIType_MAX                       = 4,
};

// Enum b1-Managed.EAIMoveSpeedType
// NumValues: 0x0004
enum class EAIMoveSpeedType : uint8
{
	JOG                                      = 0,
	RUN                                      = 1,
	SPRINT                                   = 2,
	EAIMoveSpeedType_MAX                     = 3,
};

// Enum b1-Managed.EBGUMoveMode
// NumValues: 0x001E
enum class EBGUMoveMode : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	BeatBack                                 = 2,
	SideWalk                                 = 3,
	AttackRotate                             = 4,
	TPSRotate                                = 5,
	AIPathMove                               = 6,
	AnimationMontage                         = 7,
	CameraG4Move                             = 8,
	AIWallAndCellMove                        = 9,
	CurveSplineMove                          = 10,
	JumpMove                                 = 11,
	StandRotate                              = 12,
	CarMontage                               = 13,
	FlyControl                               = 14,
	PlayerAutoMove                           = 15,
	GlideMove                                = 16,
	ParkourMove                              = 17,
	SplineFlyControl                         = 18,
	RelativeFloatMove                        = 19,
	AIFlyMove                                = 20,
	RotateWithCam                            = 21,
	PhysicsSimulation                        = 22,
	ManualSplineMove                         = 23,
	NpcGuideSplineMove                       = 24,
	AISpiderMove                             = 25,
	TurretRotate                             = 26,
	CloudMove                                = 27,
	EnumMax                                  = 28,
	EBGUMoveMode_MAX                         = 29,
};

// Enum b1-Managed.EBGUComboKey
// NumValues: 0x0008
enum class EBGUComboKey : uint8
{
	None                                     = 0,
	LightAttackDown                          = 1,
	HeavyAttackDown                          = 2,
	LightAttackUp                            = 3,
	HeavyAttackUp                            = 4,
	RollDown                                 = 5,
	RollUp                                   = 6,
	EBGUComboKey_MAX                         = 7,
};

// Enum b1-Managed.EBGUBotLifeTimeState
// NumValues: 0x0007
enum class EBGUBotLifeTimeState : uint8
{
	Idle                                     = 0,
	Battle                                   = 1,
	Dead                                     = 2,
	Patrol                                   = 3,
	ReturnHome                               = 4,
	EnumMax                                  = 5,
	EBGUBotLifeTimeState_MAX                 = 6,
};

// Enum b1-Managed.EBGUDeadLogicType
// NumValues: 0x0006
enum class EBGUDeadLogicType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	FlyByPhysical                            = 2,
	AI                                       = 3,
	Sequence                                 = 4,
	EBGUDeadLogicType_MAX                    = 5,
};

// Enum b1-Managed.EBGUMoveCurveType
// NumValues: 0x0004
enum class EBGUMoveCurveType : uint8
{
	None                                     = 0,
	SpeedCurve                               = 1,
	DistanceCurve                            = 2,
	EBGUMoveCurveType_MAX                    = 3,
};

// Enum b1-Managed.PhysicBlendInType
// NumValues: 0x0003
enum class EPhysicBlendInType : uint8
{
	Immediately                              = 0,
	BlendByTime                              = 1,
	PhysicBlendInType_MAX                    = 2,
};

// Enum b1-Managed.PhysicBlendOutType
// NumValues: 0x0004
enum class EPhysicBlendOutType : uint8
{
	Immediately                              = 0,
	BlendByTimeBeforeEnd                     = 1,
	BlendByTimeAfterEnd                      = 2,
	PhysicBlendOutType_MAX                   = 3,
};

// Enum b1-Managed.FindSceneItemWay
// NumValues: 0x000A
enum class EFindSceneItemWay : uint8
{
	FindNearest                              = 0,
	FindFurthest                             = 1,
	FindMinTotalAngle                        = 2,
	Composite                                = 3,
	CompositeV2                              = 4,
	FindNearestToTarget                      = 5,
	FindFurthestToTarget                     = 6,
	ClosestOutsideTheAngle                   = 7,
	FarthestOutsideTheAngle                  = 8,
	FindSceneItemWay_MAX                     = 9,
};

// Enum b1-Managed.SceneLocationType
// NumValues: 0x0002
enum class ESceneLocationType : uint8
{
	LandingPoint                             = 0,
	SceneLocationType_MAX                    = 1,
};

// Enum b1-Managed.EscapeWay
// NumValues: 0x0004
enum class EscapeWay : uint8
{
	None                                     = 0,
	MoveTo                                   = 1,
	CastSkill                                = 2,
	EscapeWay_MAX                            = 3,
};

// Enum b1-Managed.EscapeSkillConfigMode
// NumValues: 0x0005
enum class EscapeSkillConfigMode : uint8
{
	None                                     = 0,
	Single                                   = 1,
	Multiple                                 = 2,
	FromSceneItem                            = 3,
	EscapeSkillConfigMode_MAX                = 4,
};

// Enum b1-Managed.EAISearchTargetWay
// NumValues: 0x0004
enum class EAISearchTargetWay : uint8
{
	FindTargetNearest                        = 0,
	FindTargetFurthest                       = 1,
	FindTargetByHatred                       = 2,
	EAISearchTargetWay_MAX                   = 3,
};

// Enum b1-Managed.EAIRequestType
// NumValues: 0x0005
enum class EAIRequestType : uint8
{
	MoveToLoc                                = 0,
	MoveToActor                              = 1,
	DirDamage                                = 2,
	MoveSkill                                = 3,
	EAIRequestType_MAX                       = 4,
};

// Enum b1-Managed.EAIBasicActionState
// NumValues: 0x0009
enum class EAIBasicActionState : uint8
{
	None                                     = 0,
	Executing                                = 1,
	Finish                                   = 2,
	ErrorRequestType                         = 3,
	SkillNotFound                            = 4,
	RequestNoFound                           = 5,
	WaitingAbort                             = 6,
	Aborted                                  = 7,
	EAIBasicActionState_MAX                  = 8,
};

// Enum b1-Managed.EAIAttentionFeatureType
// NumValues: 0x0007
enum class EAIAttentionFeatureType : uint8
{
	None                                     = 0,
	NearestEnemy                             = 1,
	SkillArea                                = 2,
	StandInSkillArea                         = 3,
	SkillCastRange                           = 4,
	AttackableEnemy                          = 5,
	EAIAttentionFeatureType_MAX              = 6,
};

// Enum b1-Managed.SkillIDSource
// NumValues: 0x0003
enum class ESkillIDSource : uint8
{
	Custom                                   = 0,
	FromSceneItem                            = 1,
	SkillIDSource_MAX                        = 2,
};

// Enum b1-Managed.StandRotateType
// NumValues: 0x0005
enum class EStandRotateType : uint8
{
	Left90                                   = 0,
	Right90                                  = 1,
	Left180                                  = 2,
	Right180                                 = 3,
	StandRotateType_MAX                      = 4,
};

// Enum b1-Managed.MoveDirection
// NumValues: 0x0006
enum class EMoveDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Right                                    = 2,
	Backward                                 = 3,
	Left                                     = 4,
	MoveDirection_MAX                        = 5,
};

// Enum b1-Managed.MoveDirectionFive
// NumValues: 0x0007
enum class EMoveDirectionFive : uint8
{
	None                                     = 0,
	F                                        = 1,
	R                                        = 2,
	BR                                       = 3,
	BL                                       = 4,
	L                                        = 5,
	MoveDirectionFive_MAX                    = 6,
};

// Enum b1-Managed.MoveDirectionEight
// NumValues: 0x000A
enum class EMoveDirectionEight : uint8
{
	None                                     = 0,
	F                                        = 1,
	FR                                       = 2,
	R                                        = 3,
	BR                                       = 4,
	B                                        = 5,
	BL                                       = 6,
	L                                        = 7,
	FL                                       = 8,
	MoveDirectionEight_MAX                   = 9,
};

// Enum b1-Managed.LockMoveDirectionSix
// NumValues: 0x0008
enum class ELockMoveDirectionSix : uint8
{
	None                                     = 0,
	F                                        = 1,
	FL                                       = 2,
	FR                                       = 3,
	BL                                       = 4,
	BR                                       = 5,
	B                                        = 6,
	LockMoveDirectionSix_MAX                 = 7,
};

// Enum b1-Managed.MoveSpeedLevel
// NumValues: 0x0004
enum class EMoveSpeedLevel : uint8
{
	Walk                                     = 0,
	Run                                      = 1,
	Sprint                                   = 2,
	MoveSpeedLevel_MAX                       = 3,
};

// Enum b1-Managed.GaitGroundedState
// NumValues: 0x0006
enum class EGaitGroundedState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Walk                                     = 2,
	Run                                      = 3,
	Rush                                     = 4,
	GaitGroundedState_MAX                    = 5,
};

// Enum b1-Managed.EMMBehaviorState
// NumValues: 0x0002
enum class EMMBehaviorState : uint8
{
	MoveLoop                                 = 0,
	EMMBehaviorState_MAX                     = 1,
};

// Enum b1-Managed.EBGUSpeedCtrlID
// NumValues: 0x0004
enum class EBGUSpeedCtrlID : uint8
{
	MoveSpeedRate                            = 0,
	Custom                                   = 1,
	EnumMax                                  = 2,
	EBGUSpeedCtrlID_MAX                      = 3,
};

// Enum b1-Managed.SelectTargetTypeFilter
// NumValues: 0x0006
enum class ESelectTargetTypeFilter : uint8
{
	None                                     = 0,
	Character                                = 1,
	Bullet                                   = 2,
	MagicField                               = 4,
	DestructibleActor                        = 8,
	SelectTargetTypeFilter_MAX               = 9,
};

// Enum b1-Managed.FootStepType
// NumValues: 0x0003
enum class EFootStepType : uint8
{
	LeftFoot                                 = 0,
	RightFoot                                = 1,
	FootStepType_MAX                         = 2,
};

// Enum b1-Managed.SkillDirection
// NumValues: 0x0006
enum class ESkillDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Right                                    = 2,
	Backward                                 = 3,
	Left                                     = 4,
	SkillDirection_MAX                       = 5,
};

// Enum b1-Managed.State_MM
// NumValues: 0x000E
enum class EState_MM : uint8
{
	None                                     = 0,
	Lock                                     = 1,
	Free                                     = 2,
	FreeWalk                                 = 3,
	FreeRun                                  = 4,
	FreeSprint                               = 5,
	LockWalk                                 = 6,
	LockRun                                  = 7,
	LockSprint                               = 8,
	FrozenMove                               = 9,
	MuddyMove                                = 10,
	WindyMove                                = 11,
	SpiderSilkyMove                          = 12,
	State_MAX                                = 13,
};

// Enum b1-Managed.EB1CameraMode
// NumValues: 0x0003
enum class EB1CameraMode : uint8
{
	Normal                                   = 0,
	G4                                       = 1,
	EB1CameraMode_MAX                        = 2,
};

// Enum b1-Managed.EBSelectTargetRangeType
// NumValues: 0x0005
enum class EBSelectTargetRangeType : uint8
{
	None                                     = 0,
	CameraLock                               = 1,
	MeeleAttack                              = 2,
	EnumMax                                  = 3,
	EBSelectTargetRangeType_MAX              = 4,
};

// Enum b1-Managed.SummonBehaviorState
// NumValues: 0x0005
enum class ESummonBehaviorState : uint8
{
	Default                                  = 0,
	Idle                                     = 1,
	Follow                                   = 2,
	EnumMax                                  = 3,
	SummonBehaviorState_MAX                  = 4,
};

// Enum b1-Managed.PhysicsForceType
// NumValues: 0x0003
enum class EPhysicsForceType : uint8
{
	DirectionalForce                         = 0,
	ExplosiveForce                           = 1,
	PhysicsForceType_MAX                     = 2,
};

// Enum b1-Managed.ValueCompareType
// NumValues: 0x0007
enum class EValueCompareType : uint8
{
	IsEqualTo                                = 0,
	IsNotEqualTo                             = 1,
	IsLessThan                               = 2,
	IsLessThanOrEqualTo                      = 3,
	IsGreaterThan                            = 4,
	IsGreaterThanOrEqualTo                   = 5,
	ValueCompareType_MAX                     = 6,
};

// Enum b1-Managed.EBTTargetType
// NumValues: 0x0007
enum class EBTTargetType : uint8
{
	Target                                   = 0,
	Player                                   = 1,
	SceneItem                                = 2,
	Location                                 = 3,
	AlignToCamFwd                            = 4,
	None                                     = 5,
	EBTTargetType_MAX                        = 6,
};

// Enum b1-Managed.DropItemFlyCurveType
// NumValues: 0x0003
enum class EDropItemFlyCurveType : uint8
{
	FastBezier                               = 0,
	CurveTranslation                         = 1,
	DropItemFlyCurveType_MAX                 = 2,
};

// Enum b1-Managed.SwitchHeroReason
// NumValues: 0x0003
enum class ESwitchHeroReason : uint8
{
	Manual                                   = 0,
	Dead                                     = 1,
	SwitchHeroReason_MAX                     = 2,
};

// Enum b1-Managed.EBGUMoveAcceptableRadiusType
// NumValues: 0x0005
enum class EBGUMoveAcceptableRadiusType : uint8
{
	NoInclude                                = 0,
	IncludeSelf                              = 1,
	IncludeTarget                            = 2,
	BothIncludeSelfAndTarget                 = 3,
	EBGUMoveAcceptableRadiusType_MAX         = 4,
};

// Enum b1-Managed.TriggerType
// NumValues: 0x0006
enum class b1MinusManaged::ETriggerType : uint8
{
	None                                     = 0,
	Interact                                 = 1,
	Overlap                                  = 2,
	CharacterState                           = 3,
	CharacterAttr                            = 4,
	CircleRangeCharacterDie                  = 5,
};

// Enum b1-Managed.BeginEndOverlapTriggerDirectionType
// NumValues: 0x0004
enum class EBeginEndOverlapTriggerDirectionType : uint8
{
	None                                     = 0,
	SameDirection                            = 1,
	DiffDirection                            = 2,
	BeginEndOverlapTriggerDirectionType_MAX  = 3,
};

// Enum b1-Managed.PointGenBaseType
// NumValues: 0x0003
enum class EPointGenBaseType : uint8
{
	OwnCharacter                             = 0,
	Feature                                  = 1,
	PointGenBaseType_MAX                     = 2,
};

// Enum b1-Managed.PointTestType
// NumValues: 0x0009
enum class EPointTestType : uint8
{
	CheckAngle                               = 0,
	SkillArea                                = 1,
	Distance                                 = 2,
	SkillCastRange                           = 3,
	CharacterBlock                           = 4,
	NavPathExist                             = 5,
	Visible                                  = 6,
	Height                                   = 7,
	PointTestType_MAX                        = 8,
};

// Enum b1-Managed.AngleBaseType
// NumValues: 0x0004
enum class EAngleBaseType : uint8
{
	Self2Target                              = 0,
	Target2Self                              = 1,
	SelfXAxis                                = 2,
	AngleBaseType_MAX                        = 3,
};

// Enum b1-Managed.DisTestFilterType
// NumValues: 0x0002
enum class EDisTestFilterType : uint8
{
	DTF_Min                                  = 0,
	DTF_Max                                  = 1,
};

// Enum b1-Managed.DisTestBaseType
// NumValues: 0x0003
enum class EDisTestBaseType : uint8
{
	OwnCharacter                             = 0,
	Feature                                  = 1,
	DisTestBaseType_MAX                      = 2,
};

// Enum b1-Managed.RequestTestResult
// NumValues: 0x0005
enum class ERequestTestResult : uint8
{
	FeatureNotFound                          = 0,
	NoNeedToTest                             = 1,
	SelectFaild                              = 2,
	SelectSuccess                            = 3,
	RequestTestResult_MAX                    = 4,
};

// Enum b1-Managed.JumpType
// NumValues: 0x0005
enum class EJumpType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	GlideJump                                = 2,
	StrideJump                               = 3,
	JumpType_MAX                             = 4,
};

// Enum b1-Managed.ChangeTargetType
// NumValues: 0x0007
enum class EChangeTargetType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Master                                   = 2,
	Summon                                   = 3,
	SkillBaseTarget                          = 4,
	UnitGuid                                 = 5,
	ChangeTargetType_MAX                     = 6,
};

// Enum b1-Managed.MovePhysicsRotationType
// NumValues: 0x0004
enum class EMovePhysicsRotationType : uint8
{
	None                                     = 0,
	FollowVelocityXYPlane                    = 1,
	FollowVelocity                           = 2,
	MovePhysicsRotationType_MAX              = 3,
};

// Enum b1-Managed.NormalStiffSectorsType
// NumValues: 0x0004
enum class ENormalStiffSectorsType : uint8
{
	AllForward                               = 0,
	ForwardAndBackward                       = 1,
	FourDir                                  = 2,
	NormalStiffSectorsType_MAX               = 3,
};

// Enum b1-Managed.RotateDirection
// NumValues: 0x0004
enum class ERotateDirection : uint8
{
	Auto                                     = 0,
	Clockwise                                = 1,
	Counterclockwise                         = 2,
	RotateDirection_MAX                      = 3,
};

// Enum b1-Managed.SpecialMovementMode
// NumValues: 0x0008
enum class ESpecialMovementMode : uint8
{
	GroundMove                               = 0,
	AirMove                                  = 1,
	GlideMove                                = 2,
	ParkourMove                              = 3,
	WallMove                                 = 4,
	FlyMove                                  = 5,
	SplineMove                               = 6,
	SpecialMovementMode_MAX                  = 7,
};

// Enum b1-Managed.GlideMoveAnimState
// NumValues: 0x0005
enum class EGlideMoveAnimState : uint8
{
	None                                     = 0,
	GlideStart                               = 1,
	GlideLoop                                = 2,
	GlideEnd                                 = 3,
	GlideMoveAnimState_MAX                   = 4,
};

// Enum b1-Managed.ParkourMoveAnimState
// NumValues: 0x0006
enum class EParkourMoveAnimState : uint8
{
	None                                     = 0,
	ParkourStart                             = 1,
	ParkourStartFinished                     = 2,
	ParkourFall                              = 3,
	ParkourLand                              = 4,
	ParkourMoveAnimState_MAX                 = 5,
};

// Enum b1-Managed.GroupPriorityActionType
// NumValues: 0x0005
enum class EGroupPriorityActionType : uint8
{
	MoveToPos                                = 0,
	CastSkill                                = 1,
	AddBuff                                  = 2,
	EnumMax                                  = 255,
	GroupPriorityActionType_MAX              = 256,
};

// Enum b1-Managed.MontageSectionJumpType
// NumValues: 0x0003
enum class EMontageSectionJumpType : uint8
{
	None                                     = 0,
	AnimationSyncing                         = 1,
	MontageSectionJumpType_MAX               = 2,
};

// Enum b1-Managed.HitMoveDir
// NumValues: 0x0004
enum class EHitMoveDir : uint8
{
	Default                                  = 0,
	XAxisHitMove                             = 1,
	YAxisHitMove                             = 2,
	HitMoveDir_MAX                           = 3,
};

// Enum b1-Managed.ObserveConditionType
// NumValues: 0x0020
enum class EObserveConditionType : uint8
{
	None                                     = 0,
	PlayerEnterArea                          = 1,
	PlayerLeaveArea                          = 2,
	PlayerPenetrateArea                      = 3,
	PlayerInteractBegin                      = 4,
	PlayerInteractBreak                      = 5,
	PlayerInteractEnd                        = 6,
	PlayerInteractTimeEnd                    = 7,
	UnitAllDeadInnerRange                    = 8,
	SpawnUnitAllDead                         = 9,
	TimeOver                                 = 10,
	TimeOut                                  = 11,
	WakeUp                                   = 12,
	UnitDead                                 = 13,
	Trigger                                  = 14,
	GateOpen                                 = 15,
	GateClose                                = 16,
	ChallengeFailed                          = 17,
	ChallengeAwarded                         = 18,
	ChallengeSuccess                         = 19,
	ChallengeBegin                           = 20,
	UseTagFlag                               = 100,
	UnitDestroy                              = 101,
	UnitActive                               = 102,
	UnitInActive                             = 103,
	UnitAttr                                 = 104,
	SimpleState                              = 105,
	UnitState                                = 106,
	HasBuff                                  = 107,
	ItemFullOnline                           = 108,
	EnumMax                                  = 109,
	ObserveConditionType_MAX                 = 110,
};

// Enum b1-Managed.ObserveOnlineConditionType
// NumValues: 0x0008
enum class EObserveOnlineConditionType : uint8
{
	None                                     = 0,
	PlayerCountInRange                       = 1,
	PlayerEnterBossTraceArea                 = 2,
	KillMonsterNumber                        = 3,
	GainItemCumulative                       = 4,
	AwardCount                               = 5,
	EnumMax                                  = 6,
	ObserveOnlineConditionType_MAX           = 7,
};

// Enum b1-Managed.TeleportLocationType
// NumValues: 0x0005
enum class ETeleportLocationType : uint8
{
	None                                     = 0,
	BossTraceCenter                          = 1,
	BossTracePointRandom                     = 2,
	EnumMax                                  = 3,
	TeleportLocationType_MAX                 = 4,
};

// Enum b1-Managed.TraceSpawnType
// NumValues: 0x0004
enum class ETraceSpawnType : uint8
{
	None                                     = 0,
	ByTeleportIndex                          = 1,
	EnumMax                                  = 2,
	TraceSpawnType_MAX                       = 3,
};

// Enum b1-Managed.AwardProbabilityRaiseType
// NumValues: 0x0006
enum class EAwardProbabilityRaiseType : uint8
{
	None                                     = 0,
	RaiseToFirst                             = 1,
	RaiseToSecond                            = 2,
	RaiseToTarget                            = 3,
	EnumMax                                  = 4,
	AwardProbabilityRaiseType_MAX            = 5,
};

// Enum b1-Managed.AwardStateConditionType
// NumValues: 0x0007
enum class EAwardStateConditionType : uint8
{
	None                                     = 0,
	IsInBattle                               = 1,
	InDistanceToCenter                       = 2,
	TraceTeleportDistance                    = 3,
	PlayerDead                               = 4,
	EnumMax                                  = 5,
	AwardStateConditionType_MAX              = 6,
};

// Enum b1-Managed.ValueCompareOperationType
// NumValues: 0x0007
enum class EValueCompareOperationType : uint8
{
	EqualTo                                  = 0,
	NotEqualTo                               = 1,
	LessThan                                 = 2,
	LessThanOrEqualTo                        = 3,
	GreaterThan                              = 4,
	GreaterThanOrEqualTo                     = 5,
	ValueCompareOperationType_MAX            = 6,
};

// Enum b1-Managed.ValueCompareOperations
// NumValues: 0x000B
enum class EValueCompareOperations : uint8
{
	EqualTo                                  = 0,
	NotEqualTo                               = 1,
	LessThan                                 = 2,
	LessThanOrEqualTo                        = 3,
	GreaterThan                              = 4,
	GreaterThanOrEqualTo                     = 5,
	LessThanPercentage                       = 6,
	LessThanOrEqualToPercentage              = 7,
	GreaterThanPercentage                    = 8,
	GreaterThanOrEqualToPercentage           = 9,
	ValueCompareOperations_MAX               = 10,
};

// Enum b1-Managed.EUIPageType
// NumValues: 0x0027
enum class EUIPageType : uint8
{
	None                                     = 0,
	Practice                                 = 1,
	Equip                                    = 2,
	Bag                                      = 3,
	Shop                                     = 4,
	WeaponBuild                              = 5,
	EquipBuild                               = 6,
	EquipShop                                = 7,
	SoakingMain                              = 8,
	RefiningCommonElixir                     = 9,
	RefiningElixir                           = 10,
	HuluLevel                                = 11,
	WineLevel                                = 12,
	Farm                                     = 13,
	TravelNotes                              = 14,
	ChapterAward                             = 15,
	LearnLegacyTalent                        = 16,
	SoulSkillCollect                         = 17,
	BenchMark                                = 18,
	Archives                                 = 19,
	Setting                                  = 20,
	Story                                    = 21,
	Name                                     = 22,
	SeqMediaPlayer                           = 23,
	LearnTalent                              = 24,
	EditionAward                             = 25,
	TakePhoto                                = 26,
	ObsMode                                  = 27,
	FaBao                                    = 28,
	SoulSkill                                = 29,
	Teleport                                 = 30,
	SettingHDR                               = 31,
	SettingBrightness                        = 32,
	SettingKeyBoard                          = 33,
	SeqLogo                                  = 34,
	PastMemory                               = 35,
	SoundtrackV2                             = 36,
	EndCredits                               = 37,
	EUIPageType_MAX                          = 38,
};

// Enum b1-Managed.RotationBaseDirection
// NumValues: 0x0003
enum class ERotationBaseDirection : uint8
{
	WorldSpaceXAxis                          = 0,
	LineToTarget                             = 1,
	RotationBaseDirection_MAX                = 2,
};

// Enum b1-Managed.ComboConditionType
// NumValues: 0x0017
enum class EComboConditionType : uint8
{
	None                                     = 0,
	UnitAttr                                 = 1,
	SimpleState                              = 2,
	UnitState                                = 3,
	HasBuff                                  = 4,
	PotentialEnergy                          = 5,
	Charge                                   = 6,
	CeilingHeight                            = 7,
	HasTalent                                = 8,
	StanceType                               = 9,
	IsFalling                                = 11,
	InJumpUpper                              = 12,
	NotInStrideUpJump                        = 13,
	AirSkillCount                            = 14,
	FlooDistance                             = 15,
	MoveMode                                 = 16,
	HasMoveInput                             = 17,
	InLittleMonkeyStage                      = 18,
	InPreDaShengStage                        = 19,
	InDaShengStage                           = 20,
	InPressedSpinModeState                   = 21,
	EnumMax                                  = 22,
	ComboConditionType_MAX                   = 23,
};

// Enum b1-Managed.EFXActorType
// NumValues: 0x0004
enum class EFXActorType : uint8
{
	None                                     = 0,
	DestructibleObject                       = 1,
	NonPreTracingDestructibleObject          = 2,
	EFXActorType_MAX                         = 3,
};

// Enum b1-Managed.EAMScaleRateAxis
// NumValues: 0x0007
enum class EAMScaleRateAxis : uint8
{
	AllByScaleRateAxisX                      = 0,
	All                                      = 1,
	AxisX                                    = 2,
	AxisY                                    = 3,
	AxisZ                                    = 4,
	AxisZLanding                             = 5,
	EAMScaleRateAxis_MAX                     = 6,
};

// Enum b1-Managed.EGSMatParamType
// NumValues: 0x0014
enum class EGSMatParamType : uint8
{
	None                                     = 0,
	Float                                    = 1,
	Vector                                   = 2,
	LinearColor                              = 3,
	FloatCurve                               = 4,
	VectorCurve                              = 5,
	LinearColorValue                         = 6,
	OwnerInfoStart                           = 64,
	OwnerWorldLocation                       = 65,
	OwnerForwardVector                       = 66,
	OwnerVelocity                            = 67,
	OwnerSocketLocation                      = 68,
	OwnerSocketForwardVector                 = 69,
	PlayerInfoStart                          = 128,
	PlayerWorldLocation                      = 129,
	PlayerForwardVector                      = 130,
	PlayerVelocity                           = 131,
	PlayerSocketLocation                     = 132,
	PlayerSocketForwardVector                = 133,
	EGSMatParamType_MAX                      = 134,
};

// Enum b1-Managed.SurfaceTypeOverrideMethod
// NumValues: 0x0004
enum class ESurfaceTypeOverrideMethod : uint8
{
	None                                     = 0,
	Replace                                  = 1,
	Generate                                 = 2,
	SurfaceTypeOverrideMethod_MAX            = 3,
};

// Enum b1-Managed.MaterialLayerParamType
// NumValues: 0x0006
enum class EMaterialLayerParamType : uint8
{
	None                                     = 0,
	Scalar                                   = 1,
	LinearColor                              = 2,
	ScalarCurve                              = 3,
	ColorCurve                               = 4,
	MaterialLayerParamType_MAX               = 5,
};

// Enum b1-Managed.MaterialLayerParamEvaluateType
// NumValues: 0x0004
enum class EMaterialLayerParamEvaluateType : uint8
{
	None                                     = 0,
	Override                                 = 1,
	Additive                                 = 2,
	MaterialLayerParamEvaluateType_MAX       = 3,
};

// Enum b1-Managed.AtkFXOnGroundType
// NumValues: 0x0003
enum class EAtkFXOnGroundType : uint8
{
	UseDBC                                   = 0,
	UseMatPainter                            = 1,
	AtkFXOnGroundType_MAX                    = 2,
};

// Enum b1-Managed.MagicFieldDirectionUsage
// NumValues: 0x0003
enum class EMagicFieldDirectionUsage : uint8
{
	None                                     = 0,
	WindyMove                                = 1,
	MagicFieldDirectionUsage_MAX             = 2,
};

// Enum b1-Managed.MagicFieldDirectionType
// NumValues: 0x0005
enum class EMagicFieldDirectionType : uint8
{
	None                                     = 0,
	Directional                              = 1,
	Radial                                   = 2,
	Spiral                                   = 3,
	MagicFieldDirectionType_MAX              = 4,
};

// Enum b1-Managed.MagicFieldDirectionTypeDetail
// NumValues: 0x0003
enum class EMagicFieldDirectionTypeDetail : uint8
{
	Positive                                 = 0,
	Negative                                 = 1,
	MagicFieldDirectionTypeDetail_MAX        = 2,
};

// Enum b1-Managed.MagicFieldEffectDirectionType
// NumValues: 0x0003
enum class EMagicFieldEffectDirectionType : uint8
{
	FrontBack                                = 0,
	FrontBackLeftRight                       = 1,
	MagicFieldEffectDirectionType_MAX        = 2,
};

// Enum b1-Managed.MagicFieldEffectTriggerEvent
// NumValues: 0x0005
enum class EMagicFieldEffectTriggerEvent : uint8
{
	OnBorn                                   = 0,
	OnDead                                   = 1,
	OnEnter                                  = 2,
	OnExit                                   = 3,
	MagicFieldEffectTriggerEvent_MAX         = 4,
};

// Enum b1-Managed.PriorityActionSelectUnitType
// NumValues: 0x0003
enum class EPriorityActionSelectUnitType : uint8
{
	AllInWandering                           = 0,
	FarFromPlayerAndInScreenSort             = 1,
	PriorityActionSelectUnitType_MAX         = 2,
};

// Enum b1-Managed.PriorityActionUnitType
// NumValues: 0x0004
enum class EPriorityActionUnitType : uint8
{
	ActivatingGroupAIUnit                    = 0,
	NoneActivatingGroupAIUnit                = 1,
	AllUnit                                  = 2,
	PriorityActionUnitType_MAX               = 3,
};

// Enum b1-Managed.StartJumpSpdState
// NumValues: 0x0004
enum class EStartJumpSpdState : uint8
{
	StartJumpSpdState_Zero                   = 0,
	StartJumpSpdState_Normal                 = 1,
	StartJumpSpdState_Fast                   = 2,
	StartJumpSpdState_MAX                    = 3,
};

// Enum b1-Managed.AkEventStopMode
// NumValues: 0x0004
enum class EAkEventStopMode : uint8
{
	Auto                                     = 0,
	WhenUnitDead                             = 1,
	ByTime                                   = 2,
	AkEventStopMode_MAX                      = 3,
};

// Enum b1-Managed.AkCurveInterpolationCS
// NumValues: 0x000B
enum class EAkCurveInterpolationCS : uint8
{
	Log3                                     = 0,
	Sine                                     = 1,
	Log1                                     = 2,
	InvSCurve                                = 3,
	Linear                                   = 4,
	SCurve                                   = 5,
	Exp1                                     = 6,
	SineReciprocal                           = 7,
	Exp3                                     = 8,
	Constant                                 = 9,
	AkCurveInterpolationCS_MAX               = 10,
};

// Enum b1-Managed.FallHeightType_V2
// NumValues: 0x0006
enum class EFallHeightType_V2 : uint8
{
	FallHeight_Little                        = 0,
	FallHeight_Low                           = 1,
	FallHeight_Mid                           = 2,
	FallHeight_High                          = 3,
	FallHeight_Dead                          = 4,
	FallHeight_MAX                           = 5,
};

// Enum b1-Managed.ConditionalRelation
// NumValues: 0x0003
enum class EConditionalRelation : uint8
{
	And                                      = 0,
	Or                                       = 1,
	ConditionalRelation_MAX                  = 2,
};

// Enum b1-Managed.DetectedUnitType
// NumValues: 0x0006
enum class EDetectedUnitType : uint8
{
	Self                                     = 0,
	Target                                   = 1,
	Master                                   = 2,
	Player                                   = 3,
	UseSmartUnit                             = 4,
	DetectedUnitType_MAX                     = 5,
};

// Enum b1-Managed.DetectedForceType
// NumValues: 0x0004
enum class EDetectedForceType : uint8
{
	Friend                                   = 0,
	Enemy                                    = 1,
	Other                                    = 2,
	DetectedForceType_MAX                    = 3,
};

// Enum b1-Managed.SkillCameraRotationType
// NumValues: 0x0003
enum class ESkillCameraRotationType : uint8
{
	UseUnitRotation                          = 0,
	UseControllerRotation                    = 1,
	SkillCameraRotationType_MAX              = 2,
};

// Enum b1-Managed.QueryGameStateCondition
// NumValues: 0x0008
enum class EQueryGameStateCondition : uint8
{
	None                                     = 0,
	HasArchive                               = 1,
	IsDebug                                  = 2,
	NoArchive                                = 3,
	NotInDebug                               = 4,
	SeamlessStartNewGame                     = 5,
	GenericStartNewGame                      = 6,
	QueryGameStateCondition_MAX              = 7,
};

// Enum b1-Managed.EnvironmentInteractionType
// NumValues: 0x0002
enum class EnvironmentInteractionType : uint8
{
	Surface                                  = 0,
	EnvironmentInteractionType_MAX           = 1,
};

// Enum b1-Managed.EGSHitDestructibleDirection
// NumValues: 0x0004
enum class EGSHitDestructibleDirection : uint8
{
	DestructibleDirection                    = 0,
	AttackerSpeedDirection                   = 1,
	AttackerRelativeDirection                = 2,
	EGSHitDestructibleDirection_MAX          = 3,
};

// Enum b1-Managed.EGSHitDestructibleImpulseType
// NumValues: 0x0004
enum class EGSHitDestructibleImpulseType : uint8
{
	Default                                  = 0,
	StrengthLevel                            = 1,
	Manual                                   = 2,
	EGSHitDestructibleImpulseType_MAX        = 3,
};

// Enum b1-Managed.EGSHitDestructibleStrengthLevel
// NumValues: 0x0006
enum class EGSHitDestructibleStrengthLevel : uint8
{
	None                                     = 0,
	Light                                    = 1,
	Medium                                   = 2,
	Heavy                                    = 3,
	Special                                  = 4,
	EGSHitDestructibleStrengthLevel_MAX      = 5,
};

// Enum b1-Managed.GameplayCounterType
// NumValues: 0x0005
enum class EGameplayCounterType : uint8
{
	None                                     = 0,
	Time                                     = 1,
	HP                                       = 2,
	HPPercent                                = 3,
	GameplayCounterType_MAX                  = 4,
};

// Enum b1-Managed.DynamicObstacleState
// NumValues: 0x0003
enum class EDynamicObstacleState : uint8
{
	Opened                                   = 0,
	Closed                                   = 1,
	DynamicObstacleState_MAX                 = 2,
};

// Enum b1-Managed.OverlapState
// NumValues: 0x0003
enum class EOverlapState : uint8
{
	Enabled                                  = 0,
	Disabled                                 = 1,
	OverlapState_MAX                         = 2,
};

// Enum b1-Managed.InteractorState
// NumValues: 0x0003
enum class EInteractorState : uint8
{
	Interactive                              = 0,
	NotInteractive                           = 1,
	InteractorState_MAX                      = 2,
};

// Enum b1-Managed.SpawnerState
// NumValues: 0x0004
enum class ESpawnerState : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	Spawned                                  = 2,
	SpawnerState_MAX                         = 3,
};

// Enum b1-Managed.DynamicObstacleManagePolice
// NumValues: 0x0006
enum class EDynamicObstacleManagePolice : uint8
{
	SameAsPrevious                           = 0,
	KeepOpen                                 = 1,
	KeepClose                                = 2,
	AsBattleInDoor                           = 3,
	AsBattleOutDoor                          = 4,
	DynamicObstacleManagePolice_MAX          = 5,
};

// Enum b1-Managed.OverlapManagePolice
// NumValues: 0x0004
enum class EOverlapManagePolice : uint8
{
	SameAsPrevious                           = 0,
	KeepEnable                               = 1,
	KeepDisable                              = 2,
	OverlapManagePolice_MAX                  = 3,
};

// Enum b1-Managed.InteractorManagePolice
// NumValues: 0x0004
enum class EInteractorManagePolice : uint8
{
	SameAsPrevious                           = 0,
	KeepInteractive                          = 1,
	KeepNotInteractive                       = 2,
	InteractorManagePolice_MAX               = 3,
};

// Enum b1-Managed.SpawnerManagePolice
// NumValues: 0x0008
enum class ESpawnerManagePolice : uint8
{
	SameAsPrevious                           = 0,
	Auto                                     = 1,
	SameAsBattle                             = 2,
	OnlyBeginSameAsBattle                    = 3,
	OnlyEndSameAsBattle                      = 4,
	Disable                                  = 5,
	BeginLikeStateEndLikeBattle              = 6,
	SpawnerManagePolice_MAX                  = 7,
};

// Enum b1-Managed.UnitManagePolice
// NumValues: 0x0006
enum class EUnitManagePolice : uint8
{
	SameAsPrevious                           = 0,
	Status                                   = 1,
	StatusWithoutHP                          = 2,
	Spawn                                    = 3,
	Destroy                                  = 4,
	UnitManagePolice_MAX                     = 5,
};

// Enum b1-Managed.IdleProcessActionType
// NumValues: 0x0018
enum class EIdleProcessActionType : uint8
{
	None                                     = 0,
	Teleport                                 = 1,
	ActiveRebirthPoint                       = 2,
	DisappearUnit                            = 3,
	NotifyDropItemManagerDrop                = 4,
	AiConversation                           = 5,
	SetNPCParamOnlyInEnter                   = 6,
	TriggerUnitBattle                        = 7,
	SpawnAssociationUnit                     = 8,
	ActiveAssociationUnit                    = 9,
	KillAssociationUnit                      = 10,
	NpcPlayMontage                           = 11,
	NpcMoveTo                                = 12,
	EnterWeakPerformState                    = 13,
	ExitWeakPerformState                     = 14,
	KillFollowPartner                        = 15,
	ClearAllBloodBar                         = 16,
	NotifyStateMachine                       = 17,
	TeleportRebirthPoint                     = 18,
	PlayDefeatUI                             = 19,
	BlockRebirthPoint                        = 20,
	GameLevelPass                            = 21,
	TriggerSplineMove                        = 22,
	IdleProcessActionType_MAX                = 23,
};

// Enum b1-Managed.TransitionConditionType_Idle
// NumValues: 0x0019
enum class ETransitionConditionType_Idle : uint8
{
	None                                     = 0,
	EnterOverlap                             = 1,
	InteractorEnd                            = 2,
	InteractorInOverlap                      = 3,
	GameStateCondition                       = 4,
	ActionsAllFinish                         = 5,
	InteractorTimeOver                       = 6,
	CheckTimeInOverlap                       = 7,
	CheckTimeOutOverlap                      = 8,
	TaskStage                                = 9,
	ConsumedItem                             = 10,
	OwningItem                               = 11,
	InteractionRecord                        = 12,
	InteractionEnd                           = 13,
	UnitActive                               = 14,
	NpcActionFinished                        = 15,
	NPCReach                                 = 16,
	AiConversationChainEnd                   = 17,
	UnownedEnoughItem                        = 18,
	UnitInActive                             = 19,
	NotInOverlapBox                          = 20,
	InOverlapBox                             = 21,
	PlayerCloudMove                          = 22,
	PlayerTransAsFox                         = 23,
	TransitionConditionType_MAX              = 24,
};

// Enum b1-Managed.TransitionConditionType_Battle
// NumValues: 0x000F
enum class ETransitionConditionType_Battle : uint8
{
	None                                     = 0,
	UnitsDead                                = 1,
	WaveEnd                                  = 2,
	HasBuff                                  = 3,
	KillOrder                                = 4,
	UnitsTransStage                          = 5,
	UnitsAlive                               = 6,
	GroupUnitDead                            = 7,
	Countdown                                = 8,
	NotInOverlapBox                          = 9,
	InOverlapBox                             = 10,
	UIBattleFinish                           = 11,
	PlayerAlive                              = 12,
	PlayerDead                               = 13,
	TransitionConditionType_MAX              = 14,
};

// Enum b1-Managed.TransitionConditionType_Guide
// NumValues: 0x0017
enum class ETransitionConditionType_Guide : uint8
{
	None                                     = 0,
	EnterOverlap                             = 1,
	InAbnormalState                          = 2,
	InteractRebirthPoint                     = 3,
	PlayerDead                               = 4,
	PlayerRebirth                            = 5,
	UnitDead                                 = 6,
	GainItem                                 = 7,
	PlayerAttr                               = 8,
	UnitActive                               = 9,
	CloseToMonster                           = 10,
	TaskStage                                = 11,
	CurrentMap                               = 12,
	NotInOverlapBox                          = 13,
	InOverlapBox                             = 14,
	NotPlayingSeq                            = 15,
	LearnTalent                              = 16,
	OpenUIPage                               = 17,
	DropUIConfirm                            = 18,
	FinishGuideGroup                         = 19,
	ObserveSequence                          = 20,
	OwningItem                               = 21,
	TransitionConditionType_MAX              = 22,
};

// Enum b1-Managed.TransitionConditionType_Group
// NumValues: 0x0013
enum class ETransitionConditionType_Group : uint8
{
	None                                     = 0,
	EnterOverlap                             = 1,
	InteractorEnd                            = 2,
	InteractorInOverlap                      = 3,
	GameStateCondition                       = 4,
	InteractorTimeOver                       = 5,
	UnitsDead                                = 6,
	WaveEnd                                  = 7,
	HasBuff                                  = 8,
	KillOrder                                = 9,
	SequencePlayed                           = 10,
	TaskStage                                = 11,
	UnitsAlive                               = 12,
	CircusInteractorEnd                      = 13,
	CircusEnterOverlap                       = 14,
	NotInOverlapBox                          = 15,
	InOverlapBox                             = 16,
	UIBattleFinish                           = 17,
	TransitionConditionType_MAX              = 18,
};

// Enum b1-Managed.TransitionConditionType_State
// NumValues: 0x000F
enum class ETransitionConditionType_State : uint8
{
	None                                     = 0,
	EnterOverlap                             = 1,
	InteractorEnd                            = 2,
	InteractorTimeOver                       = 3,
	UnitsDead                                = 4,
	WaveEnd                                  = 5,
	HasBuff                                  = 6,
	SequencePlayed                           = 7,
	TaskStage                                = 8,
	GamePlayCount                            = 9,
	CircusInteractorEnd                      = 10,
	CircusEnterOverlap                       = 11,
	NotInOverlapBox                          = 12,
	InOverlapBox                             = 13,
	TransitionConditionType_MAX              = 14,
};

// Enum b1-Managed.BattleStartConditionType
// NumValues: 0x0005
enum class EBattleStartConditionType : uint8
{
	Auto                                     = 0,
	UnitActive                               = 1,
	SpawnerActive                            = 2,
	EnterOverlap                             = 3,
	BattleStartConditionType_MAX             = 4,
};

// Enum b1-Managed.FightBackCountType
// NumValues: 0x0003
enum class EFightBackCountType : uint8
{
	BeHitCount                               = 0,
	StiffCount                               = 1,
	FightBackCountType_MAX                   = 2,
};

// Enum b1-Managed.ManagedSceneObjType
// NumValues: 0x0007
enum class EManagedSceneObjType : uint8
{
	None                                     = 0,
	DynamicObstacle                          = 1,
	Overlap                                  = 2,
	Interactor                               = 3,
	Unit                                     = 4,
	Spawner                                  = 5,
	ManagedSceneObjType_MAX                  = 6,
};

// Enum b1-Managed.SpawnWaveStartConditionType
// NumValues: 0x0006
enum class ESpawnWaveStartConditionType : uint8
{
	Auto                                     = 0,
	PreviousClear                            = 1,
	TimeAfterPrevious                        = 2,
	TimeAfterPreviousClear                   = 3,
	GlobleCDFinished                         = 4,
	SpawnWaveStartConditionType_MAX          = 5,
};

// Enum b1-Managed.SpawnPointType
// NumValues: 0x0004
enum class ESpawnPointType : uint8
{
	UseSpawnPoints                           = 0,
	UseEQS                                   = 1,
	UseLocalSpaceOffset                      = 2,
	SpawnPointType_MAX                       = 3,
};

// Enum b1-Managed.AttackIKType
// NumValues: 0x0007
enum class EAttackIKType : uint8
{
	None                                     = 0,
	TerrainSlope                             = 1,
	AvatarBonePitchOnly                      = 2,
	AvatarBoneRollOnly                       = 3,
	FishSpike                                = 4,
	AvatarLockPointPitch                     = 5,
	AttackIKType_MAX                         = 6,
};

// Enum b1-Managed.FishSpikeJumpType
// NumValues: 0x0005
enum class EFishSpikeJumpType : uint8
{
	Default                                  = 0,
	OnlyCloseTo                              = 1,
	OnlyFarFrom                              = 2,
	None                                     = 3,
	FishSpikeJumpType_MAX                    = 4,
};

// Enum b1-Managed.StageStatus
// NumValues: 0x0004
enum class EStageStatus : uint8
{
	Default                                  = 0,
	Activated                                = 1,
	Finished                                 = 2,
	StageStatus_MAX                          = 3,
};

// Enum b1-Managed.SequencePhase
// NumValues: 0x0004
enum class ESequencePhase : uint8
{
	None                                     = 0,
	Started                                  = 1,
	Finished                                 = 2,
	SequencePhase_MAX                        = 3,
};

// Enum b1-Managed.EGSTrainDummyHPType
// NumValues: 0x0004
enum class EGSTrainDummyHPType : uint8
{
	Default                                  = 0,
	Infinite                                 = 1,
	Value                                    = 2,
	EGSTrainDummyHPType_MAX                  = 3,
};

// Enum b1-Managed.EDPSCalTimeType
// NumValues: 0x0003
enum class EDPSCalTimeType : uint8
{
	Total                                    = 0,
	FromLastHit                              = 1,
	EDPSCalTimeType_MAX                      = 2,
};

// Enum b1-Managed.EGSAutoTestPlayerCastConditionType
// NumValues: 0x0006
enum class EGSAutoTestPlayerCastConditionType : uint8
{
	UnitAttr                                 = 0,
	UnitState                                = 1,
	HasItem                                  = 64,
	PELevel                                  = 65,
	NotPreloading                            = 128,
	EGSAutoTestPlayerCastConditionType_MAX   = 129,
};

// Enum b1-Managed.EBGUAutoTestPlayerComboKey
// NumValues: 0x0007
enum class EBGUAutoTestPlayerComboKey : uint8
{
	None                                     = 0,
	LightAttackDown                          = 1,
	LightAttackUp                            = 2,
	HeavyAttackDown                          = 3,
	HeavyAttackUp                            = 4,
	Dodge                                    = 5,
	EBGUAutoTestPlayerComboKey_MAX           = 6,
};

// Enum b1-Managed.EBGUAutoTestPlayerMagicType
// NumValues: 0x0006
enum class EBGUAutoTestPlayerMagicType : uint8
{
	None                                     = 0,
	ShenFa                                   = 1,
	HaoMao                                   = 2,
	QiShu                                    = 3,
	BianShen                                 = 4,
	EBGUAutoTestPlayerMagicType_MAX          = 5,
};

// Enum b1-Managed.EBGMVolumeConditionType
// NumValues: 0x0005
enum class EBGMVolumeConditionType : uint8
{
	None                                     = 0,
	UnitAlive                                = 1,
	UnitInBattle                             = 2,
	IntervalTriggerActive                    = 3,
	EBGMVolumeConditionType_MAX              = 4,
};

// Enum b1-Managed.EBGMVolumeConditionSusCountType
// NumValues: 0x0003
enum class EBGMVolumeConditionSusCountType : uint8
{
	Once                                     = 0,
	All                                      = 1,
	EBGMVolumeConditionSusCountType_MAX      = 2,
};

// Enum b1-Managed.ChangeMatUnitAttrType
// NumValues: 0x0003
enum class EChangeMatUnitAttrType : uint8
{
	None                                     = 0,
	Velocity                                 = 1,
	ChangeMatUnitAttrType_MAX                = 2,
};

// Enum b1-Managed.ModelOperateType
// NumValues: 0x0005
enum class EModelOperateType : uint8
{
	UnableOperate                            = 0,
	OnlyYaw                                  = 1,
	ZoomYaw                                  = 2,
	ZoomYawPitch                             = 3,
	ModelOperateType_MAX                     = 4,
};

// Enum b1-Managed.ObModeSource
// NumValues: 0x002C
enum class EObModeSource : uint8
{
	Null                                     = 0,
	Antique                                  = 1,
	Artifact                                 = 2,
	Item                                     = 3,
	MainEquip                                = 4,
	EquipHead                                = 5,
	EquipUpwear                              = 6,
	EquipArm                                 = 7,
	EquipFoot                                = 8,
	EquipHulu                                = 9,
	EquipWeapon                              = 10,
	EquipFabao                               = 11,
	EquipAccessory                           = 12,
	EquipSoul                                = 13,
	SoakingMain                              = 14,
	SoakingLiquor                            = 15,
	SoakingConsume1                          = 16,
	SoakingConsume2                          = 17,
	SoakingConsume3                          = 18,
	SoakingConsume4                          = 19,
	Legacy                                   = 20,
	MedicineRecipe                           = 21,
	Black                                    = 22,
	Spell                                    = 23,
	Ability                                  = 24,
	Setting                                  = 25,
	Manual                                   = 26,
	TravelNotesMain                          = 27,
	LegacyEven                               = 28,
	LegacyOdd                                = 29,
	AbilitySwitch                            = 30,
	SpellSwitch                              = 31,
	EquipMainSwitch                          = 32,
	ItemSwitch                               = 33,
	TNMSwitch                                = 34,
	ManualSwitch                             = 35,
	SettingSwitch                            = 36,
	LegacySwitch                             = 37,
	EquipSoulSwitch                          = 38,
	BlackSwitch                              = 39,
	EquipFabaoSwitch                         = 40,
	EquipAccessorySwitch                     = 41,
	MedicineRecipeSwitch                     = 42,
	ObModeSource_MAX                         = 43,
};

// Enum b1-Managed.SwitchBattleFSMState
// NumValues: 0x0003
enum class ESwitchBattleFSMState : uint8
{
	Attack                                   = 0,
	Wander                                   = 1,
	SwitchBattleFSMState_MAX                 = 2,
};

// Enum b1-Managed.NpcMoveType
// NumValues: 0x0003
enum class ENpcMoveType : uint8
{
	Navigation                               = 0,
	Spline                                   = 1,
	NpcMoveType_MAX                          = 2,
};

// Enum b1-Managed.ELMFreeMode
// NumValues: 0x0003
enum class ELMFreeMode : uint8
{
	Normal                                   = 0,
	Simple                                   = 1,
	ELMFreeMode_MAX                          = 2,
};

// Enum b1-Managed.ELMLockMode
// NumValues: 0x0004
enum class ELMLockMode : uint8
{
	Normal                                   = 0,
	SimpleLeft                               = 1,
	SimpleRight                              = 2,
	ELMLockMode_MAX                          = 3,
};

// Enum b1-Managed.SpiderNavPositionType
// NumValues: 0x0003
enum class ESpiderNavPositionType : uint8
{
	Ground                                   = 0,
	Wall                                     = 1,
	SpiderNavPositionType_MAX                = 2,
};

// Enum b1-Managed.LoadingUIFadeInReason
// NumValues: 0x0005
enum class ELoadingUIFadeInReason : uint8
{
	None                                     = 0,
	CombatTeleport                           = 1,
	NonCombatTeleport                        = 2,
	OnlineDisconnect                         = 3,
	LoadingUIFadeInReason_MAX                = 4,
};

// Enum b1-Managed.ManualSplineMoveDirectionType
// NumValues: 0x0003
enum class EManualSplineMoveDirectionType : uint8
{
	Free                                     = 0,
	Lock                                     = 1,
	ManualSplineMoveDirectionType_MAX        = 2,
};

// Enum b1-Managed.ManualSplineMoveCameraType
// NumValues: 0x0003
enum class EManualSplineMoveCameraType : uint8
{
	None                                     = 0,
	AlongSpline                              = 1,
	ManualSplineMoveCameraType_MAX           = 2,
};

// Enum b1-Managed.TamerStrategyArea
// NumValues: 0x0004
enum class ETamerStrategyArea : uint8
{
	None                                     = 0,
	SuspendedSculptures                      = 1,
	Dungeon                                  = 2,
	TamerStrategyArea_MAX                    = 3,
};

// Enum b1-Managed.DeathDissolvePlayType
// NumValues: 0x0003
enum class EDeathDissolvePlayType : uint8
{
	DeadAMEnd                                = 0,
	DeadAMBegin                              = 1,
	DeathDissolvePlayType_MAX                = 2,
};

// Enum b1-Managed.AiWeakInteractCheckType
// NumValues: 0x0003
enum class EAiWeakInteractCheckType : uint8
{
	BothPlayerAndFollowPartner               = 0,
	OnlyFollowPartner                        = 1,
	AiWeakInteractCheckType_MAX              = 2,
};

// Enum b1-Managed.EGSCloudMoveRestrictType
// NumValues: 0x0004
enum class EGSCloudMoveRestrictType : uint8
{
	None                                     = 0,
	ForbidEnableCloudMove                    = 1,
	ForbidDisableCloudMove                   = 2,
	EGSCloudMoveRestrictType_MAX             = 3,
};

// Enum b1-Managed.SpeedInterpMode
// NumValues: 0x0003
enum class ESpeedInterpMode : uint8
{
	ByPercentage                             = 0,
	ByValue                                  = 1,
	SpeedInterpMode_MAX                      = 2,
};

// Enum b1-Managed.StickLevelShowType
// NumValues: 0x0004
enum class EStickLevelShowType : uint8
{
	Normal                                   = 0,
	InDaSheng                                = 1,
	Trans                                    = 2,
	StickLevelShowType_MAX                   = 3,
};

// Enum b1-Managed.MFOverlapEventType
// NumValues: 0x000A
enum class EMFOverlapEventType : uint8
{
	AddBuff                                  = 0,
	RemoveBuffWithTriggerRemove              = 1,
	RemoveBuffWithoutTriggerRemove           = 2,
	TriggerSkillEffect                       = 3,
	DrawSign                                 = 4,
	AddAvoidance                             = 5,
	RemoveAvoidance                          = 6,
	DestroyProjectileByFlag                  = 7,
	SetMastersTarget                         = 8,
	MFOverlapEventType_MAX                   = 9,
};

// Enum b1-Managed.StanceType_Combo
// NumValues: 0x0004
enum class EStanceType_Combo : uint8
{
	Heavy                                    = 0,
	PROP                                     = 1,
	POKE                                     = 2,
	StanceType_MAX                           = 3,
};

// Enum b1-Managed.EquipFXType
// NumValues: 0x0005
enum class EquipFXType : uint8
{
	None                                     = 0,
	Wear                                     = 1,
	Upgrade                                  = 2,
	UpgradeChange                            = 3,
	EquipFXType_MAX                          = 4,
};

// Enum b1-Managed.ConfigShowType
// NumValues: 0x000A
enum class EConfigShowType : uint8
{
	All                                      = 0,
	StandAlone                               = 1,
	Online                                   = 2,
	GameConsole                              = 4,
	PC                                       = 8,
	NotStartUp                               = 16,
	PlotTransMode                            = 32,
	Host                                     = 64,
	WithArchive                              = 128,
	ConfigShowType_MAX                       = 129,
};

// Enum b1-Managed.EUISettingConfigName
// NumValues: 0x0003
enum class EUISettingConfigName : uint8
{
	DmgNumShow                               = 0,
	HudShow                                  = 1,
	EUISettingConfigName_MAX                 = 2,
};

// Enum b1-Managed.MatSyncType
// NumValues: 0x0008
enum class EMatSyncType : uint8
{
	UnSync                                   = 0,
	SyncMainTex                              = 1,
	SyncTierState                            = 2,
	SyncPercent                              = 3,
	SyncMainTexAndTier                       = 4,
	SyncAllQuick                             = 5,
	SyncAll                                  = 6,
	MatSyncType_MAX                          = 7,
};

// Enum b1-Managed.MatType
// NumValues: 0x0004
enum class EMatType : uint8
{
	Scale                                    = 0,
	Vector                                   = 1,
	Texture                                  = 2,
	MatType_MAX                              = 3,
};

// Enum b1-Managed.TextColorType
// NumValues: 0x0005
enum class ETextColorType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Actived                                  = 2,
	Disable                                  = 3,
	TextColorType_MAX                        = 4,
};

// Enum b1-Managed.ManagedNPCUnitType
// NumValues: 0x0007
enum class EManagedNPCUnitType : uint8
{
	None                                     = 0,
	DynamicObstacle                          = 1,
	TriggerBox                               = 2,
	Interactor                               = 3,
	Spawner                                  = 4,
	Unit                                     = 5,
	ManagedNPCUnitType_MAX                   = 6,
};

// Enum b1-Managed.EGSDestructibleModifyType
// NumValues: 0x0003
enum class EGSDestructibleModifyType : uint8
{
	Break                                    = 0,
	Modify                                   = 1,
	EGSDestructibleModifyType_MAX            = 2,
};

// Enum b1-Managed.CharacterSlopeAlignType
// NumValues: 0x0004
enum class ECharacterSlopeAlignType : uint8
{
	None                                     = 0,
	AOPlan                                   = 1,
	RotWholeBodyPlan                         = 2,
	CharacterSlopeAlignType_MAX              = 3,
};

// Enum b1-Managed.EAMScaleType
// NumValues: 0x0006
enum class EAMScaleType : uint8
{
	ScaleForTarget                           = 0,
	ScaleForSceneItem                        = 1,
	ScaleForCachedPoint                      = 2,
	UsePureScale                             = 3,
	UseSkillBaseTarget                       = 4,
	EAMScaleType_MAX                         = 5,
};

// Enum b1-Managed.EBGUJumpTargetType
// NumValues: 0x0003
enum class EBGUJumpTargetType : uint8
{
	CurrentTarget                            = 0,
	SceneItem                                = 1,
	EBGUJumpTargetType_MAX                   = 2,
};

// Enum b1-Managed.JumpSectionCondition
// NumValues: 0x0003
enum class EJumpSectionCondition : uint8
{
	SceneItemNotFound                        = 0,
	FindSceneItemsWithSkillID                = 1,
	JumpSectionCondition_MAX                 = 2,
};

// Enum b1-Managed.EANTriggerEffectTargetType
// NumValues: 0x0004
enum class EANTriggerEffectTargetType : uint8
{
	Owner                                    = 0,
	Master                                   = 1,
	LastAttacker                             = 2,
	EANTriggerEffectTargetType_MAX           = 3,
};

// Enum b1-Managed.EDBCTransformType
// NumValues: 0x0003
enum class EDBCTransformType : uint8
{
	SweepCheck                               = 0,
	Normal                                   = 1,
	EDBCTransformType_MAX                    = 2,
};

// Enum b1-Managed.TaskStageConditionType
// NumValues: 0x0003
enum class ETaskStageConditionType : uint8
{
	Actived                                  = 0,
	Finsh                                    = 1,
	TaskStageConditionType_MAX               = 2,
};

// Enum b1-Managed.TaskQueryCompoundConditionType
// NumValues: 0x0006
enum class ETaskQueryCompoundConditionType : uint8
{
	None                                     = 0,
	QueryTaskStageState                      = 1,
	QueryInteractionRecord                   = 2,
	QueryActorState                          = 3,
	QueryOwningItem                          = 4,
	TaskQueryCompoundConditionType_MAX       = 5,
};

// Enum b1-Managed.TaskStageStateType
// NumValues: 0x0004
enum class ETaskStageStateType : uint8
{
	NoActive                                 = 0,
	Actived                                  = 1,
	Finsh                                    = 2,
	TaskStageStateType_MAX                   = 3,
};

// Enum b1-Managed.TileItemScene
// NumValues: 0x0009
enum class ETileItemScene : uint8
{
	None                                     = 0,
	EquipItem                                = 1,
	GearItem                                 = 2,
	RZDItem                                  = 3,
	ShopItem                                 = 4,
	ShopEquipItem                            = 5,
	StrengthItem                             = 6,
	StrengthRZDItem                          = 7,
	TileItemScene_MAX                        = 8,
};

// Enum b1-Managed.FocusReason
// NumValues: 0x0003
enum class EFocusReason : uint8
{
	Init                                     = 0,
	ManualSet                                = 1,
	FocusReason_MAX                          = 2,
};

// Enum b1-Managed.RoleDataType
// NumValues: 0x0008
enum class ERoleDataType : uint8
{
	None                                     = 0,
	ConsumedItem                             = 1,
	OwningItem                               = 2,
	InteractionRecord                        = 3,
	TaskStage                                = 4,
	OwningHulu                               = 5,
	Collection                               = 6,
	RoleDataType_MAX                         = 7,
};

// Enum b1-Managed.TaskStageState
// NumValues: 0x0003
enum class b1MinusManaged::ETaskStageState : uint8
{
	Default                                  = 0,
	Activated                                = 1,
	Finished                                 = 2,
};

// Enum b1-Managed.OrderSetting
// NumValues: 0x0004
enum class EOrderSetting : uint8
{
	Baseline                                 = 0,
	Top                                      = 1,
	Bottom                                   = 2,
	OrderSetting_MAX                         = 3,
};

// Enum b1-Managed.EGMCommandType
// NumValues: 0x000E
enum class EGMCommandType : uint8
{
	None                                     = 0,
	ShowBattleUI                             = 1,
	EnableEnemyBar                           = 2,
	Invincible                               = 3,
	LockHP                                   = 4,
	LockStamina                              = 5,
	Invisible                                = 6,
	LockEnemyHP                              = 7,
	CancelEnemyCD                            = 8,
	ToggleAllEnemyAI                         = 9,
	Lock60FPS                                = 10,
	VSync                                    = 11,
	EnumMax                                  = 12,
	EGMCommandType_MAX                       = 13,
};

// Enum b1-Managed.ENGSEasingFunc
// NumValues: 0x0015
enum class ENGSEasingFunc : uint8
{
	Linear                                   = 0,
	Step                                     = 1,
	SinusoidalIn                             = 2,
	SinusoidalOut                            = 3,
	SinusoidalInOut                          = 4,
	EaseIn                                   = 5,
	EaseOut                                  = 6,
	EaseInOut                                = 7,
	ExpoIn                                   = 8,
	ExpoOut                                  = 9,
	ExpoInOut                                = 10,
	CircularIn                               = 11,
	CircularOut                              = 12,
	CircularInOut                            = 13,
	BackEaseIn                               = 14,
	BackEaseOut                              = 15,
	BackEaseInOut                            = 16,
	EaseInQuart                              = 17,
	EaseInOutQuint                           = 18,
	Sin                                      = 19,
	ENGSEasingFunc_MAX                       = 20,
};

// Enum b1-Managed.FluidSimDimension
// NumValues: 0x0009
enum class EFluidSimDimension : uint8
{
	Vol_32_3                                 = 0,
	Vol_64_3                                 = 1,
	Vol_100_3                                = 2,
	Vol_128_3                                = 3,
	Vol_196_3                                = 4,
	Vol_256_3                                = 5,
	Vol_324_3                                = 6,
	Vol_400_3                                = 7,
	Vol_MAX                                  = 8,
};

// Enum b1-Managed.DefaulValueType
// NumValues: 0x0007
enum class EDefaulValueType : uint8
{
	Percent                                  = 0,
	PlayerHp                                 = 1,
	PlayerMp                                 = 2,
	PlayerSt                                 = 3,
	UnitHp                                   = 4,
	MultiMapping                             = 5,
	DefaulValueType_MAX                      = 6,
};

// Enum b1-Managed.WarnState
// NumValues: 0x0005
enum class EWarnState : uint8
{
	None                                     = 0,
	Danger                                   = 1,
	Safe                                     = 2,
	EnumMax                                  = 3,
	WarnState_MAX                            = 4,
};

// Enum b1-Managed.WarnStateBlock
// NumValues: 0x0006
enum class EWarnStateBlock : uint8
{
	UnBlock                                  = 0,
	BlockOnce                                = 1,
	BlockState                               = 2,
	BlockAll                                 = 3,
	EnumMax                                  = 4,
	WarnStateBlock_MAX                       = 5,
};

// Enum b1-Managed.CacheAssetState
// NumValues: 0x0005
enum class ECacheAssetState : uint8
{
	Unloaded                                 = 0,
	Loading                                  = 1,
	Loaded                                   = 2,
	FileNotFound                             = 255,
	CacheAssetState_MAX                      = 256,
};

// Enum b1-Managed.CardinalDir
// NumValues: 0x0005
enum class ECardinalDir : uint8
{
	Default                                  = 0,
	E                                        = 1,
	S                                        = 2,
	W                                        = 3,
	CardinalDir_MAX                          = 4,
};

// Enum b1-Managed.MoveToSceneItemAndCastSkillState
// NumValues: 0x0007
enum class EMoveToSceneItemAndCastSkillState : uint8
{
	None                                     = 0,
	RotateToSceneItem                        = 2,
	MoveToSceneItem                          = 3,
	TryCastSkill                             = 4,
	CastingSkill                             = 5,
	EnumMax                                  = 6,
	MoveToSceneItemAndCastSkillState_MAX     = 7,
};

// Enum b1-Managed.EnShortcutType
// NumValues: 0x0005
enum class EnShortcutType : uint8
{
	INIT                                     = 0,
	ITEM                                     = 1,
	SPELL                                    = 2,
	TRANSSPELL                               = 3,
	EnShortcutType_MAX                       = 4,
};

// Enum b1-Managed.UITipsMode
// NumValues: 0x0005
enum class EUITipsMode : uint8
{
	Upper                                    = 0,
	Under                                    = 1,
	Left                                     = 2,
	Right                                    = 3,
	UITipsMode_MAX                           = 4,
};

// Enum b1-Managed.EGSTickType
// NumValues: 0x0005
enum class EGSTickType : uint8
{
	NotSet                                   = 0,
	NeverGSTick                              = 1,
	AutoGSTick                               = 2,
	AlwaysGSTick                             = 3,
	EGSTickType_MAX                          = 4,
};

// Enum b1-Managed.EndCreditsType
// NumValues: 0x0003
enum class EndCreditsType : uint8
{
	EndA                                     = 0,
	EndB                                     = 1,
	EndCreditsType_MAX                       = 2,
};

// Enum b1-Managed.EndCreditsItemType
// NumValues: 0x0006
enum class EndCreditsItemType : uint8
{
	None                                     = 0,
	Text                                     = 1,
	Image                                    = 2,
	Item                                     = 3,
	Page                                     = 4,
	EndCreditsItemType_MAX                   = 5,
};

// Enum b1-Managed.EndCreditsPageAction
// NumValues: 0x0006
enum class EndCreditsPageAction : uint8
{
	Anim                                     = 0,
	AnimAndScroll                            = 1,
	Scroll                                   = 2,
	SwitchSpeedScroll                        = 3,
	ScrollAnimEnd                            = 4,
	EndCreditsPageAction_MAX                 = 5,
};

// Enum b1-Managed.MenuUIStat
// NumValues: 0x0004
enum class EMenuUIStat : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Actived                                  = 2,
	MenuUIStat_MAX                           = 3,
};

// Enum b1-Managed.MenuSwitchType
// NumValues: 0x0005
enum class EMenuSwitchType : uint8
{
	Normal                                   = 0,
	FocusActived                             = 1,
	AimingActived                            = 2,
	KeyBoardOrFocusActived                   = 3,
	MenuSwitchType_MAX                       = 4,
};

// Enum b1-Managed.InteractActionType
// NumValues: 0x0002
enum class EInteractActionType : uint8
{
	Normal                                   = 0,
	InteractActionType_MAX                   = 1,
};

// Enum b1-Managed.DependType
// NumValues: 0x0003
enum class EDependType : uint8
{
	Auto                                     = 0,
	UpDown                                   = 1,
	DependType_MAX                           = 2,
};

// Enum b1-Managed.LoopDirection
// NumValues: 0x0003
enum class ELoopDirection : uint8
{
	LeftToRight                              = 0,
	RightToLeft                              = 1,
	LoopDirection_MAX                        = 2,
};

// Enum b1-Managed.WidgetUIStat
// NumValues: 0x0008
enum class EWidgetUIStat : uint8
{
	None                                     = 0,
	Empty                                    = 1,
	NorReady                                 = 2,
	NorInCD                                  = 3,
	LockReady                                = 4,
	LockInCD                                 = 5,
	Actived                                  = 6,
	WidgetUIStat_MAX                         = 7,
};

// Enum b1-Managed.ButtonStat
// NumValues: 0x0006
enum class EButtonStat : uint8
{
	Normal                                   = 0,
	Lock                                     = 1,
	Disable                                  = 2,
	NotUse                                   = 3,
	Hide                                     = 4,
	ButtonStat_MAX                           = 5,
};

// Enum b1-Managed.ButtonUIStat
// NumValues: 0x000D
enum class EButtonUIStat : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Hovered                                  = 2,
	Focused                                  = 3,
	LockNormal                               = 4,
	LockHovered                              = 5,
	LockFocused                              = 6,
	Actived                                  = 7,
	Disable                                  = 8,
	NotUse                                   = 9,
	LockActived                              = 10,
	Hide                                     = 11,
	ButtonUIStat_MAX                         = 12,
};

// Enum b1-Managed.KeyBoardShowFocusType
// NumValues: 0x0004
enum class EKeyBoardShowFocusType : uint8
{
	Hide                                     = 0,
	OnlyHover                                = 1,
	Always                                   = 2,
	KeyBoardShowFocusType_MAX                = 3,
};

// Enum b1-Managed.MouseMoveHoverType
// NumValues: 0x0004
enum class EMouseMoveHoverType : uint8
{
	Default                                  = 0,
	MoveHover                                = 1,
	StopUnhover                              = 2,
	MouseMoveHoverType_MAX                   = 3,
};

// Enum b1-Managed.TalentState
// NumValues: 0x0004
enum class ETalentState : uint8
{
	NotLearn                                 = 0,
	HasLearn                                 = 1,
	MaxLearn                                 = 2,
	TalentState_MAX                          = 3,
};

// Enum b1-Managed.DamageTypeEnum
// NumValues: 0x0013
enum class EDamageTypeEnum : uint8
{
	NONE                                     = 0,
	PLAYER_DMG                               = 1,
	PLAYER_DMG_CRIT                          = 2,
	PLAYER_DMG_FREEZE                        = 3,
	PLAYER_DMG_BURN                          = 4,
	PLAYER_DMG_POSITION                      = 5,
	PLAYER_DMG_THUNDER                       = 6,
	PLAYER_MISS                              = 7,
	PLAYER_HEAL                              = 8,
	ENEMY_DMG                                = 9,
	ENEMY_DMG_CRIT                           = 10,
	ENEMY_DMG_FREEZE                         = 11,
	ENEMY_DMG_BURN                           = 12,
	ENEMY_DMG_POSITION                       = 13,
	ENEMY_DMG_THUNDER                        = 14,
	ENEMY_MISS                               = 15,
	ENEMY_HEAL                               = 16,
	All                                      = 17,
	DamageTypeEnum_MAX                       = 18,
};

// Enum b1-Managed.GetTamerMethod
// NumValues: 0x0003
enum class EGetTamerMethod : uint8
{
	Use_DA                                   = 0,
	Use_SingleMonster                        = 1,
	Use_MAX                                  = 2,
};

// SharpStruct b1-Managed.BUC_DispLibUtil_ForceVisibleStateCustomMode
// 0x0008 (0x0008 - 0x0000)
struct FBUC_DispLibUtil_ForceVisibleStateCustomMode final
{
public:
	int32                                         RequestATKPriority;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCNiagaraForceVisibleStateMode       Mode;                                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_ForceVisibleStateCustomMode) == 0x000004, "Wrong alignment on FBUC_DispLibUtil_ForceVisibleStateCustomMode");
static_assert(sizeof(FBUC_DispLibUtil_ForceVisibleStateCustomMode) == 0x000008, "Wrong size on FBUC_DispLibUtil_ForceVisibleStateCustomMode");
static_assert(offsetof(FBUC_DispLibUtil_ForceVisibleStateCustomMode, RequestATKPriority) == 0x000000, "Member 'FBUC_DispLibUtil_ForceVisibleStateCustomMode::RequestATKPriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ForceVisibleStateCustomMode, Mode) == 0x000004, "Member 'FBUC_DispLibUtil_ForceVisibleStateCustomMode::Mode' has a wrong offset!");

// SharpStruct b1-Managed.SingleBGMConfig
// 0x0010 (0x0010 - 0x0000)
struct FSingleBGMConfig final
{
public:
	class UAkAudioEvent*                          AkEventBegin;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventStop;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleBGMConfig) == 0x000008, "Wrong alignment on FSingleBGMConfig");
static_assert(sizeof(FSingleBGMConfig) == 0x000010, "Wrong size on FSingleBGMConfig");
static_assert(offsetof(FSingleBGMConfig, AkEventBegin) == 0x000000, "Member 'FSingleBGMConfig::AkEventBegin' has a wrong offset!");
static_assert(offsetof(FSingleBGMConfig, AkEventStop) == 0x000008, "Member 'FSingleBGMConfig::AkEventStop' has a wrong offset!");

// SharpStruct b1-Managed.IL2CPPUnitTestStruct1
// 0x0010 (0x0010 - 0x0000)
struct FIL2CPPUnitTestStruct1 final
{
public:
	class UAnimMontage*                           CSClassProperty;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CSIntProperty;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CSIntProperty2;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIL2CPPUnitTestStruct1) == 0x000008, "Wrong alignment on FIL2CPPUnitTestStruct1");
static_assert(sizeof(FIL2CPPUnitTestStruct1) == 0x000010, "Wrong size on FIL2CPPUnitTestStruct1");
static_assert(offsetof(FIL2CPPUnitTestStruct1, CSClassProperty) == 0x000000, "Member 'FIL2CPPUnitTestStruct1::CSClassProperty' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStruct1, CSIntProperty) == 0x000008, "Member 'FIL2CPPUnitTestStruct1::CSIntProperty' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStruct1, CSIntProperty2) == 0x00000C, "Member 'FIL2CPPUnitTestStruct1::CSIntProperty2' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_CurrentBeAttackedStiffLevel
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_CurrentBeAttackedStiffLevel final
{
public:
	EValueCompareOperations                       CompareOperation;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompareValueInt;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_CurrentBeAttackedStiffLevel) == 0x000004, "Wrong alignment on FDetectCondition_CurrentBeAttackedStiffLevel");
static_assert(sizeof(FDetectCondition_CurrentBeAttackedStiffLevel) == 0x000008, "Wrong size on FDetectCondition_CurrentBeAttackedStiffLevel");
static_assert(offsetof(FDetectCondition_CurrentBeAttackedStiffLevel, CompareOperation) == 0x000000, "Member 'FDetectCondition_CurrentBeAttackedStiffLevel::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition_CurrentBeAttackedStiffLevel, CompareValueInt) == 0x000004, "Member 'FDetectCondition_CurrentBeAttackedStiffLevel::CompareValueInt' has a wrong offset!");

// SharpStruct b1-Managed.SpawnWaveStartCondition
// 0x0008 (0x0008 - 0x0000)
struct FSpawnWaveStartCondition final
{
public:
	ESpawnWaveStartConditionType                  ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnWaveStartCondition) == 0x000004, "Wrong alignment on FSpawnWaveStartCondition");
static_assert(sizeof(FSpawnWaveStartCondition) == 0x000008, "Wrong size on FSpawnWaveStartCondition");
static_assert(offsetof(FSpawnWaveStartCondition, ConditionType) == 0x000000, "Member 'FSpawnWaveStartCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FSpawnWaveStartCondition, Time) == 0x000004, "Member 'FSpawnWaveStartCondition::Time' has a wrong offset!");

// SharpStruct b1-Managed.CompositeCondition_SpawnWaveStart
// 0x0038 (0x0038 - 0x0000)
struct FCompositeCondition_SpawnWaveStart final
{
public:
	struct FSpawnWaveStartCondition               Single;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCompositeCondition : 1;                        // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnWaveStartCondition>       Conditions;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x0021(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompositeCondition_SpawnWaveStart) == 0x000008, "Wrong alignment on FCompositeCondition_SpawnWaveStart");
static_assert(sizeof(FCompositeCondition_SpawnWaveStart) == 0x000038, "Wrong size on FCompositeCondition_SpawnWaveStart");
static_assert(offsetof(FCompositeCondition_SpawnWaveStart, Single) == 0x000000, "Member 'FCompositeCondition_SpawnWaveStart::Single' has a wrong offset!");
static_assert(offsetof(FCompositeCondition_SpawnWaveStart, Conditions) == 0x000010, "Member 'FCompositeCondition_SpawnWaveStart::Conditions' has a wrong offset!");
static_assert(offsetof(FCompositeCondition_SpawnWaveStart, ConditionalRelation) == 0x000020, "Member 'FCompositeCondition_SpawnWaveStart::ConditionalRelation' has a wrong offset!");
static_assert(offsetof(FCompositeCondition_SpawnWaveStart, Comment) == 0x000028, "Member 'FCompositeCondition_SpawnWaveStart::Comment' has a wrong offset!");

// SharpStruct b1-Managed.HelloUStructTest
// 0x0004 (0x0004 - 0x0000)
struct FHelloUStructTest final
{
public:
	float                                         TestValue;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHelloUStructTest) == 0x000004, "Wrong alignment on FHelloUStructTest");
static_assert(sizeof(FHelloUStructTest) == 0x000004, "Wrong size on FHelloUStructTest");
static_assert(offsetof(FHelloUStructTest, TestValue) == 0x000000, "Member 'FHelloUStructTest::TestValue' has a wrong offset!");

// SharpStruct b1-Managed.UDispLib_PostProcessRadialBlurConf
// 0x0048 (0x0048 - 0x0000)
struct FUDispLib_PostProcessRadialBlurConf final
{
public:
	class UMaterialInstance*                      Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RadialCenter;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurIntensity;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IterationCount;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthRange;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthMaskBias;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TintColor;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesaturationFaction;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeginningDuration;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishingDuration;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUDispLib_PostProcessRadialBlurConf) == 0x000008, "Wrong alignment on FUDispLib_PostProcessRadialBlurConf");
static_assert(sizeof(FUDispLib_PostProcessRadialBlurConf) == 0x000048, "Wrong size on FUDispLib_PostProcessRadialBlurConf");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, Material) == 0x000000, "Member 'FUDispLib_PostProcessRadialBlurConf::Material' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, RadialCenter) == 0x000008, "Member 'FUDispLib_PostProcessRadialBlurConf::RadialCenter' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, BlurIntensity) == 0x000018, "Member 'FUDispLib_PostProcessRadialBlurConf::BlurIntensity' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, IterationCount) == 0x00001C, "Member 'FUDispLib_PostProcessRadialBlurConf::IterationCount' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, DepthRange) == 0x000020, "Member 'FUDispLib_PostProcessRadialBlurConf::DepthRange' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, DepthMaskBias) == 0x000024, "Member 'FUDispLib_PostProcessRadialBlurConf::DepthMaskBias' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, TintColor) == 0x000028, "Member 'FUDispLib_PostProcessRadialBlurConf::TintColor' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, DesaturationFaction) == 0x000038, "Member 'FUDispLib_PostProcessRadialBlurConf::DesaturationFaction' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, BeginningDuration) == 0x00003C, "Member 'FUDispLib_PostProcessRadialBlurConf::BeginningDuration' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostProcessRadialBlurConf, FinishingDuration) == 0x000040, "Member 'FUDispLib_PostProcessRadialBlurConf::FinishingDuration' has a wrong offset!");

// SharpStruct b1-Managed.SourceAsset
// 0x0010 (0x0010 - 0x0000)
struct FSourceAsset final
{
public:
	class FName                                   AssetName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            MeshAsset;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSourceAsset) == 0x000008, "Wrong alignment on FSourceAsset");
static_assert(sizeof(FSourceAsset) == 0x000010, "Wrong size on FSourceAsset");
static_assert(offsetof(FSourceAsset, AssetName) == 0x000000, "Member 'FSourceAsset::AssetName' has a wrong offset!");
static_assert(offsetof(FSourceAsset, MeshAsset) == 0x000008, "Member 'FSourceAsset::MeshAsset' has a wrong offset!");

// SharpStruct b1-Managed.ChildActorActionInfo
// 0x0024 (0x0024 - 0x0000)
struct FChildActorActionInfo final
{
public:
	EChildActorActionType                         ActionType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NeedCheckSkillCanCast : 1;                         // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MontageStartSectionName;                           // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLayer;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffDuration;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TriggerRemoveEffect : 1;                           // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FChildActorActionInfo) == 0x000004, "Wrong alignment on FChildActorActionInfo");
static_assert(sizeof(FChildActorActionInfo) == 0x000024, "Wrong size on FChildActorActionInfo");
static_assert(offsetof(FChildActorActionInfo, ActionType) == 0x000000, "Member 'FChildActorActionInfo::ActionType' has a wrong offset!");
static_assert(offsetof(FChildActorActionInfo, SkillID) == 0x000004, "Member 'FChildActorActionInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FChildActorActionInfo, MontageStartSectionName) == 0x00000C, "Member 'FChildActorActionInfo::MontageStartSectionName' has a wrong offset!");
static_assert(offsetof(FChildActorActionInfo, BuffID) == 0x000014, "Member 'FChildActorActionInfo::BuffID' has a wrong offset!");
static_assert(offsetof(FChildActorActionInfo, BuffLayer) == 0x000018, "Member 'FChildActorActionInfo::BuffLayer' has a wrong offset!");
static_assert(offsetof(FChildActorActionInfo, BuffDuration) == 0x00001C, "Member 'FChildActorActionInfo::BuffDuration' has a wrong offset!");

// SharpStruct b1-Managed.FBPTreeInfo
// 0x0040 (0x0040 - 0x0000)
struct FFBPTreeInfo final
{
public:
	struct FVector                                LeaveBoxOri;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeaveBoxExtent;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TreeName;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFBPTreeInfo) == 0x000008, "Wrong alignment on FFBPTreeInfo");
static_assert(sizeof(FFBPTreeInfo) == 0x000040, "Wrong size on FFBPTreeInfo");
static_assert(offsetof(FFBPTreeInfo, LeaveBoxOri) == 0x000000, "Member 'FFBPTreeInfo::LeaveBoxOri' has a wrong offset!");
static_assert(offsetof(FFBPTreeInfo, LeaveBoxExtent) == 0x000018, "Member 'FFBPTreeInfo::LeaveBoxExtent' has a wrong offset!");
static_assert(offsetof(FFBPTreeInfo, TreeName) == 0x000030, "Member 'FFBPTreeInfo::TreeName' has a wrong offset!");

// SharpStruct b1-Managed.CoinFXNum
// 0x0008 (0x0008 - 0x0000)
struct FCoinFXNum final
{
public:
	int32                                         LowerLimit;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FXNum;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoinFXNum) == 0x000004, "Wrong alignment on FCoinFXNum");
static_assert(sizeof(FCoinFXNum) == 0x000008, "Wrong size on FCoinFXNum");
static_assert(offsetof(FCoinFXNum, LowerLimit) == 0x000000, "Member 'FCoinFXNum::LowerLimit' has a wrong offset!");
static_assert(offsetof(FCoinFXNum, FXNum) == 0x000004, "Member 'FCoinFXNum::FXNum' has a wrong offset!");

// SharpStruct b1-Managed.OnePCurveScalarPoint
// 0x000C (0x000C - 0x0000)
struct FOnePCurveScalarPoint final
{
public:
	EDispLibDBCPCurvePointScalarMode              Mode;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationToPrePoint;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnePCurveScalarPoint) == 0x000004, "Wrong alignment on FOnePCurveScalarPoint");
static_assert(sizeof(FOnePCurveScalarPoint) == 0x00000C, "Wrong size on FOnePCurveScalarPoint");
static_assert(offsetof(FOnePCurveScalarPoint, Mode) == 0x000000, "Member 'FOnePCurveScalarPoint::Mode' has a wrong offset!");
static_assert(offsetof(FOnePCurveScalarPoint, Value) == 0x000004, "Member 'FOnePCurveScalarPoint::Value' has a wrong offset!");
static_assert(offsetof(FOnePCurveScalarPoint, DurationToPrePoint) == 0x000008, "Member 'FOnePCurveScalarPoint::DurationToPrePoint' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCPCurveScalar
// 0x0028 (0x0028 - 0x0000)
struct FBUC_DispLibUtil_DBCPCurveScalar final
{
public:
	TArray<struct FOnePCurveScalarPoint>          PointsList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Loop : 1;                                          // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOnePCurveScalarPoint                  EndToPoint;                                        // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAdvProcessReleaseParameterControlMode ReleaseParameterControlMode;                       // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCPCurveScalar) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCPCurveScalar");
static_assert(sizeof(FBUC_DispLibUtil_DBCPCurveScalar) == 0x000028, "Wrong size on FBUC_DispLibUtil_DBCPCurveScalar");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalar, PointsList) == 0x000000, "Member 'FBUC_DispLibUtil_DBCPCurveScalar::PointsList' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalar, Duration) == 0x000014, "Member 'FBUC_DispLibUtil_DBCPCurveScalar::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalar, EndToPoint) == 0x000018, "Member 'FBUC_DispLibUtil_DBCPCurveScalar::EndToPoint' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalar, ReleaseParameterControlMode) == 0x000024, "Member 'FBUC_DispLibUtil_DBCPCurveScalar::ReleaseParameterControlMode' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_PlayCustomCameraShake
// 0x0270 (0x0270 - 0x0000)
struct FBUC_DispLibDBC_PlayCustomCameraShake final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTime;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ForceApply : 1;                                    // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_C_1 : 7;                                    // 0x000C(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         CtrlRO : 1;                                        // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EOscillatorWaveform                           RO_Noise;                                          // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBUC_DispLibUtil_DBCPCurveScalar       RO_Pitch_Amplitude;                                // 0x0010(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       RO_Yaw_Amplitude;                                  // 0x0038(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       RO_Roll_Amplitude;                                 // 0x0060(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       RO_Pitch_Frequency;                                // 0x0088(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       RO_Yaw_Frequency;                                  // 0x00B0(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       RO_Roll_Frequency;                                 // 0x00D8(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CtrlLO : 1;                                        // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EOscillatorWaveform                           LO_Noise;                                          // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBUC_DispLibUtil_DBCPCurveScalar       LO_X_Amplitude;                                    // 0x0108(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       LO_Y_Amplitude;                                    // 0x0130(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       LO_Z_Amplitude;                                    // 0x0158(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       LO_X_Frequency;                                    // 0x0180(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       LO_Y_Frequency;                                    // 0x01A8(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       LO_Z_Frequency;                                    // 0x01D0(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CtrlFOV : 1;                                       // 0x01F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EOscillatorWaveform                           FOV_Noise;                                         // 0x01F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA[0x6];                                      // 0x01FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBUC_DispLibUtil_DBCPCurveScalar       FOV_Amplitude;                                     // 0x0200(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       FOV_Frequency;                                     // 0x0228(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseDistanceDamping : 1;                            // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_250_1 : 7;                                  // 0x0250(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         AttachedTarget : 1;                                // 0x0251(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_252[0x2];                                      // 0x0252(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedTargetSocketName;                          // 0x0254(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CamShakeScaleByDistCurve;                          // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_PlayCustomCameraShake) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_PlayCustomCameraShake");
static_assert(sizeof(FBUC_DispLibDBC_PlayCustomCameraShake) == 0x000270, "Wrong size on FBUC_DispLibDBC_PlayCustomCameraShake");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, Delay) == 0x000000, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, TotalTime) == 0x000004, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::TotalTime' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, DelayTimeAfterStop) == 0x000008, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, RO_Noise) == 0x00000E, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::RO_Noise' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, RO_Pitch_Amplitude) == 0x000010, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::RO_Pitch_Amplitude' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, RO_Yaw_Amplitude) == 0x000038, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::RO_Yaw_Amplitude' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, RO_Roll_Amplitude) == 0x000060, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::RO_Roll_Amplitude' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, RO_Pitch_Frequency) == 0x000088, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::RO_Pitch_Frequency' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, RO_Yaw_Frequency) == 0x0000B0, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::RO_Yaw_Frequency' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, RO_Roll_Frequency) == 0x0000D8, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::RO_Roll_Frequency' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, LO_Noise) == 0x000101, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::LO_Noise' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, LO_X_Amplitude) == 0x000108, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::LO_X_Amplitude' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, LO_Y_Amplitude) == 0x000130, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::LO_Y_Amplitude' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, LO_Z_Amplitude) == 0x000158, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::LO_Z_Amplitude' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, LO_X_Frequency) == 0x000180, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::LO_X_Frequency' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, LO_Y_Frequency) == 0x0001A8, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::LO_Y_Frequency' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, LO_Z_Frequency) == 0x0001D0, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::LO_Z_Frequency' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, FOV_Noise) == 0x0001F9, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::FOV_Noise' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, FOV_Amplitude) == 0x000200, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::FOV_Amplitude' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, FOV_Frequency) == 0x000228, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::FOV_Frequency' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, AttachedTargetSocketName) == 0x000254, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::AttachedTargetSocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, CamShakeScaleByDistCurve) == 0x000260, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::CamShakeScaleByDistCurve' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, MaxDistance) == 0x000268, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::MaxDistance' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCustomCameraShake, PausePriority) == 0x00026C, "Member 'FBUC_DispLibDBC_PlayCustomCameraShake::PausePriority' has a wrong offset!");

// SharpStruct b1-Managed.MayaShadingEngineToUnrealMaterial
// 0x0010 (0x0010 - 0x0000)
struct FMayaShadingEngineToUnrealMaterial final
{
public:
	class FName                                   MayaShadingEngineName;                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMayaShadingEngineToUnrealMaterial) == 0x000008, "Wrong alignment on FMayaShadingEngineToUnrealMaterial");
static_assert(sizeof(FMayaShadingEngineToUnrealMaterial) == 0x000010, "Wrong size on FMayaShadingEngineToUnrealMaterial");
static_assert(offsetof(FMayaShadingEngineToUnrealMaterial, MayaShadingEngineName) == 0x000000, "Member 'FMayaShadingEngineToUnrealMaterial::MayaShadingEngineName' has a wrong offset!");
static_assert(offsetof(FMayaShadingEngineToUnrealMaterial, Material) == 0x000008, "Member 'FMayaShadingEngineToUnrealMaterial::Material' has a wrong offset!");

// SharpStruct b1-Managed.MatSyncConfig
// 0x000C (0x000C - 0x0000)
struct FMatSyncConfig final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatType                                      MatType;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatSyncConfig) == 0x000004, "Wrong alignment on FMatSyncConfig");
static_assert(sizeof(FMatSyncConfig) == 0x00000C, "Wrong size on FMatSyncConfig");
static_assert(offsetof(FMatSyncConfig, Name) == 0x000000, "Member 'FMatSyncConfig::Name' has a wrong offset!");
static_assert(offsetof(FMatSyncConfig, MatType) == 0x000008, "Member 'FMatSyncConfig::MatType' has a wrong offset!");

// SharpStruct b1-Managed.UDispLib_PostPorcessCommonConf
// 0x0030 (0x0030 - 0x0000)
struct FUDispLib_PostPorcessCommonConf final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ActorType;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeginningDuration;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishingDuration;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AutoEnable : 1;                                    // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FUDispLib_PostPorcessCommonConf) == 0x000008, "Wrong alignment on FUDispLib_PostPorcessCommonConf");
static_assert(sizeof(FUDispLib_PostPorcessCommonConf) == 0x000030, "Wrong size on FUDispLib_PostPorcessCommonConf");
static_assert(offsetof(FUDispLib_PostPorcessCommonConf, ID) == 0x000000, "Member 'FUDispLib_PostPorcessCommonConf::ID' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostPorcessCommonConf, Name) == 0x000008, "Member 'FUDispLib_PostPorcessCommonConf::Name' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostPorcessCommonConf, ActorType) == 0x000018, "Member 'FUDispLib_PostPorcessCommonConf::ActorType' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostPorcessCommonConf, BeginningDuration) == 0x000020, "Member 'FUDispLib_PostPorcessCommonConf::BeginningDuration' has a wrong offset!");
static_assert(offsetof(FUDispLib_PostPorcessCommonConf, FinishingDuration) == 0x000024, "Member 'FUDispLib_PostPorcessCommonConf::FinishingDuration' has a wrong offset!");

// SharpStruct b1-Managed.MapLineData
// 0x0000 (0x0000 - 0x0000)
struct FMapLineData final
{
};
static_assert(alignof(FMapLineData) == 0x000001, "Wrong alignment on FMapLineData");
static_assert(sizeof(FMapLineData) == 0x000001, "Wrong size on FMapLineData");

// SharpStruct b1-Managed.WEFMLODSetting
// 0x0028 (0x0028 - 0x0000)
struct FWEFMLODSetting final
{
public:
	float                                         CellLength;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CellNumV3;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleRT2DSize;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWEFMLODSetting) == 0x000008, "Wrong alignment on FWEFMLODSetting");
static_assert(sizeof(FWEFMLODSetting) == 0x000028, "Wrong size on FWEFMLODSetting");
static_assert(offsetof(FWEFMLODSetting, CellLength) == 0x000000, "Member 'FWEFMLODSetting::CellLength' has a wrong offset!");
static_assert(offsetof(FWEFMLODSetting, CellNumV3) == 0x000008, "Member 'FWEFMLODSetting::CellNumV3' has a wrong offset!");
static_assert(offsetof(FWEFMLODSetting, ScaleRT2DSize) == 0x000020, "Member 'FWEFMLODSetting::ScaleRT2DSize' has a wrong offset!");

// SharpStruct b1-Managed.AttackIKBoneScale
// 0x0030 (0x0030 - 0x0000)
struct FAttackIKBoneScale final
{
public:
	class FName                                   TargetBoneScaleName;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBoneName;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneScaleOffset;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BoneScaleDistanceLimit;                            // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneScaleYawLimit;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackIKBoneScale) == 0x000008, "Wrong alignment on FAttackIKBoneScale");
static_assert(sizeof(FAttackIKBoneScale) == 0x000030, "Wrong size on FAttackIKBoneScale");
static_assert(offsetof(FAttackIKBoneScale, TargetBoneScaleName) == 0x000000, "Member 'FAttackIKBoneScale::TargetBoneScaleName' has a wrong offset!");
static_assert(offsetof(FAttackIKBoneScale, TargetBoneName) == 0x000008, "Member 'FAttackIKBoneScale::TargetBoneName' has a wrong offset!");
static_assert(offsetof(FAttackIKBoneScale, BoneScaleOffset) == 0x000010, "Member 'FAttackIKBoneScale::BoneScaleOffset' has a wrong offset!");
static_assert(offsetof(FAttackIKBoneScale, BoneScaleDistanceLimit) == 0x000018, "Member 'FAttackIKBoneScale::BoneScaleDistanceLimit' has a wrong offset!");
static_assert(offsetof(FAttackIKBoneScale, BoneScaleYawLimit) == 0x000028, "Member 'FAttackIKBoneScale::BoneScaleYawLimit' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_ModifyNiagaraParams_FLinearColor
// 0x0060 (0x0060 - 0x0000)
struct FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor final
{
public:
	EDispLibDBCAdvProcessModifyNiagaraParamUtilMode Mode;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SetEveryFrame : 1;                                 // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibDBCSpecialAttritubeTpye               SpecAttType;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Value;                                             // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RangeMin;                                          // 0x0014(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RangeMax;                                          // 0x0024(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Loop : 1;                                          // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Period;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndStageDuration;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EndValue;                                          // 0x0044(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      Curve;                                             // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor");
static_assert(sizeof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor) == 0x000060, "Wrong size on FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, Mode) == 0x000000, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::Mode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, SpecAttType) == 0x000002, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::SpecAttType' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, Value) == 0x000004, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, RangeMin) == 0x000014, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::RangeMin' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, RangeMax) == 0x000024, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::RangeMax' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, Period) == 0x000038, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::Period' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, Duration) == 0x00003C, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, EndStageDuration) == 0x000040, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::EndStageDuration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, EndValue) == 0x000044, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::EndValue' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, Scale) == 0x000054, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::Scale' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor, Curve) == 0x000058, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor::Curve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings
// 0x0048 (0x0048 - 0x0000)
struct FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings final
{
public:
	uint8                                         Enable : 1;                                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSystemInstanceCount;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCNiagaraScalabilityKillMode         Mode;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AgeWeight;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraDistanceWeight;                              // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CameraForwardDirDotWeight;                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomWeightAdd;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings");
static_assert(sizeof(FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings) == 0x000048, "Wrong size on FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings");
static_assert(offsetof(FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings, MaxSystemInstanceCount) == 0x000004, "Member 'FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings::MaxSystemInstanceCount' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings, Mode) == 0x000008, "Member 'FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings::Mode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings, AgeWeight) == 0x000010, "Member 'FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings::AgeWeight' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings, CameraDistanceWeight) == 0x000020, "Member 'FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings::CameraDistanceWeight' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings, CameraForwardDirDotWeight) == 0x000030, "Member 'FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings::CameraForwardDirDotWeight' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings, CustomWeightAdd) == 0x000040, "Member 'FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings::CustomWeightAdd' has a wrong offset!");

// SharpStruct b1-Managed.BehaviorNodeGroupBuffList
// 0x0018 (0x0018 - 0x0000)
struct FBehaviorNodeGroupBuffList final
{
public:
	int32                                         BuffID;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLayer;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffDuration;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddNum;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckBuffId;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CheckReverse : 1;                                  // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FBehaviorNodeGroupBuffList) == 0x000004, "Wrong alignment on FBehaviorNodeGroupBuffList");
static_assert(sizeof(FBehaviorNodeGroupBuffList) == 0x000018, "Wrong size on FBehaviorNodeGroupBuffList");
static_assert(offsetof(FBehaviorNodeGroupBuffList, BuffID) == 0x000000, "Member 'FBehaviorNodeGroupBuffList::BuffID' has a wrong offset!");
static_assert(offsetof(FBehaviorNodeGroupBuffList, BuffLayer) == 0x000004, "Member 'FBehaviorNodeGroupBuffList::BuffLayer' has a wrong offset!");
static_assert(offsetof(FBehaviorNodeGroupBuffList, BuffDuration) == 0x000008, "Member 'FBehaviorNodeGroupBuffList::BuffDuration' has a wrong offset!");
static_assert(offsetof(FBehaviorNodeGroupBuffList, AddNum) == 0x00000C, "Member 'FBehaviorNodeGroupBuffList::AddNum' has a wrong offset!");
static_assert(offsetof(FBehaviorNodeGroupBuffList, CheckBuffId) == 0x000010, "Member 'FBehaviorNodeGroupBuffList::CheckBuffId' has a wrong offset!");

// SharpStruct b1-Managed.UDispLib_PostProcessBlueprintConf
// 0x0008 (0x0008 - 0x0000)
struct FUDispLib_PostProcessBlueprintConf final
{
public:
	class UClass*                                 Blueprint;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUDispLib_PostProcessBlueprintConf) == 0x000008, "Wrong alignment on FUDispLib_PostProcessBlueprintConf");
static_assert(sizeof(FUDispLib_PostProcessBlueprintConf) == 0x000008, "Wrong size on FUDispLib_PostProcessBlueprintConf");
static_assert(offsetof(FUDispLib_PostProcessBlueprintConf, Blueprint) == 0x000000, "Member 'FUDispLib_PostProcessBlueprintConf::Blueprint' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_ModifyNiagaraParams_Float
// 0x0030 (0x0030 - 0x0000)
struct FBUC_DispLibUtil_ModifyNiagaraParams_Float final
{
public:
	EDispLibDBCAdvProcessModifyNiagaraParamUtilMode Mode;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SetEveryFrame : 1;                                 // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibDBCSpecialAttritubeTpye               SpecAttType;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMin;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMax;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Loop : 1;                                          // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Period;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndStageDuration;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_ModifyNiagaraParams_Float) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_ModifyNiagaraParams_Float");
static_assert(sizeof(FBUC_DispLibUtil_ModifyNiagaraParams_Float) == 0x000030, "Wrong size on FBUC_DispLibUtil_ModifyNiagaraParams_Float");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, Mode) == 0x000000, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::Mode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, SpecAttType) == 0x000002, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::SpecAttType' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, Value) == 0x000004, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, RangeMin) == 0x000008, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::RangeMin' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, RangeMax) == 0x00000C, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::RangeMax' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, Period) == 0x000014, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::Period' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, Duration) == 0x000018, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, EndStageDuration) == 0x00001C, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::EndStageDuration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, EndValue) == 0x000020, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::EndValue' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, Scale) == 0x000024, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::Scale' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_Float, Curve) == 0x000028, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_Float::Curve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_ModifyNiagaraParams_FloatParam
// 0x0038 (0x0038 - 0x0000)
struct FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_ModifyNiagaraParams_Float ProcessValue;                                      // 0x0008(0x0030)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam");
static_assert(sizeof(FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam) == 0x000038, "Wrong size on FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam, ProcessValue) == 0x000008, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam::ProcessValue' has a wrong offset!");

// SharpStruct b1-Managed.ProceduralSpawnSceneItemInfo
// 0x0008 (0x0008 - 0x0000)
struct FProceduralSpawnSceneItemInfo final
{
public:
	class UClass*                                 SpawnClass;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralSpawnSceneItemInfo) == 0x000008, "Wrong alignment on FProceduralSpawnSceneItemInfo");
static_assert(sizeof(FProceduralSpawnSceneItemInfo) == 0x000008, "Wrong size on FProceduralSpawnSceneItemInfo");
static_assert(offsetof(FProceduralSpawnSceneItemInfo, SpawnClass) == 0x000000, "Member 'FProceduralSpawnSceneItemInfo::SpawnClass' has a wrong offset!");

// SharpStruct b1-Managed.MovieTriggerRelationInfo
// 0x0048 (0x0048 - 0x0000)
struct FMovieTriggerRelationInfo final
{
public:
	EMovieTriggerType                             TriggerType;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasMultiActor : 1;                                // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Monsters;                                          // 0x0008(0x0010)(NativeAccessSpecifierPublic)
	class FString                                 ActorGuid;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStageStatus                                  TaskStageStatus;                                   // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TaskStage;                                         // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieTriggerRelationInfo) == 0x000008, "Wrong alignment on FMovieTriggerRelationInfo");
static_assert(sizeof(FMovieTriggerRelationInfo) == 0x000048, "Wrong size on FMovieTriggerRelationInfo");
static_assert(offsetof(FMovieTriggerRelationInfo, TriggerType) == 0x000000, "Member 'FMovieTriggerRelationInfo::TriggerType' has a wrong offset!");
static_assert(offsetof(FMovieTriggerRelationInfo, Monsters) == 0x000008, "Member 'FMovieTriggerRelationInfo::Monsters' has a wrong offset!");
static_assert(offsetof(FMovieTriggerRelationInfo, ActorGuid) == 0x000018, "Member 'FMovieTriggerRelationInfo::ActorGuid' has a wrong offset!");
static_assert(offsetof(FMovieTriggerRelationInfo, Location) == 0x000028, "Member 'FMovieTriggerRelationInfo::Location' has a wrong offset!");
static_assert(offsetof(FMovieTriggerRelationInfo, TaskStageStatus) == 0x000040, "Member 'FMovieTriggerRelationInfo::TaskStageStatus' has a wrong offset!");
static_assert(offsetof(FMovieTriggerRelationInfo, TaskStage) == 0x000044, "Member 'FMovieTriggerRelationInfo::TaskStage' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_NiagaraEventMergedSettings
// 0x0068 (0x0068 - 0x0000)
struct FBUC_DispLibDBC_NiagaraEventMergedSettings final
{
public:
	uint8                                         Enable : 1;                                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PerCreateCount;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SendRotationInfo : 1;                              // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_8_1 : 7;                                    // 0x0008(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         SendScaleInfo : 1;                                 // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_9_1 : 7;                                    // 0x0009(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         SendScaleEveryTick : 1;                            // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_A_1 : 7;                                    // 0x000A(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         HasCustomVectorParam : 1;                          // 0x000B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FName>                CustomVectorParamNameMap;                          // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         MergeMangerSystem;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_NiagaraEventMergedSettings) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_NiagaraEventMergedSettings");
static_assert(sizeof(FBUC_DispLibDBC_NiagaraEventMergedSettings) == 0x000068, "Wrong size on FBUC_DispLibDBC_NiagaraEventMergedSettings");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventMergedSettings, PerCreateCount) == 0x000004, "Member 'FBUC_DispLibDBC_NiagaraEventMergedSettings::PerCreateCount' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventMergedSettings, CustomVectorParamNameMap) == 0x000010, "Member 'FBUC_DispLibDBC_NiagaraEventMergedSettings::CustomVectorParamNameMap' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventMergedSettings, MergeMangerSystem) == 0x000060, "Member 'FBUC_DispLibDBC_NiagaraEventMergedSettings::MergeMangerSystem' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_DurCastSkill
// 0x0010 (0x0010 - 0x0000)
struct FDetectCondition_DurCastSkill final
{
public:
	TArray<int32>                                 SkillIdList;                                       // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_DurCastSkill) == 0x000008, "Wrong alignment on FDetectCondition_DurCastSkill");
static_assert(sizeof(FDetectCondition_DurCastSkill) == 0x000010, "Wrong size on FDetectCondition_DurCastSkill");
static_assert(offsetof(FDetectCondition_DurCastSkill, SkillIdList) == 0x000000, "Member 'FDetectCondition_DurCastSkill::SkillIdList' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_ModifyNiagaraParams_FVector
// 0x0088 (0x0088 - 0x0000)
struct FBUC_DispLibUtil_ModifyNiagaraParams_FVector final
{
public:
	EDispLibDBCAdvProcessModifyNiagaraParamUtilMode Mode;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SetEveryFrame : 1;                                 // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibDBCSpecialAttritubeTpye               SpecAttType;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Value;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RangeMin;                                          // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RangeMax;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Loop : 1;                                          // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Period;                                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndStageDuration;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndValue;                                          // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           Curve;                                             // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_ModifyNiagaraParams_FVector");
static_assert(sizeof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector) == 0x000088, "Wrong size on FBUC_DispLibUtil_ModifyNiagaraParams_FVector");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, Mode) == 0x000000, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::Mode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, SpecAttType) == 0x000002, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::SpecAttType' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, Value) == 0x000008, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, RangeMin) == 0x000020, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::RangeMin' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, RangeMax) == 0x000038, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::RangeMax' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, Period) == 0x000054, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::Period' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, Duration) == 0x000058, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, EndStageDuration) == 0x00005C, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::EndStageDuration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, EndValue) == 0x000060, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::EndValue' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, Scale) == 0x000078, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::Scale' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVector, Curve) == 0x000080, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVector::Curve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_ModifyNiagaraParams_FVectorParam
// 0x0090 (0x0090 - 0x0000)
struct FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_ModifyNiagaraParams_FVector ProcessValue;                                      // 0x0008(0x0088)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam");
static_assert(sizeof(FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam) == 0x000090, "Wrong size on FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam, ProcessValue) == 0x000008, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam::ProcessValue' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_NiagaraEventScalabilitySettings
// 0x0170 (0x0170 - 0x0000)
struct FBUC_DispLibDBC_NiagaraEventScalabilitySettings final
{
public:
	uint8                                         Enable : 1;                                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibDBCNiagaraScalabilityPoolMode         PoolMode;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings Low;                                               // 0x0008(0x0048)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings Medium;                                            // 0x0050(0x0048)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings High;                                              // 0x0098(0x0048)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings Epic;                                              // 0x00E0(0x0048)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibDBC_OneEffectQualityNiagaraScalabilitySettings Cinematic;                                         // 0x0128(0x0048)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_NiagaraEventScalabilitySettings) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_NiagaraEventScalabilitySettings");
static_assert(sizeof(FBUC_DispLibDBC_NiagaraEventScalabilitySettings) == 0x000170, "Wrong size on FBUC_DispLibDBC_NiagaraEventScalabilitySettings");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventScalabilitySettings, PoolMode) == 0x000001, "Member 'FBUC_DispLibDBC_NiagaraEventScalabilitySettings::PoolMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventScalabilitySettings, Low) == 0x000008, "Member 'FBUC_DispLibDBC_NiagaraEventScalabilitySettings::Low' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventScalabilitySettings, Medium) == 0x000050, "Member 'FBUC_DispLibDBC_NiagaraEventScalabilitySettings::Medium' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventScalabilitySettings, High) == 0x000098, "Member 'FBUC_DispLibDBC_NiagaraEventScalabilitySettings::High' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventScalabilitySettings, Epic) == 0x0000E0, "Member 'FBUC_DispLibDBC_NiagaraEventScalabilitySettings::Epic' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_NiagaraEventScalabilitySettings, Cinematic) == 0x000128, "Member 'FBUC_DispLibDBC_NiagaraEventScalabilitySettings::Cinematic' has a wrong offset!");

// SharpStruct b1-Managed.TortoiseRotateTriggerBoxInfo
// 0x0020 (0x0020 - 0x0000)
struct FTortoiseRotateTriggerBoxInfo final
{
public:
	uint8                                         UseCurveSettings : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        RotationAnimation;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           RotationCurve;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           TransitionCurve;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTortoiseRotateTriggerBoxInfo) == 0x000008, "Wrong alignment on FTortoiseRotateTriggerBoxInfo");
static_assert(sizeof(FTortoiseRotateTriggerBoxInfo) == 0x000020, "Wrong size on FTortoiseRotateTriggerBoxInfo");
static_assert(offsetof(FTortoiseRotateTriggerBoxInfo, RotationAnimation) == 0x000008, "Member 'FTortoiseRotateTriggerBoxInfo::RotationAnimation' has a wrong offset!");
static_assert(offsetof(FTortoiseRotateTriggerBoxInfo, RotationCurve) == 0x000010, "Member 'FTortoiseRotateTriggerBoxInfo::RotationCurve' has a wrong offset!");
static_assert(offsetof(FTortoiseRotateTriggerBoxInfo, TransitionCurve) == 0x000018, "Member 'FTortoiseRotateTriggerBoxInfo::TransitionCurve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam
// 0x0068 (0x0068 - 0x0000)
struct FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColor ProcessValue;                                      // 0x0008(0x0060)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam");
static_assert(sizeof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam) == 0x000068, "Wrong size on FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam, ProcessValue) == 0x000008, "Member 'FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam::ProcessValue' has a wrong offset!");

// SharpStruct b1-Managed.MatParam
// 0x0060 (0x0060 - 0x0000)
struct FMatParam final
{
public:
	EGSMatParamType                               ParamType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParameterName;                                     // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorValue;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LinearColorValue;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FloatCurve;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           VectorCurve;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      LinearColorCurve;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CharacterInfoRefresh : 1;                          // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_58_1 : 7;                                   // 0x0058(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bUseScreenSpace : 1;                               // 0x0059(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_59_1 : 7;                                   // 0x0059(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bUseLastFrameValue : 1;                            // 0x005A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FMatParam) == 0x000008, "Wrong alignment on FMatParam");
static_assert(sizeof(FMatParam) == 0x000060, "Wrong size on FMatParam");
static_assert(offsetof(FMatParam, ParamType) == 0x000000, "Member 'FMatParam::ParamType' has a wrong offset!");
static_assert(offsetof(FMatParam, ParameterName) == 0x000004, "Member 'FMatParam::ParameterName' has a wrong offset!");
static_assert(offsetof(FMatParam, FloatValue) == 0x00000C, "Member 'FMatParam::FloatValue' has a wrong offset!");
static_assert(offsetof(FMatParam, VectorValue) == 0x000010, "Member 'FMatParam::VectorValue' has a wrong offset!");
static_assert(offsetof(FMatParam, LinearColorValue) == 0x000028, "Member 'FMatParam::LinearColorValue' has a wrong offset!");
static_assert(offsetof(FMatParam, FloatCurve) == 0x000038, "Member 'FMatParam::FloatCurve' has a wrong offset!");
static_assert(offsetof(FMatParam, VectorCurve) == 0x000040, "Member 'FMatParam::VectorCurve' has a wrong offset!");
static_assert(offsetof(FMatParam, LinearColorCurve) == 0x000048, "Member 'FMatParam::LinearColorCurve' has a wrong offset!");
static_assert(offsetof(FMatParam, SocketName) == 0x000050, "Member 'FMatParam::SocketName' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_CameraEnvFXInfo
// 0x0010 (0x0010 - 0x0000)
struct FBUC_DispLibDBC_CameraEnvFXInfo final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_CameraEnvFXInfo) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_CameraEnvFXInfo");
static_assert(sizeof(FBUC_DispLibDBC_CameraEnvFXInfo) == 0x000010, "Wrong size on FBUC_DispLibDBC_CameraEnvFXInfo");
static_assert(offsetof(FBUC_DispLibDBC_CameraEnvFXInfo, LevelName) == 0x000000, "Member 'FBUC_DispLibDBC_CameraEnvFXInfo::LevelName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_CameraEnvFXInfo, NiagaraSystem) == 0x000008, "Member 'FBUC_DispLibDBC_CameraEnvFXInfo::NiagaraSystem' has a wrong offset!");

// SharpStruct b1-Managed.InputTipsOneCfg
// 0x0020 (0x0020 - 0x0000)
struct FInputTipsOneCfg final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TxtDesc;                                           // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputTipsOneCfg) == 0x000008, "Wrong alignment on FInputTipsOneCfg");
static_assert(sizeof(FInputTipsOneCfg) == 0x000020, "Wrong size on FInputTipsOneCfg");
static_assert(offsetof(FInputTipsOneCfg, InputAction) == 0x000000, "Member 'FInputTipsOneCfg::InputAction' has a wrong offset!");
static_assert(offsetof(FInputTipsOneCfg, TxtDesc) == 0x000008, "Member 'FInputTipsOneCfg::TxtDesc' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCAdvProcessScalar
// 0x0040 (0x0040 - 0x0000)
struct FBUC_DispLibUtil_DBCAdvProcessScalar final
{
public:
	EDispLibDBCAdvProcessScalarMode               Mode;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Range;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Loop : 1;                                          // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Period;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndStageDuration;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAdvProcessReleaseParameterControlMode ReleaseParameterControlMode;                       // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCAdvProcessScalar) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCAdvProcessScalar");
static_assert(sizeof(FBUC_DispLibUtil_DBCAdvProcessScalar) == 0x000040, "Wrong size on FBUC_DispLibUtil_DBCAdvProcessScalar");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, Mode) == 0x000000, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::Mode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, Value) == 0x000004, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, Range) == 0x000008, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::Range' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, Period) == 0x00001C, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::Period' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, Duration) == 0x000020, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, EndStageDuration) == 0x000024, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::EndStageDuration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, EndValue) == 0x000028, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::EndValue' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, ReleaseParameterControlMode) == 0x00002C, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::ReleaseParameterControlMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, Scale) == 0x000030, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::Scale' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalar, Curve) == 0x000038, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalar::Curve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCAdvProcessScalarParam
// 0x0048 (0x0048 - 0x0000)
struct FBUC_DispLibUtil_DBCAdvProcessScalarParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCAdvProcessScalar   ProcessValue;                                      // 0x0008(0x0040)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCAdvProcessScalarParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCAdvProcessScalarParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCAdvProcessScalarParam) == 0x000048, "Wrong size on FBUC_DispLibUtil_DBCAdvProcessScalarParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalarParam, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalarParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalarParam, ProcessValue) == 0x000008, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalarParam::ProcessValue' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_EntityEffectTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct FBUC_DispLibDBC_EntityEffectTargetInfo final
{
public:
	EDispLibDBCCompsFilterMode                    CompsFilterMode;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CompTags;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_EntityEffectTargetInfo) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_EntityEffectTargetInfo");
static_assert(sizeof(FBUC_DispLibDBC_EntityEffectTargetInfo) == 0x000018, "Wrong size on FBUC_DispLibDBC_EntityEffectTargetInfo");
static_assert(offsetof(FBUC_DispLibDBC_EntityEffectTargetInfo, CompsFilterMode) == 0x000000, "Member 'FBUC_DispLibDBC_EntityEffectTargetInfo::CompsFilterMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_EntityEffectTargetInfo, CompTags) == 0x000008, "Member 'FBUC_DispLibDBC_EntityEffectTargetInfo::CompTags' has a wrong offset!");

// SharpStruct b1-Managed.MaterialLayerParamGlobalConfigData
// 0x0018 (0x0018 - 0x0000)
struct FMaterialLayerParamGlobalConfigData final
{
public:
	EMaterialLayerParamEvaluateType               ParamEvaluateType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampMin;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AutoBlendOutSpeedCurve;                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialLayerParamGlobalConfigData) == 0x000008, "Wrong alignment on FMaterialLayerParamGlobalConfigData");
static_assert(sizeof(FMaterialLayerParamGlobalConfigData) == 0x000018, "Wrong size on FMaterialLayerParamGlobalConfigData");
static_assert(offsetof(FMaterialLayerParamGlobalConfigData, ParamEvaluateType) == 0x000000, "Member 'FMaterialLayerParamGlobalConfigData::ParamEvaluateType' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamGlobalConfigData, ClampMin) == 0x000004, "Member 'FMaterialLayerParamGlobalConfigData::ClampMin' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamGlobalConfigData, ClampMax) == 0x000008, "Member 'FMaterialLayerParamGlobalConfigData::ClampMax' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamGlobalConfigData, AutoBlendOutSpeedCurve) == 0x000010, "Member 'FMaterialLayerParamGlobalConfigData::AutoBlendOutSpeedCurve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCAdvProcessFLinearColor
// 0x0058 (0x0058 - 0x0000)
struct FBUC_DispLibUtil_DBCAdvProcessFLinearColor final
{
public:
	EDispLibDBCAdvProcessFLinearColorMode         Mode;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Value;                                             // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Range;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Loop : 1;                                          // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Period;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndStageDuration;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EndValue;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAdvProcessReleaseParameterControlMode ReleaseParameterControlMode;                       // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      Curve;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCAdvProcessFLinearColor");
static_assert(sizeof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor) == 0x000058, "Wrong size on FBUC_DispLibUtil_DBCAdvProcessFLinearColor");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, Mode) == 0x000000, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::Mode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, Value) == 0x000004, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, Range) == 0x000018, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::Range' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, Period) == 0x00002C, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::Period' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, Duration) == 0x000030, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, EndStageDuration) == 0x000034, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::EndStageDuration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, EndValue) == 0x000038, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::EndValue' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, ReleaseParameterControlMode) == 0x000048, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::ReleaseParameterControlMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, Scale) == 0x00004C, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::Scale' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColor, Curve) == 0x000050, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColor::Curve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCAdvProcessFLinearColorParam
// 0x0060 (0x0060 - 0x0000)
struct FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCAdvProcessFLinearColor ProcessValue;                                      // 0x0008(0x0058)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam) == 0x000060, "Wrong size on FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam, ProcessValue) == 0x000008, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam::ProcessValue' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_ModifyNiagaraTargetInfo
// 0x0020 (0x0020 - 0x0000)
struct FBUC_DispLibDBC_ModifyNiagaraTargetInfo final
{
public:
	EDispLibDBCNiagaraFilterMode                  FilterMode;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TargetString;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TargetSystem;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_ModifyNiagaraTargetInfo) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_ModifyNiagaraTargetInfo");
static_assert(sizeof(FBUC_DispLibDBC_ModifyNiagaraTargetInfo) == 0x000020, "Wrong size on FBUC_DispLibDBC_ModifyNiagaraTargetInfo");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraTargetInfo, FilterMode) == 0x000000, "Member 'FBUC_DispLibDBC_ModifyNiagaraTargetInfo::FilterMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraTargetInfo, TargetString) == 0x000008, "Member 'FBUC_DispLibDBC_ModifyNiagaraTargetInfo::TargetString' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraTargetInfo, TargetSystem) == 0x000018, "Member 'FBUC_DispLibDBC_ModifyNiagaraTargetInfo::TargetSystem' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam
// 0x0058 (0x0058 - 0x0000)
struct FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam final
{
public:
	EMaterialParameterAssociation                 Association;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialFunctionInterface*             LayerFunction;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCAdvProcessScalar   ProcessValue;                                      // 0x0018(0x0040)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam) == 0x000058, "Wrong size on FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam, Association) == 0x000000, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam::Association' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam, LayerFunction) == 0x000008, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam::LayerFunction' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam, ParamName) == 0x000010, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam, ProcessValue) == 0x000018, "Member 'FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam::ProcessValue' has a wrong offset!");

// SharpStruct b1-Managed.FGSBuffInfo
// 0x0008 (0x0008 - 0x0000)
struct FFGSBuffInfo final
{
public:
	int32                                         BuffID;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffDuration;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSBuffInfo) == 0x000004, "Wrong alignment on FFGSBuffInfo");
static_assert(sizeof(FFGSBuffInfo) == 0x000008, "Wrong size on FFGSBuffInfo");
static_assert(offsetof(FFGSBuffInfo, BuffID) == 0x000000, "Member 'FFGSBuffInfo::BuffID' has a wrong offset!");
static_assert(offsetof(FFGSBuffInfo, BuffDuration) == 0x000004, "Member 'FFGSBuffInfo::BuffDuration' has a wrong offset!");

// SharpStruct b1-Managed.MFEffect
// 0x0040 (0x0040 - 0x0000)
struct FMFEffect final
{
public:
	EMFOverlapEventType                           OverlapEventType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFGSBuffInfo>                   BuffList;                                          // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillEffectList;                                   // 0x0018(0x0010)(Edit, NativeAccessSpecifierPublic)
	int32                                         SpecificFlags;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayNote;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMFEffect) == 0x000008, "Wrong alignment on FMFEffect");
static_assert(sizeof(FMFEffect) == 0x000040, "Wrong size on FMFEffect");
static_assert(offsetof(FMFEffect, OverlapEventType) == 0x000000, "Member 'FMFEffect::OverlapEventType' has a wrong offset!");
static_assert(offsetof(FMFEffect, BuffList) == 0x000008, "Member 'FMFEffect::BuffList' has a wrong offset!");
static_assert(offsetof(FMFEffect, SkillEffectList) == 0x000018, "Member 'FMFEffect::SkillEffectList' has a wrong offset!");
static_assert(offsetof(FMFEffect, SpecificFlags) == 0x000028, "Member 'FMFEffect::SpecificFlags' has a wrong offset!");
static_assert(offsetof(FMFEffect, DisplayNote) == 0x000030, "Member 'FMFEffect::DisplayNote' has a wrong offset!");

// SharpStruct b1-Managed.MFEvent
// 0x0030 (0x0030 - 0x0000)
struct FMFEvent final
{
public:
	uint8                                         bIgnoreTypeFilter : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetTeamFilter;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetTypeFilter;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMFEffect>                      MFEffectList;                                      // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FString                                 DisplayNote;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMFEvent) == 0x000008, "Wrong alignment on FMFEvent");
static_assert(sizeof(FMFEvent) == 0x000030, "Wrong size on FMFEvent");
static_assert(offsetof(FMFEvent, TargetTeamFilter) == 0x000004, "Member 'FMFEvent::TargetTeamFilter' has a wrong offset!");
static_assert(offsetof(FMFEvent, TargetTypeFilter) == 0x000008, "Member 'FMFEvent::TargetTypeFilter' has a wrong offset!");
static_assert(offsetof(FMFEvent, MFEffectList) == 0x000010, "Member 'FMFEvent::MFEffectList' has a wrong offset!");
static_assert(offsetof(FMFEvent, DisplayNote) == 0x000020, "Member 'FMFEvent::DisplayNote' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_MaterialEffectTargetInfo
// 0x0050 (0x0050 - 0x0000)
struct FBUC_DispLibDBC_MaterialEffectTargetInfo final
{
public:
	EDispLibDBCCompsFilterMode                    CompsFilterMode;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CompTags;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EDispLibDBCMaterialsFilterMode                MatsFilterMode;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MatSlotNames;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 MatIndexes;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      MatShaders;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_MaterialEffectTargetInfo) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_MaterialEffectTargetInfo");
static_assert(sizeof(FBUC_DispLibDBC_MaterialEffectTargetInfo) == 0x000050, "Wrong size on FBUC_DispLibDBC_MaterialEffectTargetInfo");
static_assert(offsetof(FBUC_DispLibDBC_MaterialEffectTargetInfo, CompsFilterMode) == 0x000000, "Member 'FBUC_DispLibDBC_MaterialEffectTargetInfo::CompsFilterMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_MaterialEffectTargetInfo, CompTags) == 0x000008, "Member 'FBUC_DispLibDBC_MaterialEffectTargetInfo::CompTags' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_MaterialEffectTargetInfo, MatsFilterMode) == 0x000018, "Member 'FBUC_DispLibDBC_MaterialEffectTargetInfo::MatsFilterMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_MaterialEffectTargetInfo, MatSlotNames) == 0x000020, "Member 'FBUC_DispLibDBC_MaterialEffectTargetInfo::MatSlotNames' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_MaterialEffectTargetInfo, MatIndexes) == 0x000030, "Member 'FBUC_DispLibDBC_MaterialEffectTargetInfo::MatIndexes' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_MaterialEffectTargetInfo, MatShaders) == 0x000040, "Member 'FBUC_DispLibDBC_MaterialEffectTargetInfo::MatShaders' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam
// 0x0070 (0x0070 - 0x0000)
struct FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam final
{
public:
	EMaterialParameterAssociation                 Association;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialFunctionInterface*             LayerFunction;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCAdvProcessFLinearColor ProcessValue;                                      // 0x0018(0x0058)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam) == 0x000070, "Wrong size on FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam, Association) == 0x000000, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam::Association' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam, LayerFunction) == 0x000008, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam::LayerFunction' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam, ParamName) == 0x000010, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam, ProcessValue) == 0x000018, "Member 'FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam::ProcessValue' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_CustomEvent
// 0x0020 (0x0020 - 0x0000)
struct FBUC_DispLibDBC_CustomEvent final
{
public:
	EDispLibDBCCustomEventTriggerMode             TriggerMode;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTime;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDispLibDBCCustomEventDataAssetBase*    ParametersDataAssets;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_CustomEvent) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_CustomEvent");
static_assert(sizeof(FBUC_DispLibDBC_CustomEvent) == 0x000020, "Wrong size on FBUC_DispLibDBC_CustomEvent");
static_assert(offsetof(FBUC_DispLibDBC_CustomEvent, TriggerMode) == 0x000000, "Member 'FBUC_DispLibDBC_CustomEvent::TriggerMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_CustomEvent, DelayTime) == 0x000004, "Member 'FBUC_DispLibDBC_CustomEvent::DelayTime' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_CustomEvent, EndMode) == 0x000008, "Member 'FBUC_DispLibDBC_CustomEvent::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_CustomEvent, Duration) == 0x00000C, "Member 'FBUC_DispLibDBC_CustomEvent::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_CustomEvent, DelayTimeAfterStop) == 0x000010, "Member 'FBUC_DispLibDBC_CustomEvent::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_CustomEvent, ParametersDataAssets) == 0x000018, "Member 'FBUC_DispLibDBC_CustomEvent::ParametersDataAssets' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_PlayCascade
// 0x0078 (0x0078 - 0x0000)
struct FBUC_DispLibDBC_PlayCascade final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        Template;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttachedTarget : 1;                                // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedTargetSocketName;                          // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslucentSortPriority;                           // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_PlayCascade) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_PlayCascade");
static_assert(sizeof(FBUC_DispLibDBC_PlayCascade) == 0x000078, "Wrong size on FBUC_DispLibDBC_PlayCascade");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, Delay) == 0x000000, "Member 'FBUC_DispLibDBC_PlayCascade::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, EndMode) == 0x000004, "Member 'FBUC_DispLibDBC_PlayCascade::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, Duration) == 0x000008, "Member 'FBUC_DispLibDBC_PlayCascade::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, Template) == 0x000010, "Member 'FBUC_DispLibDBC_PlayCascade::Template' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, AttachedTargetSocketName) == 0x00001C, "Member 'FBUC_DispLibDBC_PlayCascade::AttachedTargetSocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, LocationOffset) == 0x000028, "Member 'FBUC_DispLibDBC_PlayCascade::LocationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, RotationOffset) == 0x000040, "Member 'FBUC_DispLibDBC_PlayCascade::RotationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, Scale) == 0x000058, "Member 'FBUC_DispLibDBC_PlayCascade::Scale' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCascade, TranslucentSortPriority) == 0x000070, "Member 'FBUC_DispLibDBC_PlayCascade::TranslucentSortPriority' has a wrong offset!");

// SharpStruct b1-Managed.ComboCondition
// 0x0058 (0x0058 - 0x0000)
struct FComboCondition final
{
public:
	EComboConditionType                           ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUUnitState                                 UnitState;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUSimpleState                               SimpleState;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUAttrFloat                                 AttrFloatType;                                     // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareValue;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TalentID;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       ComparePotentialEnergyOperation;                   // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PotentialEnergyLevel;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareChargeOperation;                            // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChargeLevel;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareCeilingHeightOperation;                     // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CeilingHeight;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStanceType_Combo                             StanceType;                                        // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SkillIdList;                                       // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
	EBGUMoveMode                                  MoveMode;                                          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ConditionIdentity;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComboCondition) == 0x000008, "Wrong alignment on FComboCondition");
static_assert(sizeof(FComboCondition) == 0x000058, "Wrong size on FComboCondition");
static_assert(offsetof(FComboCondition, ConditionType) == 0x000000, "Member 'FComboCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FComboCondition, UnitState) == 0x000001, "Member 'FComboCondition::UnitState' has a wrong offset!");
static_assert(offsetof(FComboCondition, SimpleState) == 0x000002, "Member 'FComboCondition::SimpleState' has a wrong offset!");
static_assert(offsetof(FComboCondition, AttrFloatType) == 0x000003, "Member 'FComboCondition::AttrFloatType' has a wrong offset!");
static_assert(offsetof(FComboCondition, CompareOperation) == 0x000004, "Member 'FComboCondition::CompareOperation' has a wrong offset!");
static_assert(offsetof(FComboCondition, CompareValue) == 0x000008, "Member 'FComboCondition::CompareValue' has a wrong offset!");
static_assert(offsetof(FComboCondition, BuffID) == 0x00000C, "Member 'FComboCondition::BuffID' has a wrong offset!");
static_assert(offsetof(FComboCondition, TalentID) == 0x000010, "Member 'FComboCondition::TalentID' has a wrong offset!");
static_assert(offsetof(FComboCondition, ComparePotentialEnergyOperation) == 0x000014, "Member 'FComboCondition::ComparePotentialEnergyOperation' has a wrong offset!");
static_assert(offsetof(FComboCondition, PotentialEnergyLevel) == 0x000018, "Member 'FComboCondition::PotentialEnergyLevel' has a wrong offset!");
static_assert(offsetof(FComboCondition, CompareChargeOperation) == 0x00001C, "Member 'FComboCondition::CompareChargeOperation' has a wrong offset!");
static_assert(offsetof(FComboCondition, ChargeLevel) == 0x000020, "Member 'FComboCondition::ChargeLevel' has a wrong offset!");
static_assert(offsetof(FComboCondition, CompareCeilingHeightOperation) == 0x000024, "Member 'FComboCondition::CompareCeilingHeightOperation' has a wrong offset!");
static_assert(offsetof(FComboCondition, CeilingHeight) == 0x000028, "Member 'FComboCondition::CeilingHeight' has a wrong offset!");
static_assert(offsetof(FComboCondition, StanceType) == 0x00002C, "Member 'FComboCondition::StanceType' has a wrong offset!");
static_assert(offsetof(FComboCondition, SkillIdList) == 0x000030, "Member 'FComboCondition::SkillIdList' has a wrong offset!");
static_assert(offsetof(FComboCondition, MoveMode) == 0x000040, "Member 'FComboCondition::MoveMode' has a wrong offset!");
static_assert(offsetof(FComboCondition, ConditionIdentity) == 0x000048, "Member 'FComboCondition::ConditionIdentity' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_SkillCoolDown
// 0x0004 (0x0004 - 0x0000)
struct FDetectCondition_SkillCoolDown final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_SkillCoolDown) == 0x000004, "Wrong alignment on FDetectCondition_SkillCoolDown");
static_assert(sizeof(FDetectCondition_SkillCoolDown) == 0x000004, "Wrong size on FDetectCondition_SkillCoolDown");
static_assert(offsetof(FDetectCondition_SkillCoolDown, SkillID) == 0x000000, "Member 'FDetectCondition_SkillCoolDown::SkillID' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_WEFMPermanentWind
// 0x0080 (0x0080 - 0x0000)
struct FBUC_DispLibDBC_WEFMPermanentWind final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketLocalOffset;                                 // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityThreshold;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseIntensity;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleVelocityIntensity;                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceDamplingRate;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCWindMotorMode                      WindMotorMode;                                     // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAxisMode                           RangeAxis;                                         // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RangeAxisLocalRotation;                            // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMask;                                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAxisMode                           VelocityDir;                                       // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VelocityDirLocalRotation;                          // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleSecondVelocity;                               // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_WEFMPermanentWind) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_WEFMPermanentWind");
static_assert(sizeof(FBUC_DispLibDBC_WEFMPermanentWind) == 0x000080, "Wrong size on FBUC_DispLibDBC_WEFMPermanentWind");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, EventName) == 0x000000, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::EventName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, SocketName) == 0x000008, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::SocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, SocketLocalOffset) == 0x000010, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::SocketLocalOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, Radius) == 0x000028, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::Radius' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, VelocityThreshold) == 0x00002C, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::VelocityThreshold' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, BaseIntensity) == 0x000030, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::BaseIntensity' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, ScaleVelocityIntensity) == 0x000034, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::ScaleVelocityIntensity' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, DistanceDamplingRate) == 0x000038, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::DistanceDamplingRate' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, WindMotorMode) == 0x00003C, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::WindMotorMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, RangeAxis) == 0x00003D, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::RangeAxis' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, RangeAxisLocalRotation) == 0x000040, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::RangeAxisLocalRotation' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, RangeMask) == 0x000058, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::RangeMask' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, VelocityDir) == 0x00005C, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::VelocityDir' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, VelocityDirLocalRotation) == 0x000060, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::VelocityDirLocalRotation' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMPermanentWind, ScaleSecondVelocity) == 0x000078, "Member 'FBUC_DispLibDBC_WEFMPermanentWind::ScaleSecondVelocity' has a wrong offset!");

// SharpStruct b1-Managed.FollowPatrolConfig
// 0x0008 (0x0008 - 0x0000)
struct FFollowPatrolConfig final
{
public:
	class ACharacter*                             FollowTarget;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFollowPatrolConfig) == 0x000008, "Wrong alignment on FFollowPatrolConfig");
static_assert(sizeof(FFollowPatrolConfig) == 0x000008, "Wrong size on FFollowPatrolConfig");
static_assert(offsetof(FFollowPatrolConfig, FollowTarget) == 0x000000, "Member 'FFollowPatrolConfig::FollowTarget' has a wrong offset!");

// SharpStruct b1-Managed.AiConversationFact
// 0x0030 (0x0030 - 0x0000)
struct FAiConversationFact final
{
public:
	class FString                                 KeyName;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAiConversationFactType                       FactType;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultValue_Int;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DefaultValue_Bool : 1;                             // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultValue_Str;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAiConversationFact) == 0x000008, "Wrong alignment on FAiConversationFact");
static_assert(sizeof(FAiConversationFact) == 0x000030, "Wrong size on FAiConversationFact");
static_assert(offsetof(FAiConversationFact, KeyName) == 0x000000, "Member 'FAiConversationFact::KeyName' has a wrong offset!");
static_assert(offsetof(FAiConversationFact, FactType) == 0x000010, "Member 'FAiConversationFact::FactType' has a wrong offset!");
static_assert(offsetof(FAiConversationFact, DefaultValue_Int) == 0x000014, "Member 'FAiConversationFact::DefaultValue_Int' has a wrong offset!");
static_assert(offsetof(FAiConversationFact, DefaultValue_Str) == 0x000020, "Member 'FAiConversationFact::DefaultValue_Str' has a wrong offset!");

// SharpStruct b1-Managed.MovieRelationInfo
// 0x0030 (0x0030 - 0x0000)
struct FMovieRelationInfo final
{
public:
	EMovieRelationType                            MovieRelationType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActorGuid;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieRelationInfo) == 0x000008, "Wrong alignment on FMovieRelationInfo");
static_assert(sizeof(FMovieRelationInfo) == 0x000030, "Wrong size on FMovieRelationInfo");
static_assert(offsetof(FMovieRelationInfo, MovieRelationType) == 0x000000, "Member 'FMovieRelationInfo::MovieRelationType' has a wrong offset!");
static_assert(offsetof(FMovieRelationInfo, ActorGuid) == 0x000008, "Member 'FMovieRelationInfo::ActorGuid' has a wrong offset!");
static_assert(offsetof(FMovieRelationInfo, Location) == 0x000018, "Member 'FMovieRelationInfo::Location' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCPCurveScalarParam
// 0x0030 (0x0030 - 0x0000)
struct FBUC_DispLibUtil_DBCPCurveScalarParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       PCurve;                                            // 0x0008(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCPCurveScalarParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCPCurveScalarParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCPCurveScalarParam) == 0x000030, "Wrong size on FBUC_DispLibUtil_DBCPCurveScalarParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalarParam, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_DBCPCurveScalarParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalarParam, PCurve) == 0x000008, "Member 'FBUC_DispLibUtil_DBCPCurveScalarParam::PCurve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_WEFMWind
// 0x0158 (0x0158 - 0x0000)
struct FBUC_DispLibDBC_WEFMWind final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SocketLocalOffset;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerProbability;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBUC_DispLibUtil_DBCAdvProcessScalar   Radius;                                            // 0x0040(0x0040)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityThreshold;                                 // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBUC_DispLibUtil_DBCAdvProcessScalar   BaseIntensity;                                     // 0x0088(0x0040)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleVelocityIntensity;                            // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceDamplingRate;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCWindMotorMode                      WindMotorMode;                                     // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAxisMode                           RangeAxis;                                         // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RangeAxisLocalRotation;                            // 0x00D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMask;                                         // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAxisMode                           VelocityDir;                                       // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VelocityDirLocalRotation;                          // 0x00F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCAdvProcessScalar   ScaleSecondVelocity;                               // 0x0110(0x0040)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_WEFMWind) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_WEFMWind");
static_assert(sizeof(FBUC_DispLibDBC_WEFMWind) == 0x000158, "Wrong size on FBUC_DispLibDBC_WEFMWind");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, EventName) == 0x000000, "Member 'FBUC_DispLibDBC_WEFMWind::EventName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, SocketName) == 0x000008, "Member 'FBUC_DispLibDBC_WEFMWind::SocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, Delay) == 0x000010, "Member 'FBUC_DispLibDBC_WEFMWind::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, EndMode) == 0x000014, "Member 'FBUC_DispLibDBC_WEFMWind::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, Duration) == 0x000018, "Member 'FBUC_DispLibDBC_WEFMWind::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, SocketLocalOffset) == 0x000020, "Member 'FBUC_DispLibDBC_WEFMWind::SocketLocalOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, TriggerProbability) == 0x000038, "Member 'FBUC_DispLibDBC_WEFMWind::TriggerProbability' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, Radius) == 0x000040, "Member 'FBUC_DispLibDBC_WEFMWind::Radius' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, VelocityThreshold) == 0x000080, "Member 'FBUC_DispLibDBC_WEFMWind::VelocityThreshold' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, BaseIntensity) == 0x000088, "Member 'FBUC_DispLibDBC_WEFMWind::BaseIntensity' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, ScaleVelocityIntensity) == 0x0000C8, "Member 'FBUC_DispLibDBC_WEFMWind::ScaleVelocityIntensity' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, DistanceDamplingRate) == 0x0000CC, "Member 'FBUC_DispLibDBC_WEFMWind::DistanceDamplingRate' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, WindMotorMode) == 0x0000D0, "Member 'FBUC_DispLibDBC_WEFMWind::WindMotorMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, RangeAxis) == 0x0000D1, "Member 'FBUC_DispLibDBC_WEFMWind::RangeAxis' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, RangeAxisLocalRotation) == 0x0000D8, "Member 'FBUC_DispLibDBC_WEFMWind::RangeAxisLocalRotation' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, RangeMask) == 0x0000F0, "Member 'FBUC_DispLibDBC_WEFMWind::RangeMask' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, VelocityDir) == 0x0000F4, "Member 'FBUC_DispLibDBC_WEFMWind::VelocityDir' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, VelocityDirLocalRotation) == 0x0000F8, "Member 'FBUC_DispLibDBC_WEFMWind::VelocityDirLocalRotation' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, ScaleSecondVelocity) == 0x000110, "Member 'FBUC_DispLibDBC_WEFMWind::ScaleSecondVelocity' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_WEFMWind, PausePriority) == 0x000150, "Member 'FBUC_DispLibDBC_WEFMWind::PausePriority' has a wrong offset!");

// SharpStruct b1-Managed.AutoTestPlayerConditionConfig
// 0x0010 (0x0010 - 0x0000)
struct FAutoTestPlayerConditionConfig final
{
public:
	EGSAutoTestPlayerCastConditionType            ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUUnitState                                 UnitState;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUAttrFloat                                 AttrFloatType;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InverseCondition : 1;                              // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FAutoTestPlayerConditionConfig) == 0x000004, "Wrong alignment on FAutoTestPlayerConditionConfig");
static_assert(sizeof(FAutoTestPlayerConditionConfig) == 0x000010, "Wrong size on FAutoTestPlayerConditionConfig");
static_assert(offsetof(FAutoTestPlayerConditionConfig, ConditionType) == 0x000000, "Member 'FAutoTestPlayerConditionConfig::ConditionType' has a wrong offset!");
static_assert(offsetof(FAutoTestPlayerConditionConfig, UnitState) == 0x000001, "Member 'FAutoTestPlayerConditionConfig::UnitState' has a wrong offset!");
static_assert(offsetof(FAutoTestPlayerConditionConfig, AttrFloatType) == 0x000002, "Member 'FAutoTestPlayerConditionConfig::AttrFloatType' has a wrong offset!");
static_assert(offsetof(FAutoTestPlayerConditionConfig, CompareOperation) == 0x000003, "Member 'FAutoTestPlayerConditionConfig::CompareOperation' has a wrong offset!");
static_assert(offsetof(FAutoTestPlayerConditionConfig, FloatValue) == 0x000004, "Member 'FAutoTestPlayerConditionConfig::FloatValue' has a wrong offset!");
static_assert(offsetof(FAutoTestPlayerConditionConfig, IntValue) == 0x000008, "Member 'FAutoTestPlayerConditionConfig::IntValue' has a wrong offset!");

// SharpStruct b1-Managed.AutoTestPlayerCastSkillConditionGroup
// 0x0020 (0x0020 - 0x0000)
struct FAutoTestPlayerCastSkillConditionGroup final
{
public:
	class FString                                 Describe;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAutoTestPlayerConditionConfig> ConditionConfigs;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoTestPlayerCastSkillConditionGroup) == 0x000008, "Wrong alignment on FAutoTestPlayerCastSkillConditionGroup");
static_assert(sizeof(FAutoTestPlayerCastSkillConditionGroup) == 0x000020, "Wrong size on FAutoTestPlayerCastSkillConditionGroup");
static_assert(offsetof(FAutoTestPlayerCastSkillConditionGroup, Describe) == 0x000000, "Member 'FAutoTestPlayerCastSkillConditionGroup::Describe' has a wrong offset!");
static_assert(offsetof(FAutoTestPlayerCastSkillConditionGroup, ConditionConfigs) == 0x000010, "Member 'FAutoTestPlayerCastSkillConditionGroup::ConditionConfigs' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCPCurveScalarMatLayerParam
// 0x0040 (0x0040 - 0x0000)
struct FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam final
{
public:
	EMaterialParameterAssociation                 Association;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialFunctionInterface*             LayerFunction;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveScalar       PCurve;                                            // 0x0018(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam) == 0x000040, "Wrong size on FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam, Association) == 0x000000, "Member 'FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam::Association' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam, LayerFunction) == 0x000008, "Member 'FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam::LayerFunction' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam, ParamName) == 0x000010, "Member 'FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam, PCurve) == 0x000018, "Member 'FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam::PCurve' has a wrong offset!");

// SharpStruct b1-Managed.FGSCellPatitionInsatnceConfig
// 0x0028 (0x0028 - 0x0000)
struct FFGSCellPatitionInsatnceConfig final
{
public:
	struct FVector2D                              WorldCellPatitionSize;                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldCellPatitionBias;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellXCount;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CellYCount;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSCellPatitionInsatnceConfig) == 0x000008, "Wrong alignment on FFGSCellPatitionInsatnceConfig");
static_assert(sizeof(FFGSCellPatitionInsatnceConfig) == 0x000028, "Wrong size on FFGSCellPatitionInsatnceConfig");
static_assert(offsetof(FFGSCellPatitionInsatnceConfig, WorldCellPatitionSize) == 0x000000, "Member 'FFGSCellPatitionInsatnceConfig::WorldCellPatitionSize' has a wrong offset!");
static_assert(offsetof(FFGSCellPatitionInsatnceConfig, WorldCellPatitionBias) == 0x000010, "Member 'FFGSCellPatitionInsatnceConfig::WorldCellPatitionBias' has a wrong offset!");
static_assert(offsetof(FFGSCellPatitionInsatnceConfig, CellXCount) == 0x000020, "Member 'FFGSCellPatitionInsatnceConfig::CellXCount' has a wrong offset!");
static_assert(offsetof(FFGSCellPatitionInsatnceConfig, CellYCount) == 0x000024, "Member 'FFGSCellPatitionInsatnceConfig::CellYCount' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_Heat
// 0x0060 (0x0060 - 0x0000)
struct FBUC_DispLibDBC_Heat final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketLocalOffset;                                 // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketLocalRotation;                               // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerProbability;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinIntensity;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIntensity;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceDamplingRate;                              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAxisMode                           RangeAxis;                                         // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangeMask;                                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_Heat) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_Heat");
static_assert(sizeof(FBUC_DispLibDBC_Heat) == 0x000060, "Wrong size on FBUC_DispLibDBC_Heat");
static_assert(offsetof(FBUC_DispLibDBC_Heat, EventName) == 0x000000, "Member 'FBUC_DispLibDBC_Heat::EventName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, SocketName) == 0x000008, "Member 'FBUC_DispLibDBC_Heat::SocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, SocketLocalOffset) == 0x000010, "Member 'FBUC_DispLibDBC_Heat::SocketLocalOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, SocketLocalRotation) == 0x000028, "Member 'FBUC_DispLibDBC_Heat::SocketLocalRotation' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, Radius) == 0x000040, "Member 'FBUC_DispLibDBC_Heat::Radius' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, TriggerProbability) == 0x000044, "Member 'FBUC_DispLibDBC_Heat::TriggerProbability' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, MinIntensity) == 0x000048, "Member 'FBUC_DispLibDBC_Heat::MinIntensity' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, MaxIntensity) == 0x00004C, "Member 'FBUC_DispLibDBC_Heat::MaxIntensity' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, DistanceDamplingRate) == 0x000050, "Member 'FBUC_DispLibDBC_Heat::DistanceDamplingRate' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, RangeAxis) == 0x000054, "Member 'FBUC_DispLibDBC_Heat::RangeAxis' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, RangeMask) == 0x000058, "Member 'FBUC_DispLibDBC_Heat::RangeMask' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_Heat, PausePriority) == 0x00005C, "Member 'FBUC_DispLibDBC_Heat::PausePriority' has a wrong offset!");

// SharpStruct b1-Managed.WidgetConfig
// 0x0040 (0x0040 - 0x0000)
struct FWidgetConfig final
{
public:
	class FString                                 WidgetName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              Visibility;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseSize : 1;                                       // 0x0011(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UsePos : 1;                                        // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Pos;                                               // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetConfig) == 0x000008, "Wrong alignment on FWidgetConfig");
static_assert(sizeof(FWidgetConfig) == 0x000040, "Wrong size on FWidgetConfig");
static_assert(offsetof(FWidgetConfig, WidgetName) == 0x000000, "Member 'FWidgetConfig::WidgetName' has a wrong offset!");
static_assert(offsetof(FWidgetConfig, Visibility) == 0x000010, "Member 'FWidgetConfig::Visibility' has a wrong offset!");
static_assert(offsetof(FWidgetConfig, Size) == 0x000018, "Member 'FWidgetConfig::Size' has a wrong offset!");
static_assert(offsetof(FWidgetConfig, Pos) == 0x000030, "Member 'FWidgetConfig::Pos' has a wrong offset!");

// SharpStruct b1-Managed.TeleportParam_SimpleLevelIdAndTransform
// 0x0080 (0x0080 - 0x0000)
struct FTeleportParam_SimpleLevelIdAndTransform final
{
public:
	int32                                         LevelID;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TeleportTransform;                                 // 0x0010(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         LevelTravelUseDefaultPlayerStart : 1;              // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FTeleportParam_SimpleLevelIdAndTransform) == 0x000010, "Wrong alignment on FTeleportParam_SimpleLevelIdAndTransform");
static_assert(sizeof(FTeleportParam_SimpleLevelIdAndTransform) == 0x000080, "Wrong size on FTeleportParam_SimpleLevelIdAndTransform");
static_assert(offsetof(FTeleportParam_SimpleLevelIdAndTransform, LevelID) == 0x000000, "Member 'FTeleportParam_SimpleLevelIdAndTransform::LevelID' has a wrong offset!");
static_assert(offsetof(FTeleportParam_SimpleLevelIdAndTransform, TeleportTransform) == 0x000010, "Member 'FTeleportParam_SimpleLevelIdAndTransform::TeleportTransform' has a wrong offset!");

// SharpStruct b1-Managed.FNPCLeisureAnimInfo
// 0x0028 (0x0028 - 0x0000)
struct FFNPCLeisureAnimInfo final
{
public:
	class UAnimMontage*                           LeisureAnim;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnFightSkillID;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnFightSkillIDBack;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnFightSkillIDLeft;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnFightSkillIDRight;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFNPCLeisureAnimInfo) == 0x000008, "Wrong alignment on FFNPCLeisureAnimInfo");
static_assert(sizeof(FFNPCLeisureAnimInfo) == 0x000028, "Wrong size on FFNPCLeisureAnimInfo");
static_assert(offsetof(FFNPCLeisureAnimInfo, LeisureAnim) == 0x000000, "Member 'FFNPCLeisureAnimInfo::LeisureAnim' has a wrong offset!");
static_assert(offsetof(FFNPCLeisureAnimInfo, OnFightSkillID) == 0x000008, "Member 'FFNPCLeisureAnimInfo::OnFightSkillID' has a wrong offset!");
static_assert(offsetof(FFNPCLeisureAnimInfo, OnFightSkillIDBack) == 0x00000C, "Member 'FFNPCLeisureAnimInfo::OnFightSkillIDBack' has a wrong offset!");
static_assert(offsetof(FFNPCLeisureAnimInfo, OnFightSkillIDLeft) == 0x000010, "Member 'FFNPCLeisureAnimInfo::OnFightSkillIDLeft' has a wrong offset!");
static_assert(offsetof(FFNPCLeisureAnimInfo, OnFightSkillIDRight) == 0x000014, "Member 'FFNPCLeisureAnimInfo::OnFightSkillIDRight' has a wrong offset!");
static_assert(offsetof(FFNPCLeisureAnimInfo, Comment) == 0x000018, "Member 'FFNPCLeisureAnimInfo::Comment' has a wrong offset!");

// SharpStruct b1-Managed.LandCamShake
// 0x0018 (0x0018 - 0x0000)
struct FLandCamShake final
{
public:
	class UClass*                                 CameraShake_Mid;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 CameraShake_High;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 CameraShake_Dead;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandCamShake) == 0x000008, "Wrong alignment on FLandCamShake");
static_assert(sizeof(FLandCamShake) == 0x000018, "Wrong size on FLandCamShake");
static_assert(offsetof(FLandCamShake, CameraShake_Mid) == 0x000000, "Member 'FLandCamShake::CameraShake_Mid' has a wrong offset!");
static_assert(offsetof(FLandCamShake, CameraShake_High) == 0x000008, "Member 'FLandCamShake::CameraShake_High' has a wrong offset!");
static_assert(offsetof(FLandCamShake, CameraShake_Dead) == 0x000010, "Member 'FLandCamShake::CameraShake_Dead' has a wrong offset!");

// SharpStruct b1-Managed.OnePCurveColorPoint
// 0x0018 (0x0018 - 0x0000)
struct FOnePCurveColorPoint final
{
public:
	EDispLibDBCPCurvePointColorMode               Mode;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Value;                                             // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationToPrePoint;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnePCurveColorPoint) == 0x000004, "Wrong alignment on FOnePCurveColorPoint");
static_assert(sizeof(FOnePCurveColorPoint) == 0x000018, "Wrong size on FOnePCurveColorPoint");
static_assert(offsetof(FOnePCurveColorPoint, Mode) == 0x000000, "Member 'FOnePCurveColorPoint::Mode' has a wrong offset!");
static_assert(offsetof(FOnePCurveColorPoint, Value) == 0x000004, "Member 'FOnePCurveColorPoint::Value' has a wrong offset!");
static_assert(offsetof(FOnePCurveColorPoint, DurationToPrePoint) == 0x000014, "Member 'FOnePCurveColorPoint::DurationToPrePoint' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_PlayNiagara
// 0x0218 (0x0218 - 0x0000)
struct FBUC_DispLibDBC_PlayNiagara final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEffectDestroyTiming                DestroyTiming;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         Template;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideMeshCompTagName;                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttachedTarget : 1;                                // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedTargetSocketName;                          // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OffsetInLocalSpace : 1;                            // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SnapGround : 1;                                    // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibDBCSnapGroundRotationMode             SnapGroundRotationMode;                            // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DetachOnEndDispStageBegin : 1;                     // 0x0082(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_82_1 : 7;                                   // 0x0082(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         EnableShadow : 1;                                  // 0x0083(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	int32                                         TranslucentSortPriority;                           // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ForcePoolModeNone : 1;                             // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PausePriority;                                     // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCPauseMode                          PauseMode;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EndStagePriority;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForceChangeVisibleStateDEFPriority;                // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCNiagaraForceVisibleStateMode       ForceVisibleStateDefaultMode;                      // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MetaString;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibDBC_NiagaraEventScalabilitySettings ScalabilitySettings;                               // 0x00A8(0x0170)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_PlayNiagara) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_PlayNiagara");
static_assert(sizeof(FBUC_DispLibDBC_PlayNiagara) == 0x000218, "Wrong size on FBUC_DispLibDBC_PlayNiagara");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, Delay) == 0x000000, "Member 'FBUC_DispLibDBC_PlayNiagara::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, EndMode) == 0x000004, "Member 'FBUC_DispLibDBC_PlayNiagara::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, Duration) == 0x000008, "Member 'FBUC_DispLibDBC_PlayNiagara::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, DelayTimeAfterStop) == 0x00000C, "Member 'FBUC_DispLibDBC_PlayNiagara::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, DestroyTiming) == 0x000010, "Member 'FBUC_DispLibDBC_PlayNiagara::DestroyTiming' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, Template) == 0x000018, "Member 'FBUC_DispLibDBC_PlayNiagara::Template' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, OverrideMeshCompTagName) == 0x000020, "Member 'FBUC_DispLibDBC_PlayNiagara::OverrideMeshCompTagName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, AttachedTargetSocketName) == 0x00002C, "Member 'FBUC_DispLibDBC_PlayNiagara::AttachedTargetSocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, LocationOffset) == 0x000038, "Member 'FBUC_DispLibDBC_PlayNiagara::LocationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, RotationOffset) == 0x000050, "Member 'FBUC_DispLibDBC_PlayNiagara::RotationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, Scale) == 0x000068, "Member 'FBUC_DispLibDBC_PlayNiagara::Scale' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, SnapGroundRotationMode) == 0x000081, "Member 'FBUC_DispLibDBC_PlayNiagara::SnapGroundRotationMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, TranslucentSortPriority) == 0x000084, "Member 'FBUC_DispLibDBC_PlayNiagara::TranslucentSortPriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, PausePriority) == 0x00008C, "Member 'FBUC_DispLibDBC_PlayNiagara::PausePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, PauseMode) == 0x000090, "Member 'FBUC_DispLibDBC_PlayNiagara::PauseMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, EndStagePriority) == 0x000094, "Member 'FBUC_DispLibDBC_PlayNiagara::EndStagePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, ForceChangeVisibleStateDEFPriority) == 0x000098, "Member 'FBUC_DispLibDBC_PlayNiagara::ForceChangeVisibleStateDEFPriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, ForceVisibleStateDefaultMode) == 0x00009C, "Member 'FBUC_DispLibDBC_PlayNiagara::ForceVisibleStateDefaultMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, MetaString) == 0x0000A0, "Member 'FBUC_DispLibDBC_PlayNiagara::MetaString' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayNiagara, ScalabilitySettings) == 0x0000A8, "Member 'FBUC_DispLibDBC_PlayNiagara::ScalabilitySettings' has a wrong offset!");

// SharpStruct b1-Managed.ImageConfig
// 0x0130 (0x0130 - 0x0000)
struct FImageConfig final
{
public:
	struct FSlateBrush                            ImgBrush;                                          // 0x0000(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         UseImgSize : 1;                                    // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ImgSize;                                           // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseImgPos : 1;                                     // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ImgPos;                                            // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatSyncType                                  MatSyncType;                                       // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatSyncConfig>                 ExMatSyncList;                                     // 0x0108(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         UseAtlas : 1;                                      // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_118_1 : 7;                                  // 0x0118(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         SyncSprite : 1;                                    // 0x0119(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Sprite;                                            // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImageConfig) == 0x000010, "Wrong alignment on FImageConfig");
static_assert(sizeof(FImageConfig) == 0x000130, "Wrong size on FImageConfig");
static_assert(offsetof(FImageConfig, ImgBrush) == 0x000000, "Member 'FImageConfig::ImgBrush' has a wrong offset!");
static_assert(offsetof(FImageConfig, ImgSize) == 0x0000D8, "Member 'FImageConfig::ImgSize' has a wrong offset!");
static_assert(offsetof(FImageConfig, ImgPos) == 0x0000F0, "Member 'FImageConfig::ImgPos' has a wrong offset!");
static_assert(offsetof(FImageConfig, MatSyncType) == 0x000100, "Member 'FImageConfig::MatSyncType' has a wrong offset!");
static_assert(offsetof(FImageConfig, ExMatSyncList) == 0x000108, "Member 'FImageConfig::ExMatSyncList' has a wrong offset!");
static_assert(offsetof(FImageConfig, Sprite) == 0x000120, "Member 'FImageConfig::Sprite' has a wrong offset!");

// SharpStruct b1-Managed.ImageWidget
// 0x0140 (0x0140 - 0x0000)
struct FImageWidget final
{
public:
	class FString                                 WidgetName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FImageConfig                           ImgConfig;                                         // 0x0010(0x0130)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImageWidget) == 0x000010, "Wrong alignment on FImageWidget");
static_assert(sizeof(FImageWidget) == 0x000140, "Wrong size on FImageWidget");
static_assert(offsetof(FImageWidget, WidgetName) == 0x000000, "Member 'FImageWidget::WidgetName' has a wrong offset!");
static_assert(offsetof(FImageWidget, ImgConfig) == 0x000010, "Member 'FImageWidget::ImgConfig' has a wrong offset!");

// SharpStruct b1-Managed.FNPCIdleAnimInfo
// 0x0018 (0x0018 - 0x0000)
struct FFNPCIdleAnimInfo final
{
public:
	class UAnimSequence*                          IdleAnim;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFNPCIdleAnimInfo) == 0x000008, "Wrong alignment on FFNPCIdleAnimInfo");
static_assert(sizeof(FFNPCIdleAnimInfo) == 0x000018, "Wrong size on FFNPCIdleAnimInfo");
static_assert(offsetof(FFNPCIdleAnimInfo, IdleAnim) == 0x000000, "Member 'FFNPCIdleAnimInfo::IdleAnim' has a wrong offset!");
static_assert(offsetof(FFNPCIdleAnimInfo, Comment) == 0x000008, "Member 'FFNPCIdleAnimInfo::Comment' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndVectorCurve
// 0x0018 (0x0018 - 0x0000)
struct FBUC_DispLibUtil_NameAndVectorCurve final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_NameAndVectorCurve) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_NameAndVectorCurve");
static_assert(sizeof(FBUC_DispLibUtil_NameAndVectorCurve) == 0x000018, "Wrong size on FBUC_DispLibUtil_NameAndVectorCurve");
static_assert(offsetof(FBUC_DispLibUtil_NameAndVectorCurve, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndVectorCurve::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndVectorCurve, Value) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndVectorCurve::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndVectorCurve, Time) == 0x000010, "Member 'FBUC_DispLibUtil_NameAndVectorCurve::Time' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndScalar
// 0x0028 (0x0028 - 0x0000)
struct FBUC_DispLibUtil_NameAndScalar final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TimeStage;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_NameAndScalar) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_NameAndScalar");
static_assert(sizeof(FBUC_DispLibUtil_NameAndScalar) == 0x000028, "Wrong size on FBUC_DispLibUtil_NameAndScalar");
static_assert(offsetof(FBUC_DispLibUtil_NameAndScalar, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndScalar::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndScalar, Value) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndScalar::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndScalar, TimeStage) == 0x000010, "Member 'FBUC_DispLibUtil_NameAndScalar::TimeStage' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndLColor
// 0x0018 (0x0018 - 0x0000)
struct FBUC_DispLibUtil_NameAndLColor final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_NameAndLColor) == 0x000004, "Wrong alignment on FBUC_DispLibUtil_NameAndLColor");
static_assert(sizeof(FBUC_DispLibUtil_NameAndLColor) == 0x000018, "Wrong size on FBUC_DispLibUtil_NameAndLColor");
static_assert(offsetof(FBUC_DispLibUtil_NameAndLColor, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndLColor::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndLColor, Value) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndLColor::Value' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndScalarCurve
// 0x0018 (0x0018 - 0x0000)
struct FBUC_DispLibUtil_NameAndScalarCurve final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_NameAndScalarCurve) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_NameAndScalarCurve");
static_assert(sizeof(FBUC_DispLibUtil_NameAndScalarCurve) == 0x000018, "Wrong size on FBUC_DispLibUtil_NameAndScalarCurve");
static_assert(offsetof(FBUC_DispLibUtil_NameAndScalarCurve, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndScalarCurve::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndScalarCurve, Value) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndScalarCurve::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndScalarCurve, Time) == 0x000010, "Member 'FBUC_DispLibUtil_NameAndScalarCurve::Time' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndLColorCurve
// 0x0018 (0x0018 - 0x0000)
struct FBUC_DispLibUtil_NameAndLColorCurve final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_NameAndLColorCurve) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_NameAndLColorCurve");
static_assert(sizeof(FBUC_DispLibUtil_NameAndLColorCurve) == 0x000018, "Wrong size on FBUC_DispLibUtil_NameAndLColorCurve");
static_assert(offsetof(FBUC_DispLibUtil_NameAndLColorCurve, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndLColorCurve::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndLColorCurve, Value) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndLColorCurve::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndLColorCurve, Time) == 0x000010, "Member 'FBUC_DispLibUtil_NameAndLColorCurve::Time' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_PlayAdvanceNiagara
// 0x0370 (0x0370 - 0x0000)
struct FBUC_DispLibDBC_PlayAdvanceNiagara final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibAdvanceNiagaraDispLogicMode           DispLogicMode;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEffectDestroyTiming                DestroyTiming;                                     // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         Template;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideMeshCompTagName;                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttachedTarget : 1;                                // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibSocketSearchMode                      TargetSocketSearchMode;                            // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedTargetSocketName;                          // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OffsetInLocalSpace : 1;                            // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttachedTargetLocationOffset;                      // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachedTargetRotationOffset;                      // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         AttachedEmitter : 1;                               // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibSocketSearchMode                      EmitterSocketSearchMode;                           // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedEmitterSocketName;                         // 0x006C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttachedEmitterLocationOffset;                     // 0x0078(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachedEmitterRotationOffset;                     // 0x0090(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x00A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SnapGround : 1;                                    // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibDBCSnapGroundRotationMode             SnapGroundRotationMode;                            // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0xE];                                       // 0x00C2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               CustomV4Param;                                     // 0x00D0(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SetDBCTransformAsParam : 1;                        // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_F0_1 : 7;                                   // 0x00F0(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         SetSelfSKMeshParam : 1;                            // 0x00F1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_F1_1 : 7;                                   // 0x00F1(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         SetMinorSKMeshParam : 1;                           // 0x00F2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_F2_1 : 7;                                   // 0x00F2(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         UseExtraCustomParams : 1;                          // 0x00F3(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBUC_DispLibUtil_NameAndScalar> SetScalarParam;                                    // 0x00F8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndLColor> SetColorParam;                                     // 0x0108(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndScalarCurve> SetCurveScalarParam;                               // 0x0118(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndLColorCurve> SetCurveLColorParam;                               // 0x0128(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndVectorCurve> SetCurveV3Param;                                   // 0x0138(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         DetachOnEndDispStageBegin : 1;                     // 0x0148(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EDispLibAttachConstraintMode                  AttachConstraintMode;                              // 0x0149(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A[0x6];                                      // 0x014A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AttachConstraintValue;                             // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableShadow : 1;                                  // 0x0160(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_160_1 : 7;                                  // 0x0160(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         EnableVolumetricTranslucentShadow : 1;             // 0x0161(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_162[0x2];                                      // 0x0162(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TranslucentSortPriority;                           // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DeactiveAtSpawn : 1;                               // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_168_1 : 7;                                  // 0x0168(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         ForcePoolModeNone : 1;                             // 0x0169(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_16A[0x2];                                      // 0x016A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PausePriority;                                     // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCPauseMode                          PauseMode;                                         // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EndStagePriority;                                  // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForceChangeVisibleStateDEFPriority;                // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCNiagaraForceVisibleStateMode       ForceVisibleStateDefaultMode;                      // 0x017C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBUC_DispLibUtil_ForceVisibleStateCustomMode> ForceVisibleStateCustomMode;                       // 0x0180(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   MetaString;                                        // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibDBC_NiagaraEventScalabilitySettings ScalabilitySettings;                               // 0x0198(0x0170)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibDBC_NiagaraEventMergedSettings MergedSettings;                                    // 0x0308(0x0068)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_PlayAdvanceNiagara) == 0x000010, "Wrong alignment on FBUC_DispLibDBC_PlayAdvanceNiagara");
static_assert(sizeof(FBUC_DispLibDBC_PlayAdvanceNiagara) == 0x000370, "Wrong size on FBUC_DispLibDBC_PlayAdvanceNiagara");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, Delay) == 0x000000, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, EndMode) == 0x000004, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, Duration) == 0x000008, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, DelayTimeAfterStop) == 0x00000C, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, DispLogicMode) == 0x000010, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::DispLogicMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, DestroyTiming) == 0x000011, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::DestroyTiming' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, Template) == 0x000018, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::Template' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, OverrideMeshCompTagName) == 0x000020, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::OverrideMeshCompTagName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, TargetSocketSearchMode) == 0x000029, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::TargetSocketSearchMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, AttachedTargetSocketName) == 0x00002C, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::AttachedTargetSocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, AttachedTargetLocationOffset) == 0x000038, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::AttachedTargetLocationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, AttachedTargetRotationOffset) == 0x000050, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::AttachedTargetRotationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, EmitterSocketSearchMode) == 0x000069, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::EmitterSocketSearchMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, AttachedEmitterSocketName) == 0x00006C, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::AttachedEmitterSocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, AttachedEmitterLocationOffset) == 0x000078, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::AttachedEmitterLocationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, AttachedEmitterRotationOffset) == 0x000090, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::AttachedEmitterRotationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, Scale) == 0x0000A8, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::Scale' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, SnapGroundRotationMode) == 0x0000C1, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::SnapGroundRotationMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, CustomV4Param) == 0x0000D0, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::CustomV4Param' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, SetScalarParam) == 0x0000F8, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::SetScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, SetColorParam) == 0x000108, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::SetColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, SetCurveScalarParam) == 0x000118, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::SetCurveScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, SetCurveLColorParam) == 0x000128, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::SetCurveLColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, SetCurveV3Param) == 0x000138, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::SetCurveV3Param' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, AttachConstraintMode) == 0x000149, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::AttachConstraintMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, AttachConstraintValue) == 0x000150, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::AttachConstraintValue' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, TranslucentSortPriority) == 0x000164, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::TranslucentSortPriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, PausePriority) == 0x00016C, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::PausePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, PauseMode) == 0x000170, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::PauseMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, EndStagePriority) == 0x000174, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::EndStagePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, ForceChangeVisibleStateDEFPriority) == 0x000178, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::ForceChangeVisibleStateDEFPriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, ForceVisibleStateDefaultMode) == 0x00017C, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::ForceVisibleStateDefaultMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, ForceVisibleStateCustomMode) == 0x000180, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::ForceVisibleStateCustomMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, MetaString) == 0x000190, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::MetaString' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, ScalabilitySettings) == 0x000198, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::ScalabilitySettings' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAdvanceNiagara, MergedSettings) == 0x000308, "Member 'FBUC_DispLibDBC_PlayAdvanceNiagara::MergedSettings' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_PlayArtFresnel
// 0x0090 (0x0090 - 0x0000)
struct FBUC_DispLibDBC_PlayArtFresnel final
{
public:
	struct FBUC_DispLibDBC_MaterialEffectTargetInfo FilterMode;                                        // 0x0000(0x0050)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBUC_DispLibUnitArtFresnelDataAsset*    CustomUAFDataAsset;                                // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideTime;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideSimpleProgrammedCurve;                     // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFadeInTime;                                // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCommonTime;                                // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideFadeOutTime;                               // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideProgrammedPowerMax;                        // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideOnePeriodTime;                             // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideLoop;                                      // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_PlayArtFresnel) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_PlayArtFresnel");
static_assert(sizeof(FBUC_DispLibDBC_PlayArtFresnel) == 0x000090, "Wrong size on FBUC_DispLibDBC_PlayArtFresnel");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, FilterMode) == 0x000000, "Member 'FBUC_DispLibDBC_PlayArtFresnel::FilterMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, Delay) == 0x000050, "Member 'FBUC_DispLibDBC_PlayArtFresnel::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, CustomUAFDataAsset) == 0x000058, "Member 'FBUC_DispLibDBC_PlayArtFresnel::CustomUAFDataAsset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, Priority) == 0x000060, "Member 'FBUC_DispLibDBC_PlayArtFresnel::Priority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, EndMode) == 0x000064, "Member 'FBUC_DispLibDBC_PlayArtFresnel::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, OverrideTime) == 0x000068, "Member 'FBUC_DispLibDBC_PlayArtFresnel::OverrideTime' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, OverrideSimpleProgrammedCurve) == 0x00006C, "Member 'FBUC_DispLibDBC_PlayArtFresnel::OverrideSimpleProgrammedCurve' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, OverrideFadeInTime) == 0x000070, "Member 'FBUC_DispLibDBC_PlayArtFresnel::OverrideFadeInTime' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, OverrideCommonTime) == 0x000074, "Member 'FBUC_DispLibDBC_PlayArtFresnel::OverrideCommonTime' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, OverrideFadeOutTime) == 0x000078, "Member 'FBUC_DispLibDBC_PlayArtFresnel::OverrideFadeOutTime' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, OverrideProgrammedPowerMax) == 0x00007C, "Member 'FBUC_DispLibDBC_PlayArtFresnel::OverrideProgrammedPowerMax' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, OverrideOnePeriodTime) == 0x000080, "Member 'FBUC_DispLibDBC_PlayArtFresnel::OverrideOnePeriodTime' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, OverrideLoop) == 0x000084, "Member 'FBUC_DispLibDBC_PlayArtFresnel::OverrideLoop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayArtFresnel, PausePriority) == 0x000088, "Member 'FBUC_DispLibDBC_PlayArtFresnel::PausePriority' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_PlayCameraShake
// 0x0060 (0x0060 - 0x0000)
struct FBUC_DispLibDBC_PlayCameraShake final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CameraShake;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Override_Oscillation_Duration;                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ForceApply : 1;                                    // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBUC_DispLibUtil_DBCPCurveScalar       CustomScaleCurve;                                  // 0x0018(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseDistanceDamping : 1;                            // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_40_1 : 7;                                   // 0x0040(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         AttachedTarget : 1;                                // 0x0041(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedTargetSocketName;                          // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CamShakeScaleByDistCurve;                          // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_PlayCameraShake) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_PlayCameraShake");
static_assert(sizeof(FBUC_DispLibDBC_PlayCameraShake) == 0x000060, "Wrong size on FBUC_DispLibDBC_PlayCameraShake");
static_assert(offsetof(FBUC_DispLibDBC_PlayCameraShake, Delay) == 0x000000, "Member 'FBUC_DispLibDBC_PlayCameraShake::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCameraShake, CameraShake) == 0x000008, "Member 'FBUC_DispLibDBC_PlayCameraShake::CameraShake' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCameraShake, Override_Oscillation_Duration) == 0x000010, "Member 'FBUC_DispLibDBC_PlayCameraShake::Override_Oscillation_Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCameraShake, CustomScaleCurve) == 0x000018, "Member 'FBUC_DispLibDBC_PlayCameraShake::CustomScaleCurve' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCameraShake, AttachedTargetSocketName) == 0x000044, "Member 'FBUC_DispLibDBC_PlayCameraShake::AttachedTargetSocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCameraShake, CamShakeScaleByDistCurve) == 0x000050, "Member 'FBUC_DispLibDBC_PlayCameraShake::CamShakeScaleByDistCurve' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCameraShake, MaxDistance) == 0x000058, "Member 'FBUC_DispLibDBC_PlayCameraShake::MaxDistance' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayCameraShake, PausePriority) == 0x00005C, "Member 'FBUC_DispLibDBC_PlayCameraShake::PausePriority' has a wrong offset!");

// SharpStruct b1-Managed.EffectInstReq
// 0x00D0 (0x00D0 - 0x0000)
struct FEffectInstReq final
{
public:
	int32                                         ObjectId;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0008(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HitPointNormalDir;                                 // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHitActionDir                                 HitActionDir;                                      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SweepCheckBegin;                                   // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SweepCheckEnd;                                     // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDiretionRealDir;                                // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBoneName;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComp;                                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Attacker;                                          // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AudioID_HitChr;                                    // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FXWeight_HitChr;                                   // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerSkillId;                                    // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFromBullet : 1;                                   // 0x00AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LaserStiffDir;                                     // 0x00B0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         HitPartID;                                         // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectInstReq) == 0x000008, "Wrong alignment on FEffectInstReq");
static_assert(sizeof(FEffectInstReq) == 0x0000D0, "Wrong size on FEffectInstReq");
static_assert(offsetof(FEffectInstReq, ObjectId) == 0x000000, "Member 'FEffectInstReq::ObjectId' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, HitLocation) == 0x000008, "Member 'FEffectInstReq::HitLocation' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, HitPointNormalDir) == 0x000020, "Member 'FEffectInstReq::HitPointNormalDir' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, HitActionDir) == 0x000038, "Member 'FEffectInstReq::HitActionDir' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, SweepCheckBegin) == 0x000040, "Member 'FEffectInstReq::SweepCheckBegin' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, SweepCheckEnd) == 0x000058, "Member 'FEffectInstReq::SweepCheckEnd' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, HitDiretionRealDir) == 0x000070, "Member 'FEffectInstReq::HitDiretionRealDir' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, HitBoneName) == 0x000088, "Member 'FEffectInstReq::HitBoneName' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, HitComp) == 0x000090, "Member 'FEffectInstReq::HitComp' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, Attacker) == 0x000098, "Member 'FEffectInstReq::Attacker' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, AudioID_HitChr) == 0x0000A0, "Member 'FEffectInstReq::AudioID_HitChr' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, FXWeight_HitChr) == 0x0000A4, "Member 'FEffectInstReq::FXWeight_HitChr' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, TriggerSkillId) == 0x0000A8, "Member 'FEffectInstReq::TriggerSkillId' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, LaserStiffDir) == 0x0000B0, "Member 'FEffectInstReq::LaserStiffDir' has a wrong offset!");
static_assert(offsetof(FEffectInstReq, HitPartID) == 0x0000C8, "Member 'FEffectInstReq::HitPartID' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_PlayAudio
// 0x0048 (0x0048 - 0x0000)
struct FBUC_DispLibDBC_PlayAudio final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FollowActor : 1;                                   // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CompTag;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StopOnFollowActorDestroy : 1;                      // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkAudioEvent;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCAdvProcessScalarParam> RTPC;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_PlayAudio) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_PlayAudio");
static_assert(sizeof(FBUC_DispLibDBC_PlayAudio) == 0x000048, "Wrong size on FBUC_DispLibDBC_PlayAudio");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, Delay) == 0x000000, "Member 'FBUC_DispLibDBC_PlayAudio::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, EndMode) == 0x000004, "Member 'FBUC_DispLibDBC_PlayAudio::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, Duration) == 0x000008, "Member 'FBUC_DispLibDBC_PlayAudio::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, CompTag) == 0x000010, "Member 'FBUC_DispLibDBC_PlayAudio::CompTag' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, SocketName) == 0x000018, "Member 'FBUC_DispLibDBC_PlayAudio::SocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, AkAudioEvent) == 0x000028, "Member 'FBUC_DispLibDBC_PlayAudio::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, RTPC) == 0x000030, "Member 'FBUC_DispLibDBC_PlayAudio::RTPC' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, FadeOutTime) == 0x000040, "Member 'FBUC_DispLibDBC_PlayAudio::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_PlayAudio, PausePriority) == 0x000044, "Member 'FBUC_DispLibDBC_PlayAudio::PausePriority' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_SpawnSimpleActor
// 0x00A8 (0x00A8 - 0x0000)
struct FBUC_DispLibDBC_SpawnSimpleActor final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 Template;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttachedTarget : 1;                                // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedTargetSocketName;                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachedTargetLocationOffset;                      // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachedTargetRotationOffset;                      // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         AttachedEmitter : 1;                               // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedEmitterSocketName;                         // 0x005C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttachedEmitterLocationOffset;                     // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AttachedEmitterRotationOffset;                     // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         DetachOnEndDispStageBegin : 1;                     // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PausePriority;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndStagePriority;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_SpawnSimpleActor) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_SpawnSimpleActor");
static_assert(sizeof(FBUC_DispLibDBC_SpawnSimpleActor) == 0x0000A8, "Wrong size on FBUC_DispLibDBC_SpawnSimpleActor");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, Delay) == 0x000000, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, Template) == 0x000008, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::Template' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, EndMode) == 0x000010, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, Duration) == 0x000014, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, DelayTimeAfterStop) == 0x000018, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, AttachedTargetSocketName) == 0x000020, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::AttachedTargetSocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, AttachedTargetLocationOffset) == 0x000028, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::AttachedTargetLocationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, AttachedTargetRotationOffset) == 0x000040, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::AttachedTargetRotationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, AttachedEmitterSocketName) == 0x00005C, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::AttachedEmitterSocketName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, AttachedEmitterLocationOffset) == 0x000068, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::AttachedEmitterLocationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, AttachedEmitterRotationOffset) == 0x000080, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::AttachedEmitterRotationOffset' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, PausePriority) == 0x00009C, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::PausePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_SpawnSimpleActor, EndStagePriority) == 0x0000A0, "Member 'FBUC_DispLibDBC_SpawnSimpleActor::EndStagePriority' has a wrong offset!");

// SharpStruct b1-Managed.FGSwitchBulletMovableInfo
// 0x0000 (0x0000 - 0x0000)
struct FFGSwitchBulletMovableInfo final
{
};
static_assert(alignof(FFGSwitchBulletMovableInfo) == 0x000001, "Wrong alignment on FFGSwitchBulletMovableInfo");
static_assert(sizeof(FFGSwitchBulletMovableInfo) == 0x000001, "Wrong size on FFGSwitchBulletMovableInfo");

// SharpStruct b1-Managed.BUC_DispLibDBC_ScenePhysicalInteractor
// 0x0048 (0x0048 - 0x0000)
struct FBUC_DispLibDBC_ScenePhysicalInteractor final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EffectSize;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneInteractorType                          EffectType;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DestructibleTriggerLevel;                          // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Intensity;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      QueryObjectTypes;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DestructibleDamage;                                // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_ScenePhysicalInteractor) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_ScenePhysicalInteractor");
static_assert(sizeof(FBUC_DispLibDBC_ScenePhysicalInteractor) == 0x000048, "Wrong size on FBUC_DispLibDBC_ScenePhysicalInteractor");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, Delay) == 0x000000, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, EffectSize) == 0x000008, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::EffectSize' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, EffectType) == 0x000020, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::EffectType' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, DestructibleTriggerLevel) == 0x000021, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::DestructibleTriggerLevel' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, Intensity) == 0x000024, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::Intensity' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, Duration) == 0x000028, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, QueryObjectTypes) == 0x000030, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::QueryObjectTypes' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, DestructibleDamage) == 0x000040, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::DestructibleDamage' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ScenePhysicalInteractor, PausePriority) == 0x000044, "Member 'FBUC_DispLibDBC_ScenePhysicalInteractor::PausePriority' has a wrong offset!");

// SharpStruct b1-Managed.LevelSequenceConfig
// 0x00B0 (0x00B0 - 0x0000)
struct FLevelSequenceConfig final
{
public:
	TSoftObjectPtr<class ULevelSequence>          Sequence;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CameraStartTransform;                              // 0x0030(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   CameraTag;                                         // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RailTag;                                           // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CraneTag;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelSequenceConfig) == 0x000010, "Wrong alignment on FLevelSequenceConfig");
static_assert(sizeof(FLevelSequenceConfig) == 0x0000B0, "Wrong size on FLevelSequenceConfig");
static_assert(offsetof(FLevelSequenceConfig, Sequence) == 0x000000, "Member 'FLevelSequenceConfig::Sequence' has a wrong offset!");
static_assert(offsetof(FLevelSequenceConfig, CameraStartTransform) == 0x000030, "Member 'FLevelSequenceConfig::CameraStartTransform' has a wrong offset!");
static_assert(offsetof(FLevelSequenceConfig, CameraTag) == 0x000090, "Member 'FLevelSequenceConfig::CameraTag' has a wrong offset!");
static_assert(offsetof(FLevelSequenceConfig, RailTag) == 0x000098, "Member 'FLevelSequenceConfig::RailTag' has a wrong offset!");
static_assert(offsetof(FLevelSequenceConfig, CraneTag) == 0x0000A0, "Member 'FLevelSequenceConfig::CraneTag' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_PCurve_NameAndScalar
// 0x0028 (0x0028 - 0x0000)
struct FBUC_DispLibUtil_PCurve_NameAndScalar final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TimeStage;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_PCurve_NameAndScalar) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_PCurve_NameAndScalar");
static_assert(sizeof(FBUC_DispLibUtil_PCurve_NameAndScalar) == 0x000028, "Wrong size on FBUC_DispLibUtil_PCurve_NameAndScalar");
static_assert(offsetof(FBUC_DispLibUtil_PCurve_NameAndScalar, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_PCurve_NameAndScalar::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_PCurve_NameAndScalar, Value) == 0x000008, "Member 'FBUC_DispLibUtil_PCurve_NameAndScalar::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_PCurve_NameAndScalar, TimeStage) == 0x000010, "Member 'FBUC_DispLibUtil_PCurve_NameAndScalar::TimeStage' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_PCurve_NameAndLColor
// 0x0030 (0x0030 - 0x0000)
struct FBUC_DispLibUtil_PCurve_NameAndLColor final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TimeStage;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_PCurve_NameAndLColor) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_PCurve_NameAndLColor");
static_assert(sizeof(FBUC_DispLibUtil_PCurve_NameAndLColor) == 0x000030, "Wrong size on FBUC_DispLibUtil_PCurve_NameAndLColor");
static_assert(offsetof(FBUC_DispLibUtil_PCurve_NameAndLColor, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_PCurve_NameAndLColor::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_PCurve_NameAndLColor, Value) == 0x000008, "Member 'FBUC_DispLibUtil_PCurve_NameAndLColor::Value' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_PCurve_NameAndLColor, TimeStage) == 0x000018, "Member 'FBUC_DispLibUtil_PCurve_NameAndLColor::TimeStage' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_ChangeMaterial
// 0x0118 (0x0118 - 0x0000)
struct FBUC_DispLibDBC_ChangeMaterial final
{
public:
	struct FBUC_DispLibDBC_MaterialEffectTargetInfo FilterMode;                                        // 0x0000(0x0050)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Template;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibMaterialParamsInheritMode             InheriParamsMode;                                  // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           InheritScalarParam;                                // 0x0070(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           InheritFLinearColorParam;                          // 0x0080(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           InheritTextureParam;                               // 0x0090(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndScalar> SetScalarParam;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndLColor> SetColorParam;                                     // 0x00B0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndScalarCurve> SetCurveScalarParam;                               // 0x00C0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndLColorCurve> SetCurveLColorParam;                               // 0x00D0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndVectorCurve> SetCurveV3Param;                                   // 0x00E0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_PCurve_NameAndScalar> EndStage_SetPCurveScalarParam;                     // 0x00F0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_PCurve_NameAndLColor> EndStage_SetPCurveLColorParam;                     // 0x0100(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndStagePriority;                                  // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_ChangeMaterial) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_ChangeMaterial");
static_assert(sizeof(FBUC_DispLibDBC_ChangeMaterial) == 0x000118, "Wrong size on FBUC_DispLibDBC_ChangeMaterial");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, FilterMode) == 0x000000, "Member 'FBUC_DispLibDBC_ChangeMaterial::FilterMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, Delay) == 0x000050, "Member 'FBUC_DispLibDBC_ChangeMaterial::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, EndMode) == 0x000054, "Member 'FBUC_DispLibDBC_ChangeMaterial::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, Duration) == 0x000058, "Member 'FBUC_DispLibDBC_ChangeMaterial::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, DelayTimeAfterStop) == 0x00005C, "Member 'FBUC_DispLibDBC_ChangeMaterial::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, Template) == 0x000060, "Member 'FBUC_DispLibDBC_ChangeMaterial::Template' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, InheriParamsMode) == 0x000068, "Member 'FBUC_DispLibDBC_ChangeMaterial::InheriParamsMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, InheritScalarParam) == 0x000070, "Member 'FBUC_DispLibDBC_ChangeMaterial::InheritScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, InheritFLinearColorParam) == 0x000080, "Member 'FBUC_DispLibDBC_ChangeMaterial::InheritFLinearColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, InheritTextureParam) == 0x000090, "Member 'FBUC_DispLibDBC_ChangeMaterial::InheritTextureParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, SetScalarParam) == 0x0000A0, "Member 'FBUC_DispLibDBC_ChangeMaterial::SetScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, SetColorParam) == 0x0000B0, "Member 'FBUC_DispLibDBC_ChangeMaterial::SetColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, SetCurveScalarParam) == 0x0000C0, "Member 'FBUC_DispLibDBC_ChangeMaterial::SetCurveScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, SetCurveLColorParam) == 0x0000D0, "Member 'FBUC_DispLibDBC_ChangeMaterial::SetCurveLColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, SetCurveV3Param) == 0x0000E0, "Member 'FBUC_DispLibDBC_ChangeMaterial::SetCurveV3Param' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, EndStage_SetPCurveScalarParam) == 0x0000F0, "Member 'FBUC_DispLibDBC_ChangeMaterial::EndStage_SetPCurveScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, EndStage_SetPCurveLColorParam) == 0x000100, "Member 'FBUC_DispLibDBC_ChangeMaterial::EndStage_SetPCurveLColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, PausePriority) == 0x000110, "Member 'FBUC_DispLibDBC_ChangeMaterial::PausePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ChangeMaterial, EndStagePriority) == 0x000114, "Member 'FBUC_DispLibDBC_ChangeMaterial::EndStagePriority' has a wrong offset!");

// SharpStruct b1-Managed.SkillSequencePlaySettings
// 0x0058 (0x0058 - 0x0000)
struct FSkillSequencePlaySettings final
{
public:
	TArray<class ULevelSequence*>                 SequenceList;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     SequenceCameraTransforms;                          // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESkillCameraRotationType                      RotationType;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAttachToUnit : 1;                                 // 0x0021(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DummyMeshAttachSocketName;                         // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtraCameraForSeqBindTag;                          // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachedCameraFOV;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportAngleDeg;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InCameraBlendTime;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InCameraBlendFactor;                               // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableCameraAutoBlendOut : 1;                     // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_44_1 : 7;                                   // 0x0044(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bStopWhenMontageInterrupted : 1;                   // 0x0045(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutCameraBlendTime;                                // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutCameraBlendFactor;                              // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDuration;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillSequencePlaySettings) == 0x000008, "Wrong alignment on FSkillSequencePlaySettings");
static_assert(sizeof(FSkillSequencePlaySettings) == 0x000058, "Wrong size on FSkillSequencePlaySettings");
static_assert(offsetof(FSkillSequencePlaySettings, SequenceList) == 0x000000, "Member 'FSkillSequencePlaySettings::SequenceList' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, SequenceCameraTransforms) == 0x000010, "Member 'FSkillSequencePlaySettings::SequenceCameraTransforms' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, RotationType) == 0x000020, "Member 'FSkillSequencePlaySettings::RotationType' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, DummyMeshAttachSocketName) == 0x000024, "Member 'FSkillSequencePlaySettings::DummyMeshAttachSocketName' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, ExtraCameraForSeqBindTag) == 0x00002C, "Member 'FSkillSequencePlaySettings::ExtraCameraForSeqBindTag' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, AttachedCameraFOV) == 0x000034, "Member 'FSkillSequencePlaySettings::AttachedCameraFOV' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, TeleportAngleDeg) == 0x000038, "Member 'FSkillSequencePlaySettings::TeleportAngleDeg' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, InCameraBlendTime) == 0x00003C, "Member 'FSkillSequencePlaySettings::InCameraBlendTime' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, InCameraBlendFactor) == 0x000040, "Member 'FSkillSequencePlaySettings::InCameraBlendFactor' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, OutCameraBlendTime) == 0x000048, "Member 'FSkillSequencePlaySettings::OutCameraBlendTime' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, OutCameraBlendFactor) == 0x00004C, "Member 'FSkillSequencePlaySettings::OutCameraBlendFactor' has a wrong offset!");
static_assert(offsetof(FSkillSequencePlaySettings, TotalDuration) == 0x000050, "Member 'FSkillSequencePlaySettings::TotalDuration' has a wrong offset!");

// SharpStruct b1-Managed.SeqLevelRelationInfo
// 0x0020 (0x0020 - 0x0000)
struct FSeqLevelRelationInfo final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 RelationMovie;                                     // 0x0010(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeqLevelRelationInfo) == 0x000008, "Wrong alignment on FSeqLevelRelationInfo");
static_assert(sizeof(FSeqLevelRelationInfo) == 0x000020, "Wrong size on FSeqLevelRelationInfo");
static_assert(offsetof(FSeqLevelRelationInfo, LevelName) == 0x000000, "Member 'FSeqLevelRelationInfo::LevelName' has a wrong offset!");
static_assert(offsetof(FSeqLevelRelationInfo, RelationMovie) == 0x000010, "Member 'FSeqLevelRelationInfo::RelationMovie' has a wrong offset!");

// SharpStruct b1-Managed.TamerFamilyMatchChildInfo
// 0x001C (0x001C - 0x0000)
struct FTamerFamilyMatchChildInfo final
{
public:
	EChildActorFilterType                         Filter;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESocketMatchTamerType                         MatchSocketType;                                   // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResID;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NickName;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTamerFamilyMatchChildInfo) == 0x000004, "Wrong alignment on FTamerFamilyMatchChildInfo");
static_assert(sizeof(FTamerFamilyMatchChildInfo) == 0x00001C, "Wrong size on FTamerFamilyMatchChildInfo");
static_assert(offsetof(FTamerFamilyMatchChildInfo, Filter) == 0x000000, "Member 'FTamerFamilyMatchChildInfo::Filter' has a wrong offset!");
static_assert(offsetof(FTamerFamilyMatchChildInfo, MatchSocketType) == 0x000001, "Member 'FTamerFamilyMatchChildInfo::MatchSocketType' has a wrong offset!");
static_assert(offsetof(FTamerFamilyMatchChildInfo, SocketName) == 0x000004, "Member 'FTamerFamilyMatchChildInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FTamerFamilyMatchChildInfo, ResID) == 0x00000C, "Member 'FTamerFamilyMatchChildInfo::ResID' has a wrong offset!");
static_assert(offsetof(FTamerFamilyMatchChildInfo, NickName) == 0x000010, "Member 'FTamerFamilyMatchChildInfo::NickName' has a wrong offset!");
static_assert(offsetof(FTamerFamilyMatchChildInfo, BuffID) == 0x000018, "Member 'FTamerFamilyMatchChildInfo::BuffID' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition
// 0x0098 (0x0098 - 0x0000)
struct FDetectCondition final
{
public:
	EDetectedElementType                          DetectedElementType;                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUSimpleState                               SimpleState;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUUnitState                                 UnitState;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BuffID;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUAttrFloat                                 AttrFloatType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareValue;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbnormalStateType                            AbnormalStateType;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUFSMStateName                              FsmState;                                          // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillID;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       DistanceCompareOperations;                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceCompareValue;                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CustomFsmState;                                    // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompareValueInt;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationBaseDirection                        BaseDirection;                                     // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinYawAngle;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawAngle;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillIdList;                                       // 0x0038(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FTamerFamilyMatchChildInfo             MatchInfo;                                         // 0x0048(0x001C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResID;                                             // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuccessRate;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AliveUnitNum;                                      // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLayer;                                         // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperationType                    OperationType;                                     // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GamePlusCount;                                     // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneItemSurfaceType                         SurfaceType;                                       // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerLeisureOverTime;                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition) == 0x000008, "Wrong alignment on FDetectCondition");
static_assert(sizeof(FDetectCondition) == 0x000098, "Wrong size on FDetectCondition");
static_assert(offsetof(FDetectCondition, DetectedElementType) == 0x000000, "Member 'FDetectCondition::DetectedElementType' has a wrong offset!");
static_assert(offsetof(FDetectCondition, SimpleState) == 0x000001, "Member 'FDetectCondition::SimpleState' has a wrong offset!");
static_assert(offsetof(FDetectCondition, UnitState) == 0x000002, "Member 'FDetectCondition::UnitState' has a wrong offset!");
static_assert(offsetof(FDetectCondition, BuffID) == 0x000004, "Member 'FDetectCondition::BuffID' has a wrong offset!");
static_assert(offsetof(FDetectCondition, AttrFloatType) == 0x000008, "Member 'FDetectCondition::AttrFloatType' has a wrong offset!");
static_assert(offsetof(FDetectCondition, CompareOperation) == 0x000009, "Member 'FDetectCondition::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition, CompareValue) == 0x00000C, "Member 'FDetectCondition::CompareValue' has a wrong offset!");
static_assert(offsetof(FDetectCondition, AbnormalStateType) == 0x000010, "Member 'FDetectCondition::AbnormalStateType' has a wrong offset!");
static_assert(offsetof(FDetectCondition, FsmState) == 0x000011, "Member 'FDetectCondition::FsmState' has a wrong offset!");
static_assert(offsetof(FDetectCondition, SkillID) == 0x000014, "Member 'FDetectCondition::SkillID' has a wrong offset!");
static_assert(offsetof(FDetectCondition, DistanceCompareOperations) == 0x000018, "Member 'FDetectCondition::DistanceCompareOperations' has a wrong offset!");
static_assert(offsetof(FDetectCondition, DistanceCompareValue) == 0x00001C, "Member 'FDetectCondition::DistanceCompareValue' has a wrong offset!");
static_assert(offsetof(FDetectCondition, CustomFsmState) == 0x000020, "Member 'FDetectCondition::CustomFsmState' has a wrong offset!");
static_assert(offsetof(FDetectCondition, CompareValueInt) == 0x000028, "Member 'FDetectCondition::CompareValueInt' has a wrong offset!");
static_assert(offsetof(FDetectCondition, BaseDirection) == 0x00002C, "Member 'FDetectCondition::BaseDirection' has a wrong offset!");
static_assert(offsetof(FDetectCondition, MinYawAngle) == 0x000030, "Member 'FDetectCondition::MinYawAngle' has a wrong offset!");
static_assert(offsetof(FDetectCondition, MaxYawAngle) == 0x000034, "Member 'FDetectCondition::MaxYawAngle' has a wrong offset!");
static_assert(offsetof(FDetectCondition, SkillIdList) == 0x000038, "Member 'FDetectCondition::SkillIdList' has a wrong offset!");
static_assert(offsetof(FDetectCondition, MatchInfo) == 0x000048, "Member 'FDetectCondition::MatchInfo' has a wrong offset!");
static_assert(offsetof(FDetectCondition, ResID) == 0x000064, "Member 'FDetectCondition::ResID' has a wrong offset!");
static_assert(offsetof(FDetectCondition, SuccessRate) == 0x000068, "Member 'FDetectCondition::SuccessRate' has a wrong offset!");
static_assert(offsetof(FDetectCondition, AliveUnitNum) == 0x00006C, "Member 'FDetectCondition::AliveUnitNum' has a wrong offset!");
static_assert(offsetof(FDetectCondition, BuffLayer) == 0x000070, "Member 'FDetectCondition::BuffLayer' has a wrong offset!");
static_assert(offsetof(FDetectCondition, OperationType) == 0x000074, "Member 'FDetectCondition::OperationType' has a wrong offset!");
static_assert(offsetof(FDetectCondition, GamePlusCount) == 0x000078, "Member 'FDetectCondition::GamePlusCount' has a wrong offset!");
static_assert(offsetof(FDetectCondition, SurfaceType) == 0x00007C, "Member 'FDetectCondition::SurfaceType' has a wrong offset!");
static_assert(offsetof(FDetectCondition, PlayerLeisureOverTime) == 0x000080, "Member 'FDetectCondition::PlayerLeisureOverTime' has a wrong offset!");
static_assert(offsetof(FDetectCondition, Comment) == 0x000088, "Member 'FDetectCondition::Comment' has a wrong offset!");

// SharpStruct b1-Managed.TriggerAbnormalCondition
// 0x0020 (0x0020 - 0x0000)
struct FTriggerAbnormalCondition final
{
public:
	EDetectedUnitType                             UnitType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDetectCondition>               Conditions;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsReverseCondition : 1;                            // 0x0019(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FTriggerAbnormalCondition) == 0x000008, "Wrong alignment on FTriggerAbnormalCondition");
static_assert(sizeof(FTriggerAbnormalCondition) == 0x000020, "Wrong size on FTriggerAbnormalCondition");
static_assert(offsetof(FTriggerAbnormalCondition, UnitType) == 0x000000, "Member 'FTriggerAbnormalCondition::UnitType' has a wrong offset!");
static_assert(offsetof(FTriggerAbnormalCondition, Conditions) == 0x000008, "Member 'FTriggerAbnormalCondition::Conditions' has a wrong offset!");
static_assert(offsetof(FTriggerAbnormalCondition, ConditionalRelation) == 0x000018, "Member 'FTriggerAbnormalCondition::ConditionalRelation' has a wrong offset!");

// SharpStruct b1-Managed.AbnormalStateAccConfig
// 0x0030 (0x0030 - 0x0000)
struct FAbnormalStateAccConfig final
{
public:
	struct FTriggerAbnormalCondition              Condition;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbnormalStateType                            AbnormalStateType;                                 // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAccAbnormalValueType                         AccType;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbnormalStateAccConfig) == 0x000008, "Wrong alignment on FAbnormalStateAccConfig");
static_assert(sizeof(FAbnormalStateAccConfig) == 0x000030, "Wrong size on FAbnormalStateAccConfig");
static_assert(offsetof(FAbnormalStateAccConfig, Condition) == 0x000000, "Member 'FAbnormalStateAccConfig::Condition' has a wrong offset!");
static_assert(offsetof(FAbnormalStateAccConfig, AbnormalStateType) == 0x000020, "Member 'FAbnormalStateAccConfig::AbnormalStateType' has a wrong offset!");
static_assert(offsetof(FAbnormalStateAccConfig, Level) == 0x000024, "Member 'FAbnormalStateAccConfig::Level' has a wrong offset!");
static_assert(offsetof(FAbnormalStateAccConfig, AccType) == 0x000028, "Member 'FAbnormalStateAccConfig::AccType' has a wrong offset!");

// SharpStruct b1-Managed.EnvironmentAbnormalEffectConfig
// 0x0038 (0x0038 - 0x0000)
struct FEnvironmentAbnormalEffectConfig final
{
public:
	struct FAbnormalStateAccConfig                AbnormalStateConfig;                               // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableAutoRecover : 1;                           // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FEnvironmentAbnormalEffectConfig) == 0x000008, "Wrong alignment on FEnvironmentAbnormalEffectConfig");
static_assert(sizeof(FEnvironmentAbnormalEffectConfig) == 0x000038, "Wrong size on FEnvironmentAbnormalEffectConfig");
static_assert(offsetof(FEnvironmentAbnormalEffectConfig, AbnormalStateConfig) == 0x000000, "Member 'FEnvironmentAbnormalEffectConfig::AbnormalStateConfig' has a wrong offset!");

// SharpStruct b1-Managed.AutoMoveMonitorConfigItem
// 0x0020 (0x0020 - 0x0000)
struct FAutoMoveMonitorConfigItem final
{
public:
	class FString                                 AssetPath;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Desc;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoMoveMonitorConfigItem) == 0x000008, "Wrong alignment on FAutoMoveMonitorConfigItem");
static_assert(sizeof(FAutoMoveMonitorConfigItem) == 0x000020, "Wrong size on FAutoMoveMonitorConfigItem");
static_assert(offsetof(FAutoMoveMonitorConfigItem, AssetPath) == 0x000000, "Member 'FAutoMoveMonitorConfigItem::AssetPath' has a wrong offset!");
static_assert(offsetof(FAutoMoveMonitorConfigItem, Desc) == 0x000010, "Member 'FAutoMoveMonitorConfigItem::Desc' has a wrong offset!");

// SharpStruct b1-Managed.FreqConfig
// 0x0008 (0x0008 - 0x0000)
struct FFreqConfig final
{
public:
	float                                         Percent;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Freq;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFreqConfig) == 0x000004, "Wrong alignment on FFreqConfig");
static_assert(sizeof(FFreqConfig) == 0x000008, "Wrong size on FFreqConfig");
static_assert(offsetof(FFreqConfig, Percent) == 0x000000, "Member 'FFreqConfig::Percent' has a wrong offset!");
static_assert(offsetof(FFreqConfig, Freq) == 0x000004, "Member 'FFreqConfig::Freq' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCTexture
// 0x0010 (0x0010 - 0x0000)
struct FBUC_DispLibUtil_DBCTexture final
{
public:
	class UTexture*                               TextureValue;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCTexture) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCTexture");
static_assert(sizeof(FBUC_DispLibUtil_DBCTexture) == 0x000010, "Wrong size on FBUC_DispLibUtil_DBCTexture");
static_assert(offsetof(FBUC_DispLibUtil_DBCTexture, TextureValue) == 0x000000, "Member 'FBUC_DispLibUtil_DBCTexture::TextureValue' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCTexture, Duration) == 0x000008, "Member 'FBUC_DispLibUtil_DBCTexture::Duration' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCTextureMatLayerParam
// 0x0028 (0x0028 - 0x0000)
struct FBUC_DispLibUtil_DBCTextureMatLayerParam final
{
public:
	EMaterialParameterAssociation                 Association;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialFunctionInterface*             LayerFunction;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCTexture            TextureValue;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCTextureMatLayerParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCTextureMatLayerParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCTextureMatLayerParam) == 0x000028, "Wrong size on FBUC_DispLibUtil_DBCTextureMatLayerParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCTextureMatLayerParam, Association) == 0x000000, "Member 'FBUC_DispLibUtil_DBCTextureMatLayerParam::Association' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCTextureMatLayerParam, LayerFunction) == 0x000008, "Member 'FBUC_DispLibUtil_DBCTextureMatLayerParam::LayerFunction' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCTextureMatLayerParam, ParamName) == 0x000010, "Member 'FBUC_DispLibUtil_DBCTextureMatLayerParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCTextureMatLayerParam, TextureValue) == 0x000018, "Member 'FBUC_DispLibUtil_DBCTextureMatLayerParam::TextureValue' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCPCurveColor
// 0x0038 (0x0038 - 0x0000)
struct FBUC_DispLibUtil_DBCPCurveColor final
{
public:
	TArray<struct FOnePCurveColorPoint>           PointsList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Loop : 1;                                          // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOnePCurveColorPoint                   EndToPoint;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCAdvProcessReleaseParameterControlMode ReleaseParameterControlMode;                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCPCurveColor) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCPCurveColor");
static_assert(sizeof(FBUC_DispLibUtil_DBCPCurveColor) == 0x000038, "Wrong size on FBUC_DispLibUtil_DBCPCurveColor");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColor, PointsList) == 0x000000, "Member 'FBUC_DispLibUtil_DBCPCurveColor::PointsList' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColor, Duration) == 0x000014, "Member 'FBUC_DispLibUtil_DBCPCurveColor::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColor, EndToPoint) == 0x000018, "Member 'FBUC_DispLibUtil_DBCPCurveColor::EndToPoint' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColor, ReleaseParameterControlMode) == 0x000030, "Member 'FBUC_DispLibUtil_DBCPCurveColor::ReleaseParameterControlMode' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCPCurveColorMatLayerParam
// 0x0050 (0x0050 - 0x0000)
struct FBUC_DispLibUtil_DBCPCurveColorMatLayerParam final
{
public:
	EMaterialParameterAssociation                 Association;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialFunctionInterface*             LayerFunction;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveColor        PCurve;                                            // 0x0018(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCPCurveColorMatLayerParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCPCurveColorMatLayerParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCPCurveColorMatLayerParam) == 0x000050, "Wrong size on FBUC_DispLibUtil_DBCPCurveColorMatLayerParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColorMatLayerParam, Association) == 0x000000, "Member 'FBUC_DispLibUtil_DBCPCurveColorMatLayerParam::Association' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColorMatLayerParam, LayerFunction) == 0x000008, "Member 'FBUC_DispLibUtil_DBCPCurveColorMatLayerParam::LayerFunction' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColorMatLayerParam, ParamName) == 0x000010, "Member 'FBUC_DispLibUtil_DBCPCurveColorMatLayerParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColorMatLayerParam, PCurve) == 0x000018, "Member 'FBUC_DispLibUtil_DBCPCurveColorMatLayerParam::PCurve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_ModifyMaterial
// 0x0100 (0x0100 - 0x0000)
struct FBUC_DispLibDBC_ModifyMaterial final
{
public:
	struct FBUC_DispLibDBC_MaterialEffectTargetInfo FilterMode;                                        // 0x0000(0x0050)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Template;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibMaterialParamsInheritMode             InheriParamsMode;                                  // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           InheritScalarParam;                                // 0x0070(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           InheritFLinearColorParam;                          // 0x0080(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           InheritTextureParam;                               // 0x0090(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCAdvProcessScalarMatLayerParam> SetScalarParam;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCAdvProcessFLinearColorMatLayerParam> SetFLinearColorParam;                              // 0x00B0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCTextureMatLayerParam> SetTextureParam;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCPCurveScalarMatLayerParam> SetPCurveScalarParam;                              // 0x00D0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCPCurveColorMatLayerParam> SetPCurveFLinearColorParam;                        // 0x00E0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndStagePriority;                                  // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModMatPriority;                                    // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModMatEndStagePriority;                            // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_ModifyMaterial) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_ModifyMaterial");
static_assert(sizeof(FBUC_DispLibDBC_ModifyMaterial) == 0x000100, "Wrong size on FBUC_DispLibDBC_ModifyMaterial");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, FilterMode) == 0x000000, "Member 'FBUC_DispLibDBC_ModifyMaterial::FilterMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, Delay) == 0x000050, "Member 'FBUC_DispLibDBC_ModifyMaterial::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, EndMode) == 0x000054, "Member 'FBUC_DispLibDBC_ModifyMaterial::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, Duration) == 0x000058, "Member 'FBUC_DispLibDBC_ModifyMaterial::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, DelayTimeAfterStop) == 0x00005C, "Member 'FBUC_DispLibDBC_ModifyMaterial::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, Template) == 0x000060, "Member 'FBUC_DispLibDBC_ModifyMaterial::Template' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, InheriParamsMode) == 0x000068, "Member 'FBUC_DispLibDBC_ModifyMaterial::InheriParamsMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, InheritScalarParam) == 0x000070, "Member 'FBUC_DispLibDBC_ModifyMaterial::InheritScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, InheritFLinearColorParam) == 0x000080, "Member 'FBUC_DispLibDBC_ModifyMaterial::InheritFLinearColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, InheritTextureParam) == 0x000090, "Member 'FBUC_DispLibDBC_ModifyMaterial::InheritTextureParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, SetScalarParam) == 0x0000A0, "Member 'FBUC_DispLibDBC_ModifyMaterial::SetScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, SetFLinearColorParam) == 0x0000B0, "Member 'FBUC_DispLibDBC_ModifyMaterial::SetFLinearColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, SetTextureParam) == 0x0000C0, "Member 'FBUC_DispLibDBC_ModifyMaterial::SetTextureParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, SetPCurveScalarParam) == 0x0000D0, "Member 'FBUC_DispLibDBC_ModifyMaterial::SetPCurveScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, SetPCurveFLinearColorParam) == 0x0000E0, "Member 'FBUC_DispLibDBC_ModifyMaterial::SetPCurveFLinearColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, PausePriority) == 0x0000F0, "Member 'FBUC_DispLibDBC_ModifyMaterial::PausePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, EndStagePriority) == 0x0000F4, "Member 'FBUC_DispLibDBC_ModifyMaterial::EndStagePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, ModMatPriority) == 0x0000F8, "Member 'FBUC_DispLibDBC_ModifyMaterial::ModMatPriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterial, ModMatEndStagePriority) == 0x0000FC, "Member 'FBUC_DispLibDBC_ModifyMaterial::ModMatEndStagePriority' has a wrong offset!");

// SharpStruct b1-Managed.GsActorGuidReference
// 0x0038 (0x0038 - 0x0000)
struct FGsActorGuidReference final
{
public:
	TSoftObjectPtr<class AActor>                  ActorRef;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorGuid;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGsActorGuidReference) == 0x000008, "Wrong alignment on FGsActorGuidReference");
static_assert(sizeof(FGsActorGuidReference) == 0x000038, "Wrong size on FGsActorGuidReference");
static_assert(offsetof(FGsActorGuidReference, ActorRef) == 0x000000, "Member 'FGsActorGuidReference::ActorRef' has a wrong offset!");
static_assert(offsetof(FGsActorGuidReference, ActorGuid) == 0x000028, "Member 'FGsActorGuidReference::ActorGuid' has a wrong offset!");

// SharpStruct b1-Managed.FGSBuffTriggerConfig
// 0x0090 (0x0090 - 0x0000)
struct FFGSBuffTriggerConfig final
{
public:
	TArray<int32>                                 AddBuffIDList;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBuffControlCondition                         AddBuffCondition;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuffTarget                                   AddBuffTarget;                                     // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class ABUTamerActor>>   AddSceneTamer;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          AddSceneTamerRef;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemoveBuffIDList;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBuffControlCondition                         RemoveBuffCondition;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuffTarget                                   RemoveBuffTarget;                                  // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class ABUTamerActor>>   RemoveSceneTamer;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          RemoveSceneTamerRef;                               // 0x0060(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ABGUCharacterCS>> AddSceneUnit;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ABGUCharacterCS>> RemoveSceneUnit;                                   // 0x0080(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSBuffTriggerConfig) == 0x000008, "Wrong alignment on FFGSBuffTriggerConfig");
static_assert(sizeof(FFGSBuffTriggerConfig) == 0x000090, "Wrong size on FFGSBuffTriggerConfig");
static_assert(offsetof(FFGSBuffTriggerConfig, AddBuffIDList) == 0x000000, "Member 'FFGSBuffTriggerConfig::AddBuffIDList' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, AddBuffCondition) == 0x000010, "Member 'FFGSBuffTriggerConfig::AddBuffCondition' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, AddBuffTarget) == 0x000011, "Member 'FFGSBuffTriggerConfig::AddBuffTarget' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, AddSceneTamer) == 0x000018, "Member 'FFGSBuffTriggerConfig::AddSceneTamer' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, AddSceneTamerRef) == 0x000028, "Member 'FFGSBuffTriggerConfig::AddSceneTamerRef' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, RemoveBuffIDList) == 0x000038, "Member 'FFGSBuffTriggerConfig::RemoveBuffIDList' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, RemoveBuffCondition) == 0x000048, "Member 'FFGSBuffTriggerConfig::RemoveBuffCondition' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, RemoveBuffTarget) == 0x000049, "Member 'FFGSBuffTriggerConfig::RemoveBuffTarget' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, RemoveSceneTamer) == 0x000050, "Member 'FFGSBuffTriggerConfig::RemoveSceneTamer' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, RemoveSceneTamerRef) == 0x000060, "Member 'FFGSBuffTriggerConfig::RemoveSceneTamerRef' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, AddSceneUnit) == 0x000070, "Member 'FFGSBuffTriggerConfig::AddSceneUnit' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerConfig, RemoveSceneUnit) == 0x000080, "Member 'FFGSBuffTriggerConfig::RemoveSceneUnit' has a wrong offset!");

// SharpStruct b1-Managed.InputTipsList
// 0x0010 (0x0010 - 0x0000)
struct FInputTipsList final
{
public:
	TArray<struct FInputTipsOneCfg>               InputActionList;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputTipsList) == 0x000008, "Wrong alignment on FInputTipsList");
static_assert(sizeof(FInputTipsList) == 0x000010, "Wrong size on FInputTipsList");
static_assert(offsetof(FInputTipsList, InputActionList) == 0x000000, "Member 'FInputTipsList::InputActionList' has a wrong offset!");

// SharpStruct b1-Managed.InputTipsCfg
// 0x0060 (0x0060 - 0x0000)
struct FInputTipsCfg final
{
public:
	struct FInputTipsList                         AwalysShowInput;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EInputTipsType, struct FInputTipsList>   OptionShowInput;                                   // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputTipsCfg) == 0x000008, "Wrong alignment on FInputTipsCfg");
static_assert(sizeof(FInputTipsCfg) == 0x000060, "Wrong size on FInputTipsCfg");
static_assert(offsetof(FInputTipsCfg, AwalysShowInput) == 0x000000, "Member 'FInputTipsCfg::AwalysShowInput' has a wrong offset!");
static_assert(offsetof(FInputTipsCfg, OptionShowInput) == 0x000010, "Member 'FInputTipsCfg::OptionShowInput' has a wrong offset!");

// SharpStruct b1-Managed.GsSpiderNavPointLinkInfo
// 0x0008 (0x0008 - 0x0000)
struct FGsSpiderNavPointLinkInfo final
{
public:
	int32                                         LinkPointIndex;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cost;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGsSpiderNavPointLinkInfo) == 0x000004, "Wrong alignment on FGsSpiderNavPointLinkInfo");
static_assert(sizeof(FGsSpiderNavPointLinkInfo) == 0x000008, "Wrong size on FGsSpiderNavPointLinkInfo");
static_assert(offsetof(FGsSpiderNavPointLinkInfo, LinkPointIndex) == 0x000000, "Member 'FGsSpiderNavPointLinkInfo::LinkPointIndex' has a wrong offset!");
static_assert(offsetof(FGsSpiderNavPointLinkInfo, Cost) == 0x000004, "Member 'FGsSpiderNavPointLinkInfo::Cost' has a wrong offset!");

// SharpStruct b1-Managed.GsSpiderNavPointInfo
// 0x0050 (0x0050 - 0x0000)
struct FGsSpiderNavPointInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinkRadius;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinkAngle;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGsSpiderNavPointLinkInfo>      NavLinkPoints;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         IsGroundPoint : 1;                                 // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FGsSpiderNavPointInfo) == 0x000008, "Wrong alignment on FGsSpiderNavPointInfo");
static_assert(sizeof(FGsSpiderNavPointInfo) == 0x000050, "Wrong size on FGsSpiderNavPointInfo");
static_assert(offsetof(FGsSpiderNavPointInfo, Location) == 0x000000, "Member 'FGsSpiderNavPointInfo::Location' has a wrong offset!");
static_assert(offsetof(FGsSpiderNavPointInfo, Normal) == 0x000018, "Member 'FGsSpiderNavPointInfo::Normal' has a wrong offset!");
static_assert(offsetof(FGsSpiderNavPointInfo, LinkRadius) == 0x000030, "Member 'FGsSpiderNavPointInfo::LinkRadius' has a wrong offset!");
static_assert(offsetof(FGsSpiderNavPointInfo, LinkAngle) == 0x000034, "Member 'FGsSpiderNavPointInfo::LinkAngle' has a wrong offset!");
static_assert(offsetof(FGsSpiderNavPointInfo, NavLinkPoints) == 0x000038, "Member 'FGsSpiderNavPointInfo::NavLinkPoints' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_ModNiagara_NameAndBoolValue
// 0x0018 (0x0018 - 0x0000)
struct FBUC_DispLibUtil_ModNiagara_NameAndBoolValue final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value : 1;                                         // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_8_1 : 7;                                    // 0x0008(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         EndDispStageValue : 1;                             // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_9_1 : 7;                                    // 0x0009(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         AfterParamEventRealEndValue : 1;                   // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndStageDuration;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SetEveryFrame : 1;                                 // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FBUC_DispLibUtil_ModNiagara_NameAndBoolValue) == 0x000004, "Wrong alignment on FBUC_DispLibUtil_ModNiagara_NameAndBoolValue");
static_assert(sizeof(FBUC_DispLibUtil_ModNiagara_NameAndBoolValue) == 0x000018, "Wrong size on FBUC_DispLibUtil_ModNiagara_NameAndBoolValue");
static_assert(offsetof(FBUC_DispLibUtil_ModNiagara_NameAndBoolValue, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_ModNiagara_NameAndBoolValue::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModNiagara_NameAndBoolValue, Duration) == 0x00000C, "Member 'FBUC_DispLibUtil_ModNiagara_NameAndBoolValue::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_ModNiagara_NameAndBoolValue, EndStageDuration) == 0x000010, "Member 'FBUC_DispLibUtil_ModNiagara_NameAndBoolValue::EndStageDuration' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndFloatArray
// 0x0020 (0x0020 - 0x0000)
struct FBUC_DispLibUtil_NameAndFloatArray final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatArray;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         SetEveryFrame : 1;                                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FBUC_DispLibUtil_NameAndFloatArray) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_NameAndFloatArray");
static_assert(sizeof(FBUC_DispLibUtil_NameAndFloatArray) == 0x000020, "Wrong size on FBUC_DispLibUtil_NameAndFloatArray");
static_assert(offsetof(FBUC_DispLibUtil_NameAndFloatArray, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndFloatArray::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndFloatArray, FloatArray) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndFloatArray::FloatArray' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndInt32Array
// 0x0020 (0x0020 - 0x0000)
struct FBUC_DispLibUtil_NameAndInt32Array final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Int32Array;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         SetEveryFrame : 1;                                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FBUC_DispLibUtil_NameAndInt32Array) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_NameAndInt32Array");
static_assert(sizeof(FBUC_DispLibUtil_NameAndInt32Array) == 0x000020, "Wrong size on FBUC_DispLibUtil_NameAndInt32Array");
static_assert(offsetof(FBUC_DispLibUtil_NameAndInt32Array, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndInt32Array::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndInt32Array, Int32Array) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndInt32Array::Int32Array' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndFVectorArray
// 0x0020 (0x0020 - 0x0000)
struct FBUC_DispLibUtil_NameAndFVectorArray final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FVectorArray;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         SetEveryFrame : 1;                                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FBUC_DispLibUtil_NameAndFVectorArray) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_NameAndFVectorArray");
static_assert(sizeof(FBUC_DispLibUtil_NameAndFVectorArray) == 0x000020, "Wrong size on FBUC_DispLibUtil_NameAndFVectorArray");
static_assert(offsetof(FBUC_DispLibUtil_NameAndFVectorArray, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndFVectorArray::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndFVectorArray, FVectorArray) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndFVectorArray::FVectorArray' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_ModifyNiagaraParams
// 0x00F8 (0x00F8 - 0x0000)
struct FBUC_DispLibDBC_ModifyNiagaraParams final
{
public:
	struct FBUC_DispLibDBC_EntityEffectTargetInfo MeshCompFilterInfo;                                // 0x0000(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibDBC_ModifyNiagaraTargetInfo NiagaraCompFilterInfo;                             // 0x0018(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_ModNiagara_NameAndBoolValue> SetBoolParam;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam> SetFloatParam;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_ModifyNiagaraParams_FloatParam> SetInt32Param;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_ModifyNiagaraParams_FVectorParam> SetFVectorParam;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_ModifyNiagaraParams_FLinearColorParam> SetFLinearColorParam;                              // 0x0088(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndFloatArray> SetFloatArrayParam;                                // 0x0098(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndInt32Array> SetInt32ArrayParam;                                // 0x00A8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_NameAndFVectorArray> SetFVectorArrayParam;                              // 0x00B8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           SetOverrideSelfMeshBones;                          // 0x00C8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           SetOverrideSelfMeshSockets;                        // 0x00D8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EDispLibDBCModNiagaraParamsPauseMode          PauseMode;                                         // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PausePriority;                                     // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndStagePriority;                                  // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_ModifyNiagaraParams) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_ModifyNiagaraParams");
static_assert(sizeof(FBUC_DispLibDBC_ModifyNiagaraParams) == 0x0000F8, "Wrong size on FBUC_DispLibDBC_ModifyNiagaraParams");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, MeshCompFilterInfo) == 0x000000, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::MeshCompFilterInfo' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, NiagaraCompFilterInfo) == 0x000018, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::NiagaraCompFilterInfo' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, Delay) == 0x000038, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, EndMode) == 0x00003C, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, Duration) == 0x000040, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, DelayTimeAfterStop) == 0x000044, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetBoolParam) == 0x000048, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetBoolParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetFloatParam) == 0x000058, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetFloatParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetInt32Param) == 0x000068, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetInt32Param' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetFVectorParam) == 0x000078, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetFVectorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetFLinearColorParam) == 0x000088, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetFLinearColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetFloatArrayParam) == 0x000098, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetFloatArrayParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetInt32ArrayParam) == 0x0000A8, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetInt32ArrayParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetFVectorArrayParam) == 0x0000B8, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetFVectorArrayParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetOverrideSelfMeshBones) == 0x0000C8, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetOverrideSelfMeshBones' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, SetOverrideSelfMeshSockets) == 0x0000D8, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::SetOverrideSelfMeshSockets' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, PauseMode) == 0x0000E8, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::PauseMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, PausePriority) == 0x0000EC, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::PausePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyNiagaraParams, EndStagePriority) == 0x0000F0, "Member 'FBUC_DispLibDBC_ModifyNiagaraParams::EndStagePriority' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_DBCPCurveColorParam
// 0x0040 (0x0040 - 0x0000)
struct FBUC_DispLibUtil_DBCPCurveColorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBUC_DispLibUtil_DBCPCurveColor        PCurve;                                            // 0x0008(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_DBCPCurveColorParam) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_DBCPCurveColorParam");
static_assert(sizeof(FBUC_DispLibUtil_DBCPCurveColorParam) == 0x000040, "Wrong size on FBUC_DispLibUtil_DBCPCurveColorParam");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColorParam, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_DBCPCurveColorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_DBCPCurveColorParam, PCurve) == 0x000008, "Member 'FBUC_DispLibUtil_DBCPCurveColorParam::PCurve' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibDBC_ModifyMaterialParameterCollection
// 0x0070 (0x0070 - 0x0000)
struct FBUC_DispLibDBC_ModifyMaterialParameterCollection final
{
public:
	class FString                                 MPCAssetPath;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCAdvProcessScalarParam> SetScalarParam;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCAdvProcessFLinearColorParam> SetFLinearColorParam;                              // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCPCurveScalarParam> SetPCurveScalarParam;                              // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBUC_DispLibUtil_DBCPCurveColorParam> SetPCurveFLinearColorParam;                        // 0x0050(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         PausePriority;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndStagePriority;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModMPCPriority;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModMPCEndStagePriority;                            // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibDBC_ModifyMaterialParameterCollection) == 0x000008, "Wrong alignment on FBUC_DispLibDBC_ModifyMaterialParameterCollection");
static_assert(sizeof(FBUC_DispLibDBC_ModifyMaterialParameterCollection) == 0x000070, "Wrong size on FBUC_DispLibDBC_ModifyMaterialParameterCollection");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, MPCAssetPath) == 0x000000, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::MPCAssetPath' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, Delay) == 0x000010, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::Delay' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, EndMode) == 0x000014, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::EndMode' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, Duration) == 0x000018, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::Duration' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, DelayTimeAfterStop) == 0x00001C, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::DelayTimeAfterStop' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, SetScalarParam) == 0x000020, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::SetScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, SetFLinearColorParam) == 0x000030, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::SetFLinearColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, SetPCurveScalarParam) == 0x000040, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::SetPCurveScalarParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, SetPCurveFLinearColorParam) == 0x000050, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::SetPCurveFLinearColorParam' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, PausePriority) == 0x000060, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::PausePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, EndStagePriority) == 0x000064, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::EndStagePriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, ModMPCPriority) == 0x000068, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::ModMPCPriority' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibDBC_ModifyMaterialParameterCollection, ModMPCEndStagePriority) == 0x00006C, "Member 'FBUC_DispLibDBC_ModifyMaterialParameterCollection::ModMPCEndStagePriority' has a wrong offset!");

// SharpStruct b1-Managed.TreeImposter_TaskData
// 0x0028 (0x0028 - 0x0000)
struct FTreeImposter_TaskData final
{
public:
	class UStaticMesh*                            TreeMeshAsset;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BakeLOD;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardMicoScale;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardPairCount;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaptureRTSize;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotTextureSize;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrunkMaskThreshold;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeafMaskThreshold;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTreeImposter_TaskData) == 0x000008, "Wrong alignment on FTreeImposter_TaskData");
static_assert(sizeof(FTreeImposter_TaskData) == 0x000028, "Wrong size on FTreeImposter_TaskData");
static_assert(offsetof(FTreeImposter_TaskData, TreeMeshAsset) == 0x000000, "Member 'FTreeImposter_TaskData::TreeMeshAsset' has a wrong offset!");
static_assert(offsetof(FTreeImposter_TaskData, BakeLOD) == 0x000008, "Member 'FTreeImposter_TaskData::BakeLOD' has a wrong offset!");
static_assert(offsetof(FTreeImposter_TaskData, CardMicoScale) == 0x00000C, "Member 'FTreeImposter_TaskData::CardMicoScale' has a wrong offset!");
static_assert(offsetof(FTreeImposter_TaskData, CardPairCount) == 0x000010, "Member 'FTreeImposter_TaskData::CardPairCount' has a wrong offset!");
static_assert(offsetof(FTreeImposter_TaskData, CaptureRTSize) == 0x000014, "Member 'FTreeImposter_TaskData::CaptureRTSize' has a wrong offset!");
static_assert(offsetof(FTreeImposter_TaskData, ShotTextureSize) == 0x000018, "Member 'FTreeImposter_TaskData::ShotTextureSize' has a wrong offset!");
static_assert(offsetof(FTreeImposter_TaskData, TrunkMaskThreshold) == 0x00001C, "Member 'FTreeImposter_TaskData::TrunkMaskThreshold' has a wrong offset!");
static_assert(offsetof(FTreeImposter_TaskData, LeafMaskThreshold) == 0x000020, "Member 'FTreeImposter_TaskData::LeafMaskThreshold' has a wrong offset!");

// SharpStruct b1-Managed.TreeImposter_OverrideMatScalarParam
// 0x000C (0x000C - 0x0000)
struct FTreeImposter_OverrideMatScalarParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTreeImposter_OverrideMatScalarParam) == 0x000004, "Wrong alignment on FTreeImposter_OverrideMatScalarParam");
static_assert(sizeof(FTreeImposter_OverrideMatScalarParam) == 0x00000C, "Wrong size on FTreeImposter_OverrideMatScalarParam");
static_assert(offsetof(FTreeImposter_OverrideMatScalarParam, ParamName) == 0x000000, "Member 'FTreeImposter_OverrideMatScalarParam::ParamName' has a wrong offset!");
static_assert(offsetof(FTreeImposter_OverrideMatScalarParam, Value) == 0x000008, "Member 'FTreeImposter_OverrideMatScalarParam::Value' has a wrong offset!");

// SharpStruct b1-Managed.TreeImposter_OverrideMatLinearColorParam
// 0x0018 (0x0018 - 0x0000)
struct FTreeImposter_OverrideMatLinearColorParam final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTreeImposter_OverrideMatLinearColorParam) == 0x000004, "Wrong alignment on FTreeImposter_OverrideMatLinearColorParam");
static_assert(sizeof(FTreeImposter_OverrideMatLinearColorParam) == 0x000018, "Wrong size on FTreeImposter_OverrideMatLinearColorParam");
static_assert(offsetof(FTreeImposter_OverrideMatLinearColorParam, ParamName) == 0x000000, "Member 'FTreeImposter_OverrideMatLinearColorParam::ParamName' has a wrong offset!");
static_assert(offsetof(FTreeImposter_OverrideMatLinearColorParam, Value) == 0x000008, "Member 'FTreeImposter_OverrideMatLinearColorParam::Value' has a wrong offset!");

// SharpStruct b1-Managed.TreeImposter_OverrideMPCParam
// 0x0028 (0x0028 - 0x0000)
struct FTreeImposter_OverrideMPCParam final
{
public:
	class UMaterialParameterCollection*           MPC;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTreeImposter_OverrideMatScalarParam> ScalarParam;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTreeImposter_OverrideMatLinearColorParam> LinearColorParam;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTreeImposter_OverrideMPCParam) == 0x000008, "Wrong alignment on FTreeImposter_OverrideMPCParam");
static_assert(sizeof(FTreeImposter_OverrideMPCParam) == 0x000028, "Wrong size on FTreeImposter_OverrideMPCParam");
static_assert(offsetof(FTreeImposter_OverrideMPCParam, MPC) == 0x000000, "Member 'FTreeImposter_OverrideMPCParam::MPC' has a wrong offset!");
static_assert(offsetof(FTreeImposter_OverrideMPCParam, ScalarParam) == 0x000008, "Member 'FTreeImposter_OverrideMPCParam::ScalarParam' has a wrong offset!");
static_assert(offsetof(FTreeImposter_OverrideMPCParam, LinearColorParam) == 0x000018, "Member 'FTreeImposter_OverrideMPCParam::LinearColorParam' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Jump_Land
// 0x0020 (0x0020 - 0x0000)
struct FAnimHumanoidSetting_Jump_Land final
{
public:
	class UAnimSequence*                          AnimSeq_Land;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkAnimLand_MoveTime;                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLand_MoveTime;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLand_JumpTime;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLand_AttackTime;                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLand_DodgeTime;                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Jump_Land) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_Jump_Land");
static_assert(sizeof(FAnimHumanoidSetting_Jump_Land) == 0x000020, "Wrong size on FAnimHumanoidSetting_Jump_Land");
static_assert(offsetof(FAnimHumanoidSetting_Jump_Land, AnimSeq_Land) == 0x000000, "Member 'FAnimHumanoidSetting_Jump_Land::AnimSeq_Land' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump_Land, WalkAnimLand_MoveTime) == 0x000008, "Member 'FAnimHumanoidSetting_Jump_Land::WalkAnimLand_MoveTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump_Land, AnimLand_MoveTime) == 0x00000C, "Member 'FAnimHumanoidSetting_Jump_Land::AnimLand_MoveTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump_Land, AnimLand_JumpTime) == 0x000010, "Member 'FAnimHumanoidSetting_Jump_Land::AnimLand_JumpTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump_Land, AnimLand_AttackTime) == 0x000014, "Member 'FAnimHumanoidSetting_Jump_Land::AnimLand_AttackTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump_Land, AnimLand_DodgeTime) == 0x000018, "Member 'FAnimHumanoidSetting_Jump_Land::AnimLand_DodgeTime' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_GlideJump
// 0x0008 (0x0008 - 0x0000)
struct FAnimHumanoidSetting_GlideJump final
{
public:
	class UAnimSequence*                          ASGlideJumpStart;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_GlideJump) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_GlideJump");
static_assert(sizeof(FAnimHumanoidSetting_GlideJump) == 0x000008, "Wrong size on FAnimHumanoidSetting_GlideJump");
static_assert(offsetof(FAnimHumanoidSetting_GlideJump, ASGlideJumpStart) == 0x000000, "Member 'FAnimHumanoidSetting_GlideJump::ASGlideJumpStart' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Jump
// 0x0190 (0x0190 - 0x0000)
struct FAnimHumanoidSetting_Jump final
{
public:
	float                                         CustomJumpVelocityIncrementWhenPressed;            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomJumpVelocityIncrementWhenPressed_Locked;     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BS_jump_start_fwd;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BS_jump_start_bwd;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BS_jump_loop_fwd;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BS_jump_loop_bwd;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BS_jump_additive_lean;                             // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BS_jump_additive_rot;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimJumpStart_N;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimJumpStart_F;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimJumpStart_L;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimJumpStart_R;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimJumpStart_B;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimFallStart_N;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimFallStart_F;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimFallStart_F_Dash;                              // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimFallStart_B;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimFallStart_L;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimFallStart_R;                                   // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimFallLoop;                                      // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerLandHeight;                                 // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightDividingLine_Low;                            // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightDividingLine_Mid;                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimHumanoidSetting_Jump_Land         Land_F_Low;                                        // 0x00A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Jump_Land         Land_F_Mid;                                        // 0x00C8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Jump_Land         Land_F_High;                                       // 0x00E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Jump_Land         Land_L;                                            // 0x0108(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Jump_Land         Land_R;                                            // 0x0128(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Jump_Land         Land_B;                                            // 0x0148(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AddtiveMoveAfterJump_F;                            // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AddtiveMoveAfterJump_B;                            // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AddtiveMoveAfterJump_L;                            // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AddtiveMoveAfterJump_R;                            // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_GlideJump         GlideJump;                                         // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Jump) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_Jump");
static_assert(sizeof(FAnimHumanoidSetting_Jump) == 0x000190, "Wrong size on FAnimHumanoidSetting_Jump");
static_assert(offsetof(FAnimHumanoidSetting_Jump, CustomJumpVelocityIncrementWhenPressed) == 0x000000, "Member 'FAnimHumanoidSetting_Jump::CustomJumpVelocityIncrementWhenPressed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, CustomJumpVelocityIncrementWhenPressed_Locked) == 0x000004, "Member 'FAnimHumanoidSetting_Jump::CustomJumpVelocityIncrementWhenPressed_Locked' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, BS_jump_start_fwd) == 0x000008, "Member 'FAnimHumanoidSetting_Jump::BS_jump_start_fwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, BS_jump_start_bwd) == 0x000010, "Member 'FAnimHumanoidSetting_Jump::BS_jump_start_bwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, BS_jump_loop_fwd) == 0x000018, "Member 'FAnimHumanoidSetting_Jump::BS_jump_loop_fwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, BS_jump_loop_bwd) == 0x000020, "Member 'FAnimHumanoidSetting_Jump::BS_jump_loop_bwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, BS_jump_additive_lean) == 0x000028, "Member 'FAnimHumanoidSetting_Jump::BS_jump_additive_lean' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, BS_jump_additive_rot) == 0x000030, "Member 'FAnimHumanoidSetting_Jump::BS_jump_additive_rot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimJumpStart_N) == 0x000038, "Member 'FAnimHumanoidSetting_Jump::AnimJumpStart_N' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimJumpStart_F) == 0x000040, "Member 'FAnimHumanoidSetting_Jump::AnimJumpStart_F' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimJumpStart_L) == 0x000048, "Member 'FAnimHumanoidSetting_Jump::AnimJumpStart_L' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimJumpStart_R) == 0x000050, "Member 'FAnimHumanoidSetting_Jump::AnimJumpStart_R' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimJumpStart_B) == 0x000058, "Member 'FAnimHumanoidSetting_Jump::AnimJumpStart_B' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimFallStart_N) == 0x000060, "Member 'FAnimHumanoidSetting_Jump::AnimFallStart_N' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimFallStart_F) == 0x000068, "Member 'FAnimHumanoidSetting_Jump::AnimFallStart_F' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimFallStart_F_Dash) == 0x000070, "Member 'FAnimHumanoidSetting_Jump::AnimFallStart_F_Dash' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimFallStart_B) == 0x000078, "Member 'FAnimHumanoidSetting_Jump::AnimFallStart_B' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimFallStart_L) == 0x000080, "Member 'FAnimHumanoidSetting_Jump::AnimFallStart_L' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimFallStart_R) == 0x000088, "Member 'FAnimHumanoidSetting_Jump::AnimFallStart_R' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AnimFallLoop) == 0x000090, "Member 'FAnimHumanoidSetting_Jump::AnimFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, TriggerLandHeight) == 0x000098, "Member 'FAnimHumanoidSetting_Jump::TriggerLandHeight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, HeightDividingLine_Low) == 0x00009C, "Member 'FAnimHumanoidSetting_Jump::HeightDividingLine_Low' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, HeightDividingLine_Mid) == 0x0000A0, "Member 'FAnimHumanoidSetting_Jump::HeightDividingLine_Mid' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, Land_F_Low) == 0x0000A8, "Member 'FAnimHumanoidSetting_Jump::Land_F_Low' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, Land_F_Mid) == 0x0000C8, "Member 'FAnimHumanoidSetting_Jump::Land_F_Mid' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, Land_F_High) == 0x0000E8, "Member 'FAnimHumanoidSetting_Jump::Land_F_High' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, Land_L) == 0x000108, "Member 'FAnimHumanoidSetting_Jump::Land_L' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, Land_R) == 0x000128, "Member 'FAnimHumanoidSetting_Jump::Land_R' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, Land_B) == 0x000148, "Member 'FAnimHumanoidSetting_Jump::Land_B' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AddtiveMoveAfterJump_F) == 0x000168, "Member 'FAnimHumanoidSetting_Jump::AddtiveMoveAfterJump_F' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AddtiveMoveAfterJump_B) == 0x000170, "Member 'FAnimHumanoidSetting_Jump::AddtiveMoveAfterJump_B' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AddtiveMoveAfterJump_L) == 0x000178, "Member 'FAnimHumanoidSetting_Jump::AddtiveMoveAfterJump_L' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, AddtiveMoveAfterJump_R) == 0x000180, "Member 'FAnimHumanoidSetting_Jump::AddtiveMoveAfterJump_R' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Jump, GlideJump) == 0x000188, "Member 'FAnimHumanoidSetting_Jump::GlideJump' has a wrong offset!");

// SharpStruct b1-Managed.TransitionCondition_Idle
// 0x0110 (0x0110 - 0x0000)
struct FTransitionCondition_Idle final
{
public:
	ETransitionConditionType_Idle                 ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          Overlap;                                           // 0x0004(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Interactor;                                        // 0x0014(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Unit;                                              // 0x0024(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          NPCUnit;                                           // 0x0034(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EQueryGameStateCondition                      GameStateCondition;                                // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timer_InArea;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer_OutArea;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          TaskStage;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EStageStatus                                  TaskStageStatus;                                   // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InteractionGroupID;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionStep;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwningItemID;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwningNum;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumeItemID;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumptionQuantity;                               // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsActorGuidReference                  TargetActor;                                       // 0x0080(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsActorGuidReference                  SplineActor;                                       // 0x00B8(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcMoveType                                  NpcMoveType;                                       // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveAcceptableRadius;                              // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x00FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransitionCondition_Idle) == 0x000008, "Wrong alignment on FTransitionCondition_Idle");
static_assert(sizeof(FTransitionCondition_Idle) == 0x000110, "Wrong size on FTransitionCondition_Idle");
static_assert(offsetof(FTransitionCondition_Idle, ConditionType) == 0x000000, "Member 'FTransitionCondition_Idle::ConditionType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, Overlap) == 0x000004, "Member 'FTransitionCondition_Idle::Overlap' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, Interactor) == 0x000014, "Member 'FTransitionCondition_Idle::Interactor' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, Unit) == 0x000024, "Member 'FTransitionCondition_Idle::Unit' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, NPCUnit) == 0x000034, "Member 'FTransitionCondition_Idle::NPCUnit' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, GameStateCondition) == 0x000044, "Member 'FTransitionCondition_Idle::GameStateCondition' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, Timer_InArea) == 0x000048, "Member 'FTransitionCondition_Idle::Timer_InArea' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, Timer_OutArea) == 0x00004C, "Member 'FTransitionCondition_Idle::Timer_OutArea' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, TaskStage) == 0x000050, "Member 'FTransitionCondition_Idle::TaskStage' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, TaskStageStatus) == 0x000060, "Member 'FTransitionCondition_Idle::TaskStageStatus' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, InteractionGroupID) == 0x000064, "Member 'FTransitionCondition_Idle::InteractionGroupID' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, InteractionStep) == 0x000068, "Member 'FTransitionCondition_Idle::InteractionStep' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, OwningItemID) == 0x00006C, "Member 'FTransitionCondition_Idle::OwningItemID' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, OwningNum) == 0x000070, "Member 'FTransitionCondition_Idle::OwningNum' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, ConsumeItemID) == 0x000074, "Member 'FTransitionCondition_Idle::ConsumeItemID' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, ConsumptionQuantity) == 0x000078, "Member 'FTransitionCondition_Idle::ConsumptionQuantity' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, TargetActor) == 0x000080, "Member 'FTransitionCondition_Idle::TargetActor' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, SplineActor) == 0x0000B8, "Member 'FTransitionCondition_Idle::SplineActor' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, NpcMoveType) == 0x0000F0, "Member 'FTransitionCondition_Idle::NpcMoveType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, MoveAcceptableRadius) == 0x0000F4, "Member 'FTransitionCondition_Idle::MoveAcceptableRadius' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, SkillID) == 0x0000F8, "Member 'FTransitionCondition_Idle::SkillID' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Idle, Comment) == 0x000100, "Member 'FTransitionCondition_Idle::Comment' has a wrong offset!");

// SharpStruct b1-Managed.CompositeTransitionCondition_Idle
// 0x0140 (0x0140 - 0x0000)
struct FCompositeTransitionCondition_Idle final
{
public:
	struct FTransitionCondition_Idle              Single;                                            // 0x0000(0x0110)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCompositeCondition : 1;                        // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransitionCondition_Idle>      Conditions;                                        // 0x0118(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x0129(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12A[0x6];                                      // 0x012A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompositeTransitionCondition_Idle) == 0x000008, "Wrong alignment on FCompositeTransitionCondition_Idle");
static_assert(sizeof(FCompositeTransitionCondition_Idle) == 0x000140, "Wrong size on FCompositeTransitionCondition_Idle");
static_assert(offsetof(FCompositeTransitionCondition_Idle, Single) == 0x000000, "Member 'FCompositeTransitionCondition_Idle::Single' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Idle, Conditions) == 0x000118, "Member 'FCompositeTransitionCondition_Idle::Conditions' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Idle, ConditionalRelation) == 0x000128, "Member 'FCompositeTransitionCondition_Idle::ConditionalRelation' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Idle, Comment) == 0x000130, "Member 'FCompositeTransitionCondition_Idle::Comment' has a wrong offset!");

// SharpStruct b1-Managed.FGSCameraAutoLockSetting
// 0x0028 (0x0028 - 0x0000)
struct FFGSCameraAutoLockSetting final
{
public:
	float                                         MaxCamLockTargetDistance;                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CamLockAngleMax;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CamLockSwitchAngleMax;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistScoreRate;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G4SpotTurnSpeed;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CamLockTurnSpeed;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollSkillTurnSpeed;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateToCameraTurnSpeed;                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillResumeMoveBlendTime;                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Camera4GRotateSpeed;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSCameraAutoLockSetting) == 0x000004, "Wrong alignment on FFGSCameraAutoLockSetting");
static_assert(sizeof(FFGSCameraAutoLockSetting) == 0x000028, "Wrong size on FFGSCameraAutoLockSetting");
static_assert(offsetof(FFGSCameraAutoLockSetting, MaxCamLockTargetDistance) == 0x000000, "Member 'FFGSCameraAutoLockSetting::MaxCamLockTargetDistance' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, CamLockAngleMax) == 0x000004, "Member 'FFGSCameraAutoLockSetting::CamLockAngleMax' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, CamLockSwitchAngleMax) == 0x000008, "Member 'FFGSCameraAutoLockSetting::CamLockSwitchAngleMax' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, DistScoreRate) == 0x00000C, "Member 'FFGSCameraAutoLockSetting::DistScoreRate' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, G4SpotTurnSpeed) == 0x000010, "Member 'FFGSCameraAutoLockSetting::G4SpotTurnSpeed' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, CamLockTurnSpeed) == 0x000014, "Member 'FFGSCameraAutoLockSetting::CamLockTurnSpeed' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, RollSkillTurnSpeed) == 0x000018, "Member 'FFGSCameraAutoLockSetting::RollSkillTurnSpeed' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, RotateToCameraTurnSpeed) == 0x00001C, "Member 'FFGSCameraAutoLockSetting::RotateToCameraTurnSpeed' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, SkillResumeMoveBlendTime) == 0x000020, "Member 'FFGSCameraAutoLockSetting::SkillResumeMoveBlendTime' has a wrong offset!");
static_assert(offsetof(FFGSCameraAutoLockSetting, Camera4GRotateSpeed) == 0x000024, "Member 'FFGSCameraAutoLockSetting::Camera4GRotateSpeed' has a wrong offset!");

// SharpStruct b1-Managed.TreeImposter_OverrideTexSetting
// 0x0020 (0x0020 - 0x0000)
struct FTreeImposter_OverrideTexSetting final
{
public:
	class FName                                   TexName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SRGB : 1;                                          // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETextureCompressionSettings                   CompressionSettings;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureGroup                                 LODGroup;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CompressionNoAlpha : 1;                            // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ETextureFilter                                Filter;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsVT : 1;                                          // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FTreeImposter_OverrideTexSetting) == 0x000004, "Wrong alignment on FTreeImposter_OverrideTexSetting");
static_assert(sizeof(FTreeImposter_OverrideTexSetting) == 0x000020, "Wrong size on FTreeImposter_OverrideTexSetting");
static_assert(offsetof(FTreeImposter_OverrideTexSetting, TexName) == 0x000000, "Member 'FTreeImposter_OverrideTexSetting::TexName' has a wrong offset!");
static_assert(offsetof(FTreeImposter_OverrideTexSetting, CompressionSettings) == 0x00000C, "Member 'FTreeImposter_OverrideTexSetting::CompressionSettings' has a wrong offset!");
static_assert(offsetof(FTreeImposter_OverrideTexSetting, LODGroup) == 0x000010, "Member 'FTreeImposter_OverrideTexSetting::LODGroup' has a wrong offset!");
static_assert(offsetof(FTreeImposter_OverrideTexSetting, Filter) == 0x000018, "Member 'FTreeImposter_OverrideTexSetting::Filter' has a wrong offset!");

// SharpStruct b1-Managed.TransitionCondition_Guide
// 0x0080 (0x0080 - 0x0000)
struct FTransitionCondition_Guide final
{
public:
	ETransitionConditionType_Guide                ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          Overlap;                                           // 0x0004(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EAbnormalStateType                            AbnormalState;                                     // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RebirthPointId;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Unit;                                              // 0x001C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ItemId;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckRange;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 CheckResIdList;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBGUAttrFloat                                 AttrFloatType;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareValue;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          TaskStage;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EStageStatus                                  TaskStageStatus;                                   // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MapId;                                             // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TalentID;                                          // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUIPageType                                   UIPageType;                                        // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GuideGroupId;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SequenceID;                                        // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESequencePhase                                SequencePhase;                                     // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemNum;                                           // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransitionCondition_Guide) == 0x000008, "Wrong alignment on FTransitionCondition_Guide");
static_assert(sizeof(FTransitionCondition_Guide) == 0x000080, "Wrong size on FTransitionCondition_Guide");
static_assert(offsetof(FTransitionCondition_Guide, ConditionType) == 0x000000, "Member 'FTransitionCondition_Guide::ConditionType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, Overlap) == 0x000004, "Member 'FTransitionCondition_Guide::Overlap' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, AbnormalState) == 0x000014, "Member 'FTransitionCondition_Guide::AbnormalState' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, RebirthPointId) == 0x000018, "Member 'FTransitionCondition_Guide::RebirthPointId' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, Unit) == 0x00001C, "Member 'FTransitionCondition_Guide::Unit' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, ItemId) == 0x00002C, "Member 'FTransitionCondition_Guide::ItemId' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, CheckRange) == 0x000030, "Member 'FTransitionCondition_Guide::CheckRange' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, CheckResIdList) == 0x000038, "Member 'FTransitionCondition_Guide::CheckResIdList' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, AttrFloatType) == 0x000048, "Member 'FTransitionCondition_Guide::AttrFloatType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, CompareOperation) == 0x000049, "Member 'FTransitionCondition_Guide::CompareOperation' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, CompareValue) == 0x00004C, "Member 'FTransitionCondition_Guide::CompareValue' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, TaskStage) == 0x000050, "Member 'FTransitionCondition_Guide::TaskStage' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, TaskStageStatus) == 0x000060, "Member 'FTransitionCondition_Guide::TaskStageStatus' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, MapId) == 0x000064, "Member 'FTransitionCondition_Guide::MapId' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, TalentID) == 0x000068, "Member 'FTransitionCondition_Guide::TalentID' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, UIPageType) == 0x00006C, "Member 'FTransitionCondition_Guide::UIPageType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, GuideGroupId) == 0x000070, "Member 'FTransitionCondition_Guide::GuideGroupId' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, SequenceID) == 0x000074, "Member 'FTransitionCondition_Guide::SequenceID' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, SequencePhase) == 0x000078, "Member 'FTransitionCondition_Guide::SequencePhase' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Guide, ItemNum) == 0x00007C, "Member 'FTransitionCondition_Guide::ItemNum' has a wrong offset!");

// SharpStruct b1-Managed.DBCTestStruct
// 0x0010 (0x0010 - 0x0000)
struct FDBCTestStruct final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDispLibDBCEndMode                            EndMode;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeAfterStop;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDBCTestStruct) == 0x000004, "Wrong alignment on FDBCTestStruct");
static_assert(sizeof(FDBCTestStruct) == 0x000010, "Wrong size on FDBCTestStruct");
static_assert(offsetof(FDBCTestStruct, Delay) == 0x000000, "Member 'FDBCTestStruct::Delay' has a wrong offset!");
static_assert(offsetof(FDBCTestStruct, EndMode) == 0x000004, "Member 'FDBCTestStruct::EndMode' has a wrong offset!");
static_assert(offsetof(FDBCTestStruct, Duration) == 0x000008, "Member 'FDBCTestStruct::Duration' has a wrong offset!");
static_assert(offsetof(FDBCTestStruct, DelayTimeAfterStop) == 0x00000C, "Member 'FDBCTestStruct::DelayTimeAfterStop' has a wrong offset!");

// SharpStruct b1-Managed.BulletBeAttackedReactionInfo
// 0x0028 (0x0028 - 0x0000)
struct FBulletBeAttackedReactionInfo final
{
public:
	int32                                         CheckID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TriggerEffectID;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 AttackerTriggerEffectID;                           // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletBeAttackedReactionInfo) == 0x000008, "Wrong alignment on FBulletBeAttackedReactionInfo");
static_assert(sizeof(FBulletBeAttackedReactionInfo) == 0x000028, "Wrong size on FBulletBeAttackedReactionInfo");
static_assert(offsetof(FBulletBeAttackedReactionInfo, CheckID) == 0x000000, "Member 'FBulletBeAttackedReactionInfo::CheckID' has a wrong offset!");
static_assert(offsetof(FBulletBeAttackedReactionInfo, TriggerEffectID) == 0x000008, "Member 'FBulletBeAttackedReactionInfo::TriggerEffectID' has a wrong offset!");
static_assert(offsetof(FBulletBeAttackedReactionInfo, AttackerTriggerEffectID) == 0x000018, "Member 'FBulletBeAttackedReactionInfo::AttackerTriggerEffectID' has a wrong offset!");

// SharpStruct b1-Managed.ProjectileExtAbilityMask
// 0x0004 (0x0004 - 0x0000)
struct FProjectileExtAbilityMask final
{
public:
	int32                                         Mask;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileExtAbilityMask) == 0x000004, "Wrong alignment on FProjectileExtAbilityMask");
static_assert(sizeof(FProjectileExtAbilityMask) == 0x000004, "Wrong size on FProjectileExtAbilityMask");
static_assert(offsetof(FProjectileExtAbilityMask, Mask) == 0x000000, "Member 'FProjectileExtAbilityMask::Mask' has a wrong offset!");

// SharpStruct b1-Managed.NormalStiffInfo
// 0x0028 (0x0028 - 0x0000)
struct FNormalStiffInfo final
{
public:
	int32                                         StiffLevelID;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsEnableReuse : 1;                                 // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StiffLevelReuseID;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EllipsisType                                  EllipsisType;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableBeAttackedRotate : 1;                        // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENormalStiffSectorsType                       SectorsType;                                       // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalStiffRotateForwardLeft_FNB;                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateForwardRight_FNB;                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateForwardLeft_FourDir;              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateForwardRight_FourDir;             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateBackwardLeft_FourDir;             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateBackwardRight_FourDir;            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNormalStiffInfo) == 0x000004, "Wrong alignment on FNormalStiffInfo");
static_assert(sizeof(FNormalStiffInfo) == 0x000028, "Wrong size on FNormalStiffInfo");
static_assert(offsetof(FNormalStiffInfo, StiffLevelID) == 0x000000, "Member 'FNormalStiffInfo::StiffLevelID' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, StiffLevelReuseID) == 0x000008, "Member 'FNormalStiffInfo::StiffLevelReuseID' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, EllipsisType) == 0x00000C, "Member 'FNormalStiffInfo::EllipsisType' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, SectorsType) == 0x00000E, "Member 'FNormalStiffInfo::SectorsType' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, NormalStiffRotateForwardLeft_FNB) == 0x000010, "Member 'FNormalStiffInfo::NormalStiffRotateForwardLeft_FNB' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, NormalStiffRotateForwardRight_FNB) == 0x000014, "Member 'FNormalStiffInfo::NormalStiffRotateForwardRight_FNB' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, NormalStiffRotateForwardLeft_FourDir) == 0x000018, "Member 'FNormalStiffInfo::NormalStiffRotateForwardLeft_FourDir' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, NormalStiffRotateForwardRight_FourDir) == 0x00001C, "Member 'FNormalStiffInfo::NormalStiffRotateForwardRight_FourDir' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, NormalStiffRotateBackwardLeft_FourDir) == 0x000020, "Member 'FNormalStiffInfo::NormalStiffRotateBackwardLeft_FourDir' has a wrong offset!");
static_assert(offsetof(FNormalStiffInfo, NormalStiffRotateBackwardRight_FourDir) == 0x000024, "Member 'FNormalStiffInfo::NormalStiffRotateBackwardRight_FourDir' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndInt
// 0x000C (0x000C - 0x0000)
struct FBUC_DispLibUtil_NameAndInt final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_NameAndInt) == 0x000004, "Wrong alignment on FBUC_DispLibUtil_NameAndInt");
static_assert(sizeof(FBUC_DispLibUtil_NameAndInt) == 0x00000C, "Wrong size on FBUC_DispLibUtil_NameAndInt");
static_assert(offsetof(FBUC_DispLibUtil_NameAndInt, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndInt::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndInt, Value) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndInt::Value' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndString
// 0x0018 (0x0018 - 0x0000)
struct FBUC_DispLibUtil_NameAndString final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_NameAndString) == 0x000008, "Wrong alignment on FBUC_DispLibUtil_NameAndString");
static_assert(sizeof(FBUC_DispLibUtil_NameAndString) == 0x000018, "Wrong size on FBUC_DispLibUtil_NameAndString");
static_assert(offsetof(FBUC_DispLibUtil_NameAndString, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndString::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndString, Value) == 0x000008, "Member 'FBUC_DispLibUtil_NameAndString::Value' has a wrong offset!");

// SharpStruct b1-Managed.BUC_DispLibUtil_NameAndV4
// 0x0030 (0x0030 - 0x0000)
struct FBUC_DispLibUtil_NameAndV4 final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Value;                                             // 0x0010(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBUC_DispLibUtil_NameAndV4) == 0x000010, "Wrong alignment on FBUC_DispLibUtil_NameAndV4");
static_assert(sizeof(FBUC_DispLibUtil_NameAndV4) == 0x000030, "Wrong size on FBUC_DispLibUtil_NameAndV4");
static_assert(offsetof(FBUC_DispLibUtil_NameAndV4, ParamName) == 0x000000, "Member 'FBUC_DispLibUtil_NameAndV4::ParamName' has a wrong offset!");
static_assert(offsetof(FBUC_DispLibUtil_NameAndV4, Value) == 0x000010, "Member 'FBUC_DispLibUtil_NameAndV4::Value' has a wrong offset!");

// SharpStruct b1-Managed.PreciseDodgeAwards
// 0x0038 (0x0038 - 0x0000)
struct FPreciseDodgeAwards final
{
public:
	TArray<struct FFGSBuffInfo>                   AddBuffIds;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 RemoveBuffIds;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillEffectIds;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MaxAwardCount;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreciseDodgeAwards) == 0x000008, "Wrong alignment on FPreciseDodgeAwards");
static_assert(sizeof(FPreciseDodgeAwards) == 0x000038, "Wrong size on FPreciseDodgeAwards");
static_assert(offsetof(FPreciseDodgeAwards, AddBuffIds) == 0x000000, "Member 'FPreciseDodgeAwards::AddBuffIds' has a wrong offset!");
static_assert(offsetof(FPreciseDodgeAwards, RemoveBuffIds) == 0x000010, "Member 'FPreciseDodgeAwards::RemoveBuffIds' has a wrong offset!");
static_assert(offsetof(FPreciseDodgeAwards, SkillEffectIds) == 0x000020, "Member 'FPreciseDodgeAwards::SkillEffectIds' has a wrong offset!");
static_assert(offsetof(FPreciseDodgeAwards, MaxAwardCount) == 0x000030, "Member 'FPreciseDodgeAwards::MaxAwardCount' has a wrong offset!");

// SharpStruct b1-Managed.StopEventConditionConfig
// 0x0010 (0x0010 - 0x0000)
struct FStopEventConditionConfig final
{
public:
	class UAkAudioEvent*                          LeaveBattleEventStop;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          PlayerDeadEventStop;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStopEventConditionConfig) == 0x000008, "Wrong alignment on FStopEventConditionConfig");
static_assert(sizeof(FStopEventConditionConfig) == 0x000010, "Wrong size on FStopEventConditionConfig");
static_assert(offsetof(FStopEventConditionConfig, LeaveBattleEventStop) == 0x000000, "Member 'FStopEventConditionConfig::LeaveBattleEventStop' has a wrong offset!");
static_assert(offsetof(FStopEventConditionConfig, PlayerDeadEventStop) == 0x000008, "Member 'FStopEventConditionConfig::PlayerDeadEventStop' has a wrong offset!");

// SharpStruct b1-Managed.BtlBGMBPConfig
// 0x0028 (0x0028 - 0x0000)
struct FBtlBGMBPConfig final
{
public:
	uint8                                         bDisableBattleBGM : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ETransMusicConfig                             TransMusicConfig;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BGMStopDistance;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventBegin;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventStop;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStopEventConditionConfig              StopEventConditionConfig;                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBtlBGMBPConfig) == 0x000008, "Wrong alignment on FBtlBGMBPConfig");
static_assert(sizeof(FBtlBGMBPConfig) == 0x000028, "Wrong size on FBtlBGMBPConfig");
static_assert(offsetof(FBtlBGMBPConfig, TransMusicConfig) == 0x000001, "Member 'FBtlBGMBPConfig::TransMusicConfig' has a wrong offset!");
static_assert(offsetof(FBtlBGMBPConfig, BGMStopDistance) == 0x000004, "Member 'FBtlBGMBPConfig::BGMStopDistance' has a wrong offset!");
static_assert(offsetof(FBtlBGMBPConfig, AkEventBegin) == 0x000008, "Member 'FBtlBGMBPConfig::AkEventBegin' has a wrong offset!");
static_assert(offsetof(FBtlBGMBPConfig, AkEventStop) == 0x000010, "Member 'FBtlBGMBPConfig::AkEventStop' has a wrong offset!");
static_assert(offsetof(FBtlBGMBPConfig, StopEventConditionConfig) == 0x000018, "Member 'FBtlBGMBPConfig::StopEventConditionConfig' has a wrong offset!");

// SharpStruct b1-Managed.TeleportParam_NextChapter
// 0x0004 (0x0004 - 0x0000)
struct FTeleportParam_NextChapter final
{
public:
	int32                                         LevelID;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleportParam_NextChapter) == 0x000004, "Wrong alignment on FTeleportParam_NextChapter");
static_assert(sizeof(FTeleportParam_NextChapter) == 0x000004, "Wrong size on FTeleportParam_NextChapter");
static_assert(offsetof(FTeleportParam_NextChapter, LevelID) == 0x000000, "Member 'FTeleportParam_NextChapter::LevelID' has a wrong offset!");

// SharpStruct b1-Managed.FBGMVolumeCondition
// 0x0020 (0x0020 - 0x0000)
struct FFBGMVolumeCondition final
{
public:
	EBGMVolumeConditionType                       Condition;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InverseCondition : 1;                              // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGsActorGuidReference>          Actors;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBGMVolumeConditionSusCountType               ConditionSusCountType;                             // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFBGMVolumeCondition) == 0x000008, "Wrong alignment on FFBGMVolumeCondition");
static_assert(sizeof(FFBGMVolumeCondition) == 0x000020, "Wrong size on FFBGMVolumeCondition");
static_assert(offsetof(FFBGMVolumeCondition, Condition) == 0x000000, "Member 'FFBGMVolumeCondition::Condition' has a wrong offset!");
static_assert(offsetof(FFBGMVolumeCondition, Actors) == 0x000008, "Member 'FFBGMVolumeCondition::Actors' has a wrong offset!");
static_assert(offsetof(FFBGMVolumeCondition, ConditionSusCountType) == 0x000018, "Member 'FFBGMVolumeCondition::ConditionSusCountType' has a wrong offset!");

// SharpStruct b1-Managed.FBGMVolumeConditionGroup
// 0x0010 (0x0010 - 0x0000)
struct FFBGMVolumeConditionGroup final
{
public:
	TArray<struct FFBGMVolumeCondition>           Conditions;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFBGMVolumeConditionGroup) == 0x000008, "Wrong alignment on FFBGMVolumeConditionGroup");
static_assert(sizeof(FFBGMVolumeConditionGroup) == 0x000010, "Wrong size on FFBGMVolumeConditionGroup");
static_assert(offsetof(FFBGMVolumeConditionGroup, Conditions) == 0x000000, "Member 'FFBGMVolumeConditionGroup::Conditions' has a wrong offset!");

// SharpStruct b1-Managed.Birth_AbnomalState
// 0x0008 (0x0008 - 0x0000)
struct FBirth_AbnomalState final
{
public:
	EAbnormalStateType                            AbnormalStateType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AbnormalStateLevel;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBirth_AbnomalState) == 0x000004, "Wrong alignment on FBirth_AbnomalState");
static_assert(sizeof(FBirth_AbnomalState) == 0x000008, "Wrong size on FBirth_AbnomalState");
static_assert(offsetof(FBirth_AbnomalState, AbnormalStateType) == 0x000000, "Member 'FBirth_AbnomalState::AbnormalStateType' has a wrong offset!");
static_assert(offsetof(FBirth_AbnomalState, AbnormalStateLevel) == 0x000004, "Member 'FBirth_AbnomalState::AbnormalStateLevel' has a wrong offset!");

// SharpStruct b1-Managed.DispInteractInfo
// 0x0038 (0x0038 - 0x0000)
struct FDispInteractInfo final
{
public:
	struct FVector                                FirstPos;                                          // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NextPos;                                           // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstRadius;                                       // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextRadius;                                        // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDispInteractInfo) == 0x000008, "Wrong alignment on FDispInteractInfo");
static_assert(sizeof(FDispInteractInfo) == 0x000038, "Wrong size on FDispInteractInfo");
static_assert(offsetof(FDispInteractInfo, FirstPos) == 0x000000, "Member 'FDispInteractInfo::FirstPos' has a wrong offset!");
static_assert(offsetof(FDispInteractInfo, NextPos) == 0x000018, "Member 'FDispInteractInfo::NextPos' has a wrong offset!");
static_assert(offsetof(FDispInteractInfo, FirstRadius) == 0x000030, "Member 'FDispInteractInfo::FirstRadius' has a wrong offset!");
static_assert(offsetof(FDispInteractInfo, NextRadius) == 0x000034, "Member 'FDispInteractInfo::NextRadius' has a wrong offset!");

// SharpStruct b1-Managed.EffectorData
// 0x0030 (0x0030 - 0x0000)
struct FEffectorData final
{
public:
	class FName                                   EffectorRootName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaCurveValue;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectorData) == 0x000008, "Wrong alignment on FEffectorData");
static_assert(sizeof(FEffectorData) == 0x000030, "Wrong size on FEffectorData");
static_assert(offsetof(FEffectorData, EffectorRootName) == 0x000000, "Member 'FEffectorData::EffectorRootName' has a wrong offset!");
static_assert(offsetof(FEffectorData, BoneName) == 0x000008, "Member 'FEffectorData::BoneName' has a wrong offset!");
static_assert(offsetof(FEffectorData, Position) == 0x000010, "Member 'FEffectorData::Position' has a wrong offset!");
static_assert(offsetof(FEffectorData, Alpha) == 0x000028, "Member 'FEffectorData::Alpha' has a wrong offset!");
static_assert(offsetof(FEffectorData, AlphaCurveValue) == 0x00002C, "Member 'FEffectorData::AlphaCurveValue' has a wrong offset!");

// SharpStruct b1-Managed.HitCheckConf
// 0x0003 (0x0003 - 0x0000)
struct FHitCheckConf final
{
public:
	EHitActionDir                                 HitActionDir;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESweepCheckHitFilterType                      ResultFilterType;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsRenderDebugShape : 1;                            // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FHitCheckConf) == 0x000001, "Wrong alignment on FHitCheckConf");
static_assert(sizeof(FHitCheckConf) == 0x000003, "Wrong size on FHitCheckConf");
static_assert(offsetof(FHitCheckConf, HitActionDir) == 0x000000, "Member 'FHitCheckConf::HitActionDir' has a wrong offset!");
static_assert(offsetof(FHitCheckConf, ResultFilterType) == 0x000001, "Member 'FHitCheckConf::ResultFilterType' has a wrong offset!");

// SharpStruct b1-Managed.GlobalFXConfigInfo
// 0x0050 (0x0050 - 0x0000)
struct FGlobalFXConfigInfo final
{
public:
	class UNiagaraSystem*                         FXTemplate;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FXTag;                                             // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BulletPositionParamName;                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MFSpherePosParamName;                              // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MFSphereRadiusParamName;                           // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMFSphereUseRadiusArray : 1;                       // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AvoidanceMFSpherePosParamName;                     // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AvoidanceMFSphereRadiusParamName;                  // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAvoidanceMFSphereUseRadiusArray : 1;              // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FXStartPointTag;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FXStartPointParamName;                             // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGlobalFXConfigInfo) == 0x000008, "Wrong alignment on FGlobalFXConfigInfo");
static_assert(sizeof(FGlobalFXConfigInfo) == 0x000050, "Wrong size on FGlobalFXConfigInfo");
static_assert(offsetof(FGlobalFXConfigInfo, FXTemplate) == 0x000000, "Member 'FGlobalFXConfigInfo::FXTemplate' has a wrong offset!");
static_assert(offsetof(FGlobalFXConfigInfo, FXTag) == 0x000008, "Member 'FGlobalFXConfigInfo::FXTag' has a wrong offset!");
static_assert(offsetof(FGlobalFXConfigInfo, BulletPositionParamName) == 0x000010, "Member 'FGlobalFXConfigInfo::BulletPositionParamName' has a wrong offset!");
static_assert(offsetof(FGlobalFXConfigInfo, MFSpherePosParamName) == 0x000018, "Member 'FGlobalFXConfigInfo::MFSpherePosParamName' has a wrong offset!");
static_assert(offsetof(FGlobalFXConfigInfo, MFSphereRadiusParamName) == 0x000020, "Member 'FGlobalFXConfigInfo::MFSphereRadiusParamName' has a wrong offset!");
static_assert(offsetof(FGlobalFXConfigInfo, AvoidanceMFSpherePosParamName) == 0x00002C, "Member 'FGlobalFXConfigInfo::AvoidanceMFSpherePosParamName' has a wrong offset!");
static_assert(offsetof(FGlobalFXConfigInfo, AvoidanceMFSphereRadiusParamName) == 0x000034, "Member 'FGlobalFXConfigInfo::AvoidanceMFSphereRadiusParamName' has a wrong offset!");
static_assert(offsetof(FGlobalFXConfigInfo, FXStartPointTag) == 0x000040, "Member 'FGlobalFXConfigInfo::FXStartPointTag' has a wrong offset!");
static_assert(offsetof(FGlobalFXConfigInfo, FXStartPointParamName) == 0x000048, "Member 'FGlobalFXConfigInfo::FXStartPointParamName' has a wrong offset!");

// SharpStruct b1-Managed.UnitAttrCondition
// 0x0008 (0x0008 - 0x0000)
struct FUnitAttrCondition final
{
public:
	EBGUAttrFloat                                 AttrFloatType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareValue;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitAttrCondition) == 0x000004, "Wrong alignment on FUnitAttrCondition");
static_assert(sizeof(FUnitAttrCondition) == 0x000008, "Wrong size on FUnitAttrCondition");
static_assert(offsetof(FUnitAttrCondition, AttrFloatType) == 0x000000, "Member 'FUnitAttrCondition::AttrFloatType' has a wrong offset!");
static_assert(offsetof(FUnitAttrCondition, CompareOperation) == 0x000001, "Member 'FUnitAttrCondition::CompareOperation' has a wrong offset!");
static_assert(offsetof(FUnitAttrCondition, CompareValue) == 0x000004, "Member 'FUnitAttrCondition::CompareValue' has a wrong offset!");

// SharpStruct b1-Managed.TeleportParam_PlayerRebirth
// 0x000C (0x000C - 0x0000)
struct FTeleportParam_PlayerRebirth final
{
public:
	int32                                         LevelID;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportPointName;                                 // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleportParam_PlayerRebirth) == 0x000004, "Wrong alignment on FTeleportParam_PlayerRebirth");
static_assert(sizeof(FTeleportParam_PlayerRebirth) == 0x00000C, "Wrong size on FTeleportParam_PlayerRebirth");
static_assert(offsetof(FTeleportParam_PlayerRebirth, LevelID) == 0x000000, "Member 'FTeleportParam_PlayerRebirth::LevelID' has a wrong offset!");
static_assert(offsetof(FTeleportParam_PlayerRebirth, TeleportPointName) == 0x000004, "Member 'FTeleportParam_PlayerRebirth::TeleportPointName' has a wrong offset!");

// SharpStruct b1-Managed.BattleSCInfo
// 0x0050 (0x0050 - 0x0000)
struct FBattleSCInfo final
{
public:
	TMap<struct FGameplayTag, struct FGameplayTag> BattleEventMap;                                    // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleSCInfo) == 0x000008, "Wrong alignment on FBattleSCInfo");
static_assert(sizeof(FBattleSCInfo) == 0x000050, "Wrong size on FBattleSCInfo");
static_assert(offsetof(FBattleSCInfo, BattleEventMap) == 0x000000, "Member 'FBattleSCInfo::BattleEventMap' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_FootIK
// 0x0004 (0x0004 - 0x0000)
struct FAnimHumanoidSetting_FootIK final
{
public:
	uint8                                         bEnableIK : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_0_1 : 7;                                    // 0x0000(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bEnableForefootIK : 1;                             // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_1_1 : 7;                                    // 0x0001(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bEnableQuadrupedIK : 1;                            // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_2_1 : 7;                                    // 0x0002(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bFootUseFBIK : 1;                                  // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FAnimHumanoidSetting_FootIK) == 0x000001, "Wrong alignment on FAnimHumanoidSetting_FootIK");
static_assert(sizeof(FAnimHumanoidSetting_FootIK) == 0x000004, "Wrong size on FAnimHumanoidSetting_FootIK");

// SharpStruct b1-Managed.MatParamInfo
// 0x0010 (0x0010 - 0x0000)
struct FMatParamInfo final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FloatCurve;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatParamInfo) == 0x000008, "Wrong alignment on FMatParamInfo");
static_assert(sizeof(FMatParamInfo) == 0x000010, "Wrong size on FMatParamInfo");
static_assert(offsetof(FMatParamInfo, ParameterName) == 0x000000, "Member 'FMatParamInfo::ParameterName' has a wrong offset!");
static_assert(offsetof(FMatParamInfo, FloatCurve) == 0x000008, "Member 'FMatParamInfo::FloatCurve' has a wrong offset!");

// SharpStruct b1-Managed.SpawnWaveUnitConfig
// 0x00D0 (0x00D0 - 0x0000)
struct FSpawnWaveUnitConfig final
{
public:
	ESpawnPointType                               SpawnPointType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              EQSTemplate;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGSEnvNamedValue>               QueryConfig;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESpawnWaveLocalSpaceType                      LocalSpaceType;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalSpaceOffset;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 UnitType;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 TamerClass;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ABGUBattlePaceSpawnPointActor>> SpawnPoints;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 BirthBuff;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SpawnMontage;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsFacePlayer : 1;                                 // 0x0078(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_78_1 : 7;                                   // 0x0078(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bIsCatchPlayer : 1;                                // 0x0079(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ABGUCharacterCS>         SpawnMaster;                                       // 0x0080(0x0028)(Edit, BlueprintVisible, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ABUTamerActor>           MasterTamer;                                       // 0x00A8(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnWaveUnitConfig) == 0x000008, "Wrong alignment on FSpawnWaveUnitConfig");
static_assert(sizeof(FSpawnWaveUnitConfig) == 0x0000D0, "Wrong size on FSpawnWaveUnitConfig");
static_assert(offsetof(FSpawnWaveUnitConfig, SpawnPointType) == 0x000000, "Member 'FSpawnWaveUnitConfig::SpawnPointType' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, EQSTemplate) == 0x000008, "Member 'FSpawnWaveUnitConfig::EQSTemplate' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, QueryConfig) == 0x000010, "Member 'FSpawnWaveUnitConfig::QueryConfig' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, LocalSpaceType) == 0x000020, "Member 'FSpawnWaveUnitConfig::LocalSpaceType' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, LocalSpaceOffset) == 0x000028, "Member 'FSpawnWaveUnitConfig::LocalSpaceOffset' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, UnitType) == 0x000040, "Member 'FSpawnWaveUnitConfig::UnitType' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, TamerClass) == 0x000048, "Member 'FSpawnWaveUnitConfig::TamerClass' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, SpawnPoints) == 0x000050, "Member 'FSpawnWaveUnitConfig::SpawnPoints' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, BirthBuff) == 0x000060, "Member 'FSpawnWaveUnitConfig::BirthBuff' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, SpawnMontage) == 0x000070, "Member 'FSpawnWaveUnitConfig::SpawnMontage' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, SpawnMaster) == 0x000080, "Member 'FSpawnWaveUnitConfig::SpawnMaster' has a wrong offset!");
static_assert(offsetof(FSpawnWaveUnitConfig, MasterTamer) == 0x0000A8, "Member 'FSpawnWaveUnitConfig::MasterTamer' has a wrong offset!");

// SharpStruct b1-Managed.SpawnWaveConfig
// 0x0058 (0x0058 - 0x0000)
struct FSpawnWaveConfig final
{
public:
	struct FCompositeCondition_SpawnWaveStart     NextWaveStartCondition;                            // 0x0000(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpawnIntervalRnage;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnWaveUnitConfig>           SpawnWaveUnits;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnWaveConfig) == 0x000008, "Wrong alignment on FSpawnWaveConfig");
static_assert(sizeof(FSpawnWaveConfig) == 0x000058, "Wrong size on FSpawnWaveConfig");
static_assert(offsetof(FSpawnWaveConfig, NextWaveStartCondition) == 0x000000, "Member 'FSpawnWaveConfig::NextWaveStartCondition' has a wrong offset!");
static_assert(offsetof(FSpawnWaveConfig, SpawnIntervalRnage) == 0x000038, "Member 'FSpawnWaveConfig::SpawnIntervalRnage' has a wrong offset!");
static_assert(offsetof(FSpawnWaveConfig, SpawnWaveUnits) == 0x000048, "Member 'FSpawnWaveConfig::SpawnWaveUnits' has a wrong offset!");

// SharpStruct b1-Managed.SpawnWaveConfig_Infinite_OneWaveWrap
// 0x0028 (0x0028 - 0x0000)
struct FSpawnWaveConfig_Infinite_OneWaveWrap final
{
public:
	TArray<struct FSpawnWaveUnitConfig>           SpawnWaveUnits;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         RemainUnitNumToTriggerFill;                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpawnWaveUnitConfig>           SpawnWaveUnits_Fill;                               // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnWaveConfig_Infinite_OneWaveWrap) == 0x000008, "Wrong alignment on FSpawnWaveConfig_Infinite_OneWaveWrap");
static_assert(sizeof(FSpawnWaveConfig_Infinite_OneWaveWrap) == 0x000028, "Wrong size on FSpawnWaveConfig_Infinite_OneWaveWrap");
static_assert(offsetof(FSpawnWaveConfig_Infinite_OneWaveWrap, SpawnWaveUnits) == 0x000000, "Member 'FSpawnWaveConfig_Infinite_OneWaveWrap::SpawnWaveUnits' has a wrong offset!");
static_assert(offsetof(FSpawnWaveConfig_Infinite_OneWaveWrap, RemainUnitNumToTriggerFill) == 0x000010, "Member 'FSpawnWaveConfig_Infinite_OneWaveWrap::RemainUnitNumToTriggerFill' has a wrong offset!");
static_assert(offsetof(FSpawnWaveConfig_Infinite_OneWaveWrap, SpawnWaveUnits_Fill) == 0x000018, "Member 'FSpawnWaveConfig_Infinite_OneWaveWrap::SpawnWaveUnits_Fill' has a wrong offset!");

// SharpStruct b1-Managed.SpawnWaveConfig_Infinite
// 0x0058 (0x0058 - 0x0000)
struct FSpawnWaveConfig_Infinite final
{
public:
	struct FCompositeCondition_SpawnWaveStart     NextWaveStartCondition;                            // 0x0000(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpawnIntervalRnage;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpawnWaveConfig_Infinite_OneWaveWrap> SpawnWaveUnits;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnWaveConfig_Infinite) == 0x000008, "Wrong alignment on FSpawnWaveConfig_Infinite");
static_assert(sizeof(FSpawnWaveConfig_Infinite) == 0x000058, "Wrong size on FSpawnWaveConfig_Infinite");
static_assert(offsetof(FSpawnWaveConfig_Infinite, NextWaveStartCondition) == 0x000000, "Member 'FSpawnWaveConfig_Infinite::NextWaveStartCondition' has a wrong offset!");
static_assert(offsetof(FSpawnWaveConfig_Infinite, SpawnIntervalRnage) == 0x000038, "Member 'FSpawnWaveConfig_Infinite::SpawnIntervalRnage' has a wrong offset!");
static_assert(offsetof(FSpawnWaveConfig_Infinite, SpawnWaveUnits) == 0x000048, "Member 'FSpawnWaveConfig_Infinite::SpawnWaveUnits' has a wrong offset!");

// SharpStruct b1-Managed.BGUCostAttrInfo
// 0x0008 (0x0008 - 0x0000)
struct FBGUCostAttrInfo final
{
public:
	EBGUAttrFloat                                 Attr;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CostValue;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBGUCostAttrInfo) == 0x000004, "Wrong alignment on FBGUCostAttrInfo");
static_assert(sizeof(FBGUCostAttrInfo) == 0x000008, "Wrong size on FBGUCostAttrInfo");
static_assert(offsetof(FBGUCostAttrInfo, Attr) == 0x000000, "Member 'FBGUCostAttrInfo::Attr' has a wrong offset!");
static_assert(offsetof(FBGUCostAttrInfo, CostValue) == 0x000004, "Member 'FBGUCostAttrInfo::CostValue' has a wrong offset!");

// SharpStruct b1-Managed.SpecialStateAM
// 0x0010 (0x0010 - 0x0000)
struct FSpecialStateAM final
{
public:
	class UAnimMontage*                           LoopAM;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EndAM;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialStateAM) == 0x000008, "Wrong alignment on FSpecialStateAM");
static_assert(sizeof(FSpecialStateAM) == 0x000010, "Wrong size on FSpecialStateAM");
static_assert(offsetof(FSpecialStateAM, LoopAM) == 0x000000, "Member 'FSpecialStateAM::LoopAM' has a wrong offset!");
static_assert(offsetof(FSpecialStateAM, EndAM) == 0x000008, "Member 'FSpecialStateAM::EndAM' has a wrong offset!");

// SharpStruct b1-Managed.FPAQI_SelectUnitTypeInfo
// 0x0028 (0x0028 - 0x0000)
struct FFPAQI_SelectUnitTypeInfo final
{
public:
	EPriorityActionSelectUnitType                 SelectUnitType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SelectUnitTypeIntParams;                           // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<float>                                 SelectUnitTypeFloatParams;                         // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFPAQI_SelectUnitTypeInfo) == 0x000008, "Wrong alignment on FFPAQI_SelectUnitTypeInfo");
static_assert(sizeof(FFPAQI_SelectUnitTypeInfo) == 0x000028, "Wrong size on FFPAQI_SelectUnitTypeInfo");
static_assert(offsetof(FFPAQI_SelectUnitTypeInfo, SelectUnitType) == 0x000000, "Member 'FFPAQI_SelectUnitTypeInfo::SelectUnitType' has a wrong offset!");
static_assert(offsetof(FFPAQI_SelectUnitTypeInfo, SelectUnitTypeIntParams) == 0x000008, "Member 'FFPAQI_SelectUnitTypeInfo::SelectUnitTypeIntParams' has a wrong offset!");
static_assert(offsetof(FFPAQI_SelectUnitTypeInfo, SelectUnitTypeFloatParams) == 0x000018, "Member 'FFPAQI_SelectUnitTypeInfo::SelectUnitTypeFloatParams' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_UnitAttr
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_UnitAttr final
{
public:
	EBGUAttrFloat                                 AttrFloatType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareValue;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_UnitAttr) == 0x000004, "Wrong alignment on FDetectCondition_UnitAttr");
static_assert(sizeof(FDetectCondition_UnitAttr) == 0x000008, "Wrong size on FDetectCondition_UnitAttr");
static_assert(offsetof(FDetectCondition_UnitAttr, AttrFloatType) == 0x000000, "Member 'FDetectCondition_UnitAttr::AttrFloatType' has a wrong offset!");
static_assert(offsetof(FDetectCondition_UnitAttr, CompareOperation) == 0x000001, "Member 'FDetectCondition_UnitAttr::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition_UnitAttr, CompareValue) == 0x000004, "Member 'FDetectCondition_UnitAttr::CompareValue' has a wrong offset!");

// SharpStruct b1-Managed.PoleDrinkCondition
// 0x0008 (0x0008 - 0x0000)
struct FPoleDrinkCondition final
{
public:
	EPoleDrinkConditionType                       ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TalentID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoleDrinkCondition) == 0x000004, "Wrong alignment on FPoleDrinkCondition");
static_assert(sizeof(FPoleDrinkCondition) == 0x000008, "Wrong size on FPoleDrinkCondition");
static_assert(offsetof(FPoleDrinkCondition, ConditionType) == 0x000000, "Member 'FPoleDrinkCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FPoleDrinkCondition, TalentID) == 0x000004, "Member 'FPoleDrinkCondition::TalentID' has a wrong offset!");

// SharpStruct b1-Managed.EnvironmentMaskData
// 0x0008 (0x0008 - 0x0000)
struct FEnvironmentMaskData final
{
public:
	ESceneItemSurfaceType                         SurfaceType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Increment;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentMaskData) == 0x000004, "Wrong alignment on FEnvironmentMaskData");
static_assert(sizeof(FEnvironmentMaskData) == 0x000008, "Wrong size on FEnvironmentMaskData");
static_assert(offsetof(FEnvironmentMaskData, SurfaceType) == 0x000000, "Member 'FEnvironmentMaskData::SurfaceType' has a wrong offset!");
static_assert(offsetof(FEnvironmentMaskData, Increment) == 0x000004, "Member 'FEnvironmentMaskData::Increment' has a wrong offset!");

// SharpStruct b1-Managed.TamerInfo_ForAbnormal
// 0x0070 (0x0070 - 0x0000)
struct FTamerInfo_ForAbnormal final
{
public:
	class FString                                 TamerFileName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TamerPath;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResID;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SKMeshPath;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SKScale;                                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FinnalExtendID;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbnormalDispID_Attacker;                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbnormalDispID_Victim;                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ErrorFlag : 1;                                     // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorLog;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EBirth_AbnormalStateImmueType>         ImmueList;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTamerInfo_ForAbnormal) == 0x000008, "Wrong alignment on FTamerInfo_ForAbnormal");
static_assert(sizeof(FTamerInfo_ForAbnormal) == 0x000070, "Wrong size on FTamerInfo_ForAbnormal");
static_assert(offsetof(FTamerInfo_ForAbnormal, TamerFileName) == 0x000000, "Member 'FTamerInfo_ForAbnormal::TamerFileName' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, TamerPath) == 0x000010, "Member 'FTamerInfo_ForAbnormal::TamerPath' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, ResID) == 0x000020, "Member 'FTamerInfo_ForAbnormal::ResID' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, SKMeshPath) == 0x000028, "Member 'FTamerInfo_ForAbnormal::SKMeshPath' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, SKScale) == 0x000038, "Member 'FTamerInfo_ForAbnormal::SKScale' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, FinnalExtendID) == 0x00003C, "Member 'FTamerInfo_ForAbnormal::FinnalExtendID' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, AbnormalDispID_Attacker) == 0x000040, "Member 'FTamerInfo_ForAbnormal::AbnormalDispID_Attacker' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, AbnormalDispID_Victim) == 0x000044, "Member 'FTamerInfo_ForAbnormal::AbnormalDispID_Victim' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, ErrorLog) == 0x000050, "Member 'FTamerInfo_ForAbnormal::ErrorLog' has a wrong offset!");
static_assert(offsetof(FTamerInfo_ForAbnormal, ImmueList) == 0x000060, "Member 'FTamerInfo_ForAbnormal::ImmueList' has a wrong offset!");

// SharpStruct b1-Managed.NpcGuideSplineMoveConfig
// 0x0050 (0x0050 - 0x0000)
struct FNpcGuideSplineMoveConfig final
{
public:
	struct FGsActorGuidReference                  SplineActor;                                       // 0x0000(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NeedSwitchSpeedByDistanceToPlayer : 1;             // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EAIMoveSpeedType                              SplineMoveSpeed;                                   // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance_Sprint;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance_Run;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance_Jog;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBuffer;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcGuideSplineMoveConfig) == 0x000008, "Wrong alignment on FNpcGuideSplineMoveConfig");
static_assert(sizeof(FNpcGuideSplineMoveConfig) == 0x000050, "Wrong size on FNpcGuideSplineMoveConfig");
static_assert(offsetof(FNpcGuideSplineMoveConfig, SplineActor) == 0x000000, "Member 'FNpcGuideSplineMoveConfig::SplineActor' has a wrong offset!");
static_assert(offsetof(FNpcGuideSplineMoveConfig, SplineMoveSpeed) == 0x000039, "Member 'FNpcGuideSplineMoveConfig::SplineMoveSpeed' has a wrong offset!");
static_assert(offsetof(FNpcGuideSplineMoveConfig, MaxDistance_Sprint) == 0x00003C, "Member 'FNpcGuideSplineMoveConfig::MaxDistance_Sprint' has a wrong offset!");
static_assert(offsetof(FNpcGuideSplineMoveConfig, MaxDistance_Run) == 0x000040, "Member 'FNpcGuideSplineMoveConfig::MaxDistance_Run' has a wrong offset!");
static_assert(offsetof(FNpcGuideSplineMoveConfig, MaxDistance_Jog) == 0x000044, "Member 'FNpcGuideSplineMoveConfig::MaxDistance_Jog' has a wrong offset!");
static_assert(offsetof(FNpcGuideSplineMoveConfig, DistanceBuffer) == 0x000048, "Member 'FNpcGuideSplineMoveConfig::DistanceBuffer' has a wrong offset!");

// SharpStruct b1-Managed.GridRow_ForAbnormalDisp
// 0x0010 (0x0010 - 0x0000)
struct FGridRow_ForAbnormalDisp final
{
public:
	TArray<class ASkeletalMeshActor*>             ActorList;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridRow_ForAbnormalDisp) == 0x000008, "Wrong alignment on FGridRow_ForAbnormalDisp");
static_assert(sizeof(FGridRow_ForAbnormalDisp) == 0x000010, "Wrong size on FGridRow_ForAbnormalDisp");
static_assert(offsetof(FGridRow_ForAbnormalDisp, ActorList) == 0x000000, "Member 'FGridRow_ForAbnormalDisp::ActorList' has a wrong offset!");

// SharpStruct b1-Managed.FGSSceneActorActivationInfo
// 0x0010 (0x0010 - 0x0000)
struct FFGSSceneActorActivationInfo final
{
public:
	EGSSceneActorActivationType                   SceneActorActivationType;                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateDistance;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSceneActorActivationInfo) == 0x000004, "Wrong alignment on FFGSSceneActorActivationInfo");
static_assert(sizeof(FFGSSceneActorActivationInfo) == 0x000010, "Wrong size on FFGSSceneActorActivationInfo");
static_assert(offsetof(FFGSSceneActorActivationInfo, SceneActorActivationType) == 0x000000, "Member 'FFGSSceneActorActivationInfo::SceneActorActivationType' has a wrong offset!");
static_assert(offsetof(FFGSSceneActorActivationInfo, ActivateDistance) == 0x000004, "Member 'FFGSSceneActorActivationInfo::ActivateDistance' has a wrong offset!");
static_assert(offsetof(FFGSSceneActorActivationInfo, Tag) == 0x000008, "Member 'FFGSSceneActorActivationInfo::Tag' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_BodyBlend
// 0x0008 (0x0008 - 0x0000)
struct FAnimHumanoidSetting_BodyBlend final
{
public:
	class UBlendSpace*                            BSUpperBodyBlendAdditive;                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_BodyBlend) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_BodyBlend");
static_assert(sizeof(FAnimHumanoidSetting_BodyBlend) == 0x000008, "Wrong size on FAnimHumanoidSetting_BodyBlend");
static_assert(offsetof(FAnimHumanoidSetting_BodyBlend, BSUpperBodyBlendAdditive) == 0x000000, "Member 'FAnimHumanoidSetting_BodyBlend::BSUpperBodyBlendAdditive' has a wrong offset!");

// SharpStruct b1-Managed.AnimalSpawnTemplate
// 0x0028 (0x0028 - 0x0000)
struct FAnimalSpawnTemplate final
{
public:
	class UClass*                                 AnimalTamerClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            SpawnCountRange;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            ScaleRange;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimalSpawnTemplate) == 0x000008, "Wrong alignment on FAnimalSpawnTemplate");
static_assert(sizeof(FAnimalSpawnTemplate) == 0x000028, "Wrong size on FAnimalSpawnTemplate");
static_assert(offsetof(FAnimalSpawnTemplate, AnimalTamerClass) == 0x000000, "Member 'FAnimalSpawnTemplate::AnimalTamerClass' has a wrong offset!");
static_assert(offsetof(FAnimalSpawnTemplate, SpawnCountRange) == 0x000008, "Member 'FAnimalSpawnTemplate::SpawnCountRange' has a wrong offset!");
static_assert(offsetof(FAnimalSpawnTemplate, ScaleRange) == 0x000018, "Member 'FAnimalSpawnTemplate::ScaleRange' has a wrong offset!");

// SharpStruct b1-Managed.NeutralAnimalTerritoryInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FNeutralAnimalTerritoryInfo final
{
public:
	struct FTransform                             BoxTransform;                                      // 0x0000(0x0060)(Edit, BlueprintVisible, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PresetSpawnPositions;                              // 0x0060(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtend;                                         // 0x0070(0x0018)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimalSpawnTemplate>           AnimalTemplates;                                   // 0x0088(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNeutralAnimalTerritoryInfo) == 0x000010, "Wrong alignment on FNeutralAnimalTerritoryInfo");
static_assert(sizeof(FNeutralAnimalTerritoryInfo) == 0x0000A0, "Wrong size on FNeutralAnimalTerritoryInfo");
static_assert(offsetof(FNeutralAnimalTerritoryInfo, BoxTransform) == 0x000000, "Member 'FNeutralAnimalTerritoryInfo::BoxTransform' has a wrong offset!");
static_assert(offsetof(FNeutralAnimalTerritoryInfo, PresetSpawnPositions) == 0x000060, "Member 'FNeutralAnimalTerritoryInfo::PresetSpawnPositions' has a wrong offset!");
static_assert(offsetof(FNeutralAnimalTerritoryInfo, BoxExtend) == 0x000070, "Member 'FNeutralAnimalTerritoryInfo::BoxExtend' has a wrong offset!");
static_assert(offsetof(FNeutralAnimalTerritoryInfo, AnimalTemplates) == 0x000088, "Member 'FNeutralAnimalTerritoryInfo::AnimalTemplates' has a wrong offset!");

// SharpStruct b1-Managed.AreaUnitFilter
// 0x0018 (0x0018 - 0x0000)
struct FAreaUnitFilter final
{
public:
	EAreaUnitFilterType                           UnitFilterType;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpecifiedResIDList;                                // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAreaUnitFilter) == 0x000008, "Wrong alignment on FAreaUnitFilter");
static_assert(sizeof(FAreaUnitFilter) == 0x000018, "Wrong size on FAreaUnitFilter");
static_assert(offsetof(FAreaUnitFilter, UnitFilterType) == 0x000000, "Member 'FAreaUnitFilter::UnitFilterType' has a wrong offset!");
static_assert(offsetof(FAreaUnitFilter, SpecifiedResIDList) == 0x000008, "Member 'FAreaUnitFilter::SpecifiedResIDList' has a wrong offset!");

// SharpStruct b1-Managed.AreaAbilityMask
// 0x0004 (0x0004 - 0x0000)
struct FAreaAbilityMask final
{
public:
	int32                                         Mask;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAreaAbilityMask) == 0x000004, "Wrong alignment on FAreaAbilityMask");
static_assert(sizeof(FAreaAbilityMask) == 0x000004, "Wrong size on FAreaAbilityMask");
static_assert(offsetof(FAreaAbilityMask, Mask) == 0x000000, "Member 'FAreaAbilityMask::Mask' has a wrong offset!");

// SharpStruct b1-Managed.FGSForceFightUnitCondition
// 0x0078 (0x0078 - 0x0000)
struct FFGSForceFightUnitCondition final
{
public:
	TArray<class ABGUCharacterCS*>                ObservedUnits;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<class ABUTamerActor*>                  ObservedTamers;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          ObservedTamerRefs;                                 // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveHasUnitState : 1;                           // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBGUUnitState>                         ObserveUnitStates;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveHasSimpleState : 1;                         // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBGUSimpleState>                       ObserveSimpleStates;                               // 0x0050(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveHasBuff : 1;                                // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ObserveBuffIDs;                                    // 0x0068(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSForceFightUnitCondition) == 0x000008, "Wrong alignment on FFGSForceFightUnitCondition");
static_assert(sizeof(FFGSForceFightUnitCondition) == 0x000078, "Wrong size on FFGSForceFightUnitCondition");
static_assert(offsetof(FFGSForceFightUnitCondition, ObservedUnits) == 0x000000, "Member 'FFGSForceFightUnitCondition::ObservedUnits' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitCondition, ObservedTamers) == 0x000010, "Member 'FFGSForceFightUnitCondition::ObservedTamers' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitCondition, ObservedTamerRefs) == 0x000020, "Member 'FFGSForceFightUnitCondition::ObservedTamerRefs' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitCondition, ObserveUnitStates) == 0x000038, "Member 'FFGSForceFightUnitCondition::ObserveUnitStates' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitCondition, ObserveSimpleStates) == 0x000050, "Member 'FFGSForceFightUnitCondition::ObserveSimpleStates' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitCondition, ObserveBuffIDs) == 0x000068, "Member 'FFGSForceFightUnitCondition::ObserveBuffIDs' has a wrong offset!");

// SharpStruct b1-Managed.FGSForceFightWhiteListConfig
// 0x0038 (0x0038 - 0x0000)
struct FFGSForceFightWhiteListConfig final
{
public:
	uint8                                         IgnorePlayer : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class ABGUCharacterCS>> IgnoreUnits;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ABUTamerActor>>   IgnoreTamers;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          IgnoreTamerRefs;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSForceFightWhiteListConfig) == 0x000008, "Wrong alignment on FFGSForceFightWhiteListConfig");
static_assert(sizeof(FFGSForceFightWhiteListConfig) == 0x000038, "Wrong size on FFGSForceFightWhiteListConfig");
static_assert(offsetof(FFGSForceFightWhiteListConfig, IgnoreUnits) == 0x000008, "Member 'FFGSForceFightWhiteListConfig::IgnoreUnits' has a wrong offset!");
static_assert(offsetof(FFGSForceFightWhiteListConfig, IgnoreTamers) == 0x000018, "Member 'FFGSForceFightWhiteListConfig::IgnoreTamers' has a wrong offset!");
static_assert(offsetof(FFGSForceFightWhiteListConfig, IgnoreTamerRefs) == 0x000028, "Member 'FFGSForceFightWhiteListConfig::IgnoreTamerRefs' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_PlayerLocomotion_Free
// 0x0168 (0x0168 - 0x0000)
struct FAnimHumanoidSetting_PlayerLocomotion_Free final
{
public:
	class UCurveVector*                           FreeMovementCurve;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSFreeAdditiveMovingLean;                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSWalkLoopFwd;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunLoopFwd;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunLoopAdditive;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunLoopRotationAdditive;                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRushLoopFwd;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRushLoopLean;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartBwdL;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartLeft;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartFwd;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartRight;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartBwdR;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkTurnBwdL;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkTurnLeft;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkTurnRight;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkTurnBwdR;                                    // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeWalkStop;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartBwdL;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartLeft;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartFwd;                                     // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartRight;                                   // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartBwdR;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnBwdL;                                     // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnLeft;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnFwdL;                                     // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnFwdR;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnRight;                                    // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnBwdR;                                     // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnFwdFallingVelocityAdditive;               // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnFwdSpeedAdditive;                         // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnBwdFallingVelocityAdditive;               // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeRunStop;                                     // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintStartBwdL;                             // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintStartLeft;                             // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintStartFwd;                              // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintStartRight;                            // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintStartBwdR;                             // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintTurnBwdL;                              // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintTurnLeft;                              // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintTurnRight;                             // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintTurnBwdR;                              // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeSprintStop;                                  // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintStopSlopeAngleThreshold;                     // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ASFreeSprintStopSlopeUp;                           // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_PlayerLocomotion_Free) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_PlayerLocomotion_Free");
static_assert(sizeof(FAnimHumanoidSetting_PlayerLocomotion_Free) == 0x000168, "Wrong size on FAnimHumanoidSetting_PlayerLocomotion_Free");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, FreeMovementCurve) == 0x000000, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::FreeMovementCurve' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, BSFreeAdditiveMovingLean) == 0x000008, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::BSFreeAdditiveMovingLean' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, BSWalkLoopFwd) == 0x000010, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::BSWalkLoopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, BSRunLoopFwd) == 0x000018, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::BSRunLoopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, BSRunLoopAdditive) == 0x000020, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::BSRunLoopAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, BSRunLoopRotationAdditive) == 0x000028, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::BSRunLoopRotationAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, BSRushLoopFwd) == 0x000030, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::BSRushLoopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, BSRushLoopLean) == 0x000038, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::BSRushLoopLean' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkStartBwdL) == 0x000040, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkStartBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkStartLeft) == 0x000048, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkStartLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkStartFwd) == 0x000050, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkStartRight) == 0x000058, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkStartRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkStartBwdR) == 0x000060, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkStartBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkTurnBwdL) == 0x000068, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkTurnBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkTurnLeft) == 0x000070, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkTurnLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkTurnRight) == 0x000078, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkTurnRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASWalkTurnBwdR) == 0x000080, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASWalkTurnBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeWalkStop) == 0x000088, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeWalkStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunStartBwdL) == 0x000090, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunStartBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunStartLeft) == 0x000098, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunStartLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunStartFwd) == 0x0000A0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunStartRight) == 0x0000A8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunStartRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunStartBwdR) == 0x0000B0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunStartBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnBwdL) == 0x0000B8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnLeft) == 0x0000C0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnFwdL) == 0x0000C8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnFwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnFwdR) == 0x0000D0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnFwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnRight) == 0x0000D8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnBwdR) == 0x0000E0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnFwdFallingVelocityAdditive) == 0x0000E8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnFwdFallingVelocityAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnFwdSpeedAdditive) == 0x0000F0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnFwdSpeedAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASRunTurnBwdFallingVelocityAdditive) == 0x0000F8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASRunTurnBwdFallingVelocityAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeRunStop) == 0x000100, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeRunStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintStartBwdL) == 0x000108, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintStartBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintStartLeft) == 0x000110, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintStartLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintStartFwd) == 0x000118, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintStartRight) == 0x000120, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintStartRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintStartBwdR) == 0x000128, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintStartBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintTurnBwdL) == 0x000130, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintTurnBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintTurnLeft) == 0x000138, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintTurnLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintTurnRight) == 0x000140, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintTurnRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintTurnBwdR) == 0x000148, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintTurnBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintStop) == 0x000150, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, SprintStopSlopeAngleThreshold) == 0x000158, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::SprintStopSlopeAngleThreshold' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Free, ASFreeSprintStopSlopeUp) == 0x000160, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Free::ASFreeSprintStopSlopeUp' has a wrong offset!");

// SharpStruct b1-Managed.FGSForceFightTriggerUnitFilter
// 0x0048 (0x0048 - 0x0000)
struct FFGSForceFightTriggerUnitFilter final
{
public:
	EGSForceFightUnitFilterType                   FilterType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class ABGUCharacterCS>> FilterUnits;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ABUTamerActor>>   FilterTamers;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          FilterTamerRefs;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EGSForceFightUnitType>                 FilterUnitTypes;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSForceFightTriggerUnitFilter) == 0x000008, "Wrong alignment on FFGSForceFightTriggerUnitFilter");
static_assert(sizeof(FFGSForceFightTriggerUnitFilter) == 0x000048, "Wrong size on FFGSForceFightTriggerUnitFilter");
static_assert(offsetof(FFGSForceFightTriggerUnitFilter, FilterType) == 0x000000, "Member 'FFGSForceFightTriggerUnitFilter::FilterType' has a wrong offset!");
static_assert(offsetof(FFGSForceFightTriggerUnitFilter, FilterUnits) == 0x000008, "Member 'FFGSForceFightTriggerUnitFilter::FilterUnits' has a wrong offset!");
static_assert(offsetof(FFGSForceFightTriggerUnitFilter, FilterTamers) == 0x000018, "Member 'FFGSForceFightTriggerUnitFilter::FilterTamers' has a wrong offset!");
static_assert(offsetof(FFGSForceFightTriggerUnitFilter, FilterTamerRefs) == 0x000028, "Member 'FFGSForceFightTriggerUnitFilter::FilterTamerRefs' has a wrong offset!");
static_assert(offsetof(FFGSForceFightTriggerUnitFilter, FilterUnitTypes) == 0x000038, "Member 'FFGSForceFightTriggerUnitFilter::FilterUnitTypes' has a wrong offset!");

// SharpStruct b1-Managed.FGSForceFightUnitGroupConfig
// 0x0170 (0x0170 - 0x0000)
struct FFGSForceFightUnitGroupConfig final
{
public:
	EGSForceFightCondition                        TriggerCondition;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFGSForceFightTriggerUnitFilter        TriggerUnitFilter;                                 // 0x0008(0x0048)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFGSForceFightUnitCondition>    ObserveUnitsConditions;                            // 0x0050(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EGSForceFightTargetType                       ForceFightTargetType;                              // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ABGUCharacterCS>         TargetUnit;                                        // 0x0068(0x0028)(Edit, BlueprintVisible, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ABUTamerActor>           TargetTamer;                                       // 0x0090(0x0028)(Edit, BlueprintVisible, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsActorGuidReference                  TargetTamerRef;                                    // 0x00B8(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGSForceFightTriggerUnitType>          TriggerUnitsType;                                  // 0x00F0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ABGUCharacterCS>> TriggerUnits;                                      // 0x0100(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ABUTamerActor>>   TriggerTamers;                                     // 0x0110(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          TriggerTamerRefs;                                  // 0x0120(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFGSForceFightWhiteListConfig          TriggerUnitsWhiteList;                             // 0x0130(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CanRepeat : 1;                                     // 0x0168(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FFGSForceFightUnitGroupConfig) == 0x000008, "Wrong alignment on FFGSForceFightUnitGroupConfig");
static_assert(sizeof(FFGSForceFightUnitGroupConfig) == 0x000170, "Wrong size on FFGSForceFightUnitGroupConfig");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TriggerCondition) == 0x000000, "Member 'FFGSForceFightUnitGroupConfig::TriggerCondition' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TriggerUnitFilter) == 0x000008, "Member 'FFGSForceFightUnitGroupConfig::TriggerUnitFilter' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, ObserveUnitsConditions) == 0x000050, "Member 'FFGSForceFightUnitGroupConfig::ObserveUnitsConditions' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, ForceFightTargetType) == 0x000060, "Member 'FFGSForceFightUnitGroupConfig::ForceFightTargetType' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TargetUnit) == 0x000068, "Member 'FFGSForceFightUnitGroupConfig::TargetUnit' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TargetTamer) == 0x000090, "Member 'FFGSForceFightUnitGroupConfig::TargetTamer' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TargetTamerRef) == 0x0000B8, "Member 'FFGSForceFightUnitGroupConfig::TargetTamerRef' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TriggerUnitsType) == 0x0000F0, "Member 'FFGSForceFightUnitGroupConfig::TriggerUnitsType' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TriggerUnits) == 0x000100, "Member 'FFGSForceFightUnitGroupConfig::TriggerUnits' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TriggerTamers) == 0x000110, "Member 'FFGSForceFightUnitGroupConfig::TriggerTamers' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TriggerTamerRefs) == 0x000120, "Member 'FFGSForceFightUnitGroupConfig::TriggerTamerRefs' has a wrong offset!");
static_assert(offsetof(FFGSForceFightUnitGroupConfig, TriggerUnitsWhiteList) == 0x000130, "Member 'FFGSForceFightUnitGroupConfig::TriggerUnitsWhiteList' has a wrong offset!");

// SharpStruct b1-Managed.TamerStrategyPreDefinesForLevelOverride
// 0x0038 (0x0038 - 0x0000)
struct FTamerStrategyPreDefinesForLevelOverride final
{
public:
	float                                         DistanceForForceSpawn;                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffsetSpawnLimitMeter;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOffsetUnloadLimitMeter;                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDelayDestroyTime;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForActorBeginPlayMeter;                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForUnloadMeter;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AsyncTraceMinEffectRange;                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AsyncTraceMaxEffectRange;                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForPatrolActorBeginPlayMeter;              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceForUnloadPatrolUnitMeter;                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreloadDistanceMedium;                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreloadDistanceFarthest;                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreloadDistanceLoadMonsterClass;                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreloadDistanceUnLoadMonsterClass;                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTamerStrategyPreDefinesForLevelOverride) == 0x000004, "Wrong alignment on FTamerStrategyPreDefinesForLevelOverride");
static_assert(sizeof(FTamerStrategyPreDefinesForLevelOverride) == 0x000038, "Wrong size on FTamerStrategyPreDefinesForLevelOverride");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, DistanceForForceSpawn) == 0x000000, "Member 'FTamerStrategyPreDefinesForLevelOverride::DistanceForForceSpawn' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, ZOffsetSpawnLimitMeter) == 0x000004, "Member 'FTamerStrategyPreDefinesForLevelOverride::ZOffsetSpawnLimitMeter' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, ZOffsetUnloadLimitMeter) == 0x000008, "Member 'FTamerStrategyPreDefinesForLevelOverride::ZOffsetUnloadLimitMeter' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, DefaultDelayDestroyTime) == 0x00000C, "Member 'FTamerStrategyPreDefinesForLevelOverride::DefaultDelayDestroyTime' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, DistanceForActorBeginPlayMeter) == 0x000010, "Member 'FTamerStrategyPreDefinesForLevelOverride::DistanceForActorBeginPlayMeter' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, DistanceForUnloadMeter) == 0x000014, "Member 'FTamerStrategyPreDefinesForLevelOverride::DistanceForUnloadMeter' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, AsyncTraceMinEffectRange) == 0x000018, "Member 'FTamerStrategyPreDefinesForLevelOverride::AsyncTraceMinEffectRange' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, AsyncTraceMaxEffectRange) == 0x00001C, "Member 'FTamerStrategyPreDefinesForLevelOverride::AsyncTraceMaxEffectRange' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, DistanceForPatrolActorBeginPlayMeter) == 0x000020, "Member 'FTamerStrategyPreDefinesForLevelOverride::DistanceForPatrolActorBeginPlayMeter' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, DistanceForUnloadPatrolUnitMeter) == 0x000024, "Member 'FTamerStrategyPreDefinesForLevelOverride::DistanceForUnloadPatrolUnitMeter' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, PreloadDistanceMedium) == 0x000028, "Member 'FTamerStrategyPreDefinesForLevelOverride::PreloadDistanceMedium' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, PreloadDistanceFarthest) == 0x00002C, "Member 'FTamerStrategyPreDefinesForLevelOverride::PreloadDistanceFarthest' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, PreloadDistanceLoadMonsterClass) == 0x000030, "Member 'FTamerStrategyPreDefinesForLevelOverride::PreloadDistanceLoadMonsterClass' has a wrong offset!");
static_assert(offsetof(FTamerStrategyPreDefinesForLevelOverride, PreloadDistanceUnLoadMonsterClass) == 0x000034, "Member 'FTamerStrategyPreDefinesForLevelOverride::PreloadDistanceUnLoadMonsterClass' has a wrong offset!");

// SharpStruct b1-Managed.EnvironmentItemStateMachineExtAbilityMask
// 0x0004 (0x0004 - 0x0000)
struct FEnvironmentItemStateMachineExtAbilityMask final
{
public:
	int32                                         Mask;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentItemStateMachineExtAbilityMask) == 0x000004, "Wrong alignment on FEnvironmentItemStateMachineExtAbilityMask");
static_assert(sizeof(FEnvironmentItemStateMachineExtAbilityMask) == 0x000004, "Wrong size on FEnvironmentItemStateMachineExtAbilityMask");
static_assert(offsetof(FEnvironmentItemStateMachineExtAbilityMask, Mask) == 0x000000, "Member 'FEnvironmentItemStateMachineExtAbilityMask::Mask' has a wrong offset!");

// SharpStruct b1-Managed.CricketMovePointConfig
// 0x0080 (0x0080 - 0x0000)
struct FCricketMovePointConfig final
{
public:
	struct FTransform                             PointTrans;                                        // 0x0000(0x0060)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IdleTime;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  AnimIdleList;                                      // 0x0068(0x0010)(Edit, NativeAccessSpecifierPublic)
	class UAnimMontage*                           JumpAnim;                                          // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCricketMovePointConfig) == 0x000010, "Wrong alignment on FCricketMovePointConfig");
static_assert(sizeof(FCricketMovePointConfig) == 0x000080, "Wrong size on FCricketMovePointConfig");
static_assert(offsetof(FCricketMovePointConfig, PointTrans) == 0x000000, "Member 'FCricketMovePointConfig::PointTrans' has a wrong offset!");
static_assert(offsetof(FCricketMovePointConfig, IdleTime) == 0x000060, "Member 'FCricketMovePointConfig::IdleTime' has a wrong offset!");
static_assert(offsetof(FCricketMovePointConfig, AnimIdleList) == 0x000068, "Member 'FCricketMovePointConfig::AnimIdleList' has a wrong offset!");
static_assert(offsetof(FCricketMovePointConfig, JumpAnim) == 0x000078, "Member 'FCricketMovePointConfig::JumpAnim' has a wrong offset!");

// SharpStruct b1-Managed.MapSymbolConfig
// 0x0020 (0x0020 - 0x0000)
struct FMapSymbolConfig final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapSymbolType                                MapSymbolType;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnlockRadius;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnlockHeight;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapSymbolConfig) == 0x000008, "Wrong alignment on FMapSymbolConfig");
static_assert(sizeof(FMapSymbolConfig) == 0x000020, "Wrong size on FMapSymbolConfig");
static_assert(offsetof(FMapSymbolConfig, Name) == 0x000000, "Member 'FMapSymbolConfig::Name' has a wrong offset!");
static_assert(offsetof(FMapSymbolConfig, MapSymbolType) == 0x000010, "Member 'FMapSymbolConfig::MapSymbolType' has a wrong offset!");
static_assert(offsetof(FMapSymbolConfig, UnlockRadius) == 0x000014, "Member 'FMapSymbolConfig::UnlockRadius' has a wrong offset!");
static_assert(offsetof(FMapSymbolConfig, UnlockHeight) == 0x000018, "Member 'FMapSymbolConfig::UnlockHeight' has a wrong offset!");

// SharpStruct b1-Managed.FGSLeisureWithWeight
// 0x0010 (0x0010 - 0x0000)
struct FFGSLeisureWithWeight final
{
public:
	class UAnimMontage*                           LeisureReference;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSLeisureWithWeight) == 0x000008, "Wrong alignment on FFGSLeisureWithWeight");
static_assert(sizeof(FFGSLeisureWithWeight) == 0x000010, "Wrong size on FFGSLeisureWithWeight");
static_assert(offsetof(FFGSLeisureWithWeight, LeisureReference) == 0x000000, "Member 'FFGSLeisureWithWeight::LeisureReference' has a wrong offset!");
static_assert(offsetof(FFGSLeisureWithWeight, Weight) == 0x000008, "Member 'FFGSLeisureWithWeight::Weight' has a wrong offset!");

// SharpStruct b1-Managed.TreeInfo
// 0x0048 (0x0048 - 0x0000)
struct FTreeInfo final
{
public:
	struct FVector                                Bounds_WithScaled;                                 // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTreeInfo) == 0x000008, "Wrong alignment on FTreeInfo");
static_assert(sizeof(FTreeInfo) == 0x000048, "Wrong size on FTreeInfo");
static_assert(offsetof(FTreeInfo, Bounds_WithScaled) == 0x000000, "Member 'FTreeInfo::Bounds_WithScaled' has a wrong offset!");
static_assert(offsetof(FTreeInfo, Pos) == 0x000018, "Member 'FTreeInfo::Pos' has a wrong offset!");
static_assert(offsetof(FTreeInfo, Rot) == 0x000030, "Member 'FTreeInfo::Rot' has a wrong offset!");

// SharpStruct b1-Managed.AnimationInfo
// 0x0020 (0x0020 - 0x0000)
struct FAnimationInfo final
{
public:
	class FString                                 AnimationClipName;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationClipStartTime;                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationClipEndTime;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DisableInputAtStart : 1;                           // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FAnimationInfo) == 0x000008, "Wrong alignment on FAnimationInfo");
static_assert(sizeof(FAnimationInfo) == 0x000020, "Wrong size on FAnimationInfo");
static_assert(offsetof(FAnimationInfo, AnimationClipName) == 0x000000, "Member 'FAnimationInfo::AnimationClipName' has a wrong offset!");
static_assert(offsetof(FAnimationInfo, AnimationClipStartTime) == 0x000010, "Member 'FAnimationInfo::AnimationClipStartTime' has a wrong offset!");
static_assert(offsetof(FAnimationInfo, AnimationClipEndTime) == 0x000014, "Member 'FAnimationInfo::AnimationClipEndTime' has a wrong offset!");

// SharpStruct b1-Managed.TreeBirdSpawnConfig
// 0x0038 (0x0038 - 0x0000)
struct FTreeBirdSpawnConfig final
{
public:
	class UClass*                                 SpawnTemplate;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRadius;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSpdControl;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSpawnAreaAngle;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnCheckInterval;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefreshDistance;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Range                            SpawnNum;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyDist;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTreeBirdSpawnConfig) == 0x000008, "Wrong alignment on FTreeBirdSpawnConfig");
static_assert(sizeof(FTreeBirdSpawnConfig) == 0x000038, "Wrong size on FTreeBirdSpawnConfig");
static_assert(offsetof(FTreeBirdSpawnConfig, SpawnTemplate) == 0x000000, "Member 'FTreeBirdSpawnConfig::SpawnTemplate' has a wrong offset!");
static_assert(offsetof(FTreeBirdSpawnConfig, InnerRadius) == 0x000008, "Member 'FTreeBirdSpawnConfig::InnerRadius' has a wrong offset!");
static_assert(offsetof(FTreeBirdSpawnConfig, OutRadius) == 0x00000C, "Member 'FTreeBirdSpawnConfig::OutRadius' has a wrong offset!");
static_assert(offsetof(FTreeBirdSpawnConfig, PlayerSpdControl) == 0x000010, "Member 'FTreeBirdSpawnConfig::PlayerSpdControl' has a wrong offset!");
static_assert(offsetof(FTreeBirdSpawnConfig, SprintSpawnAreaAngle) == 0x000014, "Member 'FTreeBirdSpawnConfig::SprintSpawnAreaAngle' has a wrong offset!");
static_assert(offsetof(FTreeBirdSpawnConfig, SpawnCheckInterval) == 0x000018, "Member 'FTreeBirdSpawnConfig::SpawnCheckInterval' has a wrong offset!");
static_assert(offsetof(FTreeBirdSpawnConfig, RefreshDistance) == 0x00001C, "Member 'FTreeBirdSpawnConfig::RefreshDistance' has a wrong offset!");
static_assert(offsetof(FTreeBirdSpawnConfig, SpawnNum) == 0x000020, "Member 'FTreeBirdSpawnConfig::SpawnNum' has a wrong offset!");
static_assert(offsetof(FTreeBirdSpawnConfig, DestroyDist) == 0x000030, "Member 'FTreeBirdSpawnConfig::DestroyDist' has a wrong offset!");

// SharpStruct b1-Managed.CharacterAssetConfig
// 0x0018 (0x0018 - 0x0000)
struct FCharacterAssetConfig final
{
public:
	TArray<EMobAttackType>                        MobAttackTypeList;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MinSpawnNum;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnNum;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAssetConfig) == 0x000008, "Wrong alignment on FCharacterAssetConfig");
static_assert(sizeof(FCharacterAssetConfig) == 0x000018, "Wrong size on FCharacterAssetConfig");
static_assert(offsetof(FCharacterAssetConfig, MobAttackTypeList) == 0x000000, "Member 'FCharacterAssetConfig::MobAttackTypeList' has a wrong offset!");
static_assert(offsetof(FCharacterAssetConfig, MinSpawnNum) == 0x000010, "Member 'FCharacterAssetConfig::MinSpawnNum' has a wrong offset!");
static_assert(offsetof(FCharacterAssetConfig, MaxSpawnNum) == 0x000014, "Member 'FCharacterAssetConfig::MaxSpawnNum' has a wrong offset!");

// SharpStruct b1-Managed.ProceduralSpawnWaveConfig
// 0x0030 (0x0030 - 0x0000)
struct FProceduralSpawnWaveConfig final
{
public:
	struct FCharacterAssetConfig                  CharacterAssetConfig;                              // 0x0000(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWDataAsset*                          SpawnEffectDataAsset;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESPAWN_METHOD                                 SpawnMethod;                                       // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESPAWN_BASE_LOCATION                          SpawnBaseLoc;                                      // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESPAWN_CONDITION                              SpawnCondition;                                    // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnPercentageParam;                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnWaveIndexParam;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnTriggerDistanceParam;                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralSpawnWaveConfig) == 0x000008, "Wrong alignment on FProceduralSpawnWaveConfig");
static_assert(sizeof(FProceduralSpawnWaveConfig) == 0x000030, "Wrong size on FProceduralSpawnWaveConfig");
static_assert(offsetof(FProceduralSpawnWaveConfig, CharacterAssetConfig) == 0x000000, "Member 'FProceduralSpawnWaveConfig::CharacterAssetConfig' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnWaveConfig, SpawnEffectDataAsset) == 0x000018, "Member 'FProceduralSpawnWaveConfig::SpawnEffectDataAsset' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnWaveConfig, SpawnMethod) == 0x000020, "Member 'FProceduralSpawnWaveConfig::SpawnMethod' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnWaveConfig, SpawnBaseLoc) == 0x000021, "Member 'FProceduralSpawnWaveConfig::SpawnBaseLoc' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnWaveConfig, SpawnCondition) == 0x000022, "Member 'FProceduralSpawnWaveConfig::SpawnCondition' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnWaveConfig, SpawnPercentageParam) == 0x000024, "Member 'FProceduralSpawnWaveConfig::SpawnPercentageParam' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnWaveConfig, SpawnWaveIndexParam) == 0x000028, "Member 'FProceduralSpawnWaveConfig::SpawnWaveIndexParam' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnWaveConfig, SpawnTriggerDistanceParam) == 0x00002C, "Member 'FProceduralSpawnWaveConfig::SpawnTriggerDistanceParam' has a wrong offset!");

// SharpStruct b1-Managed.FGSGroupFollowConfig
// 0x001C (0x001C - 0x0000)
struct FFGSGroupFollowConfig final
{
public:
	uint8                                         bEnableAdjustTimeRate : 1;                         // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeRate;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeRate;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRateDistance;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseRateDistance;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseRateDistance;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRateDistance;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSGroupFollowConfig) == 0x000004, "Wrong alignment on FFGSGroupFollowConfig");
static_assert(sizeof(FFGSGroupFollowConfig) == 0x00001C, "Wrong size on FFGSGroupFollowConfig");
static_assert(offsetof(FFGSGroupFollowConfig, MinTimeRate) == 0x000004, "Member 'FFGSGroupFollowConfig::MinTimeRate' has a wrong offset!");
static_assert(offsetof(FFGSGroupFollowConfig, MaxTimeRate) == 0x000008, "Member 'FFGSGroupFollowConfig::MaxTimeRate' has a wrong offset!");
static_assert(offsetof(FFGSGroupFollowConfig, MinRateDistance) == 0x00000C, "Member 'FFGSGroupFollowConfig::MinRateDistance' has a wrong offset!");
static_assert(offsetof(FFGSGroupFollowConfig, DecreaseRateDistance) == 0x000010, "Member 'FFGSGroupFollowConfig::DecreaseRateDistance' has a wrong offset!");
static_assert(offsetof(FFGSGroupFollowConfig, IncreaseRateDistance) == 0x000014, "Member 'FFGSGroupFollowConfig::IncreaseRateDistance' has a wrong offset!");
static_assert(offsetof(FFGSGroupFollowConfig, MaxRateDistance) == 0x000018, "Member 'FFGSGroupFollowConfig::MaxRateDistance' has a wrong offset!");

// SharpStruct b1-Managed.TortoiseLevelGroupConfig
// 0x0010 (0x0010 - 0x0000)
struct FTortoiseLevelGroupConfig final
{
public:
	TArray<class FString>                         ManagedLevels;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTortoiseLevelGroupConfig) == 0x000008, "Wrong alignment on FTortoiseLevelGroupConfig");
static_assert(sizeof(FTortoiseLevelGroupConfig) == 0x000010, "Wrong size on FTortoiseLevelGroupConfig");
static_assert(offsetof(FTortoiseLevelGroupConfig, ManagedLevels) == 0x000000, "Member 'FTortoiseLevelGroupConfig::ManagedLevels' has a wrong offset!");

// SharpStruct b1-Managed.TortoiseManagedStateLevelConfig
// 0x0050 (0x0050 - 0x0000)
struct FTortoiseManagedStateLevelConfig final
{
public:
	TMap<EGSLevelState, struct FTortoiseLevelGroupConfig> ManagedStateLevels;                                // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTortoiseManagedStateLevelConfig) == 0x000008, "Wrong alignment on FTortoiseManagedStateLevelConfig");
static_assert(sizeof(FTortoiseManagedStateLevelConfig) == 0x000050, "Wrong size on FTortoiseManagedStateLevelConfig");
static_assert(offsetof(FTortoiseManagedStateLevelConfig, ManagedStateLevels) == 0x000000, "Member 'FTortoiseManagedStateLevelConfig::ManagedStateLevels' has a wrong offset!");

// SharpStruct b1-Managed.PriorityActInfo_AddBuff
// 0x0010 (0x0010 - 0x0000)
struct FPriorityActInfo_AddBuff final
{
public:
	TArray<int32>                                 BuffIDList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPriorityActInfo_AddBuff) == 0x000008, "Wrong alignment on FPriorityActInfo_AddBuff");
static_assert(sizeof(FPriorityActInfo_AddBuff) == 0x000010, "Wrong size on FPriorityActInfo_AddBuff");
static_assert(offsetof(FPriorityActInfo_AddBuff, BuffIDList) == 0x000000, "Member 'FPriorityActInfo_AddBuff::BuffIDList' has a wrong offset!");

// SharpStruct b1-Managed.TortoiseLevelStreamingBoxConfig
// 0x0088 (0x0088 - 0x0000)
struct FTortoiseLevelStreamingBoxConfig final
{
public:
	struct FGsActorGuidReference                  Actor;                                             // 0x0000(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTortoiseManagedStateLevelConfig       ManagedStateLevelsConfig;                          // 0x0038(0x0050)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTortoiseLevelStreamingBoxConfig) == 0x000008, "Wrong alignment on FTortoiseLevelStreamingBoxConfig");
static_assert(sizeof(FTortoiseLevelStreamingBoxConfig) == 0x000088, "Wrong size on FTortoiseLevelStreamingBoxConfig");
static_assert(offsetof(FTortoiseLevelStreamingBoxConfig, Actor) == 0x000000, "Member 'FTortoiseLevelStreamingBoxConfig::Actor' has a wrong offset!");
static_assert(offsetof(FTortoiseLevelStreamingBoxConfig, ManagedStateLevelsConfig) == 0x000038, "Member 'FTortoiseLevelStreamingBoxConfig::ManagedStateLevelsConfig' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_UnitState
// 0x0001 (0x0001 - 0x0000)
struct FDetectCondition_UnitState final
{
public:
	EBGUUnitState                                 UnitState;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_UnitState) == 0x000001, "Wrong alignment on FDetectCondition_UnitState");
static_assert(sizeof(FDetectCondition_UnitState) == 0x000001, "Wrong size on FDetectCondition_UnitState");
static_assert(offsetof(FDetectCondition_UnitState, UnitState) == 0x000000, "Member 'FDetectCondition_UnitState::UnitState' has a wrong offset!");

// SharpStruct b1-Managed.SplineFlyMoveConfig
// 0x0070 (0x0070 - 0x0000)
struct FSplineFlyMoveConfig final
{
public:
	ESplineFlyUnitType                            UnitType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ABUTamerActor>           Unit;                                              // 0x0008(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  SplineActor;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FlySpeed;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JogSpeed;                                          // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeed;                                          // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintSpeed;                                       // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineFlyMoveConfig) == 0x000008, "Wrong alignment on FSplineFlyMoveConfig");
static_assert(sizeof(FSplineFlyMoveConfig) == 0x000070, "Wrong size on FSplineFlyMoveConfig");
static_assert(offsetof(FSplineFlyMoveConfig, UnitType) == 0x000000, "Member 'FSplineFlyMoveConfig::UnitType' has a wrong offset!");
static_assert(offsetof(FSplineFlyMoveConfig, Unit) == 0x000008, "Member 'FSplineFlyMoveConfig::Unit' has a wrong offset!");
static_assert(offsetof(FSplineFlyMoveConfig, SplineActor) == 0x000030, "Member 'FSplineFlyMoveConfig::SplineActor' has a wrong offset!");
static_assert(offsetof(FSplineFlyMoveConfig, FlySpeed) == 0x000058, "Member 'FSplineFlyMoveConfig::FlySpeed' has a wrong offset!");
static_assert(offsetof(FSplineFlyMoveConfig, DelayTime) == 0x000060, "Member 'FSplineFlyMoveConfig::DelayTime' has a wrong offset!");
static_assert(offsetof(FSplineFlyMoveConfig, JogSpeed) == 0x000064, "Member 'FSplineFlyMoveConfig::JogSpeed' has a wrong offset!");
static_assert(offsetof(FSplineFlyMoveConfig, RunSpeed) == 0x000068, "Member 'FSplineFlyMoveConfig::RunSpeed' has a wrong offset!");
static_assert(offsetof(FSplineFlyMoveConfig, SprintSpeed) == 0x00006C, "Member 'FSplineFlyMoveConfig::SprintSpeed' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove_Climb_High
// 0x0028 (0x0028 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove_Climb_High final
{
public:
	class UAnimSequence*                          ASParkourHighClimbStart;                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourHighClimbGetUp;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourHighClimbFallLoop;                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourHighClimbLand;                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourHighClimbLandMove;                        // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove_Climb_High) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove_Climb_High");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove_Climb_High) == 0x000028, "Wrong size on FAnimHumanoidSetting_ParkourMove_Climb_High");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_High, ASParkourHighClimbStart) == 0x000000, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_High::ASParkourHighClimbStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_High, ASParkourHighClimbGetUp) == 0x000008, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_High::ASParkourHighClimbGetUp' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_High, ASParkourHighClimbFallLoop) == 0x000010, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_High::ASParkourHighClimbFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_High, ASParkourHighClimbLand) == 0x000018, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_High::ASParkourHighClimbLand' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_High, ASParkourHighClimbLandMove) == 0x000020, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_High::ASParkourHighClimbLandMove' has a wrong offset!");

// SharpStruct b1-Managed.ProcessUnitTriggerBattleConfig
// 0x0024 (0x0024 - 0x0000)
struct FProcessUnitTriggerBattleConfig final
{
public:
	struct FGsSmartParam                          Unit;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SwitchTeamID;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          TargetUnit;                                        // 0x0014(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProcessUnitTriggerBattleConfig) == 0x000004, "Wrong alignment on FProcessUnitTriggerBattleConfig");
static_assert(sizeof(FProcessUnitTriggerBattleConfig) == 0x000024, "Wrong size on FProcessUnitTriggerBattleConfig");
static_assert(offsetof(FProcessUnitTriggerBattleConfig, Unit) == 0x000000, "Member 'FProcessUnitTriggerBattleConfig::Unit' has a wrong offset!");
static_assert(offsetof(FProcessUnitTriggerBattleConfig, SwitchTeamID) == 0x000010, "Member 'FProcessUnitTriggerBattleConfig::SwitchTeamID' has a wrong offset!");
static_assert(offsetof(FProcessUnitTriggerBattleConfig, TargetUnit) == 0x000014, "Member 'FProcessUnitTriggerBattleConfig::TargetUnit' has a wrong offset!");

// SharpStruct b1-Managed.IdleProcessAction
// 0x01F0 (0x01F0 - 0x0000)
struct FIdleProcessAction final
{
public:
	EIdleProcessActionType                        ActionType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTeleportToOtherLevel : 1;                         // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetLevelID;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PointName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            BeforeTeleportMontage;                             // 0x0010(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            AfterTeleportMontage;                              // 0x0038(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSaveArchiveAfterTeleport : 1;                     // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ArchiveLabel;                                      // 0x0064(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RebirthPointId;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsBlockRebirthpoint : 1;                           // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          Unit;                                              // 0x0074(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          UnitOrPlayerorNPC;                                 // 0x0084(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DropItemManageGuid;                                // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          AiConversation;                                    // 0x00A8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          NPCUnit;                                           // 0x00B8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NPCTeamID;                                         // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NPCIdleAMIdx;                                      // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NPCLeisureAnimIndex;                               // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NPCActionSkillID;                                  // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NPCInteractGroupID;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsActorGuidReference                  TargetActor;                                       // 0x00E0(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUMoveAIType                                MoveAIType;                                        // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIMoveSpeedType                              MoveSpeedType;                                     // 0x0119(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x2];                                      // 0x011A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveAcceptableRadius;                              // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGsNPCShowState                               NPCShowState;                                      // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FProcessUnitTriggerBattleConfig> UnitTriggerBattleConfigs;                          // 0x0128(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          AssociationUnitInfoConfigId;                       // 0x0138(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AssociationUnitSpawnInfoDelayExecuteTime;          // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAssociationUnitSpawnType                     AssociationUnitSpawnInfoSpawnType;                 // 0x014C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAssociationUnitActiveType                    AssociationUnitSpawnInfoActiveType;                // 0x014D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E[0x2];                                      // 0x014E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          AssociationUnitTarget;                             // 0x0150(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AssociationOnFightSkillID;                         // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcMoveType                                  NpcMoveType;                                       // 0x0164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNpcGuideSplineMoveConfig              NpcGuideSplineMoveConfig;                          // 0x0168(0x0050)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeakPerformConfigID;                               // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          FollowPartnerConfigId;                             // 0x01BC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x01CC(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDontResetPlayerState : 1;                         // 0x01D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EGSLoadingScreenType                          LoadingScreenType;                                 // 0x01D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D6[0x2];                                      // 0x01D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnitExtendID;                                      // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TeleportLoadingTips;                               // 0x01E0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIdleProcessAction) == 0x000008, "Wrong alignment on FIdleProcessAction");
static_assert(sizeof(FIdleProcessAction) == 0x0001F0, "Wrong size on FIdleProcessAction");
static_assert(offsetof(FIdleProcessAction, ActionType) == 0x000000, "Member 'FIdleProcessAction::ActionType' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, TargetLevelID) == 0x000004, "Member 'FIdleProcessAction::TargetLevelID' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, PointName) == 0x000008, "Member 'FIdleProcessAction::PointName' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, BeforeTeleportMontage) == 0x000010, "Member 'FIdleProcessAction::BeforeTeleportMontage' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, AfterTeleportMontage) == 0x000038, "Member 'FIdleProcessAction::AfterTeleportMontage' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, ArchiveLabel) == 0x000064, "Member 'FIdleProcessAction::ArchiveLabel' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, RebirthPointId) == 0x00006C, "Member 'FIdleProcessAction::RebirthPointId' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, Unit) == 0x000074, "Member 'FIdleProcessAction::Unit' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, UnitOrPlayerorNPC) == 0x000084, "Member 'FIdleProcessAction::UnitOrPlayerorNPC' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, DropItemManageGuid) == 0x000098, "Member 'FIdleProcessAction::DropItemManageGuid' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, AiConversation) == 0x0000A8, "Member 'FIdleProcessAction::AiConversation' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NPCUnit) == 0x0000B8, "Member 'FIdleProcessAction::NPCUnit' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NPCTeamID) == 0x0000C8, "Member 'FIdleProcessAction::NPCTeamID' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NPCIdleAMIdx) == 0x0000CC, "Member 'FIdleProcessAction::NPCIdleAMIdx' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NPCLeisureAnimIndex) == 0x0000D0, "Member 'FIdleProcessAction::NPCLeisureAnimIndex' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NPCActionSkillID) == 0x0000D4, "Member 'FIdleProcessAction::NPCActionSkillID' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NPCInteractGroupID) == 0x0000D8, "Member 'FIdleProcessAction::NPCInteractGroupID' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, TargetActor) == 0x0000E0, "Member 'FIdleProcessAction::TargetActor' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, MoveAIType) == 0x000118, "Member 'FIdleProcessAction::MoveAIType' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, MoveSpeedType) == 0x000119, "Member 'FIdleProcessAction::MoveSpeedType' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, MoveAcceptableRadius) == 0x00011C, "Member 'FIdleProcessAction::MoveAcceptableRadius' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NPCShowState) == 0x000120, "Member 'FIdleProcessAction::NPCShowState' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, UnitTriggerBattleConfigs) == 0x000128, "Member 'FIdleProcessAction::UnitTriggerBattleConfigs' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, AssociationUnitInfoConfigId) == 0x000138, "Member 'FIdleProcessAction::AssociationUnitInfoConfigId' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, AssociationUnitSpawnInfoDelayExecuteTime) == 0x000148, "Member 'FIdleProcessAction::AssociationUnitSpawnInfoDelayExecuteTime' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, AssociationUnitSpawnInfoSpawnType) == 0x00014C, "Member 'FIdleProcessAction::AssociationUnitSpawnInfoSpawnType' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, AssociationUnitSpawnInfoActiveType) == 0x00014D, "Member 'FIdleProcessAction::AssociationUnitSpawnInfoActiveType' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, AssociationUnitTarget) == 0x000150, "Member 'FIdleProcessAction::AssociationUnitTarget' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, AssociationOnFightSkillID) == 0x000160, "Member 'FIdleProcessAction::AssociationOnFightSkillID' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NpcMoveType) == 0x000164, "Member 'FIdleProcessAction::NpcMoveType' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, NpcGuideSplineMoveConfig) == 0x000168, "Member 'FIdleProcessAction::NpcGuideSplineMoveConfig' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, WeakPerformConfigID) == 0x0001B8, "Member 'FIdleProcessAction::WeakPerformConfigID' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, FollowPartnerConfigId) == 0x0001BC, "Member 'FIdleProcessAction::FollowPartnerConfigId' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, GameplayTag) == 0x0001CC, "Member 'FIdleProcessAction::GameplayTag' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, LoadingScreenType) == 0x0001D5, "Member 'FIdleProcessAction::LoadingScreenType' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, UnitExtendID) == 0x0001D8, "Member 'FIdleProcessAction::UnitExtendID' has a wrong offset!");
static_assert(offsetof(FIdleProcessAction, TeleportLoadingTips) == 0x0001E0, "Member 'FIdleProcessAction::TeleportLoadingTips' has a wrong offset!");

// SharpStruct b1-Managed.RandomAnims
// 0x0010 (0x0010 - 0x0000)
struct FRandomAnims final
{
public:
	TArray<class UAnimSequence*>                  AnimSequences;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomAnims) == 0x000008, "Wrong alignment on FRandomAnims");
static_assert(sizeof(FRandomAnims) == 0x000010, "Wrong size on FRandomAnims");
static_assert(offsetof(FRandomAnims, AnimSequences) == 0x000000, "Member 'FRandomAnims::AnimSequences' has a wrong offset!");

// SharpStruct b1-Managed.TextConfig
// 0x0168 (0x0168 - 0x0000)
struct FTextConfig final
{
public:
	struct FAnchors                               Anchors;                                           // 0x0000(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Alignment;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Pos;                                               // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            Color;                                             // 0x0040(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         UseFontSize : 1;                                   // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FontSize;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseLetterSpacing : 1;                              // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LetterSpacing;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ShadowOffset;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColor;                                       // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         FontInfo;                                          // 0x0090(0x0088)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ETextColorType, struct FSlateColor>      ColorMap;                                          // 0x0118(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextConfig) == 0x000008, "Wrong alignment on FTextConfig");
static_assert(sizeof(FTextConfig) == 0x000168, "Wrong size on FTextConfig");
static_assert(offsetof(FTextConfig, Anchors) == 0x000000, "Member 'FTextConfig::Anchors' has a wrong offset!");
static_assert(offsetof(FTextConfig, Alignment) == 0x000020, "Member 'FTextConfig::Alignment' has a wrong offset!");
static_assert(offsetof(FTextConfig, Pos) == 0x000030, "Member 'FTextConfig::Pos' has a wrong offset!");
static_assert(offsetof(FTextConfig, Color) == 0x000040, "Member 'FTextConfig::Color' has a wrong offset!");
static_assert(offsetof(FTextConfig, FontSize) == 0x000058, "Member 'FTextConfig::FontSize' has a wrong offset!");
static_assert(offsetof(FTextConfig, LetterSpacing) == 0x000060, "Member 'FTextConfig::LetterSpacing' has a wrong offset!");
static_assert(offsetof(FTextConfig, ShadowOffset) == 0x000068, "Member 'FTextConfig::ShadowOffset' has a wrong offset!");
static_assert(offsetof(FTextConfig, ShadowColor) == 0x000078, "Member 'FTextConfig::ShadowColor' has a wrong offset!");
static_assert(offsetof(FTextConfig, Justification) == 0x000088, "Member 'FTextConfig::Justification' has a wrong offset!");
static_assert(offsetof(FTextConfig, FontInfo) == 0x000090, "Member 'FTextConfig::FontInfo' has a wrong offset!");
static_assert(offsetof(FTextConfig, ColorMap) == 0x000118, "Member 'FTextConfig::ColorMap' has a wrong offset!");

// SharpStruct b1-Managed.BuffDispTickData
// 0x0000 (0x0000 - 0x0000)
struct FBuffDispTickData final
{
};
static_assert(alignof(FBuffDispTickData) == 0x000001, "Wrong alignment on FBuffDispTickData");
static_assert(sizeof(FBuffDispTickData) == 0x000001, "Wrong size on FBuffDispTickData");

// SharpStruct b1-Managed.HatchConfigInfo
// 0x0048 (0x0048 - 0x0000)
struct FHatchConfigInfo final
{
public:
	class UClass*                                 TamerClass;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   SpawnAMList;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   SpawnSocketName;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFaceToTarget : 1;                                 // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBGWDataAsset_B1DBC*                    SpawnDBC;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSyncCurTarget : 1;                                // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 BirthBuffIDList;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHatchConfigInfo) == 0x000008, "Wrong alignment on FHatchConfigInfo");
static_assert(sizeof(FHatchConfigInfo) == 0x000048, "Wrong size on FHatchConfigInfo");
static_assert(offsetof(FHatchConfigInfo, TamerClass) == 0x000000, "Member 'FHatchConfigInfo::TamerClass' has a wrong offset!");
static_assert(offsetof(FHatchConfigInfo, SpawnAMList) == 0x000008, "Member 'FHatchConfigInfo::SpawnAMList' has a wrong offset!");
static_assert(offsetof(FHatchConfigInfo, SpawnSocketName) == 0x000018, "Member 'FHatchConfigInfo::SpawnSocketName' has a wrong offset!");
static_assert(offsetof(FHatchConfigInfo, SpawnDBC) == 0x000028, "Member 'FHatchConfigInfo::SpawnDBC' has a wrong offset!");
static_assert(offsetof(FHatchConfigInfo, BirthBuffIDList) == 0x000038, "Member 'FHatchConfigInfo::BirthBuffIDList' has a wrong offset!");

// SharpStruct b1-Managed.LightningFXSpawnConfig
// 0x0060 (0x0060 - 0x0000)
struct FLightningFXSpawnConfig final
{
public:
	class UNiagaraSystem*                         LightningTemplate;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 DecalActorClass;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnWaves;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveGap;                                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnNumPerWave;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningDelaySpawnDecalTime;                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecalcPointPerWave : 1;                           // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_20_1 : 7;                                   // 0x0020(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bSpawnBySelfMode : 1;                              // 0x0021(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_21_1 : 7;                                   // 0x0021(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         DirBaseOnParent : 1;                               // 0x0022(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            RangeDir_X;                                        // 0x0024(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RangeDir_Y;                                        // 0x0034(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            RangeDir_Z;                                        // 0x0044(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineTraceMaxLength;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceTypeQuery;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PointMinBetween;                                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightningFXSpawnConfig) == 0x000008, "Wrong alignment on FLightningFXSpawnConfig");
static_assert(sizeof(FLightningFXSpawnConfig) == 0x000060, "Wrong size on FLightningFXSpawnConfig");
static_assert(offsetof(FLightningFXSpawnConfig, LightningTemplate) == 0x000000, "Member 'FLightningFXSpawnConfig::LightningTemplate' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, DecalActorClass) == 0x000008, "Member 'FLightningFXSpawnConfig::DecalActorClass' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, SpawnWaves) == 0x000010, "Member 'FLightningFXSpawnConfig::SpawnWaves' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, WaveGap) == 0x000014, "Member 'FLightningFXSpawnConfig::WaveGap' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, SpawnNumPerWave) == 0x000018, "Member 'FLightningFXSpawnConfig::SpawnNumPerWave' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, LightningDelaySpawnDecalTime) == 0x00001C, "Member 'FLightningFXSpawnConfig::LightningDelaySpawnDecalTime' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, RangeDir_X) == 0x000024, "Member 'FLightningFXSpawnConfig::RangeDir_X' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, RangeDir_Y) == 0x000034, "Member 'FLightningFXSpawnConfig::RangeDir_Y' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, RangeDir_Z) == 0x000044, "Member 'FLightningFXSpawnConfig::RangeDir_Z' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, LineTraceMaxLength) == 0x000054, "Member 'FLightningFXSpawnConfig::LineTraceMaxLength' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, TraceTypeQuery) == 0x000058, "Member 'FLightningFXSpawnConfig::TraceTypeQuery' has a wrong offset!");
static_assert(offsetof(FLightningFXSpawnConfig, PointMinBetween) == 0x00005C, "Member 'FLightningFXSpawnConfig::PointMinBetween' has a wrong offset!");

// SharpStruct b1-Managed.StateNodeChildActorControlJJSObstacle
// 0x000C (0x000C - 0x0000)
struct FStateNodeChildActorControlJJSObstacle final
{
public:
	struct FGameplayTag                           NickName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicObstacleState                         State;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateNodeChildActorControlJJSObstacle) == 0x000004, "Wrong alignment on FStateNodeChildActorControlJJSObstacle");
static_assert(sizeof(FStateNodeChildActorControlJJSObstacle) == 0x00000C, "Wrong size on FStateNodeChildActorControlJJSObstacle");
static_assert(offsetof(FStateNodeChildActorControlJJSObstacle, NickName) == 0x000000, "Member 'FStateNodeChildActorControlJJSObstacle::NickName' has a wrong offset!");
static_assert(offsetof(FStateNodeChildActorControlJJSObstacle, State) == 0x000008, "Member 'FStateNodeChildActorControlJJSObstacle::State' has a wrong offset!");

// SharpStruct b1-Managed.MovieRelationInfoCollection
// 0x0028 (0x0028 - 0x0000)
struct FMovieRelationInfoCollection final
{
public:
	int32                                         SequenceID;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanRepeatPlay : 1;                                // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovieRelationInfo>             RelationInfos;                                     // 0x0008(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FMovieRelationInfo>             ManualRelationInfos;                               // 0x0018(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieRelationInfoCollection) == 0x000008, "Wrong alignment on FMovieRelationInfoCollection");
static_assert(sizeof(FMovieRelationInfoCollection) == 0x000028, "Wrong size on FMovieRelationInfoCollection");
static_assert(offsetof(FMovieRelationInfoCollection, SequenceID) == 0x000000, "Member 'FMovieRelationInfoCollection::SequenceID' has a wrong offset!");
static_assert(offsetof(FMovieRelationInfoCollection, RelationInfos) == 0x000008, "Member 'FMovieRelationInfoCollection::RelationInfos' has a wrong offset!");
static_assert(offsetof(FMovieRelationInfoCollection, ManualRelationInfos) == 0x000018, "Member 'FMovieRelationInfoCollection::ManualRelationInfos' has a wrong offset!");

// SharpStruct b1-Managed.FGSCameraOffsetSetting
// 0x0020 (0x0020 - 0x0000)
struct FFGSCameraOffsetSetting final
{
public:
	uint8                                         EnableArmLength : 1;                               // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ArmLengthOffsetCurve;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableFOVOffset : 1;                               // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FOVOffsetCurve;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSCameraOffsetSetting) == 0x000008, "Wrong alignment on FFGSCameraOffsetSetting");
static_assert(sizeof(FFGSCameraOffsetSetting) == 0x000020, "Wrong size on FFGSCameraOffsetSetting");
static_assert(offsetof(FFGSCameraOffsetSetting, ArmLengthOffsetCurve) == 0x000008, "Member 'FFGSCameraOffsetSetting::ArmLengthOffsetCurve' has a wrong offset!");
static_assert(offsetof(FFGSCameraOffsetSetting, FOVOffsetCurve) == 0x000018, "Member 'FFGSCameraOffsetSetting::FOVOffsetCurve' has a wrong offset!");

// SharpStruct b1-Managed.RelationLevelInfo
// 0x0020 (0x0020 - 0x0000)
struct FRelationLevelInfo final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RelationInfo;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRelationLevelInfo) == 0x000008, "Wrong alignment on FRelationLevelInfo");
static_assert(sizeof(FRelationLevelInfo) == 0x000020, "Wrong size on FRelationLevelInfo");
static_assert(offsetof(FRelationLevelInfo, LevelName) == 0x000000, "Member 'FRelationLevelInfo::LevelName' has a wrong offset!");
static_assert(offsetof(FRelationLevelInfo, RelationInfo) == 0x000010, "Member 'FRelationLevelInfo::RelationInfo' has a wrong offset!");

// SharpStruct b1-Managed.InputMappingContextLevelInfo
// 0x0002 (0x0002 - 0x0000)
struct FInputMappingContextLevelInfo final
{
public:
	EInputMappingContextLevelInfoType             LevelInfoType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELevelTag                                     LevelTag;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputMappingContextLevelInfo) == 0x000001, "Wrong alignment on FInputMappingContextLevelInfo");
static_assert(sizeof(FInputMappingContextLevelInfo) == 0x000002, "Wrong size on FInputMappingContextLevelInfo");
static_assert(offsetof(FInputMappingContextLevelInfo, LevelInfoType) == 0x000000, "Member 'FInputMappingContextLevelInfo::LevelInfoType' has a wrong offset!");
static_assert(offsetof(FInputMappingContextLevelInfo, LevelTag) == 0x000001, "Member 'FInputMappingContextLevelInfo::LevelTag' has a wrong offset!");

// SharpStruct b1-Managed.InputActionOverrideConfig
// 0x0050 (0x0050 - 0x0000)
struct FInputActionOverrideConfig final
{
public:
	TMap<ETriggerEvent, ETriggerEvent>            OverrideTriggerEvents;                             // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputActionOverrideConfig) == 0x000008, "Wrong alignment on FInputActionOverrideConfig");
static_assert(sizeof(FInputActionOverrideConfig) == 0x000050, "Wrong size on FInputActionOverrideConfig");
static_assert(offsetof(FInputActionOverrideConfig, OverrideTriggerEvents) == 0x000000, "Member 'FInputActionOverrideConfig::OverrideTriggerEvents' has a wrong offset!");

// SharpStruct b1-Managed.CustomizedInputOverrideConfig
// 0x0068 (0x0068 - 0x0000)
struct FCustomizedInputOverrideConfig final
{
public:
	class UInputMappingContext*                   InputMappingContext;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UInputAction*, struct FInputActionOverrideConfig> OverrideInputActionTriggerEvents;                  // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         IsOverridePriority : 1;                            // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerPriority;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizedInputOverrideConfig) == 0x000008, "Wrong alignment on FCustomizedInputOverrideConfig");
static_assert(sizeof(FCustomizedInputOverrideConfig) == 0x000068, "Wrong size on FCustomizedInputOverrideConfig");
static_assert(offsetof(FCustomizedInputOverrideConfig, InputMappingContext) == 0x000000, "Member 'FCustomizedInputOverrideConfig::InputMappingContext' has a wrong offset!");
static_assert(offsetof(FCustomizedInputOverrideConfig, OverrideInputActionTriggerEvents) == 0x000008, "Member 'FCustomizedInputOverrideConfig::OverrideInputActionTriggerEvents' has a wrong offset!");
static_assert(offsetof(FCustomizedInputOverrideConfig, Priority) == 0x00005C, "Member 'FCustomizedInputOverrideConfig::Priority' has a wrong offset!");
static_assert(offsetof(FCustomizedInputOverrideConfig, TriggerPriority) == 0x000060, "Member 'FCustomizedInputOverrideConfig::TriggerPriority' has a wrong offset!");

// SharpStruct b1-Managed.InputMappingContextConfigV2
// 0x0078 (0x0078 - 0x0000)
struct FInputMappingContextConfigV2 final
{
public:
	class UInputMappingContext*                   InputMappingContext;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerPriority;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EInputMappingContextTagV2>             TriggerContextTags;                                // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EInputMappingContextMode                      InputMode;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsInitLoading : 1;                                 // 0x0021(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_21_1 : 7;                                   // 0x0021(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsIgnoreBlockRequest : 1;                          // 0x0022(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FInputMappingContextLevelInfo          LevelInfo;                                         // 0x0023(0x0002)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsPermanent : 1;                                   // 0x0025(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECustomizedInputType, struct FCustomizedInputOverrideConfig> CustomizedInputOverrideConfigs;                    // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputMappingContextConfigV2) == 0x000008, "Wrong alignment on FInputMappingContextConfigV2");
static_assert(sizeof(FInputMappingContextConfigV2) == 0x000078, "Wrong size on FInputMappingContextConfigV2");
static_assert(offsetof(FInputMappingContextConfigV2, InputMappingContext) == 0x000000, "Member 'FInputMappingContextConfigV2::InputMappingContext' has a wrong offset!");
static_assert(offsetof(FInputMappingContextConfigV2, Priority) == 0x000008, "Member 'FInputMappingContextConfigV2::Priority' has a wrong offset!");
static_assert(offsetof(FInputMappingContextConfigV2, TriggerPriority) == 0x00000C, "Member 'FInputMappingContextConfigV2::TriggerPriority' has a wrong offset!");
static_assert(offsetof(FInputMappingContextConfigV2, TriggerContextTags) == 0x000010, "Member 'FInputMappingContextConfigV2::TriggerContextTags' has a wrong offset!");
static_assert(offsetof(FInputMappingContextConfigV2, InputMode) == 0x000020, "Member 'FInputMappingContextConfigV2::InputMode' has a wrong offset!");
static_assert(offsetof(FInputMappingContextConfigV2, LevelInfo) == 0x000023, "Member 'FInputMappingContextConfigV2::LevelInfo' has a wrong offset!");
static_assert(offsetof(FInputMappingContextConfigV2, CustomizedInputOverrideConfigs) == 0x000028, "Member 'FInputMappingContextConfigV2::CustomizedInputOverrideConfigs' has a wrong offset!");

// SharpStruct b1-Managed.Demo820TimeInfo
// 0x0020 (0x0020 - 0x0000)
struct FDemo820TimeInfo final
{
public:
	float                                         SmallTipsTimeDur;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TipsTimeDur;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 TipsTime;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         GameplayTimeMax;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDemo820TimeInfo) == 0x000008, "Wrong alignment on FDemo820TimeInfo");
static_assert(sizeof(FDemo820TimeInfo) == 0x000020, "Wrong size on FDemo820TimeInfo");
static_assert(offsetof(FDemo820TimeInfo, SmallTipsTimeDur) == 0x000000, "Member 'FDemo820TimeInfo::SmallTipsTimeDur' has a wrong offset!");
static_assert(offsetof(FDemo820TimeInfo, TipsTimeDur) == 0x000004, "Member 'FDemo820TimeInfo::TipsTimeDur' has a wrong offset!");
static_assert(offsetof(FDemo820TimeInfo, TipsTime) == 0x000008, "Member 'FDemo820TimeInfo::TipsTime' has a wrong offset!");
static_assert(offsetof(FDemo820TimeInfo, GameplayTimeMax) == 0x000018, "Member 'FDemo820TimeInfo::GameplayTimeMax' has a wrong offset!");

// SharpStruct b1-Managed.FGSSpawnMagicFieldInfo
// 0x0000 (0x0000 - 0x0000)
struct FFGSSpawnMagicFieldInfo final
{
};
static_assert(alignof(FFGSSpawnMagicFieldInfo) == 0x000001, "Wrong alignment on FFGSSpawnMagicFieldInfo");
static_assert(sizeof(FFGSSpawnMagicFieldInfo) == 0x000001, "Wrong size on FFGSSpawnMagicFieldInfo");

// SharpStruct b1-Managed.SkillDamageConfig
// 0x0038 (0x0038 - 0x0000)
struct FSkillDamageConfig final
{
public:
	EDamageReason                                 DmgReason;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DmgReasonEffectID;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DmgReasonEffectIdx;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BuffOwner;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageCalcType                               DamageCalcType;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DamageImmueLevel;                                  // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPMaxINV10000Damage_Abs;                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CameraShakeDA;                                     // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillDamageConfig) == 0x000008, "Wrong alignment on FSkillDamageConfig");
static_assert(sizeof(FSkillDamageConfig) == 0x000038, "Wrong size on FSkillDamageConfig");
static_assert(offsetof(FSkillDamageConfig, DmgReason) == 0x000000, "Member 'FSkillDamageConfig::DmgReason' has a wrong offset!");
static_assert(offsetof(FSkillDamageConfig, DmgReasonEffectID) == 0x000004, "Member 'FSkillDamageConfig::DmgReasonEffectID' has a wrong offset!");
static_assert(offsetof(FSkillDamageConfig, DmgReasonEffectIdx) == 0x000008, "Member 'FSkillDamageConfig::DmgReasonEffectIdx' has a wrong offset!");
static_assert(offsetof(FSkillDamageConfig, BuffOwner) == 0x000010, "Member 'FSkillDamageConfig::BuffOwner' has a wrong offset!");
static_assert(offsetof(FSkillDamageConfig, DamageCalcType) == 0x000018, "Member 'FSkillDamageConfig::DamageCalcType' has a wrong offset!");
static_assert(offsetof(FSkillDamageConfig, DamageImmueLevel) == 0x00001C, "Member 'FSkillDamageConfig::DamageImmueLevel' has a wrong offset!");
static_assert(offsetof(FSkillDamageConfig, HPMaxINV10000Damage_Abs) == 0x000020, "Member 'FSkillDamageConfig::HPMaxINV10000Damage_Abs' has a wrong offset!");
static_assert(offsetof(FSkillDamageConfig, CameraShakeDA) == 0x000028, "Member 'FSkillDamageConfig::CameraShakeDA' has a wrong offset!");

// SharpStruct b1-Managed.DispInteractOverride
// 0x0040 (0x0040 - 0x0000)
struct FDispInteractOverride final
{
public:
	class FName                                   FirstBoneName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextBoneName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstScaleValue;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextScaleValue;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FirstScaleCurve;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            NextScaleCurve;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstOffsetValue;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextOffsetValue;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FirstOffsetCurve;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            NextOffsetCurve;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDispInteractOverride) == 0x000008, "Wrong alignment on FDispInteractOverride");
static_assert(sizeof(FDispInteractOverride) == 0x000040, "Wrong size on FDispInteractOverride");
static_assert(offsetof(FDispInteractOverride, FirstBoneName) == 0x000000, "Member 'FDispInteractOverride::FirstBoneName' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, NextBoneName) == 0x000008, "Member 'FDispInteractOverride::NextBoneName' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, FirstScaleValue) == 0x000010, "Member 'FDispInteractOverride::FirstScaleValue' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, NextScaleValue) == 0x000014, "Member 'FDispInteractOverride::NextScaleValue' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, FirstScaleCurve) == 0x000018, "Member 'FDispInteractOverride::FirstScaleCurve' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, NextScaleCurve) == 0x000020, "Member 'FDispInteractOverride::NextScaleCurve' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, FirstOffsetValue) == 0x000028, "Member 'FDispInteractOverride::FirstOffsetValue' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, NextOffsetValue) == 0x00002C, "Member 'FDispInteractOverride::NextOffsetValue' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, FirstOffsetCurve) == 0x000030, "Member 'FDispInteractOverride::FirstOffsetCurve' has a wrong offset!");
static_assert(offsetof(FDispInteractOverride, NextOffsetCurve) == 0x000038, "Member 'FDispInteractOverride::NextOffsetCurve' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_GlideMove_Start
// 0x0050 (0x0050 - 0x0000)
struct FAnimHumanoidSetting_GlideMove_Start final
{
public:
	class UAnimSequence*                          ASGlideStartGroundFlatSlow;                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartGroundFlatFast;                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartGroundSteepSlow;                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartGroundSteepFast;                       // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartAirFlatSlow;                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartAirFlatFast;                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartAirSteepSlow;                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartAirSteepFast;                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartBackAirFlat;                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideStartBackAirSteep;                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_GlideMove_Start) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_GlideMove_Start");
static_assert(sizeof(FAnimHumanoidSetting_GlideMove_Start) == 0x000050, "Wrong size on FAnimHumanoidSetting_GlideMove_Start");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartGroundFlatSlow) == 0x000000, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartGroundFlatSlow' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartGroundFlatFast) == 0x000008, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartGroundFlatFast' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartGroundSteepSlow) == 0x000010, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartGroundSteepSlow' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartGroundSteepFast) == 0x000018, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartGroundSteepFast' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartAirFlatSlow) == 0x000020, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartAirFlatSlow' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartAirFlatFast) == 0x000028, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartAirFlatFast' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartAirSteepSlow) == 0x000030, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartAirSteepSlow' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartAirSteepFast) == 0x000038, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartAirSteepFast' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartBackAirFlat) == 0x000040, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartBackAirFlat' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Start, ASGlideStartBackAirSteep) == 0x000048, "Member 'FAnimHumanoidSetting_GlideMove_Start::ASGlideStartBackAirSteep' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_GlideMove_Loop
// 0x0050 (0x0050 - 0x0000)
struct FAnimHumanoidSetting_GlideMove_Loop final
{
public:
	class UAnimSequence*                          ASGlideLoopSteep;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSGlideLoopSteepAdditive;                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideLoopFlatSlow;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideLoopFlatFast;                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSGlideLoopFlatSlowDirAdditive;                    // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSGlideLoopFlatFastDirAdditive;                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSGlideLoopFlatVerticalInputAdditive;              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSGlideLoopFlatHorizonalInputAdditive;             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideLoopFlatRotationLeftAdditive;               // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideLoopFlatRotationRightAdditive;              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_GlideMove_Loop) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_GlideMove_Loop");
static_assert(sizeof(FAnimHumanoidSetting_GlideMove_Loop) == 0x000050, "Wrong size on FAnimHumanoidSetting_GlideMove_Loop");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, ASGlideLoopSteep) == 0x000000, "Member 'FAnimHumanoidSetting_GlideMove_Loop::ASGlideLoopSteep' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, BSGlideLoopSteepAdditive) == 0x000008, "Member 'FAnimHumanoidSetting_GlideMove_Loop::BSGlideLoopSteepAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, ASGlideLoopFlatSlow) == 0x000010, "Member 'FAnimHumanoidSetting_GlideMove_Loop::ASGlideLoopFlatSlow' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, ASGlideLoopFlatFast) == 0x000018, "Member 'FAnimHumanoidSetting_GlideMove_Loop::ASGlideLoopFlatFast' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, BSGlideLoopFlatSlowDirAdditive) == 0x000020, "Member 'FAnimHumanoidSetting_GlideMove_Loop::BSGlideLoopFlatSlowDirAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, BSGlideLoopFlatFastDirAdditive) == 0x000028, "Member 'FAnimHumanoidSetting_GlideMove_Loop::BSGlideLoopFlatFastDirAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, BSGlideLoopFlatVerticalInputAdditive) == 0x000030, "Member 'FAnimHumanoidSetting_GlideMove_Loop::BSGlideLoopFlatVerticalInputAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, BSGlideLoopFlatHorizonalInputAdditive) == 0x000038, "Member 'FAnimHumanoidSetting_GlideMove_Loop::BSGlideLoopFlatHorizonalInputAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, ASGlideLoopFlatRotationLeftAdditive) == 0x000040, "Member 'FAnimHumanoidSetting_GlideMove_Loop::ASGlideLoopFlatRotationLeftAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_Loop, ASGlideLoopFlatRotationRightAdditive) == 0x000048, "Member 'FAnimHumanoidSetting_GlideMove_Loop::ASGlideLoopFlatRotationRightAdditive' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_GlideMove_End
// 0x0010 (0x0010 - 0x0000)
struct FAnimHumanoidSetting_GlideMove_End final
{
public:
	class UAnimSequence*                          ASGlideEndSlow;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASGlideEndFast;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_GlideMove_End) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_GlideMove_End");
static_assert(sizeof(FAnimHumanoidSetting_GlideMove_End) == 0x000010, "Wrong size on FAnimHumanoidSetting_GlideMove_End");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_End, ASGlideEndSlow) == 0x000000, "Member 'FAnimHumanoidSetting_GlideMove_End::ASGlideEndSlow' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove_End, ASGlideEndFast) == 0x000008, "Member 'FAnimHumanoidSetting_GlideMove_End::ASGlideEndFast' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_GlideMove
// 0x00C0 (0x00C0 - 0x0000)
struct FAnimHumanoidSetting_GlideMove final
{
public:
	uint8                                         bEnableGlideAnim : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MoveParamCurve;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_GlideMove_Start   Start;                                             // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_GlideMove_Loop    Loop;                                              // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_GlideMove_End     End;                                               // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_GlideMove) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_GlideMove");
static_assert(sizeof(FAnimHumanoidSetting_GlideMove) == 0x0000C0, "Wrong size on FAnimHumanoidSetting_GlideMove");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove, MoveParamCurve) == 0x000008, "Member 'FAnimHumanoidSetting_GlideMove::MoveParamCurve' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove, Start) == 0x000010, "Member 'FAnimHumanoidSetting_GlideMove::Start' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove, Loop) == 0x000060, "Member 'FAnimHumanoidSetting_GlideMove::Loop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_GlideMove, End) == 0x0000B0, "Member 'FAnimHumanoidSetting_GlideMove::End' has a wrong offset!");

// SharpStruct b1-Managed.TransitionCondition_Group
// 0x00B0 (0x00B0 - 0x0000)
struct FTransitionCondition_Group final
{
public:
	ETransitionConditionType_Group                ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParamArray                     UnitList;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          UnitSpawner;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Unit;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Buff;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParamArray                     UnitKillOrder;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Overlap;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Interactor;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EQueryGameStateCondition                      GameStateCondition;                                // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          Sequence;                                          // 0x007C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          TaskStage;                                         // 0x008C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EStageStatus                                  TaskStageStatus;                                   // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x009D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransitionCondition_Group) == 0x000008, "Wrong alignment on FTransitionCondition_Group");
static_assert(sizeof(FTransitionCondition_Group) == 0x0000B0, "Wrong size on FTransitionCondition_Group");
static_assert(offsetof(FTransitionCondition_Group, ConditionType) == 0x000000, "Member 'FTransitionCondition_Group::ConditionType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, UnitList) == 0x000008, "Member 'FTransitionCondition_Group::UnitList' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, UnitSpawner) == 0x000018, "Member 'FTransitionCondition_Group::UnitSpawner' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, Unit) == 0x000028, "Member 'FTransitionCondition_Group::Unit' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, Buff) == 0x000038, "Member 'FTransitionCondition_Group::Buff' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, UnitKillOrder) == 0x000048, "Member 'FTransitionCondition_Group::UnitKillOrder' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, Overlap) == 0x000058, "Member 'FTransitionCondition_Group::Overlap' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, Interactor) == 0x000068, "Member 'FTransitionCondition_Group::Interactor' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, GameStateCondition) == 0x000078, "Member 'FTransitionCondition_Group::GameStateCondition' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, Sequence) == 0x00007C, "Member 'FTransitionCondition_Group::Sequence' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, TaskStage) == 0x00008C, "Member 'FTransitionCondition_Group::TaskStage' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, TaskStageStatus) == 0x00009C, "Member 'FTransitionCondition_Group::TaskStageStatus' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Group, Comment) == 0x0000A0, "Member 'FTransitionCondition_Group::Comment' has a wrong offset!");

// SharpStruct b1-Managed.CompositeTransitionCondition_Group
// 0x00E0 (0x00E0 - 0x0000)
struct FCompositeTransitionCondition_Group final
{
public:
	struct FTransitionCondition_Group             Single;                                            // 0x0000(0x00B0)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCompositeCondition : 1;                        // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransitionCondition_Group>     Conditions;                                        // 0x00B8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x00C9(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompositeTransitionCondition_Group) == 0x000008, "Wrong alignment on FCompositeTransitionCondition_Group");
static_assert(sizeof(FCompositeTransitionCondition_Group) == 0x0000E0, "Wrong size on FCompositeTransitionCondition_Group");
static_assert(offsetof(FCompositeTransitionCondition_Group, Single) == 0x000000, "Member 'FCompositeTransitionCondition_Group::Single' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Group, Conditions) == 0x0000B8, "Member 'FCompositeTransitionCondition_Group::Conditions' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Group, ConditionalRelation) == 0x0000C8, "Member 'FCompositeTransitionCondition_Group::ConditionalRelation' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Group, Comment) == 0x0000D0, "Member 'FCompositeTransitionCondition_Group::Comment' has a wrong offset!");

// SharpStruct b1-Managed.FCBGCastSkillInfo
// 0x0010 (0x0010 - 0x0000)
struct FFCBGCastSkillInfo final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MontageStartSectionName;                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DontCheckSkillCanCast : 1;                         // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_C_1 : 7;                                    // 0x000C(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         CanCastWhenDead : 1;                               // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FFCBGCastSkillInfo) == 0x000004, "Wrong alignment on FFCBGCastSkillInfo");
static_assert(sizeof(FFCBGCastSkillInfo) == 0x000010, "Wrong size on FFCBGCastSkillInfo");
static_assert(offsetof(FFCBGCastSkillInfo, SkillID) == 0x000000, "Member 'FFCBGCastSkillInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FFCBGCastSkillInfo, MontageStartSectionName) == 0x000004, "Member 'FFCBGCastSkillInfo::MontageStartSectionName' has a wrong offset!");

// SharpStruct b1-Managed.WeightConfig
// 0x0010 (0x0010 - 0x0000)
struct FWeightConfig final
{
public:
	int32                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Comment;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomValue;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightConfig) == 0x000004, "Wrong alignment on FWeightConfig");
static_assert(sizeof(FWeightConfig) == 0x000010, "Wrong size on FWeightConfig");
static_assert(offsetof(FWeightConfig, Weight) == 0x000000, "Member 'FWeightConfig::Weight' has a wrong offset!");
static_assert(offsetof(FWeightConfig, Comment) == 0x000004, "Member 'FWeightConfig::Comment' has a wrong offset!");
static_assert(offsetof(FWeightConfig, RandomValue) == 0x00000C, "Member 'FWeightConfig::RandomValue' has a wrong offset!");

// SharpStruct b1-Managed.EnvOverlapByObjectTypeData
// 0x0040 (0x0040 - 0x0000)
struct FEnvOverlapByObjectTypeData final
{
public:
	float                                         ExtentX;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentY;                                           // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentZ;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ShapeOffset;                                       // 0x0010(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      OverlapObjectTypes;                                // 0x0028(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EGSSweepCheckShapeType                        OverlapShape;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSkipOverlapQuerier : 1;                           // 0x0039(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FEnvOverlapByObjectTypeData) == 0x000008, "Wrong alignment on FEnvOverlapByObjectTypeData");
static_assert(sizeof(FEnvOverlapByObjectTypeData) == 0x000040, "Wrong size on FEnvOverlapByObjectTypeData");
static_assert(offsetof(FEnvOverlapByObjectTypeData, ExtentX) == 0x000000, "Member 'FEnvOverlapByObjectTypeData::ExtentX' has a wrong offset!");
static_assert(offsetof(FEnvOverlapByObjectTypeData, ExtentY) == 0x000004, "Member 'FEnvOverlapByObjectTypeData::ExtentY' has a wrong offset!");
static_assert(offsetof(FEnvOverlapByObjectTypeData, ExtentZ) == 0x000008, "Member 'FEnvOverlapByObjectTypeData::ExtentZ' has a wrong offset!");
static_assert(offsetof(FEnvOverlapByObjectTypeData, ShapeOffset) == 0x000010, "Member 'FEnvOverlapByObjectTypeData::ShapeOffset' has a wrong offset!");
static_assert(offsetof(FEnvOverlapByObjectTypeData, OverlapObjectTypes) == 0x000028, "Member 'FEnvOverlapByObjectTypeData::OverlapObjectTypes' has a wrong offset!");
static_assert(offsetof(FEnvOverlapByObjectTypeData, OverlapShape) == 0x000038, "Member 'FEnvOverlapByObjectTypeData::OverlapShape' has a wrong offset!");

// SharpStruct b1-Managed.MovieConditionQueryConfig
// 0x000C (0x000C - 0x0000)
struct FMovieConditionQueryConfig final
{
public:
	EMovieConditionQueryType                      ConditionQueryType;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GroupUnitGuid;                                     // 0x0004(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieConditionQueryConfig) == 0x000004, "Wrong alignment on FMovieConditionQueryConfig");
static_assert(sizeof(FMovieConditionQueryConfig) == 0x00000C, "Wrong size on FMovieConditionQueryConfig");
static_assert(offsetof(FMovieConditionQueryConfig, ConditionQueryType) == 0x000000, "Member 'FMovieConditionQueryConfig::ConditionQueryType' has a wrong offset!");
static_assert(offsetof(FMovieConditionQueryConfig, GroupUnitGuid) == 0x000004, "Member 'FMovieConditionQueryConfig::GroupUnitGuid' has a wrong offset!");

// SharpStruct b1-Managed.FEQSRunParamInfo
// 0x0058 (0x0058 - 0x0000)
struct FFEQSRunParamInfo final
{
public:
	float                                         AcceptableRadius;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IncludeSelfRadius : 1;                             // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              EQSTemplate;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUMoveAIType                                MoveAIType;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIMoveSpeedType                              SpeedRateType;                                     // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedRateDistanceCurve;                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableRangeAcceptableRadius : 1;                   // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAcceptableRadius;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceptableRadius;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableContinuousPathFinding : 1;                  // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ContinuousPathFindingRadiusThreshold;              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoUpdatePathTime;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableDebug : 1;                                   // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_38_1 : 7;                                   // 0x0038(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         EnableLeisure : 1;                                 // 0x0039(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntervalTime;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFGSLeisureWithWeight>          LeisureList;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         EnableDrawLineDebug : 1;                           // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FFEQSRunParamInfo) == 0x000008, "Wrong alignment on FFEQSRunParamInfo");
static_assert(sizeof(FFEQSRunParamInfo) == 0x000058, "Wrong size on FFEQSRunParamInfo");
static_assert(offsetof(FFEQSRunParamInfo, AcceptableRadius) == 0x000000, "Member 'FFEQSRunParamInfo::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, EQSTemplate) == 0x000008, "Member 'FFEQSRunParamInfo::EQSTemplate' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, MoveAIType) == 0x000010, "Member 'FFEQSRunParamInfo::MoveAIType' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, SpeedRateType) == 0x000011, "Member 'FFEQSRunParamInfo::SpeedRateType' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, SpeedRateDistanceCurve) == 0x000018, "Member 'FFEQSRunParamInfo::SpeedRateDistanceCurve' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, MinAcceptableRadius) == 0x000024, "Member 'FFEQSRunParamInfo::MinAcceptableRadius' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, MaxAcceptableRadius) == 0x000028, "Member 'FFEQSRunParamInfo::MaxAcceptableRadius' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, ContinuousPathFindingRadiusThreshold) == 0x000030, "Member 'FFEQSRunParamInfo::ContinuousPathFindingRadiusThreshold' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, AutoUpdatePathTime) == 0x000034, "Member 'FFEQSRunParamInfo::AutoUpdatePathTime' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, IntervalTime) == 0x00003C, "Member 'FFEQSRunParamInfo::IntervalTime' has a wrong offset!");
static_assert(offsetof(FFEQSRunParamInfo, LeisureList) == 0x000040, "Member 'FFEQSRunParamInfo::LeisureList' has a wrong offset!");

// SharpStruct b1-Managed.FollowPartnerDodgeInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FFollowPartnerDodgeInfo final
{
public:
	uint8                                         CanTrigger : 1;                                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TriggerCD;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerRadius;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VelocityDifferent;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   ForwardDodgeMontageList;                           // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   BackwardDodgeMontageList;                          // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   LeftSideDodgeMontageList;                          // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   RightSideDodgeMontageList;                         // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         CanTriggerEQSRun : 1;                              // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFEQSRunParamInfo                      EQSRunParamInfo;                                   // 0x0058(0x0058)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFollowPartnerDodgeInfo) == 0x000008, "Wrong alignment on FFollowPartnerDodgeInfo");
static_assert(sizeof(FFollowPartnerDodgeInfo) == 0x0000B0, "Wrong size on FFollowPartnerDodgeInfo");
static_assert(offsetof(FFollowPartnerDodgeInfo, TriggerCD) == 0x000004, "Member 'FFollowPartnerDodgeInfo::TriggerCD' has a wrong offset!");
static_assert(offsetof(FFollowPartnerDodgeInfo, TriggerRadius) == 0x000008, "Member 'FFollowPartnerDodgeInfo::TriggerRadius' has a wrong offset!");
static_assert(offsetof(FFollowPartnerDodgeInfo, VelocityDifferent) == 0x00000C, "Member 'FFollowPartnerDodgeInfo::VelocityDifferent' has a wrong offset!");
static_assert(offsetof(FFollowPartnerDodgeInfo, ForwardDodgeMontageList) == 0x000010, "Member 'FFollowPartnerDodgeInfo::ForwardDodgeMontageList' has a wrong offset!");
static_assert(offsetof(FFollowPartnerDodgeInfo, BackwardDodgeMontageList) == 0x000020, "Member 'FFollowPartnerDodgeInfo::BackwardDodgeMontageList' has a wrong offset!");
static_assert(offsetof(FFollowPartnerDodgeInfo, LeftSideDodgeMontageList) == 0x000030, "Member 'FFollowPartnerDodgeInfo::LeftSideDodgeMontageList' has a wrong offset!");
static_assert(offsetof(FFollowPartnerDodgeInfo, RightSideDodgeMontageList) == 0x000040, "Member 'FFollowPartnerDodgeInfo::RightSideDodgeMontageList' has a wrong offset!");
static_assert(offsetof(FFollowPartnerDodgeInfo, EQSRunParamInfo) == 0x000058, "Member 'FFollowPartnerDodgeInfo::EQSRunParamInfo' has a wrong offset!");

// SharpStruct b1-Managed.MovieLevelStateRequestConfig
// 0x0008 (0x0008 - 0x0000)
struct FMovieLevelStateRequestConfig final
{
public:
	int32                                         LevelID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfigID;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovieLevelStateRequestConfig) == 0x000004, "Wrong alignment on FMovieLevelStateRequestConfig");
static_assert(sizeof(FMovieLevelStateRequestConfig) == 0x000008, "Wrong size on FMovieLevelStateRequestConfig");
static_assert(offsetof(FMovieLevelStateRequestConfig, LevelID) == 0x000000, "Member 'FMovieLevelStateRequestConfig::LevelID' has a wrong offset!");
static_assert(offsetof(FMovieLevelStateRequestConfig, ConfigID) == 0x000004, "Member 'FMovieLevelStateRequestConfig::ConfigID' has a wrong offset!");

// SharpStruct b1-Managed.ManagedLevelStates
// 0x0018 (0x0018 - 0x0000)
struct FManagedLevelStates final
{
public:
	EGSLevelState                                 LevelState;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableKeyword : 1;                               // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         LevelNames;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedLevelStates) == 0x000008, "Wrong alignment on FManagedLevelStates");
static_assert(sizeof(FManagedLevelStates) == 0x000018, "Wrong size on FManagedLevelStates");
static_assert(offsetof(FManagedLevelStates, LevelState) == 0x000000, "Member 'FManagedLevelStates::LevelState' has a wrong offset!");
static_assert(offsetof(FManagedLevelStates, LevelNames) == 0x000008, "Member 'FManagedLevelStates::LevelNames' has a wrong offset!");

// SharpStruct b1-Managed.PairSkillIDBeginEnd
// 0x0008 (0x0008 - 0x0000)
struct FPairSkillIDBeginEnd final
{
public:
	int32                                         SkillIDBegin;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillIDEnd;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPairSkillIDBeginEnd) == 0x000004, "Wrong alignment on FPairSkillIDBeginEnd");
static_assert(sizeof(FPairSkillIDBeginEnd) == 0x000008, "Wrong size on FPairSkillIDBeginEnd");
static_assert(offsetof(FPairSkillIDBeginEnd, SkillIDBegin) == 0x000000, "Member 'FPairSkillIDBeginEnd::SkillIDBegin' has a wrong offset!");
static_assert(offsetof(FPairSkillIDBeginEnd, SkillIDEnd) == 0x000004, "Member 'FPairSkillIDBeginEnd::SkillIDEnd' has a wrong offset!");

// SharpStruct b1-Managed.SkillTypeInfo
// 0x0010 (0x0010 - 0x0000)
struct FSkillTypeInfo final
{
public:
	TArray<struct FPairSkillIDBeginEnd>           SkillIDBeginEndList;                               // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillTypeInfo) == 0x000008, "Wrong alignment on FSkillTypeInfo");
static_assert(sizeof(FSkillTypeInfo) == 0x000010, "Wrong size on FSkillTypeInfo");
static_assert(offsetof(FSkillTypeInfo, SkillIDBeginEndList) == 0x000000, "Member 'FSkillTypeInfo::SkillIDBeginEndList' has a wrong offset!");

// SharpStruct b1-Managed.OneUnitPreloadInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FOneUnitPreloadInfo final
{
public:
	uint8                                         EnableUnitTransPreloadPreload : 1;                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, uint8>                    WhiteListPreloadTypeMap;                           // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSkillTypeInfo>    WhiteListPreloadTypeInfoMap;                       // 0x0058(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOneUnitPreloadInfo) == 0x000008, "Wrong alignment on FOneUnitPreloadInfo");
static_assert(sizeof(FOneUnitPreloadInfo) == 0x0000A8, "Wrong size on FOneUnitPreloadInfo");
static_assert(offsetof(FOneUnitPreloadInfo, WhiteListPreloadTypeMap) == 0x000008, "Member 'FOneUnitPreloadInfo::WhiteListPreloadTypeMap' has a wrong offset!");
static_assert(offsetof(FOneUnitPreloadInfo, WhiteListPreloadTypeInfoMap) == 0x000058, "Member 'FOneUnitPreloadInfo::WhiteListPreloadTypeInfoMap' has a wrong offset!");

// SharpStruct b1-Managed.IL2CPPUnitTestStructInnerInner
// 0x0018 (0x0018 - 0x0000)
struct FIL2CPPUnitTestStructInnerInner final
{
public:
	float                                         FloatVal;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSYesNo                                      YesNo;                                             // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GameTag;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSub;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIL2CPPUnitTestStructInnerInner) == 0x000008, "Wrong alignment on FIL2CPPUnitTestStructInnerInner");
static_assert(sizeof(FIL2CPPUnitTestStructInnerInner) == 0x000018, "Wrong size on FIL2CPPUnitTestStructInnerInner");
static_assert(offsetof(FIL2CPPUnitTestStructInnerInner, FloatVal) == 0x000000, "Member 'FIL2CPPUnitTestStructInnerInner::FloatVal' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStructInnerInner, YesNo) == 0x000004, "Member 'FIL2CPPUnitTestStructInnerInner::YesNo' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStructInnerInner, GameTag) == 0x000008, "Member 'FIL2CPPUnitTestStructInnerInner::GameTag' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStructInnerInner, AnimSub) == 0x000010, "Member 'FIL2CPPUnitTestStructInnerInner::AnimSub' has a wrong offset!");

// SharpStruct b1-Managed.IL2CPPUnitTestStructInner
// 0x0020 (0x0020 - 0x0000)
struct FIL2CPPUnitTestStructInner final
{
public:
	TArray<class FName>                           ItemInts;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FIL2CPPUnitTestStructInnerInner> InnerStruct;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIL2CPPUnitTestStructInner) == 0x000008, "Wrong alignment on FIL2CPPUnitTestStructInner");
static_assert(sizeof(FIL2CPPUnitTestStructInner) == 0x000020, "Wrong size on FIL2CPPUnitTestStructInner");
static_assert(offsetof(FIL2CPPUnitTestStructInner, ItemInts) == 0x000000, "Member 'FIL2CPPUnitTestStructInner::ItemInts' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStructInner, InnerStruct) == 0x000010, "Member 'FIL2CPPUnitTestStructInner::InnerStruct' has a wrong offset!");

// SharpStruct b1-Managed.ManagedStreamingLevelStateConfig
// 0x0020 (0x0020 - 0x0000)
struct FManagedStreamingLevelStateConfig final
{
public:
	class FString                                 Description;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FManagedLevelStates>            LevelStateConfigs;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedStreamingLevelStateConfig) == 0x000008, "Wrong alignment on FManagedStreamingLevelStateConfig");
static_assert(sizeof(FManagedStreamingLevelStateConfig) == 0x000020, "Wrong size on FManagedStreamingLevelStateConfig");
static_assert(offsetof(FManagedStreamingLevelStateConfig, Description) == 0x000000, "Member 'FManagedStreamingLevelStateConfig::Description' has a wrong offset!");
static_assert(offsetof(FManagedStreamingLevelStateConfig, LevelStateConfigs) == 0x000010, "Member 'FManagedStreamingLevelStateConfig::LevelStateConfigs' has a wrong offset!");

// SharpStruct b1-Managed.PartDamagedAMInfo
// 0x0020 (0x0020 - 0x0000)
struct FPartDamagedAMInfo final
{
public:
	class UAnimMontage*                           DamagedAMPathForward;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DamagedAMPathBackward;                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DamagedAMPathLeftSide;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DamagedAMPathRightSide;                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartDamagedAMInfo) == 0x000008, "Wrong alignment on FPartDamagedAMInfo");
static_assert(sizeof(FPartDamagedAMInfo) == 0x000020, "Wrong size on FPartDamagedAMInfo");
static_assert(offsetof(FPartDamagedAMInfo, DamagedAMPathForward) == 0x000000, "Member 'FPartDamagedAMInfo::DamagedAMPathForward' has a wrong offset!");
static_assert(offsetof(FPartDamagedAMInfo, DamagedAMPathBackward) == 0x000008, "Member 'FPartDamagedAMInfo::DamagedAMPathBackward' has a wrong offset!");
static_assert(offsetof(FPartDamagedAMInfo, DamagedAMPathLeftSide) == 0x000010, "Member 'FPartDamagedAMInfo::DamagedAMPathLeftSide' has a wrong offset!");
static_assert(offsetof(FPartDamagedAMInfo, DamagedAMPathRightSide) == 0x000018, "Member 'FPartDamagedAMInfo::DamagedAMPathRightSide' has a wrong offset!");

// SharpStruct b1-Managed.ManagedStreamingLevelStateBoxConfig
// 0x0058 (0x0058 - 0x0000)
struct FManagedStreamingLevelStateBoxConfig final
{
public:
	struct FGsActorGuidReference                  Actor;                                             // 0x0000(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManagedStreamingLevelStateConfig      ManagedStateLevelsConfig;                          // 0x0038(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedStreamingLevelStateBoxConfig) == 0x000008, "Wrong alignment on FManagedStreamingLevelStateBoxConfig");
static_assert(sizeof(FManagedStreamingLevelStateBoxConfig) == 0x000058, "Wrong size on FManagedStreamingLevelStateBoxConfig");
static_assert(offsetof(FManagedStreamingLevelStateBoxConfig, Actor) == 0x000000, "Member 'FManagedStreamingLevelStateBoxConfig::Actor' has a wrong offset!");
static_assert(offsetof(FManagedStreamingLevelStateBoxConfig, ManagedStateLevelsConfig) == 0x000038, "Member 'FManagedStreamingLevelStateBoxConfig::ManagedStateLevelsConfig' has a wrong offset!");

// SharpStruct b1-Managed.PerformerInfo
// 0x0018 (0x0018 - 0x0000)
struct FPerformerInfo final
{
public:
	struct FGameplayTag                           PerformerActorFixedGuid;                           // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformerInfo) == 0x000008, "Wrong alignment on FPerformerInfo");
static_assert(sizeof(FPerformerInfo) == 0x000018, "Wrong size on FPerformerInfo");
static_assert(offsetof(FPerformerInfo, PerformerActorFixedGuid) == 0x000000, "Member 'FPerformerInfo::PerformerActorFixedGuid' has a wrong offset!");
static_assert(offsetof(FPerformerInfo, Comment) == 0x000008, "Member 'FPerformerInfo::Comment' has a wrong offset!");

// SharpStruct b1-Managed.SplineInfo
// 0x0048 (0x0048 - 0x0000)
struct FSplineInfo final
{
public:
	struct FVector                                SplineStart;                                       // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SplineEnd;                                         // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGUSimpleSplineActor*                  SplineActor;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Guid;                                              // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSplineInfo) == 0x000008, "Wrong alignment on FSplineInfo");
static_assert(sizeof(FSplineInfo) == 0x000048, "Wrong size on FSplineInfo");
static_assert(offsetof(FSplineInfo, SplineStart) == 0x000000, "Member 'FSplineInfo::SplineStart' has a wrong offset!");
static_assert(offsetof(FSplineInfo, SplineEnd) == 0x000018, "Member 'FSplineInfo::SplineEnd' has a wrong offset!");
static_assert(offsetof(FSplineInfo, SplineActor) == 0x000030, "Member 'FSplineInfo::SplineActor' has a wrong offset!");
static_assert(offsetof(FSplineInfo, Guid) == 0x000038, "Member 'FSplineInfo::Guid' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_CompareBuffLayer
// 0x000C (0x000C - 0x0000)
struct FDetectCondition_CompareBuffLayer final
{
public:
	int32                                         BuffID;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLayer;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperationType                    OperationType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_CompareBuffLayer) == 0x000004, "Wrong alignment on FDetectCondition_CompareBuffLayer");
static_assert(sizeof(FDetectCondition_CompareBuffLayer) == 0x00000C, "Wrong size on FDetectCondition_CompareBuffLayer");
static_assert(offsetof(FDetectCondition_CompareBuffLayer, BuffID) == 0x000000, "Member 'FDetectCondition_CompareBuffLayer::BuffID' has a wrong offset!");
static_assert(offsetof(FDetectCondition_CompareBuffLayer, BuffLayer) == 0x000004, "Member 'FDetectCondition_CompareBuffLayer::BuffLayer' has a wrong offset!");
static_assert(offsetof(FDetectCondition_CompareBuffLayer, OperationType) == 0x000008, "Member 'FDetectCondition_CompareBuffLayer::OperationType' has a wrong offset!");

// SharpStruct b1-Managed.KeyIconInfo
// 0x0020 (0x0020 - 0x0000)
struct FKeyIconInfo final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyIconInfo) == 0x000008, "Wrong alignment on FKeyIconInfo");
static_assert(sizeof(FKeyIconInfo) == 0x000020, "Wrong size on FKeyIconInfo");
static_assert(offsetof(FKeyIconInfo, Key) == 0x000000, "Member 'FKeyIconInfo::Key' has a wrong offset!");
static_assert(offsetof(FKeyIconInfo, Offset) == 0x000018, "Member 'FKeyIconInfo::Offset' has a wrong offset!");

// SharpStruct b1-Managed.PatrolGroupSetting
// 0x0060 (0x0060 - 0x0000)
struct FPatrolGroupSetting final
{
public:
	struct FGsActorGuidReference                  SplineActor;                                       // 0x0000(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSGroupSplinePatrolType                      GroupSplinePatrolType;                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGsActorGuidReference>          GroupMembers;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        GroupFormation;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPatrolGroupSetting) == 0x000008, "Wrong alignment on FPatrolGroupSetting");
static_assert(sizeof(FPatrolGroupSetting) == 0x000060, "Wrong size on FPatrolGroupSetting");
static_assert(offsetof(FPatrolGroupSetting, SplineActor) == 0x000000, "Member 'FPatrolGroupSetting::SplineActor' has a wrong offset!");
static_assert(offsetof(FPatrolGroupSetting, GroupSplinePatrolType) == 0x000038, "Member 'FPatrolGroupSetting::GroupSplinePatrolType' has a wrong offset!");
static_assert(offsetof(FPatrolGroupSetting, GroupMembers) == 0x000040, "Member 'FPatrolGroupSetting::GroupMembers' has a wrong offset!");
static_assert(offsetof(FPatrolGroupSetting, GroupFormation) == 0x000050, "Member 'FPatrolGroupSetting::GroupFormation' has a wrong offset!");

// SharpStruct b1-Managed.SummonSpawnConfigWrap
// 0x00C8 (0x00C8 - 0x0000)
struct FSummonSpawnConfigWrap final
{
public:
	float                                         SummonAliveTime;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BornDelayTime;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BornEffDisplayTime;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeforeBornTime;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 TamerTemplate;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EServantSearchTargetType                      SearchTargetType;                                  // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESummonUnitRotationType                       SummonUnitRotationType;                            // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESummonUnitLocationType                       SummonUnitLocationType;                            // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBGWMonkeySummonDataAsset*              SummonPointDA;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              EQSTemplate;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointSetCachedReqID;                               // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnSocketName;                                   // 0x0034(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SelectPointsRandom : 1;                            // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            SpawnScaleRange;                                   // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseBornSkill : 1;                                  // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 BornSkillIDs;                                      // 0x0058(0x0010)(NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   BornMontages;                                      // 0x0068(0x0010)(NativeAccessSpecifierPublic)
	int32                                         CopyAttrConfigID;                                  // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsCopyEquip : 1;                                   // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_7C_1 : 7;                                   // 0x007C(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         SyncBattleSC : 1;                                  // 0x007D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_7D_1 : 7;                                   // 0x007D(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsSummonerAsMaster : 1;                            // 0x007E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_7E_1 : 7;                                   // 0x007E(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsDestroyWhenSummonerDead : 1;                     // 0x007F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         InitSpeed;                                         // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpawnBirthBuff;                                    // 0x0088(0x0010)(NativeAccessSpecifierPublic)
	class UParticleSystem*                        BornParticle;                                      // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         BornNiagara;                                       // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWDataAsset_B1DBC*                    BornDBC;                                           // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         DisappearMontagePathList;                          // 0x00B0(0x0010)(NativeAccessSpecifierPublic)
	float                                         DestroyDelayTime;                                  // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SafeClampToLand : 1;                               // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_C4_1 : 7;                                   // 0x00C4(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         EnsureBornPosCanNavToPlayer : 1;                   // 0x00C5(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FSummonSpawnConfigWrap) == 0x000008, "Wrong alignment on FSummonSpawnConfigWrap");
static_assert(sizeof(FSummonSpawnConfigWrap) == 0x0000C8, "Wrong size on FSummonSpawnConfigWrap");
static_assert(offsetof(FSummonSpawnConfigWrap, SummonAliveTime) == 0x000000, "Member 'FSummonSpawnConfigWrap::SummonAliveTime' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, BornDelayTime) == 0x000004, "Member 'FSummonSpawnConfigWrap::BornDelayTime' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, BornEffDisplayTime) == 0x000008, "Member 'FSummonSpawnConfigWrap::BornEffDisplayTime' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, BeforeBornTime) == 0x00000C, "Member 'FSummonSpawnConfigWrap::BeforeBornTime' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, TamerTemplate) == 0x000010, "Member 'FSummonSpawnConfigWrap::TamerTemplate' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, SearchTargetType) == 0x000018, "Member 'FSummonSpawnConfigWrap::SearchTargetType' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, SummonUnitRotationType) == 0x000019, "Member 'FSummonSpawnConfigWrap::SummonUnitRotationType' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, SummonUnitLocationType) == 0x00001A, "Member 'FSummonSpawnConfigWrap::SummonUnitLocationType' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, SummonPointDA) == 0x000020, "Member 'FSummonSpawnConfigWrap::SummonPointDA' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, EQSTemplate) == 0x000028, "Member 'FSummonSpawnConfigWrap::EQSTemplate' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, PointSetCachedReqID) == 0x000030, "Member 'FSummonSpawnConfigWrap::PointSetCachedReqID' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, SpawnSocketName) == 0x000034, "Member 'FSummonSpawnConfigWrap::SpawnSocketName' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, SpawnScaleRange) == 0x000040, "Member 'FSummonSpawnConfigWrap::SpawnScaleRange' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, BornSkillIDs) == 0x000058, "Member 'FSummonSpawnConfigWrap::BornSkillIDs' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, BornMontages) == 0x000068, "Member 'FSummonSpawnConfigWrap::BornMontages' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, CopyAttrConfigID) == 0x000078, "Member 'FSummonSpawnConfigWrap::CopyAttrConfigID' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, InitSpeed) == 0x000080, "Member 'FSummonSpawnConfigWrap::InitSpeed' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, SpawnBirthBuff) == 0x000088, "Member 'FSummonSpawnConfigWrap::SpawnBirthBuff' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, BornParticle) == 0x000098, "Member 'FSummonSpawnConfigWrap::BornParticle' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, BornNiagara) == 0x0000A0, "Member 'FSummonSpawnConfigWrap::BornNiagara' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, BornDBC) == 0x0000A8, "Member 'FSummonSpawnConfigWrap::BornDBC' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, DisappearMontagePathList) == 0x0000B0, "Member 'FSummonSpawnConfigWrap::DisappearMontagePathList' has a wrong offset!");
static_assert(offsetof(FSummonSpawnConfigWrap, DestroyDelayTime) == 0x0000C0, "Member 'FSummonSpawnConfigWrap::DestroyDelayTime' has a wrong offset!");

// SharpStruct b1-Managed.MapAttrNode
// 0x0010 (0x0010 - 0x0000)
struct FMapAttrNode final
{
public:
	EMapCatFlag                                   BlockCatDir;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsPointBlock : 1;                                  // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EPointBlockLocFlag                            InPointLoc;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        PathCatID;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapAttrNode) == 0x000008, "Wrong alignment on FMapAttrNode");
static_assert(sizeof(FMapAttrNode) == 0x000010, "Wrong size on FMapAttrNode");
static_assert(offsetof(FMapAttrNode, BlockCatDir) == 0x000000, "Member 'FMapAttrNode::BlockCatDir' has a wrong offset!");
static_assert(offsetof(FMapAttrNode, InPointLoc) == 0x000002, "Member 'FMapAttrNode::InPointLoc' has a wrong offset!");
static_assert(offsetof(FMapAttrNode, PathCatID) == 0x000008, "Member 'FMapAttrNode::PathCatID' has a wrong offset!");

// SharpStruct b1-Managed.ContinueBehaviorInfo
// 0x0018 (0x0018 - 0x0000)
struct FContinueBehaviorInfo final
{
public:
	EContinueBehaviorType                         CBT;                                               // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MontagePos;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           BeatbackMontage;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContinueBehaviorInfo) == 0x000008, "Wrong alignment on FContinueBehaviorInfo");
static_assert(sizeof(FContinueBehaviorInfo) == 0x000018, "Wrong size on FContinueBehaviorInfo");
static_assert(offsetof(FContinueBehaviorInfo, CBT) == 0x000000, "Member 'FContinueBehaviorInfo::CBT' has a wrong offset!");
static_assert(offsetof(FContinueBehaviorInfo, MontagePos) == 0x000004, "Member 'FContinueBehaviorInfo::MontagePos' has a wrong offset!");
static_assert(offsetof(FContinueBehaviorInfo, SkillID) == 0x000008, "Member 'FContinueBehaviorInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FContinueBehaviorInfo, BeatbackMontage) == 0x000010, "Member 'FContinueBehaviorInfo::BeatbackMontage' has a wrong offset!");

// SharpStruct b1-Managed.SummonReq
// 0x0158 (0x0158 - 0x0000)
struct FSummonReq final
{
public:
	ESummonType                                   SummonType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCalliopeGuid                          SummonGuid;                                        // 0x0004(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonID;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonCount;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Summoner;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTeleportSelf : 1;                                 // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_28_1 : 7;                                   // 0x0028(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bConfuseSelf : 1;                                  // 0x0029(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EffectCaster;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 BuffOwner;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnPointRot;                                     // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FContinueBehaviorInfo                  ContinueBehaviorInfo;                              // 0x0070(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseContinuousRefresh : 1;                         // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSummonSpawnConfigWrap                 SpawnConfigWrap;                                   // 0x0090(0x00C8)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummonReq) == 0x000008, "Wrong alignment on FSummonReq");
static_assert(sizeof(FSummonReq) == 0x000158, "Wrong size on FSummonReq");
static_assert(offsetof(FSummonReq, SummonType) == 0x000000, "Member 'FSummonReq::SummonType' has a wrong offset!");
static_assert(offsetof(FSummonReq, SummonGuid) == 0x000004, "Member 'FSummonReq::SummonGuid' has a wrong offset!");
static_assert(offsetof(FSummonReq, SummonID) == 0x000014, "Member 'FSummonReq::SummonID' has a wrong offset!");
static_assert(offsetof(FSummonReq, SummonCount) == 0x000018, "Member 'FSummonReq::SummonCount' has a wrong offset!");
static_assert(offsetof(FSummonReq, Summoner) == 0x000020, "Member 'FSummonReq::Summoner' has a wrong offset!");
static_assert(offsetof(FSummonReq, EffectCaster) == 0x000030, "Member 'FSummonReq::EffectCaster' has a wrong offset!");
static_assert(offsetof(FSummonReq, BuffOwner) == 0x000038, "Member 'FSummonReq::BuffOwner' has a wrong offset!");
static_assert(offsetof(FSummonReq, HitLocation) == 0x000040, "Member 'FSummonReq::HitLocation' has a wrong offset!");
static_assert(offsetof(FSummonReq, SpawnPointRot) == 0x000058, "Member 'FSummonReq::SpawnPointRot' has a wrong offset!");
static_assert(offsetof(FSummonReq, ContinueBehaviorInfo) == 0x000070, "Member 'FSummonReq::ContinueBehaviorInfo' has a wrong offset!");
static_assert(offsetof(FSummonReq, SpawnConfigWrap) == 0x000090, "Member 'FSummonReq::SpawnConfigWrap' has a wrong offset!");

// SharpStruct b1-Managed.ServantReq
// 0x01E0 (0x01E0 - 0x0000)
struct FServantReq final
{
public:
	struct FCalliopeGuid                          SummonInstanceID;                                  // 0x0000(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServantTamerGuid;                                  // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Summoner;                                          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CatchTarget;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EServantType                                  ServantType;                                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FContinueBehaviorInfo                  CBI;                                               // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AnimationSyncHostGuid;                             // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EServantSearchTargetType                      SearchTargetType;                                  // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CooperativeSCGuid;                                 // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBornTime;                                     // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           BornMontage;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BornSkill;                                         // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayEffectTime;                                   // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelaySummonTime;                                   // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BornTransform;                                     // 0x00A0(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AliveTime;                                         // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 TamerTemplate;                                     // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MasterActor;                                       // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DummyServantActor;                                 // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EquipPosition, int32>                    MapEquip;                                          // 0x0120(0x0050)(NativeAccessSpecifierPublic)
	TArray<float>                                 AttrSnapShot;                                      // 0x0170(0x0010)(NativeAccessSpecifierPublic)
	TArray<uint8>                                 AttrCopyConfigDesc;                                // 0x0180(0x0010)(NativeAccessSpecifierPublic)
	uint8                                         bFaceToPlayer : 1;                                 // 0x0190(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitSpeed;                                         // 0x0194(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BornParticle;                                      // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         BornNiagara;                                       // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWDataAsset_B1DBC*                    BornDBC;                                           // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BirthBuffIDs;                                      // 0x01B0(0x0010)(NativeAccessSpecifierPublic)
	TArray<class FString>                         DisappearMontagePathList;                          // 0x01C0(0x0010)(NativeAccessSpecifierPublic)
	float                                         DestroyDelayTime;                                  // 0x01D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SafeClampToLand : 1;                               // 0x01D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FServantReq) == 0x000010, "Wrong alignment on FServantReq");
static_assert(sizeof(FServantReq) == 0x0001E0, "Wrong size on FServantReq");
static_assert(offsetof(FServantReq, SummonInstanceID) == 0x000000, "Member 'FServantReq::SummonInstanceID' has a wrong offset!");
static_assert(offsetof(FServantReq, ServantTamerGuid) == 0x000010, "Member 'FServantReq::ServantTamerGuid' has a wrong offset!");
static_assert(offsetof(FServantReq, Summoner) == 0x000020, "Member 'FServantReq::Summoner' has a wrong offset!");
static_assert(offsetof(FServantReq, CatchTarget) == 0x000028, "Member 'FServantReq::CatchTarget' has a wrong offset!");
static_assert(offsetof(FServantReq, ServantType) == 0x000030, "Member 'FServantReq::ServantType' has a wrong offset!");
static_assert(offsetof(FServantReq, CBI) == 0x000038, "Member 'FServantReq::CBI' has a wrong offset!");
static_assert(offsetof(FServantReq, AnimationSyncHostGuid) == 0x000050, "Member 'FServantReq::AnimationSyncHostGuid' has a wrong offset!");
static_assert(offsetof(FServantReq, SearchTargetType) == 0x000060, "Member 'FServantReq::SearchTargetType' has a wrong offset!");
static_assert(offsetof(FServantReq, CooperativeSCGuid) == 0x000068, "Member 'FServantReq::CooperativeSCGuid' has a wrong offset!");
static_assert(offsetof(FServantReq, DelayBornTime) == 0x000078, "Member 'FServantReq::DelayBornTime' has a wrong offset!");
static_assert(offsetof(FServantReq, BornMontage) == 0x000080, "Member 'FServantReq::BornMontage' has a wrong offset!");
static_assert(offsetof(FServantReq, BornSkill) == 0x000088, "Member 'FServantReq::BornSkill' has a wrong offset!");
static_assert(offsetof(FServantReq, DelayEffectTime) == 0x00008C, "Member 'FServantReq::DelayEffectTime' has a wrong offset!");
static_assert(offsetof(FServantReq, DelaySummonTime) == 0x000090, "Member 'FServantReq::DelaySummonTime' has a wrong offset!");
static_assert(offsetof(FServantReq, BornTransform) == 0x0000A0, "Member 'FServantReq::BornTransform' has a wrong offset!");
static_assert(offsetof(FServantReq, AliveTime) == 0x000100, "Member 'FServantReq::AliveTime' has a wrong offset!");
static_assert(offsetof(FServantReq, TamerTemplate) == 0x000108, "Member 'FServantReq::TamerTemplate' has a wrong offset!");
static_assert(offsetof(FServantReq, MasterActor) == 0x000110, "Member 'FServantReq::MasterActor' has a wrong offset!");
static_assert(offsetof(FServantReq, DummyServantActor) == 0x000118, "Member 'FServantReq::DummyServantActor' has a wrong offset!");
static_assert(offsetof(FServantReq, MapEquip) == 0x000120, "Member 'FServantReq::MapEquip' has a wrong offset!");
static_assert(offsetof(FServantReq, AttrSnapShot) == 0x000170, "Member 'FServantReq::AttrSnapShot' has a wrong offset!");
static_assert(offsetof(FServantReq, AttrCopyConfigDesc) == 0x000180, "Member 'FServantReq::AttrCopyConfigDesc' has a wrong offset!");
static_assert(offsetof(FServantReq, InitSpeed) == 0x000194, "Member 'FServantReq::InitSpeed' has a wrong offset!");
static_assert(offsetof(FServantReq, BornParticle) == 0x000198, "Member 'FServantReq::BornParticle' has a wrong offset!");
static_assert(offsetof(FServantReq, BornNiagara) == 0x0001A0, "Member 'FServantReq::BornNiagara' has a wrong offset!");
static_assert(offsetof(FServantReq, BornDBC) == 0x0001A8, "Member 'FServantReq::BornDBC' has a wrong offset!");
static_assert(offsetof(FServantReq, BirthBuffIDs) == 0x0001B0, "Member 'FServantReq::BirthBuffIDs' has a wrong offset!");
static_assert(offsetof(FServantReq, DisappearMontagePathList) == 0x0001C0, "Member 'FServantReq::DisappearMontagePathList' has a wrong offset!");
static_assert(offsetof(FServantReq, DestroyDelayTime) == 0x0001D0, "Member 'FServantReq::DestroyDelayTime' has a wrong offset!");

// SharpStruct b1-Managed.MatCommParams
// 0x0060 (0x0060 - 0x0000)
struct FMatCommParams final
{
public:
	uint8                                         UseTimerParam : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timer;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseRandomParam : 1;                                // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomUpdate;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseMouseParam : 1;                                 // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_10_1 : 7;                                   // 0x0010(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsShowFocusPosInGamepad : 1;                       // 0x0011(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MousePos;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSpeed;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseWidgetParam : 1;                                // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_2C_1 : 7;                                   // 0x002C(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsDynamic : 1;                                     // 0x002D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewportScale;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AbsPos;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AbsSize;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InHover : 1;                                       // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FMatCommParams) == 0x000008, "Wrong alignment on FMatCommParams");
static_assert(sizeof(FMatCommParams) == 0x000060, "Wrong size on FMatCommParams");
static_assert(offsetof(FMatCommParams, Timer) == 0x000004, "Member 'FMatCommParams::Timer' has a wrong offset!");
static_assert(offsetof(FMatCommParams, RandomUpdate) == 0x00000C, "Member 'FMatCommParams::RandomUpdate' has a wrong offset!");
static_assert(offsetof(FMatCommParams, MousePos) == 0x000018, "Member 'FMatCommParams::MousePos' has a wrong offset!");
static_assert(offsetof(FMatCommParams, MouseSpeed) == 0x000028, "Member 'FMatCommParams::MouseSpeed' has a wrong offset!");
static_assert(offsetof(FMatCommParams, ViewportScale) == 0x000030, "Member 'FMatCommParams::ViewportScale' has a wrong offset!");
static_assert(offsetof(FMatCommParams, AbsPos) == 0x000038, "Member 'FMatCommParams::AbsPos' has a wrong offset!");
static_assert(offsetof(FMatCommParams, AbsSize) == 0x000048, "Member 'FMatCommParams::AbsSize' has a wrong offset!");

// SharpStruct b1-Managed.RangePointSetRule
// 0x0028 (0x0028 - 0x0000)
struct FRangePointSetRule final
{
public:
	ERangePointSetType                            RangePointSetType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatrixDensity;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircleRadius;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerCircleRadius;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Noise;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRangePointSetRule) == 0x000008, "Wrong alignment on FRangePointSetRule");
static_assert(sizeof(FRangePointSetRule) == 0x000028, "Wrong size on FRangePointSetRule");
static_assert(offsetof(FRangePointSetRule, RangePointSetType) == 0x000000, "Member 'FRangePointSetRule::RangePointSetType' has a wrong offset!");
static_assert(offsetof(FRangePointSetRule, MatrixDensity) == 0x000004, "Member 'FRangePointSetRule::MatrixDensity' has a wrong offset!");
static_assert(offsetof(FRangePointSetRule, CircleRadius) == 0x000008, "Member 'FRangePointSetRule::CircleRadius' has a wrong offset!");
static_assert(offsetof(FRangePointSetRule, InnerCircleRadius) == 0x00000C, "Member 'FRangePointSetRule::InnerCircleRadius' has a wrong offset!");
static_assert(offsetof(FRangePointSetRule, Noise) == 0x000010, "Member 'FRangePointSetRule::Noise' has a wrong offset!");

// SharpStruct b1-Managed.ProjectilePosOffsetStruct
// 0x0058 (0x0058 - 0x0000)
struct FProjectilePosOffsetStruct final
{
public:
	EProjectilePosOffsetType                      PosOffsetType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectilePosOffsetSpace                     OffsetSpace;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectileBaseType                           BaseType;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseSocket : 1;                                     // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	class FName                                   SocketName;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PosOffset;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRangePointSetRule                     RangeOffsetInfo;                                   // 0x0028(0x0028)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalOffset_World;                              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectilePosOffsetStruct) == 0x000008, "Wrong alignment on FProjectilePosOffsetStruct");
static_assert(sizeof(FProjectilePosOffsetStruct) == 0x000058, "Wrong size on FProjectilePosOffsetStruct");
static_assert(offsetof(FProjectilePosOffsetStruct, PosOffsetType) == 0x000000, "Member 'FProjectilePosOffsetStruct::PosOffsetType' has a wrong offset!");
static_assert(offsetof(FProjectilePosOffsetStruct, OffsetSpace) == 0x000001, "Member 'FProjectilePosOffsetStruct::OffsetSpace' has a wrong offset!");
static_assert(offsetof(FProjectilePosOffsetStruct, BaseType) == 0x000002, "Member 'FProjectilePosOffsetStruct::BaseType' has a wrong offset!");
static_assert(offsetof(FProjectilePosOffsetStruct, SocketName) == 0x000004, "Member 'FProjectilePosOffsetStruct::SocketName' has a wrong offset!");
static_assert(offsetof(FProjectilePosOffsetStruct, PosOffset) == 0x000010, "Member 'FProjectilePosOffsetStruct::PosOffset' has a wrong offset!");
static_assert(offsetof(FProjectilePosOffsetStruct, RangeOffsetInfo) == 0x000028, "Member 'FProjectilePosOffsetStruct::RangeOffsetInfo' has a wrong offset!");
static_assert(offsetof(FProjectilePosOffsetStruct, VerticalOffset_World) == 0x000050, "Member 'FProjectilePosOffsetStruct::VerticalOffset_World' has a wrong offset!");

// SharpStruct b1-Managed.PlayerTransactionInteractStartParams
// 0x0008 (0x0008 - 0x0000)
struct FPlayerTransactionInteractStartParams final
{
public:
	class AActor*                                 InteractTarget;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerTransactionInteractStartParams) == 0x000008, "Wrong alignment on FPlayerTransactionInteractStartParams");
static_assert(sizeof(FPlayerTransactionInteractStartParams) == 0x000008, "Wrong size on FPlayerTransactionInteractStartParams");
static_assert(offsetof(FPlayerTransactionInteractStartParams, InteractTarget) == 0x000000, "Member 'FPlayerTransactionInteractStartParams::InteractTarget' has a wrong offset!");

// SharpStruct b1-Managed.GamepadCustomizedInputDetailConfig
// 0x0030 (0x0030 - 0x0000)
struct FGamepadCustomizedInputDetailConfig final
{
public:
	int32                                         DetailUIWord;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimationName;                                     // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FirstMappableNames;                                // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           SecondMappableNames;                               // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadCustomizedInputDetailConfig) == 0x000008, "Wrong alignment on FGamepadCustomizedInputDetailConfig");
static_assert(sizeof(FGamepadCustomizedInputDetailConfig) == 0x000030, "Wrong size on FGamepadCustomizedInputDetailConfig");
static_assert(offsetof(FGamepadCustomizedInputDetailConfig, DetailUIWord) == 0x000000, "Member 'FGamepadCustomizedInputDetailConfig::DetailUIWord' has a wrong offset!");
static_assert(offsetof(FGamepadCustomizedInputDetailConfig, AnimationName) == 0x000004, "Member 'FGamepadCustomizedInputDetailConfig::AnimationName' has a wrong offset!");
static_assert(offsetof(FGamepadCustomizedInputDetailConfig, FirstMappableNames) == 0x000010, "Member 'FGamepadCustomizedInputDetailConfig::FirstMappableNames' has a wrong offset!");
static_assert(offsetof(FGamepadCustomizedInputDetailConfig, SecondMappableNames) == 0x000020, "Member 'FGamepadCustomizedInputDetailConfig::SecondMappableNames' has a wrong offset!");

// SharpStruct b1-Managed.EquipMeshConfig
// 0x0030 (0x0030 - 0x0000)
struct FEquipMeshConfig final
{
public:
	class USkeletalMesh*                          Head;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          UpWear;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Arm;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Foot;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Hulu;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Weapon;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipMeshConfig) == 0x000008, "Wrong alignment on FEquipMeshConfig");
static_assert(sizeof(FEquipMeshConfig) == 0x000030, "Wrong size on FEquipMeshConfig");
static_assert(offsetof(FEquipMeshConfig, Head) == 0x000000, "Member 'FEquipMeshConfig::Head' has a wrong offset!");
static_assert(offsetof(FEquipMeshConfig, UpWear) == 0x000008, "Member 'FEquipMeshConfig::UpWear' has a wrong offset!");
static_assert(offsetof(FEquipMeshConfig, Arm) == 0x000010, "Member 'FEquipMeshConfig::Arm' has a wrong offset!");
static_assert(offsetof(FEquipMeshConfig, Foot) == 0x000018, "Member 'FEquipMeshConfig::Foot' has a wrong offset!");
static_assert(offsetof(FEquipMeshConfig, Hulu) == 0x000020, "Member 'FEquipMeshConfig::Hulu' has a wrong offset!");
static_assert(offsetof(FEquipMeshConfig, Weapon) == 0x000028, "Member 'FEquipMeshConfig::Weapon' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_PlayerLeisureOverTime
// 0x0004 (0x0004 - 0x0000)
struct FDetectCondition_PlayerLeisureOverTime final
{
public:
	float                                         PlayerLeisureOverTime;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_PlayerLeisureOverTime) == 0x000004, "Wrong alignment on FDetectCondition_PlayerLeisureOverTime");
static_assert(sizeof(FDetectCondition_PlayerLeisureOverTime) == 0x000004, "Wrong size on FDetectCondition_PlayerLeisureOverTime");
static_assert(offsetof(FDetectCondition_PlayerLeisureOverTime, PlayerLeisureOverTime) == 0x000000, "Member 'FDetectCondition_PlayerLeisureOverTime::PlayerLeisureOverTime' has a wrong offset!");

// SharpStruct b1-Managed.InteractInfoTemplateNameList
// 0x0010 (0x0010 - 0x0000)
struct FInteractInfoTemplateNameList final
{
public:
	TArray<class FName>                           BoneNameList;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractInfoTemplateNameList) == 0x000008, "Wrong alignment on FInteractInfoTemplateNameList");
static_assert(sizeof(FInteractInfoTemplateNameList) == 0x000010, "Wrong size on FInteractInfoTemplateNameList");
static_assert(offsetof(FInteractInfoTemplateNameList, BoneNameList) == 0x000000, "Member 'FInteractInfoTemplateNameList::BoneNameList' has a wrong offset!");

// SharpStruct b1-Managed.InteractInfoTemplateWithLOD
// 0x0050 (0x0050 - 0x0000)
struct FInteractInfoTemplateWithLOD final
{
public:
	TMap<int32, struct FInteractInfoTemplateNameList> InfoTemplateWithLOD;                               // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractInfoTemplateWithLOD) == 0x000008, "Wrong alignment on FInteractInfoTemplateWithLOD");
static_assert(sizeof(FInteractInfoTemplateWithLOD) == 0x000050, "Wrong size on FInteractInfoTemplateWithLOD");
static_assert(offsetof(FInteractInfoTemplateWithLOD, InfoTemplateWithLOD) == 0x000000, "Member 'FInteractInfoTemplateWithLOD::InfoTemplateWithLOD' has a wrong offset!");

// SharpStruct b1-Managed.EquipAbpConfig
// 0x0030 (0x0030 - 0x0000)
struct FEquipAbpConfig final
{
public:
	class UClass*                                 Head;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 UpWear;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Arm;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Foot;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Hulu;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Weapon;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipAbpConfig) == 0x000008, "Wrong alignment on FEquipAbpConfig");
static_assert(sizeof(FEquipAbpConfig) == 0x000030, "Wrong size on FEquipAbpConfig");
static_assert(offsetof(FEquipAbpConfig, Head) == 0x000000, "Member 'FEquipAbpConfig::Head' has a wrong offset!");
static_assert(offsetof(FEquipAbpConfig, UpWear) == 0x000008, "Member 'FEquipAbpConfig::UpWear' has a wrong offset!");
static_assert(offsetof(FEquipAbpConfig, Arm) == 0x000010, "Member 'FEquipAbpConfig::Arm' has a wrong offset!");
static_assert(offsetof(FEquipAbpConfig, Foot) == 0x000018, "Member 'FEquipAbpConfig::Foot' has a wrong offset!");
static_assert(offsetof(FEquipAbpConfig, Hulu) == 0x000020, "Member 'FEquipAbpConfig::Hulu' has a wrong offset!");
static_assert(offsetof(FEquipAbpConfig, Weapon) == 0x000028, "Member 'FEquipAbpConfig::Weapon' has a wrong offset!");

// SharpStruct b1-Managed.PerformerTag
// 0x0030 (0x0030 - 0x0000)
struct FPerformerTag final
{
public:
	struct FGameplayTagContainer                  GameplayTagContainer;                              // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           Name;                                              // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerformerTag) == 0x000008, "Wrong alignment on FPerformerTag");
static_assert(sizeof(FPerformerTag) == 0x000030, "Wrong size on FPerformerTag");
static_assert(offsetof(FPerformerTag, GameplayTagContainer) == 0x000000, "Member 'FPerformerTag::GameplayTagContainer' has a wrong offset!");
static_assert(offsetof(FPerformerTag, Name) == 0x000020, "Member 'FPerformerTag::Name' has a wrong offset!");

// SharpStruct b1-Managed.MovieGraphPlaySettings
// 0x0018 (0x0018 - 0x0000)
struct FMovieGraphPlaySettings final
{
public:
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x0000(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLevelSequenceCameraSettings           CameraSettings;                                    // 0x0014(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bUsePlayerCamera : 1;                              // 0x0016(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_16_1 : 7;                                   // 0x0016(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bTriggerMonsterGoHome : 1;                         // 0x0017(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FMovieGraphPlaySettings) == 0x000004, "Wrong alignment on FMovieGraphPlaySettings");
static_assert(sizeof(FMovieGraphPlaySettings) == 0x000018, "Wrong size on FMovieGraphPlaySettings");
static_assert(offsetof(FMovieGraphPlaySettings, PlaybackSettings) == 0x000000, "Member 'FMovieGraphPlaySettings::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(FMovieGraphPlaySettings, CameraSettings) == 0x000014, "Member 'FMovieGraphPlaySettings::CameraSettings' has a wrong offset!");

// SharpStruct b1-Managed.CheckAssignTargetInfo
// 0x0048 (0x0048 - 0x0000)
struct FCheckAssignTargetInfo final
{
public:
	uint8                                         CheckPlayer : 1;                                   // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CheckUnitGUID;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECheckConditionType                           CheckConditionType;                                // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CheckSelfIsAITarget : 1;                           // 0x0019(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HpLowPercent;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeDistance;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartId;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsPartBreak : 1;                                   // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BuffID;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffLayer;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeatbackStiffLevel;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsPlayerAttack : 1;                                // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillID;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbnormalStateType                            CheckAbnormalStateType;                            // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCheckAssignTargetInfo) == 0x000008, "Wrong alignment on FCheckAssignTargetInfo");
static_assert(sizeof(FCheckAssignTargetInfo) == 0x000048, "Wrong size on FCheckAssignTargetInfo");
static_assert(offsetof(FCheckAssignTargetInfo, CheckUnitGUID) == 0x000008, "Member 'FCheckAssignTargetInfo::CheckUnitGUID' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, CheckConditionType) == 0x000018, "Member 'FCheckAssignTargetInfo::CheckConditionType' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, HpLowPercent) == 0x00001C, "Member 'FCheckAssignTargetInfo::HpLowPercent' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, RangeDistance) == 0x000020, "Member 'FCheckAssignTargetInfo::RangeDistance' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, PartId) == 0x000024, "Member 'FCheckAssignTargetInfo::PartId' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, BuffID) == 0x00002C, "Member 'FCheckAssignTargetInfo::BuffID' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, BuffLayer) == 0x000030, "Member 'FCheckAssignTargetInfo::BuffLayer' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, BeatbackStiffLevel) == 0x000034, "Member 'FCheckAssignTargetInfo::BeatbackStiffLevel' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, SkillID) == 0x00003C, "Member 'FCheckAssignTargetInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FCheckAssignTargetInfo, CheckAbnormalStateType) == 0x000040, "Member 'FCheckAssignTargetInfo::CheckAbnormalStateType' has a wrong offset!");

// SharpStruct b1-Managed.CircusCollector
// 0x0040 (0x0040 - 0x0000)
struct FCircusCollector final
{
public:
	uint8                                         IsRootMember : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_0_1 : 7;                                    // 0x0000(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         SpawnByDefault : 1;                                // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Socket;                                            // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResID;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Member;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECircusMemberType                             MemberType;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   NickName;                                          // 0x0020(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ChildMembers;                                      // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCircusCollector) == 0x000008, "Wrong alignment on FCircusCollector");
static_assert(sizeof(FCircusCollector) == 0x000040, "Wrong size on FCircusCollector");
static_assert(offsetof(FCircusCollector, Socket) == 0x000004, "Member 'FCircusCollector::Socket' has a wrong offset!");
static_assert(offsetof(FCircusCollector, ResID) == 0x00000C, "Member 'FCircusCollector::ResID' has a wrong offset!");
static_assert(offsetof(FCircusCollector, Member) == 0x000010, "Member 'FCircusCollector::Member' has a wrong offset!");
static_assert(offsetof(FCircusCollector, MemberType) == 0x000018, "Member 'FCircusCollector::MemberType' has a wrong offset!");
static_assert(offsetof(FCircusCollector, NickName) == 0x000020, "Member 'FCircusCollector::NickName' has a wrong offset!");
static_assert(offsetof(FCircusCollector, ChildMembers) == 0x000030, "Member 'FCircusCollector::ChildMembers' has a wrong offset!");

// SharpStruct b1-Managed.FGSArmorCounterWithBlood
// 0x000C (0x000C - 0x0000)
struct FFGSArmorCounterWithBlood final
{
public:
	int32                                         BloodChangeLine;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeHitNum_Min;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeHitNum_Max;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSArmorCounterWithBlood) == 0x000004, "Wrong alignment on FFGSArmorCounterWithBlood");
static_assert(sizeof(FFGSArmorCounterWithBlood) == 0x00000C, "Wrong size on FFGSArmorCounterWithBlood");
static_assert(offsetof(FFGSArmorCounterWithBlood, BloodChangeLine) == 0x000000, "Member 'FFGSArmorCounterWithBlood::BloodChangeLine' has a wrong offset!");
static_assert(offsetof(FFGSArmorCounterWithBlood, BeHitNum_Min) == 0x000004, "Member 'FFGSArmorCounterWithBlood::BeHitNum_Min' has a wrong offset!");
static_assert(offsetof(FFGSArmorCounterWithBlood, BeHitNum_Max) == 0x000008, "Member 'FFGSArmorCounterWithBlood::BeHitNum_Max' has a wrong offset!");

// SharpStruct b1-Managed.SpiderSpawnPointData
// 0x0018 (0x0018 - 0x0000)
struct FSpiderSpawnPointData final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATargetPoint*>                   SpiderSpawnPoints;                                 // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpiderSpawnPointData) == 0x000008, "Wrong alignment on FSpiderSpawnPointData");
static_assert(sizeof(FSpiderSpawnPointData) == 0x000018, "Wrong size on FSpiderSpawnPointData");
static_assert(offsetof(FSpiderSpawnPointData, Tag) == 0x000000, "Member 'FSpiderSpawnPointData::Tag' has a wrong offset!");
static_assert(offsetof(FSpiderSpawnPointData, SpiderSpawnPoints) == 0x000008, "Member 'FSpiderSpawnPointData::SpiderSpawnPoints' has a wrong offset!");

// SharpStruct b1-Managed.ProjectileDisableAbilityMask
// 0x0004 (0x0004 - 0x0000)
struct FProjectileDisableAbilityMask final
{
public:
	int32                                         Mask;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileDisableAbilityMask) == 0x000004, "Wrong alignment on FProjectileDisableAbilityMask");
static_assert(sizeof(FProjectileDisableAbilityMask) == 0x000004, "Wrong size on FProjectileDisableAbilityMask");
static_assert(offsetof(FProjectileDisableAbilityMask, Mask) == 0x000000, "Member 'FProjectileDisableAbilityMask::Mask' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Spider
// 0x0060 (0x0060 - 0x0000)
struct FAnimHumanoidSetting_Spider final
{
public:
	class UAnimSequence*                          AnimSeqIdle;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpStart;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpLoop;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpEndLight;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpEndHeavy;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingHeightThreshold;                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeScale;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 LegMoveDistance;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<float>                                 LegForwardDistance;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           LegNames;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Spider) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_Spider");
static_assert(sizeof(FAnimHumanoidSetting_Spider) == 0x000060, "Wrong size on FAnimHumanoidSetting_Spider");
static_assert(offsetof(FAnimHumanoidSetting_Spider, AnimSeqIdle) == 0x000000, "Member 'FAnimHumanoidSetting_Spider::AnimSeqIdle' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, JumpStart) == 0x000008, "Member 'FAnimHumanoidSetting_Spider::JumpStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, JumpLoop) == 0x000010, "Member 'FAnimHumanoidSetting_Spider::JumpLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, JumpEndLight) == 0x000018, "Member 'FAnimHumanoidSetting_Spider::JumpEndLight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, JumpEndHeavy) == 0x000020, "Member 'FAnimHumanoidSetting_Spider::JumpEndHeavy' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, FallingHeightThreshold) == 0x000028, "Member 'FAnimHumanoidSetting_Spider::FallingHeightThreshold' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, RelativeScale) == 0x00002C, "Member 'FAnimHumanoidSetting_Spider::RelativeScale' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, LegMoveDistance) == 0x000030, "Member 'FAnimHumanoidSetting_Spider::LegMoveDistance' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, LegForwardDistance) == 0x000040, "Member 'FAnimHumanoidSetting_Spider::LegForwardDistance' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider, LegNames) == 0x000050, "Member 'FAnimHumanoidSetting_Spider::LegNames' has a wrong offset!");

// SharpStruct b1-Managed.FGSBuffTriggerUnitCondition
// 0x01A8 (0x01A8 - 0x0000)
struct FFGSBuffTriggerUnitCondition final
{
public:
	EConditionsTarget                             ConditionsTarget;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class ABUTamerActor>>   ObservedTamers;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          ObservedTamerRefs;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveIsActivedUnit : 1;                          // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class ABUTamerActor>>   ObserveActiveTamers;                               // 0x0040(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          ObserveActiveTamerRefs;                            // 0x0050(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveIsDeadUnit : 1;                             // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class ABUTamerActor>>   ObserveDeadTamers;                                 // 0x0068(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGsActorGuidReference>          ObserveDeadTamerRefs;                              // 0x0078(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveHasUnitState : 1;                           // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBGUUnitState>                         ObserveUnitStates;                                 // 0x0090(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveHasSimpleState : 1;                         // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBGUSimpleState>                       ObserveSimpleStates;                               // 0x00A8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveHasBuff : 1;                                // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ObserveBuffIDs;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ObserveHasUnitAttr : 1;                            // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUnitAttrCondition>             ObserveUnitAttrs;                                  // 0x00D8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFGSBuffTriggerConfig                  BuffTriggerConfig;                                 // 0x00E8(0x0090)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABGUCharacterCS*>                ObservedUnits;                                     // 0x0178(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<class ABGUCharacterCS*>                ObserveActiveUnits;                                // 0x0188(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TArray<class ABGUCharacterCS*>                ObserveDeadUnits;                                  // 0x0198(0x0010)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSBuffTriggerUnitCondition) == 0x000008, "Wrong alignment on FFGSBuffTriggerUnitCondition");
static_assert(sizeof(FFGSBuffTriggerUnitCondition) == 0x0001A8, "Wrong size on FFGSBuffTriggerUnitCondition");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ConditionsTarget) == 0x000000, "Member 'FFGSBuffTriggerUnitCondition::ConditionsTarget' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, Tags) == 0x000008, "Member 'FFGSBuffTriggerUnitCondition::Tags' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObservedTamers) == 0x000018, "Member 'FFGSBuffTriggerUnitCondition::ObservedTamers' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObservedTamerRefs) == 0x000028, "Member 'FFGSBuffTriggerUnitCondition::ObservedTamerRefs' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveActiveTamers) == 0x000040, "Member 'FFGSBuffTriggerUnitCondition::ObserveActiveTamers' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveActiveTamerRefs) == 0x000050, "Member 'FFGSBuffTriggerUnitCondition::ObserveActiveTamerRefs' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveDeadTamers) == 0x000068, "Member 'FFGSBuffTriggerUnitCondition::ObserveDeadTamers' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveDeadTamerRefs) == 0x000078, "Member 'FFGSBuffTriggerUnitCondition::ObserveDeadTamerRefs' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveUnitStates) == 0x000090, "Member 'FFGSBuffTriggerUnitCondition::ObserveUnitStates' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveSimpleStates) == 0x0000A8, "Member 'FFGSBuffTriggerUnitCondition::ObserveSimpleStates' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveBuffIDs) == 0x0000C0, "Member 'FFGSBuffTriggerUnitCondition::ObserveBuffIDs' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveUnitAttrs) == 0x0000D8, "Member 'FFGSBuffTriggerUnitCondition::ObserveUnitAttrs' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, BuffTriggerConfig) == 0x0000E8, "Member 'FFGSBuffTriggerUnitCondition::BuffTriggerConfig' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObservedUnits) == 0x000178, "Member 'FFGSBuffTriggerUnitCondition::ObservedUnits' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveActiveUnits) == 0x000188, "Member 'FFGSBuffTriggerUnitCondition::ObserveActiveUnits' has a wrong offset!");
static_assert(offsetof(FFGSBuffTriggerUnitCondition, ObserveDeadUnits) == 0x000198, "Member 'FFGSBuffTriggerUnitCondition::ObserveDeadUnits' has a wrong offset!");

// SharpStruct b1-Managed.PickingConditionItem
// 0x000C (0x000C - 0x0000)
struct FPickingConditionItem final
{
public:
	uint8                                         UseCondi_HasItem : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Condi_HasItem_TargetItemID;                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Condi_HasItem_InteractGroupID;                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPickingConditionItem) == 0x000004, "Wrong alignment on FPickingConditionItem");
static_assert(sizeof(FPickingConditionItem) == 0x00000C, "Wrong size on FPickingConditionItem");
static_assert(offsetof(FPickingConditionItem, Condi_HasItem_TargetItemID) == 0x000004, "Member 'FPickingConditionItem::Condi_HasItem_TargetItemID' has a wrong offset!");
static_assert(offsetof(FPickingConditionItem, Condi_HasItem_InteractGroupID) == 0x000008, "Member 'FPickingConditionItem::Condi_HasItem_InteractGroupID' has a wrong offset!");

// SharpStruct b1-Managed.FAKEventParamter
// 0x0078 (0x0078 - 0x0000)
struct FFAKEventParamter final
{
public:
	class FString                                 AttachPointName;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           AkEvent;                                           // 0x0010(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           AkStopEvent;                                       // 0x0038(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Follow : 1;                                        // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventName;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFAKEventParamter) == 0x000008, "Wrong alignment on FFAKEventParamter");
static_assert(sizeof(FFAKEventParamter) == 0x000078, "Wrong size on FFAKEventParamter");
static_assert(offsetof(FFAKEventParamter, AttachPointName) == 0x000000, "Member 'FFAKEventParamter::AttachPointName' has a wrong offset!");
static_assert(offsetof(FFAKEventParamter, AkEvent) == 0x000010, "Member 'FFAKEventParamter::AkEvent' has a wrong offset!");
static_assert(offsetof(FFAKEventParamter, AkStopEvent) == 0x000038, "Member 'FFAKEventParamter::AkStopEvent' has a wrong offset!");
static_assert(offsetof(FFAKEventParamter, EventName) == 0x000068, "Member 'FFAKEventParamter::EventName' has a wrong offset!");

// SharpStruct b1-Managed.HitDestructibleActorConfig
// 0x0003 (0x0003 - 0x0000)
struct FHitDestructibleActorConfig final
{
public:
	uint8                                         EnableCanHitDestructible : 1;                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EGSHitDestructibleStrengthLevel               HitStrengthLevel;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSHitDestructibleDirection                   HitDirection;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitDestructibleActorConfig) == 0x000001, "Wrong alignment on FHitDestructibleActorConfig");
static_assert(sizeof(FHitDestructibleActorConfig) == 0x000003, "Wrong size on FHitDestructibleActorConfig");
static_assert(offsetof(FHitDestructibleActorConfig, HitStrengthLevel) == 0x000001, "Member 'FHitDestructibleActorConfig::HitStrengthLevel' has a wrong offset!");
static_assert(offsetof(FHitDestructibleActorConfig, HitDirection) == 0x000002, "Member 'FHitDestructibleActorConfig::HitDirection' has a wrong offset!");

// SharpStruct b1-Managed.TriggerEffectWithCondition
// 0x0030 (0x0030 - 0x0000)
struct FTriggerEffectWithCondition final
{
public:
	EDetectedUnitType                             UnitType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDetectCondition>               Conditions;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsReverseCondition : 1;                            // 0x0019(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 EffectIDList;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriggerEffectWithCondition) == 0x000008, "Wrong alignment on FTriggerEffectWithCondition");
static_assert(sizeof(FTriggerEffectWithCondition) == 0x000030, "Wrong size on FTriggerEffectWithCondition");
static_assert(offsetof(FTriggerEffectWithCondition, UnitType) == 0x000000, "Member 'FTriggerEffectWithCondition::UnitType' has a wrong offset!");
static_assert(offsetof(FTriggerEffectWithCondition, Conditions) == 0x000008, "Member 'FTriggerEffectWithCondition::Conditions' has a wrong offset!");
static_assert(offsetof(FTriggerEffectWithCondition, ConditionalRelation) == 0x000018, "Member 'FTriggerEffectWithCondition::ConditionalRelation' has a wrong offset!");
static_assert(offsetof(FTriggerEffectWithCondition, EffectIDList) == 0x000020, "Member 'FTriggerEffectWithCondition::EffectIDList' has a wrong offset!");

// SharpStruct b1-Managed.SweepCheckParamter
// 0x00A0 (0x00A0 - 0x0000)
struct FSweepCheckParamter final
{
public:
	int32                                         WeaponIndex;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUStCheckShape>                 SweepCheckShape;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 EffectIDList;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FAbnormalStateAccConfig>        AbnormalStateEffectList;                           // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 EffectIDListForSceneItem;                          // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHitDestructibleActorConfig            HitDestructibleActorConfig;                        // 0x0048(0x0003)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x1];                                       // 0x004B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitChrAudioID;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitChrFXWeight;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitCheckConf                          HitCheckConfl;                                     // 0x0054(0x0003)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CanHitBackBullet : 1;                              // 0x0057(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         SweepCheckProtectTime;                             // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Animation;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AtkReboundingAM;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LowAtkReboundingAM;                                // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SweepCheckGroupID;                                 // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTriggerEffectWithCondition>    EffectsWithCondition_Before;                       // 0x0080(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTriggerEffectWithCondition>    EffectsWithCondition_After;                        // 0x0090(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSweepCheckParamter) == 0x000008, "Wrong alignment on FSweepCheckParamter");
static_assert(sizeof(FSweepCheckParamter) == 0x0000A0, "Wrong size on FSweepCheckParamter");
static_assert(offsetof(FSweepCheckParamter, WeaponIndex) == 0x000000, "Member 'FSweepCheckParamter::WeaponIndex' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, SweepCheckShape) == 0x000008, "Member 'FSweepCheckParamter::SweepCheckShape' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, EffectIDList) == 0x000018, "Member 'FSweepCheckParamter::EffectIDList' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, AbnormalStateEffectList) == 0x000028, "Member 'FSweepCheckParamter::AbnormalStateEffectList' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, EffectIDListForSceneItem) == 0x000038, "Member 'FSweepCheckParamter::EffectIDListForSceneItem' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, HitDestructibleActorConfig) == 0x000048, "Member 'FSweepCheckParamter::HitDestructibleActorConfig' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, HitChrAudioID) == 0x00004C, "Member 'FSweepCheckParamter::HitChrAudioID' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, HitChrFXWeight) == 0x000050, "Member 'FSweepCheckParamter::HitChrFXWeight' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, HitCheckConfl) == 0x000054, "Member 'FSweepCheckParamter::HitCheckConfl' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, SweepCheckProtectTime) == 0x000058, "Member 'FSweepCheckParamter::SweepCheckProtectTime' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, Animation) == 0x000060, "Member 'FSweepCheckParamter::Animation' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, AtkReboundingAM) == 0x000068, "Member 'FSweepCheckParamter::AtkReboundingAM' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, LowAtkReboundingAM) == 0x000070, "Member 'FSweepCheckParamter::LowAtkReboundingAM' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, SweepCheckGroupID) == 0x000078, "Member 'FSweepCheckParamter::SweepCheckGroupID' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, EffectsWithCondition_Before) == 0x000080, "Member 'FSweepCheckParamter::EffectsWithCondition_Before' has a wrong offset!");
static_assert(offsetof(FSweepCheckParamter, EffectsWithCondition_After) == 0x000090, "Member 'FSweepCheckParamter::EffectsWithCondition_After' has a wrong offset!");

// SharpStruct b1-Managed.FGSWakeUpDirectionOnFightSkillConfig
// 0x000C (0x000C - 0x0000)
struct FFGSWakeUpDirectionOnFightSkillConfig final
{
public:
	int32                                         OnFightSkillIDBack;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnFightSkillIDLeft;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnFightSkillIDRight;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSWakeUpDirectionOnFightSkillConfig) == 0x000004, "Wrong alignment on FFGSWakeUpDirectionOnFightSkillConfig");
static_assert(sizeof(FFGSWakeUpDirectionOnFightSkillConfig) == 0x00000C, "Wrong size on FFGSWakeUpDirectionOnFightSkillConfig");
static_assert(offsetof(FFGSWakeUpDirectionOnFightSkillConfig, OnFightSkillIDBack) == 0x000000, "Member 'FFGSWakeUpDirectionOnFightSkillConfig::OnFightSkillIDBack' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpDirectionOnFightSkillConfig, OnFightSkillIDLeft) == 0x000004, "Member 'FFGSWakeUpDirectionOnFightSkillConfig::OnFightSkillIDLeft' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpDirectionOnFightSkillConfig, OnFightSkillIDRight) == 0x000008, "Member 'FFGSWakeUpDirectionOnFightSkillConfig::OnFightSkillIDRight' has a wrong offset!");

// SharpStruct b1-Managed.CliffUnbalanceAMConfig
// 0x0020 (0x0020 - 0x0000)
struct FCliffUnbalanceAMConfig final
{
public:
	class UAnimMontage*                           CliffUnbalance_F;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CliffUnbalance_B;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CliffUnbalance_L;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CliffUnbalance_R;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCliffUnbalanceAMConfig) == 0x000008, "Wrong alignment on FCliffUnbalanceAMConfig");
static_assert(sizeof(FCliffUnbalanceAMConfig) == 0x000020, "Wrong size on FCliffUnbalanceAMConfig");
static_assert(offsetof(FCliffUnbalanceAMConfig, CliffUnbalance_F) == 0x000000, "Member 'FCliffUnbalanceAMConfig::CliffUnbalance_F' has a wrong offset!");
static_assert(offsetof(FCliffUnbalanceAMConfig, CliffUnbalance_B) == 0x000008, "Member 'FCliffUnbalanceAMConfig::CliffUnbalance_B' has a wrong offset!");
static_assert(offsetof(FCliffUnbalanceAMConfig, CliffUnbalance_L) == 0x000010, "Member 'FCliffUnbalanceAMConfig::CliffUnbalance_L' has a wrong offset!");
static_assert(offsetof(FCliffUnbalanceAMConfig, CliffUnbalance_R) == 0x000018, "Member 'FCliffUnbalanceAMConfig::CliffUnbalance_R' has a wrong offset!");

// SharpStruct b1-Managed.FFXActorConfig
// 0x000C (0x000C - 0x0000)
struct FFFXActorConfig final
{
public:
	float                                         LifeTime;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayDestroyTime;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFXActorType                                  FXActorType;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFFXActorConfig) == 0x000004, "Wrong alignment on FFFXActorConfig");
static_assert(sizeof(FFFXActorConfig) == 0x00000C, "Wrong size on FFFXActorConfig");
static_assert(offsetof(FFFXActorConfig, LifeTime) == 0x000000, "Member 'FFFXActorConfig::LifeTime' has a wrong offset!");
static_assert(offsetof(FFFXActorConfig, DelayDestroyTime) == 0x000004, "Member 'FFFXActorConfig::DelayDestroyTime' has a wrong offset!");
static_assert(offsetof(FFFXActorConfig, FXActorType) == 0x000008, "Member 'FFFXActorConfig::FXActorType' has a wrong offset!");

// SharpStruct b1-Managed.MeditationPointConfig
// 0x0008 (0x0008 - 0x0000)
struct FMeditationPointConfig final
{
public:
	int32                                         MeditationPointID;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetCheckRange;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeditationPointConfig) == 0x000004, "Wrong alignment on FMeditationPointConfig");
static_assert(sizeof(FMeditationPointConfig) == 0x000008, "Wrong size on FMeditationPointConfig");
static_assert(offsetof(FMeditationPointConfig, MeditationPointID) == 0x000000, "Member 'FMeditationPointConfig::MeditationPointID' has a wrong offset!");
static_assert(offsetof(FMeditationPointConfig, TargetCheckRange) == 0x000004, "Member 'FMeditationPointConfig::TargetCheckRange' has a wrong offset!");

// SharpStruct b1-Managed.FGSSplinePatrolWaitPoint
// 0x0008 (0x0008 - 0x0000)
struct FFGSSplinePatrolWaitPoint final
{
public:
	class UAnimMontage*                           WaitAM;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSplinePatrolWaitPoint) == 0x000008, "Wrong alignment on FFGSSplinePatrolWaitPoint");
static_assert(sizeof(FFGSSplinePatrolWaitPoint) == 0x000008, "Wrong size on FFGSSplinePatrolWaitPoint");
static_assert(offsetof(FFGSSplinePatrolWaitPoint, WaitAM) == 0x000000, "Member 'FFGSSplinePatrolWaitPoint::WaitAM' has a wrong offset!");

// SharpStruct b1-Managed.AudioConfig
// 0x0010 (0x0010 - 0x0000)
struct FAudioConfig final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTime;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAudioConfig) == 0x000008, "Wrong alignment on FAudioConfig");
static_assert(sizeof(FAudioConfig) == 0x000010, "Wrong size on FAudioConfig");
static_assert(offsetof(FAudioConfig, AudioEvent) == 0x000000, "Member 'FAudioConfig::AudioEvent' has a wrong offset!");
static_assert(offsetof(FAudioConfig, DelayTime) == 0x000008, "Member 'FAudioConfig::DelayTime' has a wrong offset!");

// SharpStruct b1-Managed.ObserveRoleDataInfo
// 0x0058 (0x0058 - 0x0000)
struct FObserveRoleDataInfo final
{
public:
	ERoleDataType                                 ObserveType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          TaskStage;                                         // 0x0004(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	b1MinusManaged::ETaskStageState               ObserveTaskStageState;                             // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          InteractorGroupID;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InteractionStep;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwningItemID;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwningNum;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumeItemID;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumptionQuantity;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NeedObserveTaskStageID;                            // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionGroupID;                                // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObserveRoleDataInfo) == 0x000008, "Wrong alignment on FObserveRoleDataInfo");
static_assert(sizeof(FObserveRoleDataInfo) == 0x000058, "Wrong size on FObserveRoleDataInfo");
static_assert(offsetof(FObserveRoleDataInfo, ObserveType) == 0x000000, "Member 'FObserveRoleDataInfo::ObserveType' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, TaskStage) == 0x000004, "Member 'FObserveRoleDataInfo::TaskStage' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, ObserveTaskStageState) == 0x000014, "Member 'FObserveRoleDataInfo::ObserveTaskStageState' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, InteractorGroupID) == 0x000018, "Member 'FObserveRoleDataInfo::InteractorGroupID' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, InteractionStep) == 0x000028, "Member 'FObserveRoleDataInfo::InteractionStep' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, OwningItemID) == 0x00002C, "Member 'FObserveRoleDataInfo::OwningItemID' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, OwningNum) == 0x000030, "Member 'FObserveRoleDataInfo::OwningNum' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, ConsumeItemID) == 0x000034, "Member 'FObserveRoleDataInfo::ConsumeItemID' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, ConsumptionQuantity) == 0x000038, "Member 'FObserveRoleDataInfo::ConsumptionQuantity' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, Comment) == 0x000040, "Member 'FObserveRoleDataInfo::Comment' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, NeedObserveTaskStageID) == 0x000050, "Member 'FObserveRoleDataInfo::NeedObserveTaskStageID' has a wrong offset!");
static_assert(offsetof(FObserveRoleDataInfo, InteractionGroupID) == 0x000054, "Member 'FObserveRoleDataInfo::InteractionGroupID' has a wrong offset!");

// SharpStruct b1-Managed.AvoidObstacleSection
// 0x0018 (0x0018 - 0x0000)
struct FAvoidObstacleSection final
{
public:
	float                                         StartAngle;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAngle;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillList;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAvoidObstacleSection) == 0x000008, "Wrong alignment on FAvoidObstacleSection");
static_assert(sizeof(FAvoidObstacleSection) == 0x000018, "Wrong size on FAvoidObstacleSection");
static_assert(offsetof(FAvoidObstacleSection, StartAngle) == 0x000000, "Member 'FAvoidObstacleSection::StartAngle' has a wrong offset!");
static_assert(offsetof(FAvoidObstacleSection, EndAngle) == 0x000004, "Member 'FAvoidObstacleSection::EndAngle' has a wrong offset!");
static_assert(offsetof(FAvoidObstacleSection, SkillList) == 0x000008, "Member 'FAvoidObstacleSection::SkillList' has a wrong offset!");

// SharpStruct b1-Managed.TeleportParam_RebirthPoint
// 0x0008 (0x0008 - 0x0000)
struct FTeleportParam_RebirthPoint final
{
public:
	int32                                         RebirthPointId;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERebirthType                                  RebirthType;                                       // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FromSettingUI : 1;                                 // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FTeleportParam_RebirthPoint) == 0x000004, "Wrong alignment on FTeleportParam_RebirthPoint");
static_assert(sizeof(FTeleportParam_RebirthPoint) == 0x000008, "Wrong size on FTeleportParam_RebirthPoint");
static_assert(offsetof(FTeleportParam_RebirthPoint, RebirthPointId) == 0x000000, "Member 'FTeleportParam_RebirthPoint::RebirthPointId' has a wrong offset!");
static_assert(offsetof(FTeleportParam_RebirthPoint, RebirthType) == 0x000004, "Member 'FTeleportParam_RebirthPoint::RebirthType' has a wrong offset!");

// SharpStruct b1-Managed.LevelIdListInfo
// 0x0010 (0x0010 - 0x0000)
struct FLevelIdListInfo final
{
public:
	TArray<int32>                                 LevelIdList;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelIdListInfo) == 0x000008, "Wrong alignment on FLevelIdListInfo");
static_assert(sizeof(FLevelIdListInfo) == 0x000010, "Wrong size on FLevelIdListInfo");
static_assert(offsetof(FLevelIdListInfo, LevelIdList) == 0x000000, "Member 'FLevelIdListInfo::LevelIdList' has a wrong offset!");

// SharpStruct b1-Managed.ObstacleCheckPointWeight
// 0x0008 (0x0008 - 0x0000)
struct FObstacleCheckPointWeight final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObstacleCheckPointWeight) == 0x000004, "Wrong alignment on FObstacleCheckPointWeight");
static_assert(sizeof(FObstacleCheckPointWeight) == 0x000008, "Wrong size on FObstacleCheckPointWeight");
static_assert(offsetof(FObstacleCheckPointWeight, Angle) == 0x000000, "Member 'FObstacleCheckPointWeight::Angle' has a wrong offset!");
static_assert(offsetof(FObstacleCheckPointWeight, Weight) == 0x000004, "Member 'FObstacleCheckPointWeight::Weight' has a wrong offset!");

// SharpStruct b1-Managed.TeleportParam_TeleportNamedPoint
// 0x000C (0x000C - 0x0000)
struct FTeleportParam_TeleportNamedPoint final
{
public:
	int32                                         LevelID;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportPointName;                                 // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleportParam_TeleportNamedPoint) == 0x000004, "Wrong alignment on FTeleportParam_TeleportNamedPoint");
static_assert(sizeof(FTeleportParam_TeleportNamedPoint) == 0x00000C, "Wrong size on FTeleportParam_TeleportNamedPoint");
static_assert(offsetof(FTeleportParam_TeleportNamedPoint, LevelID) == 0x000000, "Member 'FTeleportParam_TeleportNamedPoint::LevelID' has a wrong offset!");
static_assert(offsetof(FTeleportParam_TeleportNamedPoint, TeleportPointName) == 0x000004, "Member 'FTeleportParam_TeleportNamedPoint::TeleportPointName' has a wrong offset!");

// SharpStruct b1-Managed.CanvasPainterData
// 0x00A0 (0x00A0 - 0x0000)
struct FCanvasPainterData final
{
public:
	class FName                                   RTTextureParamName;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  RTPing;                                            // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  RTPong;                                            // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  RTResult;                                          // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              PainterMaterial;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              CanvasMaterial;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RTSize;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCanvasPainterData) == 0x000008, "Wrong alignment on FCanvasPainterData");
static_assert(sizeof(FCanvasPainterData) == 0x0000A0, "Wrong size on FCanvasPainterData");
static_assert(offsetof(FCanvasPainterData, RTTextureParamName) == 0x000000, "Member 'FCanvasPainterData::RTTextureParamName' has a wrong offset!");
static_assert(offsetof(FCanvasPainterData, RTPing) == 0x000008, "Member 'FCanvasPainterData::RTPing' has a wrong offset!");
static_assert(offsetof(FCanvasPainterData, RTPong) == 0x000030, "Member 'FCanvasPainterData::RTPong' has a wrong offset!");
static_assert(offsetof(FCanvasPainterData, RTResult) == 0x000058, "Member 'FCanvasPainterData::RTResult' has a wrong offset!");
static_assert(offsetof(FCanvasPainterData, PainterMaterial) == 0x000080, "Member 'FCanvasPainterData::PainterMaterial' has a wrong offset!");
static_assert(offsetof(FCanvasPainterData, CanvasMaterial) == 0x000088, "Member 'FCanvasPainterData::CanvasMaterial' has a wrong offset!");
static_assert(offsetof(FCanvasPainterData, FadeOutTime) == 0x000090, "Member 'FCanvasPainterData::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FCanvasPainterData, EndTime) == 0x000094, "Member 'FCanvasPainterData::EndTime' has a wrong offset!");
static_assert(offsetof(FCanvasPainterData, RTSize) == 0x000098, "Member 'FCanvasPainterData::RTSize' has a wrong offset!");

// SharpStruct b1-Managed.SummonSpawnPoints
// 0x0010 (0x0010 - 0x0000)
struct FSummonSpawnPoints final
{
public:
	TArray<struct FTransform>                     SpawnPoints;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummonSpawnPoints) == 0x000008, "Wrong alignment on FSummonSpawnPoints");
static_assert(sizeof(FSummonSpawnPoints) == 0x000010, "Wrong size on FSummonSpawnPoints");
static_assert(offsetof(FSummonSpawnPoints, SpawnPoints) == 0x000000, "Member 'FSummonSpawnPoints::SpawnPoints' has a wrong offset!");

// SharpStruct b1-Managed.TeleportParam_Dream
// 0x0014 (0x0014 - 0x0000)
struct FTeleportParam_Dream final
{
public:
	int32                                         LevelID;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportPointName;                                 // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RebirthPointId;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DontResetPlayerState : 1;                          // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EGSLoadingScreenType                          LoadingScreenType;                                 // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleportParam_Dream) == 0x000004, "Wrong alignment on FTeleportParam_Dream");
static_assert(sizeof(FTeleportParam_Dream) == 0x000014, "Wrong size on FTeleportParam_Dream");
static_assert(offsetof(FTeleportParam_Dream, LevelID) == 0x000000, "Member 'FTeleportParam_Dream::LevelID' has a wrong offset!");
static_assert(offsetof(FTeleportParam_Dream, TeleportPointName) == 0x000004, "Member 'FTeleportParam_Dream::TeleportPointName' has a wrong offset!");
static_assert(offsetof(FTeleportParam_Dream, RebirthPointId) == 0x00000C, "Member 'FTeleportParam_Dream::RebirthPointId' has a wrong offset!");
static_assert(offsetof(FTeleportParam_Dream, LoadingScreenType) == 0x000011, "Member 'FTeleportParam_Dream::LoadingScreenType' has a wrong offset!");

// SharpStruct b1-Managed.ComboSkillNumInfo
// 0x0008 (0x0008 - 0x0000)
struct FComboSkillNumInfo final
{
public:
	int32                                         ComboNum;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComboPercenRatio;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComboSkillNumInfo) == 0x000004, "Wrong alignment on FComboSkillNumInfo");
static_assert(sizeof(FComboSkillNumInfo) == 0x000008, "Wrong size on FComboSkillNumInfo");
static_assert(offsetof(FComboSkillNumInfo, ComboNum) == 0x000000, "Member 'FComboSkillNumInfo::ComboNum' has a wrong offset!");
static_assert(offsetof(FComboSkillNumInfo, ComboPercenRatio) == 0x000004, "Member 'FComboSkillNumInfo::ComboPercenRatio' has a wrong offset!");

// SharpStruct b1-Managed.GroupAIHotZoneCircleCustomInfo
// 0x000C (0x000C - 0x0000)
struct FGroupAIHotZoneCircleCustomInfo final
{
public:
	uint8                                         EnableCustomSetting : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BattleCirclePointRingNum;                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleCirclePointAngleInterval;                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroupAIHotZoneCircleCustomInfo) == 0x000004, "Wrong alignment on FGroupAIHotZoneCircleCustomInfo");
static_assert(sizeof(FGroupAIHotZoneCircleCustomInfo) == 0x00000C, "Wrong size on FGroupAIHotZoneCircleCustomInfo");
static_assert(offsetof(FGroupAIHotZoneCircleCustomInfo, BattleCirclePointRingNum) == 0x000004, "Member 'FGroupAIHotZoneCircleCustomInfo::BattleCirclePointRingNum' has a wrong offset!");
static_assert(offsetof(FGroupAIHotZoneCircleCustomInfo, BattleCirclePointAngleInterval) == 0x000008, "Member 'FGroupAIHotZoneCircleCustomInfo::BattleCirclePointAngleInterval' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_SimpleState
// 0x0001 (0x0001 - 0x0000)
struct FDetectCondition_SimpleState final
{
public:
	EBGUSimpleState                               SimpleState;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_SimpleState) == 0x000001, "Wrong alignment on FDetectCondition_SimpleState");
static_assert(sizeof(FDetectCondition_SimpleState) == 0x000001, "Wrong size on FDetectCondition_SimpleState");
static_assert(offsetof(FDetectCondition_SimpleState, SimpleState) == 0x000000, "Member 'FDetectCondition_SimpleState::SimpleState' has a wrong offset!");

// SharpStruct b1-Managed.PriorityActInfo_CastSkill
// 0x0004 (0x0004 - 0x0000)
struct FPriorityActInfo_CastSkill final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPriorityActInfo_CastSkill) == 0x000004, "Wrong alignment on FPriorityActInfo_CastSkill");
static_assert(sizeof(FPriorityActInfo_CastSkill) == 0x000004, "Wrong size on FPriorityActInfo_CastSkill");
static_assert(offsetof(FPriorityActInfo_CastSkill, SkillID) == 0x000000, "Member 'FPriorityActInfo_CastSkill::SkillID' has a wrong offset!");

// SharpStruct b1-Managed.PriorityActInfo_MoveToPos
// 0x0018 (0x0018 - 0x0000)
struct FPriorityActInfo_MoveToPos final
{
public:
	class UEnvQuery*                              MoveActionEnvQueryTemplate;                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptableRadius;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIMoveSpeedType                              SpeedType;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUMoveAIType                                MoveAIType;                                        // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPriorityActInfo_MoveToPos) == 0x000008, "Wrong alignment on FPriorityActInfo_MoveToPos");
static_assert(sizeof(FPriorityActInfo_MoveToPos) == 0x000018, "Wrong size on FPriorityActInfo_MoveToPos");
static_assert(offsetof(FPriorityActInfo_MoveToPos, MoveActionEnvQueryTemplate) == 0x000000, "Member 'FPriorityActInfo_MoveToPos::MoveActionEnvQueryTemplate' has a wrong offset!");
static_assert(offsetof(FPriorityActInfo_MoveToPos, WaitTime) == 0x000008, "Member 'FPriorityActInfo_MoveToPos::WaitTime' has a wrong offset!");
static_assert(offsetof(FPriorityActInfo_MoveToPos, AcceptableRadius) == 0x00000C, "Member 'FPriorityActInfo_MoveToPos::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(FPriorityActInfo_MoveToPos, SpeedType) == 0x000010, "Member 'FPriorityActInfo_MoveToPos::SpeedType' has a wrong offset!");
static_assert(offsetof(FPriorityActInfo_MoveToPos, MoveAIType) == 0x000011, "Member 'FPriorityActInfo_MoveToPos::MoveAIType' has a wrong offset!");

// SharpStruct b1-Managed.OnePriorityActionInfo
// 0x0040 (0x0040 - 0x0000)
struct FOnePriorityActionInfo final
{
public:
	float                                         WaitForBeginTime;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsRandomNoiseTime : 1;                             // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeginNoiseTime;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGroupPriorityActionType                      ActionType;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPriorityActInfo_MoveToPos             PAI_MoveToPos;                                     // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPriorityActInfo_CastSkill             PAI_CastSkill;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPriorityActInfo_AddBuff               PAI_AddBuff;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnePriorityActionInfo) == 0x000008, "Wrong alignment on FOnePriorityActionInfo");
static_assert(sizeof(FOnePriorityActionInfo) == 0x000040, "Wrong size on FOnePriorityActionInfo");
static_assert(offsetof(FOnePriorityActionInfo, WaitForBeginTime) == 0x000000, "Member 'FOnePriorityActionInfo::WaitForBeginTime' has a wrong offset!");
static_assert(offsetof(FOnePriorityActionInfo, BeginNoiseTime) == 0x000008, "Member 'FOnePriorityActionInfo::BeginNoiseTime' has a wrong offset!");
static_assert(offsetof(FOnePriorityActionInfo, ActionType) == 0x00000C, "Member 'FOnePriorityActionInfo::ActionType' has a wrong offset!");
static_assert(offsetof(FOnePriorityActionInfo, PAI_MoveToPos) == 0x000010, "Member 'FOnePriorityActionInfo::PAI_MoveToPos' has a wrong offset!");
static_assert(offsetof(FOnePriorityActionInfo, PAI_CastSkill) == 0x000028, "Member 'FOnePriorityActionInfo::PAI_CastSkill' has a wrong offset!");
static_assert(offsetof(FOnePriorityActionInfo, PAI_AddBuff) == 0x000030, "Member 'FOnePriorityActionInfo::PAI_AddBuff' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_HasBuff
// 0x0004 (0x0004 - 0x0000)
struct FDetectCondition_HasBuff final
{
public:
	int32                                         BuffID;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_HasBuff) == 0x000004, "Wrong alignment on FDetectCondition_HasBuff");
static_assert(sizeof(FDetectCondition_HasBuff) == 0x000004, "Wrong size on FDetectCondition_HasBuff");
static_assert(offsetof(FDetectCondition_HasBuff, BuffID) == 0x000000, "Member 'FDetectCondition_HasBuff::BuffID' has a wrong offset!");

// SharpStruct b1-Managed.EquipPreviewPositionConfig
// 0x0088 (0x0088 - 0x0000)
struct FEquipPreviewPositionConfig final
{
public:
	TMap<EquipFXType, class UBGWDataAsset*>       DBCDAMap;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimIn;                                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HeadAnimIn;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimOutSuccess;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HeadAnimOutSuccess;                                // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimOutBack;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HeadAnimOutBack;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MarkIcon;                                          // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipPreviewPositionConfig) == 0x000008, "Wrong alignment on FEquipPreviewPositionConfig");
static_assert(sizeof(FEquipPreviewPositionConfig) == 0x000088, "Wrong size on FEquipPreviewPositionConfig");
static_assert(offsetof(FEquipPreviewPositionConfig, DBCDAMap) == 0x000000, "Member 'FEquipPreviewPositionConfig::DBCDAMap' has a wrong offset!");
static_assert(offsetof(FEquipPreviewPositionConfig, AnimIn) == 0x000050, "Member 'FEquipPreviewPositionConfig::AnimIn' has a wrong offset!");
static_assert(offsetof(FEquipPreviewPositionConfig, HeadAnimIn) == 0x000058, "Member 'FEquipPreviewPositionConfig::HeadAnimIn' has a wrong offset!");
static_assert(offsetof(FEquipPreviewPositionConfig, AnimOutSuccess) == 0x000060, "Member 'FEquipPreviewPositionConfig::AnimOutSuccess' has a wrong offset!");
static_assert(offsetof(FEquipPreviewPositionConfig, HeadAnimOutSuccess) == 0x000068, "Member 'FEquipPreviewPositionConfig::HeadAnimOutSuccess' has a wrong offset!");
static_assert(offsetof(FEquipPreviewPositionConfig, AnimOutBack) == 0x000070, "Member 'FEquipPreviewPositionConfig::AnimOutBack' has a wrong offset!");
static_assert(offsetof(FEquipPreviewPositionConfig, HeadAnimOutBack) == 0x000078, "Member 'FEquipPreviewPositionConfig::HeadAnimOutBack' has a wrong offset!");
static_assert(offsetof(FEquipPreviewPositionConfig, MarkIcon) == 0x000080, "Member 'FEquipPreviewPositionConfig::MarkIcon' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_AbnormalState
// 0x0001 (0x0001 - 0x0000)
struct FDetectCondition_AbnormalState final
{
public:
	EAbnormalStateType                            AbnormalStateType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_AbnormalState) == 0x000001, "Wrong alignment on FDetectCondition_AbnormalState");
static_assert(sizeof(FDetectCondition_AbnormalState) == 0x000001, "Wrong size on FDetectCondition_AbnormalState");
static_assert(offsetof(FDetectCondition_AbnormalState, AbnormalStateType) == 0x000000, "Member 'FDetectCondition_AbnormalState::AbnormalStateType' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_FsmState
// 0x0001 (0x0001 - 0x0000)
struct FDetectCondition_FsmState final
{
public:
	EBGUFSMStateName                              FsmState;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_FsmState) == 0x000001, "Wrong alignment on FDetectCondition_FsmState");
static_assert(sizeof(FDetectCondition_FsmState) == 0x000001, "Wrong size on FDetectCondition_FsmState");
static_assert(offsetof(FDetectCondition_FsmState, FsmState) == 0x000000, "Member 'FDetectCondition_FsmState::FsmState' has a wrong offset!");

// SharpStruct b1-Managed.EnvironmentInteractionConfig
// 0x0060 (0x0060 - 0x0000)
struct FEnvironmentInteractionConfig final
{
public:
	ESceneItemSurfaceType                         EnvironmentSurfaceType;                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESurfaceTypeOverrideMethod                    SurfaceTypeOverrideMethod;                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESceneItemSurfaceType, ESceneItemSurfaceType> SurfaceTypeGenerationMapping;                      // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentInteractionConfig) == 0x000008, "Wrong alignment on FEnvironmentInteractionConfig");
static_assert(sizeof(FEnvironmentInteractionConfig) == 0x000060, "Wrong size on FEnvironmentInteractionConfig");
static_assert(offsetof(FEnvironmentInteractionConfig, EnvironmentSurfaceType) == 0x000000, "Member 'FEnvironmentInteractionConfig::EnvironmentSurfaceType' has a wrong offset!");
static_assert(offsetof(FEnvironmentInteractionConfig, SurfaceTypeOverrideMethod) == 0x000001, "Member 'FEnvironmentInteractionConfig::SurfaceTypeOverrideMethod' has a wrong offset!");
static_assert(offsetof(FEnvironmentInteractionConfig, SurfaceTypeGenerationMapping) == 0x000008, "Member 'FEnvironmentInteractionConfig::SurfaceTypeGenerationMapping' has a wrong offset!");
static_assert(offsetof(FEnvironmentInteractionConfig, Priority) == 0x000058, "Member 'FEnvironmentInteractionConfig::Priority' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_DistanceFromTarget
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_DistanceFromTarget final
{
public:
	EValueCompareOperations                       DistanceCompareOperations;                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceCompareValue;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_DistanceFromTarget) == 0x000004, "Wrong alignment on FDetectCondition_DistanceFromTarget");
static_assert(sizeof(FDetectCondition_DistanceFromTarget) == 0x000008, "Wrong size on FDetectCondition_DistanceFromTarget");
static_assert(offsetof(FDetectCondition_DistanceFromTarget, DistanceCompareOperations) == 0x000000, "Member 'FDetectCondition_DistanceFromTarget::DistanceCompareOperations' has a wrong offset!");
static_assert(offsetof(FDetectCondition_DistanceFromTarget, DistanceCompareValue) == 0x000004, "Member 'FDetectCondition_DistanceFromTarget::DistanceCompareValue' has a wrong offset!");

// SharpStruct b1-Managed.SectorParam
// 0x0010 (0x0010 - 0x0000)
struct FSectorParam final
{
public:
	float                                         MinR;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxR;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftAngle;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightAngle;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSectorParam) == 0x000004, "Wrong alignment on FSectorParam");
static_assert(sizeof(FSectorParam) == 0x000010, "Wrong size on FSectorParam");
static_assert(offsetof(FSectorParam, MinR) == 0x000000, "Member 'FSectorParam::MinR' has a wrong offset!");
static_assert(offsetof(FSectorParam, MaxR) == 0x000004, "Member 'FSectorParam::MaxR' has a wrong offset!");
static_assert(offsetof(FSectorParam, LeftAngle) == 0x000008, "Member 'FSectorParam::LeftAngle' has a wrong offset!");
static_assert(offsetof(FSectorParam, RightAngle) == 0x00000C, "Member 'FSectorParam::RightAngle' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_SkillCanCast
// 0x0004 (0x0004 - 0x0000)
struct FDetectCondition_SkillCanCast final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_SkillCanCast) == 0x000004, "Wrong alignment on FDetectCondition_SkillCanCast");
static_assert(sizeof(FDetectCondition_SkillCanCast) == 0x000004, "Wrong size on FDetectCondition_SkillCanCast");
static_assert(offsetof(FDetectCondition_SkillCanCast, SkillID) == 0x000000, "Member 'FDetectCondition_SkillCanCast::SkillID' has a wrong offset!");

// SharpStruct b1-Managed.ManagedNPCUnit
// 0x0068 (0x0068 - 0x0000)
struct FManagedNPCUnit final
{
public:
	TSoftObjectPtr<class ABGUCharacterCS>         Actor;                                             // 0x0000(0x0028)(Edit, BlueprintVisible, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ABUTamerActor>           Tamer;                                             // 0x0028(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorGuid;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AliasName;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedNPCUnit) == 0x000008, "Wrong alignment on FManagedNPCUnit");
static_assert(sizeof(FManagedNPCUnit) == 0x000068, "Wrong size on FManagedNPCUnit");
static_assert(offsetof(FManagedNPCUnit, Actor) == 0x000000, "Member 'FManagedNPCUnit::Actor' has a wrong offset!");
static_assert(offsetof(FManagedNPCUnit, Tamer) == 0x000028, "Member 'FManagedNPCUnit::Tamer' has a wrong offset!");
static_assert(offsetof(FManagedNPCUnit, ActorGuid) == 0x000050, "Member 'FManagedNPCUnit::ActorGuid' has a wrong offset!");
static_assert(offsetof(FManagedNPCUnit, AliasName) == 0x000060, "Member 'FManagedNPCUnit::AliasName' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_CustomFsmState
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_CustomFsmState final
{
public:
	struct FGameplayTag                           CustomFsmState;                                    // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_CustomFsmState) == 0x000004, "Wrong alignment on FDetectCondition_CustomFsmState");
static_assert(sizeof(FDetectCondition_CustomFsmState) == 0x000008, "Wrong size on FDetectCondition_CustomFsmState");
static_assert(offsetof(FDetectCondition_CustomFsmState, CustomFsmState) == 0x000000, "Member 'FDetectCondition_CustomFsmState::CustomFsmState' has a wrong offset!");

// SharpStruct b1-Managed.ManagedNPCObj
// 0x0048 (0x0048 - 0x0000)
struct FManagedNPCObj final
{
public:
	TSoftObjectPtr<class ABGUActorBaseCS>         Actor;                                             // 0x0000(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorGuid;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AliasName;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EManagedNPCUnitType                           ManagedNPCUnitType;                                // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedNPCObj) == 0x000008, "Wrong alignment on FManagedNPCObj");
static_assert(sizeof(FManagedNPCObj) == 0x000048, "Wrong size on FManagedNPCObj");
static_assert(offsetof(FManagedNPCObj, Actor) == 0x000000, "Member 'FManagedNPCObj::Actor' has a wrong offset!");
static_assert(offsetof(FManagedNPCObj, ActorGuid) == 0x000028, "Member 'FManagedNPCObj::ActorGuid' has a wrong offset!");
static_assert(offsetof(FManagedNPCObj, AliasName) == 0x000038, "Member 'FManagedNPCObj::AliasName' has a wrong offset!");
static_assert(offsetof(FManagedNPCObj, ManagedNPCUnitType) == 0x000040, "Member 'FManagedNPCObj::ManagedNPCUnitType' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_LastBeAttackedStiffLevel
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_LastBeAttackedStiffLevel final
{
public:
	EValueCompareOperations                       CompareOperation;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompareValueInt;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_LastBeAttackedStiffLevel) == 0x000004, "Wrong alignment on FDetectCondition_LastBeAttackedStiffLevel");
static_assert(sizeof(FDetectCondition_LastBeAttackedStiffLevel) == 0x000008, "Wrong size on FDetectCondition_LastBeAttackedStiffLevel");
static_assert(offsetof(FDetectCondition_LastBeAttackedStiffLevel, CompareOperation) == 0x000000, "Member 'FDetectCondition_LastBeAttackedStiffLevel::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition_LastBeAttackedStiffLevel, CompareValueInt) == 0x000004, "Member 'FDetectCondition_LastBeAttackedStiffLevel::CompareValueInt' has a wrong offset!");

// SharpStruct b1-Managed.ManagedTaskUnit
// 0x0068 (0x0068 - 0x0000)
struct FManagedTaskUnit final
{
public:
	TSoftObjectPtr<class ABGUCharacterCS>         Actor;                                             // 0x0000(0x0028)(Edit, BlueprintVisible, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ABUTamerActor>           Tamer;                                             // 0x0028(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorGuid;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AliasName;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedTaskUnit) == 0x000008, "Wrong alignment on FManagedTaskUnit");
static_assert(sizeof(FManagedTaskUnit) == 0x000068, "Wrong size on FManagedTaskUnit");
static_assert(offsetof(FManagedTaskUnit, Actor) == 0x000000, "Member 'FManagedTaskUnit::Actor' has a wrong offset!");
static_assert(offsetof(FManagedTaskUnit, Tamer) == 0x000028, "Member 'FManagedTaskUnit::Tamer' has a wrong offset!");
static_assert(offsetof(FManagedTaskUnit, ActorGuid) == 0x000050, "Member 'FManagedTaskUnit::ActorGuid' has a wrong offset!");
static_assert(offsetof(FManagedTaskUnit, AliasName) == 0x000060, "Member 'FManagedTaskUnit::AliasName' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_DistanceFromMaster
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_DistanceFromMaster final
{
public:
	EValueCompareOperations                       DistanceCompareOperations;                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceCompareValue;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_DistanceFromMaster) == 0x000004, "Wrong alignment on FDetectCondition_DistanceFromMaster");
static_assert(sizeof(FDetectCondition_DistanceFromMaster) == 0x000008, "Wrong size on FDetectCondition_DistanceFromMaster");
static_assert(offsetof(FDetectCondition_DistanceFromMaster, DistanceCompareOperations) == 0x000000, "Member 'FDetectCondition_DistanceFromMaster::DistanceCompareOperations' has a wrong offset!");
static_assert(offsetof(FDetectCondition_DistanceFromMaster, DistanceCompareValue) == 0x000004, "Member 'FDetectCondition_DistanceFromMaster::DistanceCompareValue' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_ActorYawRotation
// 0x000C (0x000C - 0x0000)
struct FDetectCondition_ActorYawRotation final
{
public:
	ERotationBaseDirection                        BaseDirection;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinYawAngle;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawAngle;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_ActorYawRotation) == 0x000004, "Wrong alignment on FDetectCondition_ActorYawRotation");
static_assert(sizeof(FDetectCondition_ActorYawRotation) == 0x00000C, "Wrong size on FDetectCondition_ActorYawRotation");
static_assert(offsetof(FDetectCondition_ActorYawRotation, BaseDirection) == 0x000000, "Member 'FDetectCondition_ActorYawRotation::BaseDirection' has a wrong offset!");
static_assert(offsetof(FDetectCondition_ActorYawRotation, MinYawAngle) == 0x000004, "Member 'FDetectCondition_ActorYawRotation::MinYawAngle' has a wrong offset!");
static_assert(offsetof(FDetectCondition_ActorYawRotation, MaxYawAngle) == 0x000008, "Member 'FDetectCondition_ActorYawRotation::MaxYawAngle' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_GlobalCastSkillCount
// 0x000C (0x000C - 0x0000)
struct FDetectCondition_GlobalCastSkillCount final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompareValueInt;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_GlobalCastSkillCount) == 0x000004, "Wrong alignment on FDetectCondition_GlobalCastSkillCount");
static_assert(sizeof(FDetectCondition_GlobalCastSkillCount) == 0x00000C, "Wrong size on FDetectCondition_GlobalCastSkillCount");
static_assert(offsetof(FDetectCondition_GlobalCastSkillCount, SkillID) == 0x000000, "Member 'FDetectCondition_GlobalCastSkillCount::SkillID' has a wrong offset!");
static_assert(offsetof(FDetectCondition_GlobalCastSkillCount, CompareOperation) == 0x000004, "Member 'FDetectCondition_GlobalCastSkillCount::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition_GlobalCastSkillCount, CompareValueInt) == 0x000008, "Member 'FDetectCondition_GlobalCastSkillCount::CompareValueInt' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_CurSkillCostDmgNum
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_CurSkillCostDmgNum final
{
public:
	EValueCompareOperations                       CompareOperation;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompareValueInt;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_CurSkillCostDmgNum) == 0x000004, "Wrong alignment on FDetectCondition_CurSkillCostDmgNum");
static_assert(sizeof(FDetectCondition_CurSkillCostDmgNum) == 0x000008, "Wrong size on FDetectCondition_CurSkillCostDmgNum");
static_assert(offsetof(FDetectCondition_CurSkillCostDmgNum, CompareOperation) == 0x000000, "Member 'FDetectCondition_CurSkillCostDmgNum::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition_CurSkillCostDmgNum, CompareValueInt) == 0x000004, "Member 'FDetectCondition_CurSkillCostDmgNum::CompareValueInt' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_SocketUnitsDead
// 0x001C (0x001C - 0x0000)
struct FDetectCondition_SocketUnitsDead final
{
public:
	struct FTamerFamilyMatchChildInfo             MatchInfo;                                         // 0x0000(0x001C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_SocketUnitsDead) == 0x000004, "Wrong alignment on FDetectCondition_SocketUnitsDead");
static_assert(sizeof(FDetectCondition_SocketUnitsDead) == 0x00001C, "Wrong size on FDetectCondition_SocketUnitsDead");
static_assert(offsetof(FDetectCondition_SocketUnitsDead, MatchInfo) == 0x000000, "Member 'FDetectCondition_SocketUnitsDead::MatchInfo' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_DistanceFromNearestPlayer
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_DistanceFromNearestPlayer final
{
public:
	EValueCompareOperations                       CompareOperation;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompareValueInt;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_DistanceFromNearestPlayer) == 0x000004, "Wrong alignment on FDetectCondition_DistanceFromNearestPlayer");
static_assert(sizeof(FDetectCondition_DistanceFromNearestPlayer) == 0x000008, "Wrong size on FDetectCondition_DistanceFromNearestPlayer");
static_assert(offsetof(FDetectCondition_DistanceFromNearestPlayer, CompareOperation) == 0x000000, "Member 'FDetectCondition_DistanceFromNearestPlayer::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition_DistanceFromNearestPlayer, CompareValueInt) == 0x000004, "Member 'FDetectCondition_DistanceFromNearestPlayer::CompareValueInt' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_SpecifyResIdUnitsDead
// 0x0004 (0x0004 - 0x0000)
struct FDetectCondition_SpecifyResIdUnitsDead final
{
public:
	int32                                         ResID;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_SpecifyResIdUnitsDead) == 0x000004, "Wrong alignment on FDetectCondition_SpecifyResIdUnitsDead");
static_assert(sizeof(FDetectCondition_SpecifyResIdUnitsDead) == 0x000004, "Wrong size on FDetectCondition_SpecifyResIdUnitsDead");
static_assert(offsetof(FDetectCondition_SpecifyResIdUnitsDead, ResID) == 0x000000, "Member 'FDetectCondition_SpecifyResIdUnitsDead::ResID' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_FamilySpecifyUnitAttr
// 0x0024 (0x0024 - 0x0000)
struct FDetectCondition_FamilySpecifyUnitAttr final
{
public:
	struct FTamerFamilyMatchChildInfo             MatchInfo;                                         // 0x0000(0x001C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUAttrFloat                                 AttrFloatType;                                     // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CompareValue;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_FamilySpecifyUnitAttr) == 0x000004, "Wrong alignment on FDetectCondition_FamilySpecifyUnitAttr");
static_assert(sizeof(FDetectCondition_FamilySpecifyUnitAttr) == 0x000024, "Wrong size on FDetectCondition_FamilySpecifyUnitAttr");
static_assert(offsetof(FDetectCondition_FamilySpecifyUnitAttr, MatchInfo) == 0x000000, "Member 'FDetectCondition_FamilySpecifyUnitAttr::MatchInfo' has a wrong offset!");
static_assert(offsetof(FDetectCondition_FamilySpecifyUnitAttr, AttrFloatType) == 0x00001C, "Member 'FDetectCondition_FamilySpecifyUnitAttr::AttrFloatType' has a wrong offset!");
static_assert(offsetof(FDetectCondition_FamilySpecifyUnitAttr, CompareOperation) == 0x00001D, "Member 'FDetectCondition_FamilySpecifyUnitAttr::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition_FamilySpecifyUnitAttr, CompareValue) == 0x000020, "Member 'FDetectCondition_FamilySpecifyUnitAttr::CompareValue' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_Random
// 0x0004 (0x0004 - 0x0000)
struct FDetectCondition_Random final
{
public:
	float                                         SuccessRate;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_Random) == 0x000004, "Wrong alignment on FDetectCondition_Random");
static_assert(sizeof(FDetectCondition_Random) == 0x000004, "Wrong size on FDetectCondition_Random");
static_assert(offsetof(FDetectCondition_Random, SuccessRate) == 0x000000, "Member 'FDetectCondition_Random::SuccessRate' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_FamilyUnitAliveNum
// 0x0024 (0x0024 - 0x0000)
struct FDetectCondition_FamilyUnitAliveNum final
{
public:
	struct FTamerFamilyMatchChildInfo             MatchInfo;                                         // 0x0000(0x001C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AliveUnitNum;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_FamilyUnitAliveNum) == 0x000004, "Wrong alignment on FDetectCondition_FamilyUnitAliveNum");
static_assert(sizeof(FDetectCondition_FamilyUnitAliveNum) == 0x000024, "Wrong size on FDetectCondition_FamilyUnitAliveNum");
static_assert(offsetof(FDetectCondition_FamilyUnitAliveNum, MatchInfo) == 0x000000, "Member 'FDetectCondition_FamilyUnitAliveNum::MatchInfo' has a wrong offset!");
static_assert(offsetof(FDetectCondition_FamilyUnitAliveNum, CompareOperation) == 0x00001C, "Member 'FDetectCondition_FamilyUnitAliveNum::CompareOperation' has a wrong offset!");
static_assert(offsetof(FDetectCondition_FamilyUnitAliveNum, AliveUnitNum) == 0x000020, "Member 'FDetectCondition_FamilyUnitAliveNum::AliveUnitNum' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_CompareGamePlusCount
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_CompareGamePlusCount final
{
public:
	EValueCompareOperationType                    OperationType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GamePlusCount;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_CompareGamePlusCount) == 0x000004, "Wrong alignment on FDetectCondition_CompareGamePlusCount");
static_assert(sizeof(FDetectCondition_CompareGamePlusCount) == 0x000008, "Wrong size on FDetectCondition_CompareGamePlusCount");
static_assert(offsetof(FDetectCondition_CompareGamePlusCount, OperationType) == 0x000000, "Member 'FDetectCondition_CompareGamePlusCount::OperationType' has a wrong offset!");
static_assert(offsetof(FDetectCondition_CompareGamePlusCount, GamePlusCount) == 0x000004, "Member 'FDetectCondition_CompareGamePlusCount::GamePlusCount' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_CheckSurfaceType
// 0x0001 (0x0001 - 0x0000)
struct FDetectCondition_CheckSurfaceType final
{
public:
	ESceneItemSurfaceType                         SurfaceType;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_CheckSurfaceType) == 0x000001, "Wrong alignment on FDetectCondition_CheckSurfaceType");
static_assert(sizeof(FDetectCondition_CheckSurfaceType) == 0x000001, "Wrong size on FDetectCondition_CheckSurfaceType");
static_assert(offsetof(FDetectCondition_CheckSurfaceType, SurfaceType) == 0x000000, "Member 'FDetectCondition_CheckSurfaceType::SurfaceType' has a wrong offset!");

// SharpStruct b1-Managed.DetectCondition_TargetInAngleRange
// 0x0008 (0x0008 - 0x0000)
struct FDetectCondition_TargetInAngleRange final
{
public:
	float                                         MinYawAngle;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawAngle;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectCondition_TargetInAngleRange) == 0x000004, "Wrong alignment on FDetectCondition_TargetInAngleRange");
static_assert(sizeof(FDetectCondition_TargetInAngleRange) == 0x000008, "Wrong size on FDetectCondition_TargetInAngleRange");
static_assert(offsetof(FDetectCondition_TargetInAngleRange, MinYawAngle) == 0x000000, "Member 'FDetectCondition_TargetInAngleRange::MinYawAngle' has a wrong offset!");
static_assert(offsetof(FDetectCondition_TargetInAngleRange, MaxYawAngle) == 0x000004, "Member 'FDetectCondition_TargetInAngleRange::MaxYawAngle' has a wrong offset!");

// SharpStruct b1-Managed.BossPhaseInfo
// 0x0001 (0x0001 - 0x0000)
struct FBossPhaseInfo final
{
public:
	uint8                                         HasPhasePerformance : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FBossPhaseInfo) == 0x000001, "Wrong alignment on FBossPhaseInfo");
static_assert(sizeof(FBossPhaseInfo) == 0x000001, "Wrong size on FBossPhaseInfo");

// SharpStruct b1-Managed.TransitionCondition_State
// 0x00A8 (0x00A8 - 0x0000)
struct FTransitionCondition_State final
{
public:
	ETransitionConditionType_State                ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParamArray                     UnitList;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          UnitSpawner;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Unit;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Buff;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Overlap;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Interactor;                                        // 0x0058(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Sequence;                                          // 0x0068(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          TaskStage;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EStageStatus                                  TaskStageStatus;                                   // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayCounterType                          CounterType;                                       // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CounterValue;                                      // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CircusMemberNickName;                              // 0x00A0(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransitionCondition_State) == 0x000008, "Wrong alignment on FTransitionCondition_State");
static_assert(sizeof(FTransitionCondition_State) == 0x0000A8, "Wrong size on FTransitionCondition_State");
static_assert(offsetof(FTransitionCondition_State, ConditionType) == 0x000000, "Member 'FTransitionCondition_State::ConditionType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, UnitList) == 0x000008, "Member 'FTransitionCondition_State::UnitList' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, UnitSpawner) == 0x000018, "Member 'FTransitionCondition_State::UnitSpawner' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, Unit) == 0x000028, "Member 'FTransitionCondition_State::Unit' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, Buff) == 0x000038, "Member 'FTransitionCondition_State::Buff' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, Overlap) == 0x000048, "Member 'FTransitionCondition_State::Overlap' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, Interactor) == 0x000058, "Member 'FTransitionCondition_State::Interactor' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, Sequence) == 0x000068, "Member 'FTransitionCondition_State::Sequence' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, TaskStage) == 0x000078, "Member 'FTransitionCondition_State::TaskStage' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, TaskStageStatus) == 0x000088, "Member 'FTransitionCondition_State::TaskStageStatus' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, CounterType) == 0x000089, "Member 'FTransitionCondition_State::CounterType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, CounterValue) == 0x00008C, "Member 'FTransitionCondition_State::CounterValue' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, Comment) == 0x000090, "Member 'FTransitionCondition_State::Comment' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_State, CircusMemberNickName) == 0x0000A0, "Member 'FTransitionCondition_State::CircusMemberNickName' has a wrong offset!");

// SharpStruct b1-Managed.CompositeTransitionCondition_State
// 0x00E0 (0x00E0 - 0x0000)
struct FCompositeTransitionCondition_State final
{
public:
	struct FTransitionCondition_State             Single;                                            // 0x0000(0x00A8)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCompositeCondition : 1;                        // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransitionCondition_State>     Conditions;                                        // 0x00B0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBossPhaseInfo                         BossPhaseInfo;                                     // 0x00D8(0x0001)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompositeTransitionCondition_State) == 0x000008, "Wrong alignment on FCompositeTransitionCondition_State");
static_assert(sizeof(FCompositeTransitionCondition_State) == 0x0000E0, "Wrong size on FCompositeTransitionCondition_State");
static_assert(offsetof(FCompositeTransitionCondition_State, Single) == 0x000000, "Member 'FCompositeTransitionCondition_State::Single' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_State, Conditions) == 0x0000B0, "Member 'FCompositeTransitionCondition_State::Conditions' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_State, ConditionalRelation) == 0x0000C0, "Member 'FCompositeTransitionCondition_State::ConditionalRelation' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_State, Comment) == 0x0000C8, "Member 'FCompositeTransitionCondition_State::Comment' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_State, BossPhaseInfo) == 0x0000D8, "Member 'FCompositeTransitionCondition_State::BossPhaseInfo' has a wrong offset!");

// SharpStruct b1-Managed.TamerRoleSync
// 0x0018 (0x0018 - 0x0000)
struct FTamerRoleSync final
{
public:
	class FString                                 Guid;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EClientTamerInitNetState                      SyncState;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTamerRoleSync) == 0x000008, "Wrong alignment on FTamerRoleSync");
static_assert(sizeof(FTamerRoleSync) == 0x000018, "Wrong size on FTamerRoleSync");
static_assert(offsetof(FTamerRoleSync, Guid) == 0x000000, "Member 'FTamerRoleSync::Guid' has a wrong offset!");
static_assert(offsetof(FTamerRoleSync, SyncState) == 0x000010, "Member 'FTamerRoleSync::SyncState' has a wrong offset!");

// SharpStruct b1-Managed.DynamicTamerSpawnReq
// 0x0090 (0x0090 - 0x0000)
struct FDynamicTamerSpawnReq final
{
public:
	class FString                                 TamerGuidOverride;                                 // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 TamerClass;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnWorldTransform;                               // 0x0020(0x0060)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 TriggerSpawnActor;                                 // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDynamicTamerSpawnReq) == 0x000010, "Wrong alignment on FDynamicTamerSpawnReq");
static_assert(sizeof(FDynamicTamerSpawnReq) == 0x000090, "Wrong size on FDynamicTamerSpawnReq");
static_assert(offsetof(FDynamicTamerSpawnReq, TamerGuidOverride) == 0x000000, "Member 'FDynamicTamerSpawnReq::TamerGuidOverride' has a wrong offset!");
static_assert(offsetof(FDynamicTamerSpawnReq, TamerClass) == 0x000010, "Member 'FDynamicTamerSpawnReq::TamerClass' has a wrong offset!");
static_assert(offsetof(FDynamicTamerSpawnReq, SpawnWorldTransform) == 0x000020, "Member 'FDynamicTamerSpawnReq::SpawnWorldTransform' has a wrong offset!");
static_assert(offsetof(FDynamicTamerSpawnReq, TriggerSpawnActor) == 0x000080, "Member 'FDynamicTamerSpawnReq::TriggerSpawnActor' has a wrong offset!");

// SharpStruct b1-Managed.BattleTriggerUnitConfig
// 0x0050 (0x0050 - 0x0000)
struct FBattleTriggerUnitConfig final
{
public:
	struct FGsActorGuidReference                  Unit;                                              // 0x0000(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SwitchTeamID;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGsActorGuidReference>          TargetUnit;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleTriggerUnitConfig) == 0x000008, "Wrong alignment on FBattleTriggerUnitConfig");
static_assert(sizeof(FBattleTriggerUnitConfig) == 0x000050, "Wrong size on FBattleTriggerUnitConfig");
static_assert(offsetof(FBattleTriggerUnitConfig, Unit) == 0x000000, "Member 'FBattleTriggerUnitConfig::Unit' has a wrong offset!");
static_assert(offsetof(FBattleTriggerUnitConfig, SwitchTeamID) == 0x000038, "Member 'FBattleTriggerUnitConfig::SwitchTeamID' has a wrong offset!");
static_assert(offsetof(FBattleTriggerUnitConfig, TargetUnit) == 0x000040, "Member 'FBattleTriggerUnitConfig::TargetUnit' has a wrong offset!");

// SharpStruct b1-Managed.FBGMVolumeGroupConfig
// 0x0018 (0x0018 - 0x0000)
struct FFBGMVolumeGroupConfig final
{
public:
	class FName                                   VolumeGroupName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VolumePriority;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          PriorityEvent;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFBGMVolumeGroupConfig) == 0x000008, "Wrong alignment on FFBGMVolumeGroupConfig");
static_assert(sizeof(FFBGMVolumeGroupConfig) == 0x000018, "Wrong size on FFBGMVolumeGroupConfig");
static_assert(offsetof(FFBGMVolumeGroupConfig, VolumeGroupName) == 0x000000, "Member 'FFBGMVolumeGroupConfig::VolumeGroupName' has a wrong offset!");
static_assert(offsetof(FFBGMVolumeGroupConfig, VolumePriority) == 0x000008, "Member 'FFBGMVolumeGroupConfig::VolumePriority' has a wrong offset!");
static_assert(offsetof(FFBGMVolumeGroupConfig, PriorityEvent) == 0x000010, "Member 'FFBGMVolumeGroupConfig::PriorityEvent' has a wrong offset!");

// SharpStruct b1-Managed.UnitLockTargetInfo
// 0x0048 (0x0048 - 0x0000)
struct FUnitLockTargetInfo final
{
public:
	uint32                                        LockTargetEntity;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELockTargetWayType                            LockTargetWayType;                                 // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELockTargetType                               LockTargetType;                                    // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LockTargetSceneCompName;                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LockTargetSkeletonSocketName;                      // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockPointLocation;                                 // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETargetSourceType                             SourceType;                                        // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitLockTargetInfo) == 0x000008, "Wrong alignment on FUnitLockTargetInfo");
static_assert(sizeof(FUnitLockTargetInfo) == 0x000048, "Wrong size on FUnitLockTargetInfo");
static_assert(offsetof(FUnitLockTargetInfo, LockTargetEntity) == 0x000000, "Member 'FUnitLockTargetInfo::LockTargetEntity' has a wrong offset!");
static_assert(offsetof(FUnitLockTargetInfo, LockTargetWayType) == 0x000004, "Member 'FUnitLockTargetInfo::LockTargetWayType' has a wrong offset!");
static_assert(offsetof(FUnitLockTargetInfo, LockTargetType) == 0x000005, "Member 'FUnitLockTargetInfo::LockTargetType' has a wrong offset!");
static_assert(offsetof(FUnitLockTargetInfo, LockTargetSceneCompName) == 0x000008, "Member 'FUnitLockTargetInfo::LockTargetSceneCompName' has a wrong offset!");
static_assert(offsetof(FUnitLockTargetInfo, LockTargetSkeletonSocketName) == 0x000018, "Member 'FUnitLockTargetInfo::LockTargetSkeletonSocketName' has a wrong offset!");
static_assert(offsetof(FUnitLockTargetInfo, LockPointLocation) == 0x000028, "Member 'FUnitLockTargetInfo::LockPointLocation' has a wrong offset!");
static_assert(offsetof(FUnitLockTargetInfo, SourceType) == 0x000040, "Member 'FUnitLockTargetInfo::SourceType' has a wrong offset!");

// SharpStruct b1-Managed.MoveAMPath
// 0x0020 (0x0020 - 0x0000)
struct FMoveAMPath final
{
public:
	class FString                                 OriginPath;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewAMName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveAMPath) == 0x000008, "Wrong alignment on FMoveAMPath");
static_assert(sizeof(FMoveAMPath) == 0x000020, "Wrong size on FMoveAMPath");
static_assert(offsetof(FMoveAMPath, OriginPath) == 0x000000, "Member 'FMoveAMPath::OriginPath' has a wrong offset!");
static_assert(offsetof(FMoveAMPath, NewAMName) == 0x000010, "Member 'FMoveAMPath::NewAMName' has a wrong offset!");

// SharpStruct b1-Managed.FGSCellPatitionLayerConfig
// 0x0028 (0x0028 - 0x0000)
struct FFGSCellPatitionLayerConfig final
{
public:
	class FString                                 CellPartionInstanceName;                           // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnitFilter;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamFilter;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FilterAnd : 1;                                     // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FFGSCellPatitionLayerConfig) == 0x000008, "Wrong alignment on FFGSCellPatitionLayerConfig");
static_assert(sizeof(FFGSCellPatitionLayerConfig) == 0x000028, "Wrong size on FFGSCellPatitionLayerConfig");
static_assert(offsetof(FFGSCellPatitionLayerConfig, CellPartionInstanceName) == 0x000000, "Member 'FFGSCellPatitionLayerConfig::CellPartionInstanceName' has a wrong offset!");
static_assert(offsetof(FFGSCellPatitionLayerConfig, Radius) == 0x000010, "Member 'FFGSCellPatitionLayerConfig::Radius' has a wrong offset!");
static_assert(offsetof(FFGSCellPatitionLayerConfig, UnitFilter) == 0x000014, "Member 'FFGSCellPatitionLayerConfig::UnitFilter' has a wrong offset!");
static_assert(offsetof(FFGSCellPatitionLayerConfig, TeamFilter) == 0x000018, "Member 'FFGSCellPatitionLayerConfig::TeamFilter' has a wrong offset!");
static_assert(offsetof(FFGSCellPatitionLayerConfig, Priority) == 0x00001C, "Member 'FFGSCellPatitionLayerConfig::Priority' has a wrong offset!");

// SharpStruct b1-Managed.FGSTROConfig
// 0x0030 (0x0030 - 0x0000)
struct FFGSTROConfig final
{
public:
	struct FFGSCellPatitionLayerConfig            PatitionLayerConfig;                               // 0x0000(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TROLevel;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSTROConfig) == 0x000008, "Wrong alignment on FFGSTROConfig");
static_assert(sizeof(FFGSTROConfig) == 0x000030, "Wrong size on FFGSTROConfig");
static_assert(offsetof(FFGSTROConfig, PatitionLayerConfig) == 0x000000, "Member 'FFGSTROConfig::PatitionLayerConfig' has a wrong offset!");
static_assert(offsetof(FFGSTROConfig, TROLevel) == 0x000028, "Member 'FFGSTROConfig::TROLevel' has a wrong offset!");

// SharpStruct b1-Managed.ComboConditionSkill_UnitResIDInfo
// 0x0008 (0x0008 - 0x0000)
struct FComboConditionSkill_UnitResIDInfo final
{
public:
	int32                                         ResID;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComboConditionSkill_UnitResIDInfo) == 0x000004, "Wrong alignment on FComboConditionSkill_UnitResIDInfo");
static_assert(sizeof(FComboConditionSkill_UnitResIDInfo) == 0x000008, "Wrong size on FComboConditionSkill_UnitResIDInfo");
static_assert(offsetof(FComboConditionSkill_UnitResIDInfo, ResID) == 0x000000, "Member 'FComboConditionSkill_UnitResIDInfo::ResID' has a wrong offset!");
static_assert(offsetof(FComboConditionSkill_UnitResIDInfo, SkillID) == 0x000004, "Member 'FComboConditionSkill_UnitResIDInfo::SkillID' has a wrong offset!");

// SharpStruct b1-Managed.FGSRepGraphConfig
// 0x0030 (0x0030 - 0x0000)
struct FFGSRepGraphConfig final
{
public:
	struct FFGSCellPatitionLayerConfig            PatitionLayerConfig;                               // 0x0000(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepGraphLevel;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSRepGraphConfig) == 0x000008, "Wrong alignment on FFGSRepGraphConfig");
static_assert(sizeof(FFGSRepGraphConfig) == 0x000030, "Wrong size on FFGSRepGraphConfig");
static_assert(offsetof(FFGSRepGraphConfig, PatitionLayerConfig) == 0x000000, "Member 'FFGSRepGraphConfig::PatitionLayerConfig' has a wrong offset!");
static_assert(offsetof(FFGSRepGraphConfig, RepGraphLevel) == 0x000028, "Member 'FFGSRepGraphConfig::RepGraphLevel' has a wrong offset!");

// SharpStruct b1-Managed.RandomPatrolConfig
// 0x0020 (0x0020 - 0x0000)
struct FRandomPatrolConfig final
{
public:
	class UEnvQuery*                              EnvQuery;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitAMProbability;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   WaitAM;                                            // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomPatrolConfig) == 0x000008, "Wrong alignment on FRandomPatrolConfig");
static_assert(sizeof(FRandomPatrolConfig) == 0x000020, "Wrong size on FRandomPatrolConfig");
static_assert(offsetof(FRandomPatrolConfig, EnvQuery) == 0x000000, "Member 'FRandomPatrolConfig::EnvQuery' has a wrong offset!");
static_assert(offsetof(FRandomPatrolConfig, WaitAMProbability) == 0x000008, "Member 'FRandomPatrolConfig::WaitAMProbability' has a wrong offset!");
static_assert(offsetof(FRandomPatrolConfig, WaitAM) == 0x000010, "Member 'FRandomPatrolConfig::WaitAM' has a wrong offset!");

// SharpStruct b1-Managed.StaminaTextureInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FStaminaTextureInfo final
{
public:
	TMap<class FName, class UTexture*>            StaminaTextureConfig;                              // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, class UTexture*>            StaminaCostTextureConfig;                          // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        StaminaRecoverColorConfig;                         // 0x00A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaminaTextureInfo) == 0x000008, "Wrong alignment on FStaminaTextureInfo");
static_assert(sizeof(FStaminaTextureInfo) == 0x0000F0, "Wrong size on FStaminaTextureInfo");
static_assert(offsetof(FStaminaTextureInfo, StaminaTextureConfig) == 0x000000, "Member 'FStaminaTextureInfo::StaminaTextureConfig' has a wrong offset!");
static_assert(offsetof(FStaminaTextureInfo, StaminaCostTextureConfig) == 0x000050, "Member 'FStaminaTextureInfo::StaminaCostTextureConfig' has a wrong offset!");
static_assert(offsetof(FStaminaTextureInfo, StaminaRecoverColorConfig) == 0x0000A0, "Member 'FStaminaTextureInfo::StaminaRecoverColorConfig' has a wrong offset!");

// SharpStruct b1-Managed.TerrainEffectInfo
// 0x0004 (0x0004 - 0x0000)
struct FTerrainEffectInfo final
{
public:
	int32                                         BuffID;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerrainEffectInfo) == 0x000004, "Wrong alignment on FTerrainEffectInfo");
static_assert(sizeof(FTerrainEffectInfo) == 0x000004, "Wrong size on FTerrainEffectInfo");
static_assert(offsetof(FTerrainEffectInfo, BuffID) == 0x000000, "Member 'FTerrainEffectInfo::BuffID' has a wrong offset!");

// SharpStruct b1-Managed.HitForZBBInfo
// 0x0000 (0x0000 - 0x0000)
struct FHitForZBBInfo final
{
};
static_assert(alignof(FHitForZBBInfo) == 0x000001, "Wrong alignment on FHitForZBBInfo");
static_assert(sizeof(FHitForZBBInfo) == 0x000001, "Wrong size on FHitForZBBInfo");

// SharpStruct b1-Managed.ZBBPreviewConfig
// 0x0048 (0x0048 - 0x0000)
struct FZBBPreviewConfig final
{
public:
	uint8                                         EnableZBBTest : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 AttackerClass;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillID;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TargetAddBati : 1;                                 // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_18_1 : 7;                                   // 0x0018(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         OpenLowDensityTest : 1;                            // 0x0019(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DistRange;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapSize;                                           // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SectorFilterList;                                  // 0x0038(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZBBPreviewConfig) == 0x000008, "Wrong alignment on FZBBPreviewConfig");
static_assert(sizeof(FZBBPreviewConfig) == 0x000048, "Wrong size on FZBBPreviewConfig");
static_assert(offsetof(FZBBPreviewConfig, AttackerClass) == 0x000008, "Member 'FZBBPreviewConfig::AttackerClass' has a wrong offset!");
static_assert(offsetof(FZBBPreviewConfig, SkillID) == 0x000010, "Member 'FZBBPreviewConfig::SkillID' has a wrong offset!");
static_assert(offsetof(FZBBPreviewConfig, Delay) == 0x000014, "Member 'FZBBPreviewConfig::Delay' has a wrong offset!");
static_assert(offsetof(FZBBPreviewConfig, DistRange) == 0x000020, "Member 'FZBBPreviewConfig::DistRange' has a wrong offset!");
static_assert(offsetof(FZBBPreviewConfig, MapSize) == 0x000030, "Member 'FZBBPreviewConfig::MapSize' has a wrong offset!");
static_assert(offsetof(FZBBPreviewConfig, SectorFilterList) == 0x000038, "Member 'FZBBPreviewConfig::SectorFilterList' has a wrong offset!");

// SharpStruct b1-Managed.UnitGuidData
// 0x0010 (0x0010 - 0x0000)
struct FUnitGuidData final
{
public:
	struct FGameplayTag                           GameplayTagGuid;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTagGuidForGroup;                           // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitGuidData) == 0x000004, "Wrong alignment on FUnitGuidData");
static_assert(sizeof(FUnitGuidData) == 0x000010, "Wrong size on FUnitGuidData");
static_assert(offsetof(FUnitGuidData, GameplayTagGuid) == 0x000000, "Member 'FUnitGuidData::GameplayTagGuid' has a wrong offset!");
static_assert(offsetof(FUnitGuidData, GameplayTagGuidForGroup) == 0x000008, "Member 'FUnitGuidData::GameplayTagGuidForGroup' has a wrong offset!");

// SharpStruct b1-Managed.LeisureWithWeight
// 0x0010 (0x0010 - 0x0000)
struct FLeisureWithWeight final
{
public:
	class UAnimMontage*                           LeisureReference;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeisureWithWeight) == 0x000008, "Wrong alignment on FLeisureWithWeight");
static_assert(sizeof(FLeisureWithWeight) == 0x000010, "Wrong size on FLeisureWithWeight");
static_assert(offsetof(FLeisureWithWeight, LeisureReference) == 0x000000, "Member 'FLeisureWithWeight::LeisureReference' has a wrong offset!");
static_assert(offsetof(FLeisureWithWeight, Weight) == 0x000008, "Member 'FLeisureWithWeight::Weight' has a wrong offset!");

// SharpStruct b1-Managed.GSObjActorMoveInfo
// 0x0000 (0x0000 - 0x0000)
struct FGSObjActorMoveInfo final
{
};
static_assert(alignof(FGSObjActorMoveInfo) == 0x000001, "Wrong alignment on FGSObjActorMoveInfo");
static_assert(sizeof(FGSObjActorMoveInfo) == 0x000001, "Wrong size on FGSObjActorMoveInfo");

// SharpStruct b1-Managed.AnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop
// 0x0018 (0x0018 - 0x0000)
struct FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop final
{
public:
	float                                         Fwd;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FL;                                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BL;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FR;                                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BR;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bwd;                                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop) == 0x000004, "Wrong alignment on FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop");
static_assert(sizeof(FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop) == 0x000018, "Wrong size on FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop, Fwd) == 0x000000, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop::Fwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop, FL) == 0x000004, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop::FL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop, BL) == 0x000008, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop::BL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop, FR) == 0x00000C, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop::FR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop, BR) == 0x000010, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop::BR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop, Bwd) == 0x000014, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop::Bwd' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim
// 0x0018 (0x0018 - 0x0000)
struct FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim final
{
public:
	class UAnimSequence*                          ASStopBlendAnim;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPosition;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim");
static_assert(sizeof(FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim) == 0x000018, "Wrong size on FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim, ASStopBlendAnim) == 0x000000, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim::ASStopBlendAnim' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim, BlendInTime) == 0x000008, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim::BlendInTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim, BlendOutTime) == 0x00000C, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim, PlayRate) == 0x000010, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim::PlayRate' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim, StartPosition) == 0x000014, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim::StartPosition' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_MonsterLocomotion_Lock
// 0x0090 (0x0090 - 0x0000)
struct FAnimHumanoidSetting_MonsterLocomotion_Lock final
{
public:
	class UAnimSequence*                          ASLockWalkFwd;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkFR;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkBR;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkFL;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkBL;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkBwd;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop ExplicitTimeForLeftFootStop;                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_MonsterLocomotion_Lock_ExplicitTimeForMoveStop ExplicitTimeForRightFootStop;                      // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim StopLeftBlendAnim;                                 // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_MonsterLocomotion_Lock_StopBlendAnim StopRightBlendAnim;                                // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_MonsterLocomotion_Lock) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_MonsterLocomotion_Lock");
static_assert(sizeof(FAnimHumanoidSetting_MonsterLocomotion_Lock) == 0x000090, "Wrong size on FAnimHumanoidSetting_MonsterLocomotion_Lock");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, ASLockWalkFwd) == 0x000000, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::ASLockWalkFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, ASLockWalkFR) == 0x000008, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::ASLockWalkFR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, ASLockWalkBR) == 0x000010, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::ASLockWalkBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, ASLockWalkFL) == 0x000018, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::ASLockWalkFL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, ASLockWalkBL) == 0x000020, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::ASLockWalkBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, ASLockWalkBwd) == 0x000028, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::ASLockWalkBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, ExplicitTimeForLeftFootStop) == 0x000030, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::ExplicitTimeForLeftFootStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, ExplicitTimeForRightFootStop) == 0x000048, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::ExplicitTimeForRightFootStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, StopLeftBlendAnim) == 0x000060, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::StopLeftBlendAnim' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Lock, StopRightBlendAnim) == 0x000078, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Lock::StopRightBlendAnim' has a wrong offset!");

// SharpStruct b1-Managed.ManagedTaskObj
// 0x0040 (0x0040 - 0x0000)
struct FManagedTaskObj final
{
public:
	TSoftObjectPtr<class ABGUActorBaseCS>         Actor;                                             // 0x0000(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActorGuid;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AliasName;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedTaskObj) == 0x000008, "Wrong alignment on FManagedTaskObj");
static_assert(sizeof(FManagedTaskObj) == 0x000040, "Wrong size on FManagedTaskObj");
static_assert(offsetof(FManagedTaskObj, Actor) == 0x000000, "Member 'FManagedTaskObj::Actor' has a wrong offset!");
static_assert(offsetof(FManagedTaskObj, ActorGuid) == 0x000028, "Member 'FManagedTaskObj::ActorGuid' has a wrong offset!");
static_assert(offsetof(FManagedTaskObj, AliasName) == 0x000038, "Member 'FManagedTaskObj::AliasName' has a wrong offset!");

// SharpStruct b1-Managed.DispInteractLandscapeInfo
// 0x0048 (0x0048 - 0x0000)
struct FDispInteractLandscapeInfo final
{
public:
	class ALandscape*                             Landscape;                                         // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             LS_HeightMap;                                      // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             LS_WeightMap;                                      // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _LandscapeOriginOffset;                            // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VertexCount_Width;                                 // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VertexCount_Height;                                // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimulationSize_cm;                                 // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractiveData_StorageSize_cm;                    // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractDistLimitToDispActor;                      // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDispInteractLandscapeInfo) == 0x000008, "Wrong alignment on FDispInteractLandscapeInfo");
static_assert(sizeof(FDispInteractLandscapeInfo) == 0x000048, "Wrong size on FDispInteractLandscapeInfo");
static_assert(offsetof(FDispInteractLandscapeInfo, Landscape) == 0x000000, "Member 'FDispInteractLandscapeInfo::Landscape' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, LS_HeightMap) == 0x000008, "Member 'FDispInteractLandscapeInfo::LS_HeightMap' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, LS_WeightMap) == 0x000010, "Member 'FDispInteractLandscapeInfo::LS_WeightMap' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, _LandscapeOriginOffset) == 0x000018, "Member 'FDispInteractLandscapeInfo::_LandscapeOriginOffset' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, VertexCount_Width) == 0x000030, "Member 'FDispInteractLandscapeInfo::VertexCount_Width' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, VertexCount_Height) == 0x000034, "Member 'FDispInteractLandscapeInfo::VertexCount_Height' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, MaxHeight) == 0x000038, "Member 'FDispInteractLandscapeInfo::MaxHeight' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, SimulationSize_cm) == 0x00003C, "Member 'FDispInteractLandscapeInfo::SimulationSize_cm' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, InteractiveData_StorageSize_cm) == 0x000040, "Member 'FDispInteractLandscapeInfo::InteractiveData_StorageSize_cm' has a wrong offset!");
static_assert(offsetof(FDispInteractLandscapeInfo, InteractDistLimitToDispActor) == 0x000044, "Member 'FDispInteractLandscapeInfo::InteractDistLimitToDispActor' has a wrong offset!");

// SharpStruct b1-Managed.RebirthPointConfig
// 0x000C (0x000C - 0x0000)
struct FRebirthPointConfig final
{
public:
	int32                                         RebirthPointId;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bActiveSetCurrentRebirthPoint : 1;                 // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetCheckRange;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRebirthPointConfig) == 0x000004, "Wrong alignment on FRebirthPointConfig");
static_assert(sizeof(FRebirthPointConfig) == 0x00000C, "Wrong size on FRebirthPointConfig");
static_assert(offsetof(FRebirthPointConfig, RebirthPointId) == 0x000000, "Member 'FRebirthPointConfig::RebirthPointId' has a wrong offset!");
static_assert(offsetof(FRebirthPointConfig, TargetCheckRange) == 0x000008, "Member 'FRebirthPointConfig::TargetCheckRange' has a wrong offset!");

// SharpStruct b1-Managed.NeutralAnimalConfig
// 0x0008 (0x0008 - 0x0000)
struct FNeutralAnimalConfig final
{
public:
	ENeutralAnimalType                            NeutralAnimalType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackToPatrolRange;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNeutralAnimalConfig) == 0x000004, "Wrong alignment on FNeutralAnimalConfig");
static_assert(sizeof(FNeutralAnimalConfig) == 0x000008, "Wrong size on FNeutralAnimalConfig");
static_assert(offsetof(FNeutralAnimalConfig, NeutralAnimalType) == 0x000000, "Member 'FNeutralAnimalConfig::NeutralAnimalType' has a wrong offset!");
static_assert(offsetof(FNeutralAnimalConfig, BackToPatrolRange) == 0x000004, "Member 'FNeutralAnimalConfig::BackToPatrolRange' has a wrong offset!");

// SharpStruct b1-Managed.DelaySpawnInfo
// 0x0000 (0x0000 - 0x0000)
struct FDelaySpawnInfo final
{
};
static_assert(alignof(FDelaySpawnInfo) == 0x000001, "Wrong alignment on FDelaySpawnInfo");
static_assert(sizeof(FDelaySpawnInfo) == 0x000001, "Wrong size on FDelaySpawnInfo");

// SharpStruct b1-Managed.CharacterSpawnerLibInfo
// 0x0010 (0x0010 - 0x0000)
struct FCharacterSpawnerLibInfo final
{
public:
	class UClass*                                 SpawnClass;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CanBeElite : 1;                                    // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FCharacterSpawnerLibInfo) == 0x000008, "Wrong alignment on FCharacterSpawnerLibInfo");
static_assert(sizeof(FCharacterSpawnerLibInfo) == 0x000010, "Wrong size on FCharacterSpawnerLibInfo");
static_assert(offsetof(FCharacterSpawnerLibInfo, SpawnClass) == 0x000000, "Member 'FCharacterSpawnerLibInfo::SpawnClass' has a wrong offset!");

// SharpStruct b1-Managed.ChargeLevelUnitInfo
// 0x0028 (0x0028 - 0x0000)
struct FChargeLevelUnitInfo final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 BuffList;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int32>                                 LoopBuffList;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChargeLevelUnitInfo) == 0x000008, "Wrong alignment on FChargeLevelUnitInfo");
static_assert(sizeof(FChargeLevelUnitInfo) == 0x000028, "Wrong size on FChargeLevelUnitInfo");
static_assert(offsetof(FChargeLevelUnitInfo, Duration) == 0x000000, "Member 'FChargeLevelUnitInfo::Duration' has a wrong offset!");
static_assert(offsetof(FChargeLevelUnitInfo, BuffList) == 0x000008, "Member 'FChargeLevelUnitInfo::BuffList' has a wrong offset!");
static_assert(offsetof(FChargeLevelUnitInfo, LoopBuffList) == 0x000018, "Member 'FChargeLevelUnitInfo::LoopBuffList' has a wrong offset!");

// SharpStruct b1-Managed.ProceduralSpawnCharaterConfig
// 0x0018 (0x0018 - 0x0000)
struct FProceduralSpawnCharaterConfig final
{
public:
	float                                         ProceduralSpawnRadius;                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableEditorPreviewing : 1;                        // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FProceduralSpawnWaveConfig>     ProceduralWaveConfigs;                             // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralSpawnCharaterConfig) == 0x000008, "Wrong alignment on FProceduralSpawnCharaterConfig");
static_assert(sizeof(FProceduralSpawnCharaterConfig) == 0x000018, "Wrong size on FProceduralSpawnCharaterConfig");
static_assert(offsetof(FProceduralSpawnCharaterConfig, ProceduralSpawnRadius) == 0x000000, "Member 'FProceduralSpawnCharaterConfig::ProceduralSpawnRadius' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnCharaterConfig, ProceduralWaveConfigs) == 0x000008, "Member 'FProceduralSpawnCharaterConfig::ProceduralWaveConfigs' has a wrong offset!");

// SharpStruct b1-Managed.ProceduralSpawnSceneItemConfig
// 0x0018 (0x0018 - 0x0000)
struct FProceduralSpawnSceneItemConfig final
{
public:
	TArray<struct FProceduralSpawnSceneItemInfo>  ProceduralSpawnList;                               // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         EnablePreviewing : 1;                              // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnRadius;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralSpawnSceneItemConfig) == 0x000008, "Wrong alignment on FProceduralSpawnSceneItemConfig");
static_assert(sizeof(FProceduralSpawnSceneItemConfig) == 0x000018, "Wrong size on FProceduralSpawnSceneItemConfig");
static_assert(offsetof(FProceduralSpawnSceneItemConfig, ProceduralSpawnList) == 0x000000, "Member 'FProceduralSpawnSceneItemConfig::ProceduralSpawnList' has a wrong offset!");
static_assert(offsetof(FProceduralSpawnSceneItemConfig, SpawnRadius) == 0x000014, "Member 'FProceduralSpawnSceneItemConfig::SpawnRadius' has a wrong offset!");

// SharpStruct b1-Managed.SceneObjWithState
// 0x0018 (0x0018 - 0x0000)
struct FSceneObjWithState final
{
public:
	class FString                                 UnitGuid;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneObjTransitionState                      ActiveState;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneObjWithState) == 0x000008, "Wrong alignment on FSceneObjWithState");
static_assert(sizeof(FSceneObjWithState) == 0x000018, "Wrong size on FSceneObjWithState");
static_assert(offsetof(FSceneObjWithState, UnitGuid) == 0x000000, "Member 'FSceneObjWithState::UnitGuid' has a wrong offset!");
static_assert(offsetof(FSceneObjWithState, ActiveState) == 0x000010, "Member 'FSceneObjWithState::ActiveState' has a wrong offset!");

// SharpStruct b1-Managed.SceneObjTriggerEvent
// 0x0018 (0x0018 - 0x0000)
struct FSceneObjTriggerEvent final
{
public:
	class FString                                 UnitGuid;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneObjTransitionEvent                      UnTriggerEvent;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneObjTransitionEvent                      TriggerEvent;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSceneObjTriggerEvent) == 0x000008, "Wrong alignment on FSceneObjTriggerEvent");
static_assert(sizeof(FSceneObjTriggerEvent) == 0x000018, "Wrong size on FSceneObjTriggerEvent");
static_assert(offsetof(FSceneObjTriggerEvent, UnitGuid) == 0x000000, "Member 'FSceneObjTriggerEvent::UnitGuid' has a wrong offset!");
static_assert(offsetof(FSceneObjTriggerEvent, UnTriggerEvent) == 0x000010, "Member 'FSceneObjTriggerEvent::UnTriggerEvent' has a wrong offset!");
static_assert(offsetof(FSceneObjTriggerEvent, TriggerEvent) == 0x000011, "Member 'FSceneObjTriggerEvent::TriggerEvent' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Common
// 0x0040 (0x0040 - 0x0000)
struct FAnimHumanoidSetting_Common final
{
public:
	uint8                                         bDisableABPMove : 1;                               // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EABPMoveMode                                  ABPMoveMode;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimSeqIdle;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RetargetAnimSeqIdle;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLockUseFreeMode : 1;                              // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimTurnMinAngle;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimTurnLeft90;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimTurnRight90;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimTurnLeft180;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimTurnRight180;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Common) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_Common");
static_assert(sizeof(FAnimHumanoidSetting_Common) == 0x000040, "Wrong size on FAnimHumanoidSetting_Common");
static_assert(offsetof(FAnimHumanoidSetting_Common, ABPMoveMode) == 0x000001, "Member 'FAnimHumanoidSetting_Common::ABPMoveMode' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Common, AnimSeqIdle) == 0x000008, "Member 'FAnimHumanoidSetting_Common::AnimSeqIdle' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Common, RetargetAnimSeqIdle) == 0x000010, "Member 'FAnimHumanoidSetting_Common::RetargetAnimSeqIdle' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Common, AnimTurnMinAngle) == 0x00001C, "Member 'FAnimHumanoidSetting_Common::AnimTurnMinAngle' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Common, AnimTurnLeft90) == 0x000020, "Member 'FAnimHumanoidSetting_Common::AnimTurnLeft90' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Common, AnimTurnRight90) == 0x000028, "Member 'FAnimHumanoidSetting_Common::AnimTurnRight90' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Common, AnimTurnLeft180) == 0x000030, "Member 'FAnimHumanoidSetting_Common::AnimTurnLeft180' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Common, AnimTurnRight180) == 0x000038, "Member 'FAnimHumanoidSetting_Common::AnimTurnRight180' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_MotionMatching
// 0x00B8 (0x00B8 - 0x0000)
struct FAnimHumanoidSetting_MotionMatching final
{
public:
	class UAnimationAnalyzer*                     Walk2RunAA;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMMLockUseFreeMode : 1;                            // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            RotateAdditiveBS;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMUpBodyStateAlpha;                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EState_MM                                     DefaultMMState;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EABPMoveMode                                  SpareMoveMode;                                     // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EState_MM, class UBUAnimationAnalyzer*>  MMState2AACS;                                      // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         AnimationAnalyzerBlendTime;                        // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBlendTime;                                   // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UIKRetargeter*                          Retargeter;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisOffsetZ;                                     // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootOffsetScale;                                   // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceSetRotAnimSpeed;                              // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableRotVerifyAnimSpeed;                         // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToIdleAnimSpeed;                                   // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNeedFixMM : 1;                                    // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          MMAdditivePose;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMAdditiveWeight;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFixMMWeapon_MeshSpaceRotation : 1;                // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_A4_1 : 7;                                   // 0x00A4(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bFixMMAdditive_MeshSpaceRotation : 1;              // 0x00A5(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGSInputBlendPose>              MMAdditiveLayerSetup;                              // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_MotionMatching) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_MotionMatching");
static_assert(sizeof(FAnimHumanoidSetting_MotionMatching) == 0x0000B8, "Wrong size on FAnimHumanoidSetting_MotionMatching");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, Walk2RunAA) == 0x000000, "Member 'FAnimHumanoidSetting_MotionMatching::Walk2RunAA' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, RotateAdditiveBS) == 0x000010, "Member 'FAnimHumanoidSetting_MotionMatching::RotateAdditiveBS' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, MMUpBodyStateAlpha) == 0x000018, "Member 'FAnimHumanoidSetting_MotionMatching::MMUpBodyStateAlpha' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, DefaultMMState) == 0x00001C, "Member 'FAnimHumanoidSetting_MotionMatching::DefaultMMState' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, SpareMoveMode) == 0x00001D, "Member 'FAnimHumanoidSetting_MotionMatching::SpareMoveMode' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, MMState2AACS) == 0x000020, "Member 'FAnimHumanoidSetting_MotionMatching::MMState2AACS' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, AnimationAnalyzerBlendTime) == 0x000070, "Member 'FAnimHumanoidSetting_MotionMatching::AnimationAnalyzerBlendTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, MotionBlendTime) == 0x000074, "Member 'FAnimHumanoidSetting_MotionMatching::MotionBlendTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, Retargeter) == 0x000078, "Member 'FAnimHumanoidSetting_MotionMatching::Retargeter' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, PelvisOffsetZ) == 0x000080, "Member 'FAnimHumanoidSetting_MotionMatching::PelvisOffsetZ' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, FootOffsetScale) == 0x000084, "Member 'FAnimHumanoidSetting_MotionMatching::FootOffsetScale' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, ForceSetRotAnimSpeed) == 0x000088, "Member 'FAnimHumanoidSetting_MotionMatching::ForceSetRotAnimSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, DisableRotVerifyAnimSpeed) == 0x00008C, "Member 'FAnimHumanoidSetting_MotionMatching::DisableRotVerifyAnimSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, ToIdleAnimSpeed) == 0x000090, "Member 'FAnimHumanoidSetting_MotionMatching::ToIdleAnimSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, MMAdditivePose) == 0x000098, "Member 'FAnimHumanoidSetting_MotionMatching::MMAdditivePose' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, MMAdditiveWeight) == 0x0000A0, "Member 'FAnimHumanoidSetting_MotionMatching::MMAdditiveWeight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MotionMatching, MMAdditiveLayerSetup) == 0x0000A8, "Member 'FAnimHumanoidSetting_MotionMatching::MMAdditiveLayerSetup' has a wrong offset!");

// SharpStruct b1-Managed.HiAltFxAnimalRotInfo
// 0x0020 (0x0020 - 0x0000)
struct FHiAltFxAnimalRotInfo final
{
public:
	EHitAltFxAnimalRotType                        RotType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SurroundOffset;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiAltFxAnimalRotInfo) == 0x000008, "Wrong alignment on FHiAltFxAnimalRotInfo");
static_assert(sizeof(FHiAltFxAnimalRotInfo) == 0x000020, "Wrong size on FHiAltFxAnimalRotInfo");
static_assert(offsetof(FHiAltFxAnimalRotInfo, RotType) == 0x000000, "Member 'FHiAltFxAnimalRotInfo::RotType' has a wrong offset!");
static_assert(offsetof(FHiAltFxAnimalRotInfo, SurroundOffset) == 0x000008, "Member 'FHiAltFxAnimalRotInfo::SurroundOffset' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Simple4Dir
// 0x0060 (0x0060 - 0x0000)
struct FAnimHumanoidSetting_Simple4Dir final
{
public:
	class UBlendSpace*                            BSStart;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSEnd;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CardinalDirectionBlendTime;                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            BSWalkFwd;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSWalkBwd;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSWalkLeft;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSWalkRight;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunFwd;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunBwd;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunLeft;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunRight;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSSprint;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Simple4Dir) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_Simple4Dir");
static_assert(sizeof(FAnimHumanoidSetting_Simple4Dir) == 0x000060, "Wrong size on FAnimHumanoidSetting_Simple4Dir");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSStart) == 0x000000, "Member 'FAnimHumanoidSetting_Simple4Dir::BSStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSEnd) == 0x000008, "Member 'FAnimHumanoidSetting_Simple4Dir::BSEnd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, CardinalDirectionBlendTime) == 0x000010, "Member 'FAnimHumanoidSetting_Simple4Dir::CardinalDirectionBlendTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSWalkFwd) == 0x000018, "Member 'FAnimHumanoidSetting_Simple4Dir::BSWalkFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSWalkBwd) == 0x000020, "Member 'FAnimHumanoidSetting_Simple4Dir::BSWalkBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSWalkLeft) == 0x000028, "Member 'FAnimHumanoidSetting_Simple4Dir::BSWalkLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSWalkRight) == 0x000030, "Member 'FAnimHumanoidSetting_Simple4Dir::BSWalkRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSRunFwd) == 0x000038, "Member 'FAnimHumanoidSetting_Simple4Dir::BSRunFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSRunBwd) == 0x000040, "Member 'FAnimHumanoidSetting_Simple4Dir::BSRunBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSRunLeft) == 0x000048, "Member 'FAnimHumanoidSetting_Simple4Dir::BSRunLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSRunRight) == 0x000050, "Member 'FAnimHumanoidSetting_Simple4Dir::BSRunRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Simple4Dir, BSSprint) == 0x000058, "Member 'FAnimHumanoidSetting_Simple4Dir::BSSprint' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_AimOffset
// 0x0018 (0x0018 - 0x0000)
struct FAnimHumanoidSetting_AimOffset final
{
public:
	int32                                         AimOffsetTurnSpeed;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AimOffsetBlindAngle;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   DefaultAimOffset;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AttackAimOffset;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_AimOffset) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_AimOffset");
static_assert(sizeof(FAnimHumanoidSetting_AimOffset) == 0x000018, "Wrong size on FAnimHumanoidSetting_AimOffset");
static_assert(offsetof(FAnimHumanoidSetting_AimOffset, AimOffsetTurnSpeed) == 0x000000, "Member 'FAnimHumanoidSetting_AimOffset::AimOffsetTurnSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AimOffset, AimOffsetBlindAngle) == 0x000004, "Member 'FAnimHumanoidSetting_AimOffset::AimOffsetBlindAngle' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AimOffset, DefaultAimOffset) == 0x000008, "Member 'FAnimHumanoidSetting_AimOffset::DefaultAimOffset' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AimOffset, AttackAimOffset) == 0x000010, "Member 'FAnimHumanoidSetting_AimOffset::AttackAimOffset' has a wrong offset!");

// SharpStruct b1-Managed.LimbIKData
// 0x0028 (0x0028 - 0x0000)
struct FLimbIKData final
{
public:
	class FName                                   LimbRootBoneName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LimbEndBoneName;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         LimbTraceUP;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbTraceDown;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LimbCurveName;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLimbIKData) == 0x000008, "Wrong alignment on FLimbIKData");
static_assert(sizeof(FLimbIKData) == 0x000028, "Wrong size on FLimbIKData");
static_assert(offsetof(FLimbIKData, LimbRootBoneName) == 0x000000, "Member 'FLimbIKData::LimbRootBoneName' has a wrong offset!");
static_assert(offsetof(FLimbIKData, LimbEndBoneName) == 0x000008, "Member 'FLimbIKData::LimbEndBoneName' has a wrong offset!");
static_assert(offsetof(FLimbIKData, LimbTraceUP) == 0x000018, "Member 'FLimbIKData::LimbTraceUP' has a wrong offset!");
static_assert(offsetof(FLimbIKData, LimbTraceDown) == 0x00001C, "Member 'FLimbIKData::LimbTraceDown' has a wrong offset!");
static_assert(offsetof(FLimbIKData, LimbCurveName) == 0x000020, "Member 'FLimbIKData::LimbCurveName' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_SpineIK
// 0x0030 (0x0030 - 0x0000)
struct FAnimHumanoidSetting_SpineIK final
{
public:
	uint8                                         bEnableSpineIK : 1;                                // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_0_1 : 7;                                    // 0x0000(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bEnableSpineIKDebug : 1;                           // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpineIKTraceUpDistance;                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpineIKTraceDownDistance;                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetPitch;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetRoll;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSpeed;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DisableLimbIKAlpha : 1;                            // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IgnoreDistance;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLimbIKData>                    LimbIKDataList;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_SpineIK) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_SpineIK");
static_assert(sizeof(FAnimHumanoidSetting_SpineIK) == 0x000030, "Wrong size on FAnimHumanoidSetting_SpineIK");
static_assert(offsetof(FAnimHumanoidSetting_SpineIK, SpineIKTraceUpDistance) == 0x000004, "Member 'FAnimHumanoidSetting_SpineIK::SpineIKTraceUpDistance' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpineIK, SpineIKTraceDownDistance) == 0x000008, "Member 'FAnimHumanoidSetting_SpineIK::SpineIKTraceDownDistance' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpineIK, OffsetPitch) == 0x00000C, "Member 'FAnimHumanoidSetting_SpineIK::OffsetPitch' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpineIK, OffsetRoll) == 0x000010, "Member 'FAnimHumanoidSetting_SpineIK::OffsetRoll' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpineIK, LerpSpeed) == 0x000014, "Member 'FAnimHumanoidSetting_SpineIK::LerpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpineIK, IgnoreDistance) == 0x00001C, "Member 'FAnimHumanoidSetting_SpineIK::IgnoreDistance' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpineIK, LimbIKDataList) == 0x000020, "Member 'FAnimHumanoidSetting_SpineIK::LimbIKDataList' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_DingShen
// 0x0010 (0x0010 - 0x0000)
struct FAnimHumanoidSetting_DingShen final
{
public:
	class UAnimSequence*                          AnimDingShenStart;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimDingShenHold;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_DingShen) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_DingShen");
static_assert(sizeof(FAnimHumanoidSetting_DingShen) == 0x000010, "Wrong size on FAnimHumanoidSetting_DingShen");
static_assert(offsetof(FAnimHumanoidSetting_DingShen, AnimDingShenStart) == 0x000000, "Member 'FAnimHumanoidSetting_DingShen::AnimDingShenStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_DingShen, AnimDingShenHold) == 0x000008, "Member 'FAnimHumanoidSetting_DingShen::AnimDingShenHold' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Fall
// 0x0030 (0x0030 - 0x0000)
struct FAnimHumanoidSetting_Fall final
{
public:
	class UAnimSequence*                          AnimFallStart;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimFallLoop;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Jump_Land         LandSetting;                                       // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Fall) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_Fall");
static_assert(sizeof(FAnimHumanoidSetting_Fall) == 0x000030, "Wrong size on FAnimHumanoidSetting_Fall");
static_assert(offsetof(FAnimHumanoidSetting_Fall, AnimFallStart) == 0x000000, "Member 'FAnimHumanoidSetting_Fall::AnimFallStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Fall, AnimFallLoop) == 0x000008, "Member 'FAnimHumanoidSetting_Fall::AnimFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Fall, LandSetting) == 0x000010, "Member 'FAnimHumanoidSetting_Fall::LandSetting' has a wrong offset!");

// SharpStruct b1-Managed.CloudBreakAnimSetting
// 0x0060 (0x0060 - 0x0000)
struct FCloudBreakAnimSetting final
{
public:
	struct FAnimHumanoidSetting_Fall              CloudBreakAnimSetting_Low;                         // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Fall              CloudBreakAnimSetting_High;                        // 0x0030(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudBreakAnimSetting) == 0x000008, "Wrong alignment on FCloudBreakAnimSetting");
static_assert(sizeof(FCloudBreakAnimSetting) == 0x000060, "Wrong size on FCloudBreakAnimSetting");
static_assert(offsetof(FCloudBreakAnimSetting, CloudBreakAnimSetting_Low) == 0x000000, "Member 'FCloudBreakAnimSetting::CloudBreakAnimSetting_Low' has a wrong offset!");
static_assert(offsetof(FCloudBreakAnimSetting, CloudBreakAnimSetting_High) == 0x000030, "Member 'FCloudBreakAnimSetting::CloudBreakAnimSetting_High' has a wrong offset!");

// SharpStruct b1-Managed.GainItemConfig
// 0x0008 (0x0008 - 0x0000)
struct FGainItemConfig final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGainItemConfig) == 0x000004, "Wrong alignment on FGainItemConfig");
static_assert(sizeof(FGainItemConfig) == 0x000008, "Wrong size on FGainItemConfig");
static_assert(offsetof(FGainItemConfig, ItemId) == 0x000000, "Member 'FGainItemConfig::ItemId' has a wrong offset!");
static_assert(offsetof(FGainItemConfig, ItemCount) == 0x000004, "Member 'FGainItemConfig::ItemCount' has a wrong offset!");

// SharpStruct b1-Managed.WaterSplashResource
// 0x0390 (0x0390 - 0x0000)
struct FWaterSplashResource final
{
public:
	uint8                                         ApplyDir : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBUC_DispLibDBC_PlayAdvanceNiagara     AdvanceNiagara;                                    // 0x0010(0x0370)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraSys;                                        // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterSplashResource) == 0x000010, "Wrong alignment on FWaterSplashResource");
static_assert(sizeof(FWaterSplashResource) == 0x000390, "Wrong size on FWaterSplashResource");
static_assert(offsetof(FWaterSplashResource, AdvanceNiagara) == 0x000010, "Member 'FWaterSplashResource::AdvanceNiagara' has a wrong offset!");
static_assert(offsetof(FWaterSplashResource, NiagaraSys) == 0x000380, "Member 'FWaterSplashResource::NiagaraSys' has a wrong offset!");
static_assert(offsetof(FWaterSplashResource, AkEvent) == 0x000388, "Member 'FWaterSplashResource::AkEvent' has a wrong offset!");

// SharpStruct b1-Managed.WaterSplashResourceMap_WithSurfaceType
// 0x0050 (0x0050 - 0x0000)
struct FWaterSplashResourceMap_WithSurfaceType final
{
public:
	TMap<ESceneItemSurfaceType, struct FWaterSplashResource> FXMap;                                             // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaterSplashResourceMap_WithSurfaceType) == 0x000008, "Wrong alignment on FWaterSplashResourceMap_WithSurfaceType");
static_assert(sizeof(FWaterSplashResourceMap_WithSurfaceType) == 0x000050, "Wrong size on FWaterSplashResourceMap_WithSurfaceType");
static_assert(offsetof(FWaterSplashResourceMap_WithSurfaceType, FXMap) == 0x000000, "Member 'FWaterSplashResourceMap_WithSurfaceType::FXMap' has a wrong offset!");

// SharpStruct b1-Managed.BattleStartCondition
// 0x0034 (0x0034 - 0x0000)
struct FBattleStartCondition final
{
public:
	EBattleStartConditionType                     StartConditionType;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          Unit;                                              // 0x0004(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Spawner;                                           // 0x0014(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Overlap;                                           // 0x0024(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleStartCondition) == 0x000004, "Wrong alignment on FBattleStartCondition");
static_assert(sizeof(FBattleStartCondition) == 0x000034, "Wrong size on FBattleStartCondition");
static_assert(offsetof(FBattleStartCondition, StartConditionType) == 0x000000, "Member 'FBattleStartCondition::StartConditionType' has a wrong offset!");
static_assert(offsetof(FBattleStartCondition, Unit) == 0x000004, "Member 'FBattleStartCondition::Unit' has a wrong offset!");
static_assert(offsetof(FBattleStartCondition, Spawner) == 0x000014, "Member 'FBattleStartCondition::Spawner' has a wrong offset!");
static_assert(offsetof(FBattleStartCondition, Overlap) == 0x000024, "Member 'FBattleStartCondition::Overlap' has a wrong offset!");

// SharpStruct b1-Managed.PerformerStateConfig
// 0x0008 (0x0008 - 0x0000)
struct FPerformerStateConfig final
{
public:
	uint8                                         bPauseAI : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_0_1 : 7;                                    // 0x0000(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bDisableCollision : 1;                             // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_1_1 : 7;                                    // 0x0001(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bDisableMeshCollision : 1;                         // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_2_1 : 7;                                    // 0x0002(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bDisableGravity : 1;                               // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_3_1 : 7;                                    // 0x0003(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bCannotSelected : 1;                               // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_4_1 : 7;                                    // 0x0004(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bInvisible : 1;                                    // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_5_1 : 7;                                    // 0x0005(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bInvincible : 1;                                   // 0x0006(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_6_1 : 7;                                    // 0x0006(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bPerforming : 1;                                   // 0x0007(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FPerformerStateConfig) == 0x000001, "Wrong alignment on FPerformerStateConfig");
static_assert(sizeof(FPerformerStateConfig) == 0x000008, "Wrong size on FPerformerStateConfig");

// SharpStruct b1-Managed.AnimHumanoidSetting_Patrol
// 0x0048 (0x0048 - 0x0000)
struct FAnimHumanoidSetting_Patrol final
{
public:
	class UAnimSequence*                          AnimIdle;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSWalkFwd;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSWalkBwd;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSWalkLeft;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSWalkRight;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunFwd;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunBwd;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunLeft;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunRight;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Patrol) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_Patrol");
static_assert(sizeof(FAnimHumanoidSetting_Patrol) == 0x000048, "Wrong size on FAnimHumanoidSetting_Patrol");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, AnimIdle) == 0x000000, "Member 'FAnimHumanoidSetting_Patrol::AnimIdle' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, BSWalkFwd) == 0x000008, "Member 'FAnimHumanoidSetting_Patrol::BSWalkFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, BSWalkBwd) == 0x000010, "Member 'FAnimHumanoidSetting_Patrol::BSWalkBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, BSWalkLeft) == 0x000018, "Member 'FAnimHumanoidSetting_Patrol::BSWalkLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, BSWalkRight) == 0x000020, "Member 'FAnimHumanoidSetting_Patrol::BSWalkRight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, BSRunFwd) == 0x000028, "Member 'FAnimHumanoidSetting_Patrol::BSRunFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, BSRunBwd) == 0x000030, "Member 'FAnimHumanoidSetting_Patrol::BSRunBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, BSRunLeft) == 0x000038, "Member 'FAnimHumanoidSetting_Patrol::BSRunLeft' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Patrol, BSRunRight) == 0x000040, "Member 'FAnimHumanoidSetting_Patrol::BSRunRight' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_FlyControl
// 0x0030 (0x0030 - 0x0000)
struct FAnimHumanoidSetting_FlyControl final
{
public:
	class UBlendSpace*                            BSFly;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFlyUpward;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFlyDownward;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFlyUpToDown;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFlyDownToUp;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSFlyLean;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_FlyControl) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_FlyControl");
static_assert(sizeof(FAnimHumanoidSetting_FlyControl) == 0x000030, "Wrong size on FAnimHumanoidSetting_FlyControl");
static_assert(offsetof(FAnimHumanoidSetting_FlyControl, BSFly) == 0x000000, "Member 'FAnimHumanoidSetting_FlyControl::BSFly' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_FlyControl, ASFlyUpward) == 0x000008, "Member 'FAnimHumanoidSetting_FlyControl::ASFlyUpward' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_FlyControl, ASFlyDownward) == 0x000010, "Member 'FAnimHumanoidSetting_FlyControl::ASFlyDownward' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_FlyControl, ASFlyUpToDown) == 0x000018, "Member 'FAnimHumanoidSetting_FlyControl::ASFlyUpToDown' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_FlyControl, ASFlyDownToUp) == 0x000020, "Member 'FAnimHumanoidSetting_FlyControl::ASFlyDownToUp' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_FlyControl, BSFlyLean) == 0x000028, "Member 'FAnimHumanoidSetting_FlyControl::BSFlyLean' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_PlayerLocomotion_Lock
// 0x02D8 (0x02D8 - 0x0000)
struct FAnimHumanoidSetting_PlayerLocomotion_Lock final
{
public:
	class UCurveVector*                           LockMovementCurve;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkLoopFwd;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkLoopBwd;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkLoopLeftF;                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkLoopRightF;                              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkLoopLeftB;                               // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkLoopRightB;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkLoopLeftFAdd;                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkLoopRightFAdd;                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunLoopFwd;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunLoopLeftF;                                // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunLoopLeftB;                                // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunLoopLeftFAdd;                             // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunLoopRightF;                               // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunLoopRightB;                               // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunLoopRightFAdd;                            // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunLoopBwd;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkStartFwd;                                // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkStartBwd;                                // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStartFwdL;                               // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStartFwdR;                               // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStartBwdL;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStartBwdR;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStartLeftF;                              // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStartLeftB;                              // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStartRightF;                             // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStartRightB;                             // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunStartFwd;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunStartBwd;                                 // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStartFwdL;                                // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStartFwdR;                                // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStartBwdL;                                // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStartBwdR;                                // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStartLeftF;                               // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStartLeftB;                               // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStartRightF;                              // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStartRightB;                              // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnF2B;                                 // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnB2F;                                 // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnFR2BL;                               // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnBR2FL;                               // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnBL2FR;                               // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnFL2BR;                               // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnFR2FL;                               // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnFL2FR;                               // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnBL2FL;                               // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnFL2BL;                               // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnBR2FR;                               // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockWalkTurnFR2BR;                               // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnF2B;                                  // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnB2F;                                  // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnBR2FL;                                // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnFR2FL;                                // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnBL2FL;                                // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnFR2BL;                                // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnFL2BL;                                // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnFL2FR;                                // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnBL2FR;                                // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnBR2FR;                                // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnFL2BR;                                // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockRunTurnFR2BR;                                // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnFRFromFRBL;                              // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnFRFromFLBR;                              // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnBRFromFRBL;                              // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnBRFromFLBR;                              // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnBLFromFRBL;                              // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnBLFromFLBR;                              // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnFLFromFRBL;                              // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnFLFromFLBR;                              // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnStopFL;                                  // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnStopFR;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnStopBL;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSLockTurnStopBR;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopFwd;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopBwd;                                 // 0x0250(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopLeftF;                               // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopLeftB;                               // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopRightF;                              // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopRightB;                              // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopFL45;                                // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopFR45;                                // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopBL45;                                // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockWalkStopBR45;                                // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStopFwdL;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStopFwdR;                                 // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStopLeftF;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStopLeftB;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStopRightF;                               // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStopRightB;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStopBwdL;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASLockRunStopBwdR;                                 // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_PlayerLocomotion_Lock) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_PlayerLocomotion_Lock");
static_assert(sizeof(FAnimHumanoidSetting_PlayerLocomotion_Lock) == 0x0002D8, "Wrong size on FAnimHumanoidSetting_PlayerLocomotion_Lock");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, LockMovementCurve) == 0x000000, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::LockMovementCurve' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkLoopFwd) == 0x000008, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkLoopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkLoopBwd) == 0x000010, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkLoopBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkLoopLeftF) == 0x000018, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkLoopLeftF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkLoopRightF) == 0x000020, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkLoopRightF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkLoopLeftB) == 0x000028, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkLoopLeftB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkLoopRightB) == 0x000030, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkLoopRightB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkLoopLeftFAdd) == 0x000038, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkLoopLeftFAdd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkLoopRightFAdd) == 0x000040, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkLoopRightFAdd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunLoopFwd) == 0x000048, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunLoopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunLoopLeftF) == 0x000050, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunLoopLeftF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunLoopLeftB) == 0x000058, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunLoopLeftB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunLoopLeftFAdd) == 0x000060, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunLoopLeftFAdd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunLoopRightF) == 0x000068, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunLoopRightF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunLoopRightB) == 0x000070, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunLoopRightB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunLoopRightFAdd) == 0x000078, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunLoopRightFAdd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunLoopBwd) == 0x000080, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunLoopBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkStartFwd) == 0x000088, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkStartBwd) == 0x000090, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkStartBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStartFwdL) == 0x000098, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStartFwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStartFwdR) == 0x0000A0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStartFwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStartBwdL) == 0x0000A8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStartBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStartBwdR) == 0x0000B0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStartBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStartLeftF) == 0x0000B8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStartLeftF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStartLeftB) == 0x0000C0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStartLeftB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStartRightF) == 0x0000C8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStartRightF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStartRightB) == 0x0000D0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStartRightB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunStartFwd) == 0x0000D8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunStartBwd) == 0x0000E0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunStartBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStartFwdL) == 0x0000E8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStartFwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStartFwdR) == 0x0000F0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStartFwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStartBwdL) == 0x0000F8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStartBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStartBwdR) == 0x000100, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStartBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStartLeftF) == 0x000108, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStartLeftF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStartLeftB) == 0x000110, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStartLeftB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStartRightF) == 0x000118, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStartRightF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStartRightB) == 0x000120, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStartRightB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnF2B) == 0x000128, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnF2B' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnB2F) == 0x000130, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnB2F' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnFR2BL) == 0x000138, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnFR2BL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnBR2FL) == 0x000140, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnBR2FL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnBL2FR) == 0x000148, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnBL2FR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnFL2BR) == 0x000150, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnFL2BR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnFR2FL) == 0x000158, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnFR2FL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnFL2FR) == 0x000160, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnFL2FR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnBL2FL) == 0x000168, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnBL2FL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnFL2BL) == 0x000170, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnFL2BL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnBR2FR) == 0x000178, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnBR2FR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockWalkTurnFR2BR) == 0x000180, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockWalkTurnFR2BR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnF2B) == 0x000188, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnF2B' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnB2F) == 0x000190, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnB2F' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnBR2FL) == 0x000198, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnBR2FL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnFR2FL) == 0x0001A0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnFR2FL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnBL2FL) == 0x0001A8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnBL2FL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnFR2BL) == 0x0001B0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnFR2BL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnFL2BL) == 0x0001B8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnFL2BL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnFL2FR) == 0x0001C0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnFL2FR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnBL2FR) == 0x0001C8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnBL2FR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnBR2FR) == 0x0001D0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnBR2FR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnFL2BR) == 0x0001D8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnFL2BR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockRunTurnFR2BR) == 0x0001E0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockRunTurnFR2BR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnFRFromFRBL) == 0x0001E8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnFRFromFRBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnFRFromFLBR) == 0x0001F0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnFRFromFLBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnBRFromFRBL) == 0x0001F8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnBRFromFRBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnBRFromFLBR) == 0x000200, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnBRFromFLBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnBLFromFRBL) == 0x000208, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnBLFromFRBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnBLFromFLBR) == 0x000210, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnBLFromFLBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnFLFromFRBL) == 0x000218, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnFLFromFRBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnFLFromFLBR) == 0x000220, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnFLFromFLBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnStopFL) == 0x000228, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnStopFL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnStopFR) == 0x000230, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnStopFR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnStopBL) == 0x000238, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnStopBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, BSLockTurnStopBR) == 0x000240, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::BSLockTurnStopBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopFwd) == 0x000248, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopBwd) == 0x000250, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopLeftF) == 0x000258, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopLeftF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopLeftB) == 0x000260, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopLeftB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopRightF) == 0x000268, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopRightF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopRightB) == 0x000270, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopRightB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopFL45) == 0x000278, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopFL45' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopFR45) == 0x000280, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopFR45' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopBL45) == 0x000288, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopBL45' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockWalkStopBR45) == 0x000290, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockWalkStopBR45' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStopFwdL) == 0x000298, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStopFwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStopFwdR) == 0x0002A0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStopFwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStopLeftF) == 0x0002A8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStopLeftF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStopLeftB) == 0x0002B0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStopLeftB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStopRightF) == 0x0002B8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStopRightF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStopRightB) == 0x0002C0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStopRightB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStopBwdL) == 0x0002C8, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStopBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion_Lock, ASLockRunStopBwdR) == 0x0002D0, "Member 'FAnimHumanoidSetting_PlayerLocomotion_Lock::ASLockRunStopBwdR' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_PlayerLocomotion
// 0x0480 (0x0480 - 0x0000)
struct FAnimHumanoidSetting_PlayerLocomotion final
{
public:
	TArray<class UAnimSequence*>                  ASIdleList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSequenceTransitionMoveFromWalkLFoot;             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSequenceTransitionMoveFromWalkRFoot;             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSequenceTransitionMoveFromRunLFoot;              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSequenceTransitionMoveFromRunRFoot;              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSequenceTransitionMoveFromRushLFoot;             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSequenceTransitionMoveFromRushRFoot;             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_PlayerLocomotion_Free Free;                                              // 0x0040(0x0168)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_PlayerLocomotion_Lock Lock;                                              // 0x01A8(0x02D8)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_PlayerLocomotion) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_PlayerLocomotion");
static_assert(sizeof(FAnimHumanoidSetting_PlayerLocomotion) == 0x000480, "Wrong size on FAnimHumanoidSetting_PlayerLocomotion");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, ASIdleList) == 0x000000, "Member 'FAnimHumanoidSetting_PlayerLocomotion::ASIdleList' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, ASSequenceTransitionMoveFromWalkLFoot) == 0x000010, "Member 'FAnimHumanoidSetting_PlayerLocomotion::ASSequenceTransitionMoveFromWalkLFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, ASSequenceTransitionMoveFromWalkRFoot) == 0x000018, "Member 'FAnimHumanoidSetting_PlayerLocomotion::ASSequenceTransitionMoveFromWalkRFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, ASSequenceTransitionMoveFromRunLFoot) == 0x000020, "Member 'FAnimHumanoidSetting_PlayerLocomotion::ASSequenceTransitionMoveFromRunLFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, ASSequenceTransitionMoveFromRunRFoot) == 0x000028, "Member 'FAnimHumanoidSetting_PlayerLocomotion::ASSequenceTransitionMoveFromRunRFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, ASSequenceTransitionMoveFromRushLFoot) == 0x000030, "Member 'FAnimHumanoidSetting_PlayerLocomotion::ASSequenceTransitionMoveFromRushLFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, ASSequenceTransitionMoveFromRushRFoot) == 0x000038, "Member 'FAnimHumanoidSetting_PlayerLocomotion::ASSequenceTransitionMoveFromRushRFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, Free) == 0x000040, "Member 'FAnimHumanoidSetting_PlayerLocomotion::Free' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_PlayerLocomotion, Lock) == 0x0001A8, "Member 'FAnimHumanoidSetting_PlayerLocomotion::Lock' has a wrong offset!");

// SharpStruct b1-Managed.ResourceID_PreloadOutlaw
// 0x0018 (0x0018 - 0x0000)
struct FResourceID_PreloadOutlaw final
{
public:
	EIDType_Outlaw                                Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RefInfo;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceID_PreloadOutlaw) == 0x000008, "Wrong alignment on FResourceID_PreloadOutlaw");
static_assert(sizeof(FResourceID_PreloadOutlaw) == 0x000018, "Wrong size on FResourceID_PreloadOutlaw");
static_assert(offsetof(FResourceID_PreloadOutlaw, Type) == 0x000000, "Member 'FResourceID_PreloadOutlaw::Type' has a wrong offset!");
static_assert(offsetof(FResourceID_PreloadOutlaw, ID) == 0x000004, "Member 'FResourceID_PreloadOutlaw::ID' has a wrong offset!");
static_assert(offsetof(FResourceID_PreloadOutlaw, RefInfo) == 0x000008, "Member 'FResourceID_PreloadOutlaw::RefInfo' has a wrong offset!");

// SharpStruct b1-Managed.ManagedObjectsForTask
// 0x0020 (0x0020 - 0x0000)
struct FManagedObjectsForTask final
{
public:
	TArray<struct FManagedTaskUnit>               TaskUnitCollection;                                // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FManagedTaskObj>                TaskObjCollection;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManagedObjectsForTask) == 0x000008, "Wrong alignment on FManagedObjectsForTask");
static_assert(sizeof(FManagedObjectsForTask) == 0x000020, "Wrong size on FManagedObjectsForTask");
static_assert(offsetof(FManagedObjectsForTask, TaskUnitCollection) == 0x000000, "Member 'FManagedObjectsForTask::TaskUnitCollection' has a wrong offset!");
static_assert(offsetof(FManagedObjectsForTask, TaskObjCollection) == 0x000010, "Member 'FManagedObjectsForTask::TaskObjCollection' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_AdvancedMonsterLocomotion
// 0x0338 (0x0338 - 0x0000)
struct FAnimHumanoidSetting_AdvancedMonsterLocomotion final
{
public:
	ELMFreeMode                                   FreeMode;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMLockMode                                   LockMode;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkMaxAcceleration;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkBrakingFriction;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkBrakingDecelerationWalking;                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunMaxAcceleration;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunBrakingFriction;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunBrakingDecelerationWalking;                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushMaxAcceleration;                               // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushBrakingFriction;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushBrakingDecelerationWalking;                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartAndTurnAnimPlayRateClamped;                   // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LoopAnimPlayRateClamped;                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  ASIdleList;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartFwd;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartBwd;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartLeftMin;                                // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartLeftMax;                                // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartRightMin;                               // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartRightMax;                               // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartLF;                                     // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartLB;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartRF;                                     // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStartRB;                                     // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkLoopFwd;                                     // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkLoopBwd;                                     // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkLoopLF;                                      // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkLoopLB;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkLoopRF;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkLoopRB;                                      // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkSharpturnLeftMin;                            // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkSharpturnLeftMax;                            // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkSharpturnRightMin;                           // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkSharpturnRightMax;                           // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkPivotFwd;                                    // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkPivotBwd;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkPivotLF;                                     // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkPivotLB;                                     // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkPivotRF;                                     // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkPivotRB;                                     // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkTransFRToBR;                                 // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkTransBRToFR;                                 // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkTransFLToBL;                                 // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkTransBLToFL;                                 // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStopFwd;                                     // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStopBwd;                                     // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStopLF;                                      // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStopLB;                                      // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStopRF;                                      // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStopRB;                                      // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkLoopAddPose;                                 // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  ASWalkLoopAdditiveList;                            // 0x0180(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartFwd;                                     // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartBwd;                                     // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartLeftMin;                                 // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartLeftMax;                                 // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartRightMin;                                // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartRightMax;                                // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartLF;                                      // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartLB;                                      // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartRF;                                      // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartRB;                                      // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLoopFwd;                                      // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLoopBwd;                                      // 0x01E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLoopLF;                                       // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLoopLB;                                       // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLoopRF;                                       // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLoopRB;                                       // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunSharpturnLeftMin;                             // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunSharpturnLeftMax;                             // 0x0218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunSharpturnRightMin;                            // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunSharpturnRightMax;                            // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunPivotFwd;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunPivotBwd;                                     // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunPivotLF;                                      // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunPivotLB;                                      // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunPivotRF;                                      // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunPivotRB;                                      // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTransFRToBR;                                  // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTransBRToFR;                                  // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTransFLToBL;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTransBLToFL;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStopFwd;                                      // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStopBwd;                                      // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStopLF;                                       // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStopLB;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStopRF;                                       // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStopRB;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLoopAddPose;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  ASRunLoopAdditiveList;                             // 0x02B8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartFwd;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartLeftMin;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartLeftMax;                                // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartRightMin;                               // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartRightMax;                               // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushLoopFwd;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushSharpturnLeftMin;                            // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushSharpturnLeftMax;                            // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushSharpturnRightMin;                           // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushSharpturnRightMax;                           // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStopFwd;                                     // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushLoopAddPose;                                 // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  ASRushLoopAdditiveList;                            // 0x0328(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_AdvancedMonsterLocomotion) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_AdvancedMonsterLocomotion");
static_assert(sizeof(FAnimHumanoidSetting_AdvancedMonsterLocomotion) == 0x000338, "Wrong size on FAnimHumanoidSetting_AdvancedMonsterLocomotion");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, FreeMode) == 0x000000, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::FreeMode' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, LockMode) == 0x000001, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::LockMode' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, WalkMaxAcceleration) == 0x000004, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::WalkMaxAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, WalkBrakingFriction) == 0x000008, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::WalkBrakingFriction' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, WalkBrakingDecelerationWalking) == 0x00000C, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::WalkBrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, RunMaxAcceleration) == 0x000010, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::RunMaxAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, RunBrakingFriction) == 0x000014, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::RunBrakingFriction' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, RunBrakingDecelerationWalking) == 0x000018, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::RunBrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, RushMaxAcceleration) == 0x00001C, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::RushMaxAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, RushBrakingFriction) == 0x000020, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::RushBrakingFriction' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, RushBrakingDecelerationWalking) == 0x000024, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::RushBrakingDecelerationWalking' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, StartAndTurnAnimPlayRateClamped) == 0x000028, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::StartAndTurnAnimPlayRateClamped' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, LoopAnimPlayRateClamped) == 0x000038, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::LoopAnimPlayRateClamped' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASIdleList) == 0x000048, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASIdleList' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartFwd) == 0x000058, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartBwd) == 0x000060, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartLeftMin) == 0x000068, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartLeftMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartLeftMax) == 0x000070, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartLeftMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartRightMin) == 0x000078, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartRightMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartRightMax) == 0x000080, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartRightMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartLF) == 0x000088, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartLF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartLB) == 0x000090, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartLB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartRF) == 0x000098, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartRF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStartRB) == 0x0000A0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStartRB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkLoopFwd) == 0x0000A8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkLoopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkLoopBwd) == 0x0000B0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkLoopBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkLoopLF) == 0x0000B8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkLoopLF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkLoopLB) == 0x0000C0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkLoopLB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkLoopRF) == 0x0000C8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkLoopRF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkLoopRB) == 0x0000D0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkLoopRB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkSharpturnLeftMin) == 0x0000D8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkSharpturnLeftMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkSharpturnLeftMax) == 0x0000E0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkSharpturnLeftMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkSharpturnRightMin) == 0x0000E8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkSharpturnRightMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkSharpturnRightMax) == 0x0000F0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkSharpturnRightMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkPivotFwd) == 0x0000F8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkPivotFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkPivotBwd) == 0x000100, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkPivotBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkPivotLF) == 0x000108, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkPivotLF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkPivotLB) == 0x000110, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkPivotLB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkPivotRF) == 0x000118, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkPivotRF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkPivotRB) == 0x000120, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkPivotRB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkTransFRToBR) == 0x000128, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkTransFRToBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkTransBRToFR) == 0x000130, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkTransBRToFR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkTransFLToBL) == 0x000138, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkTransFLToBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkTransBLToFL) == 0x000140, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkTransBLToFL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStopFwd) == 0x000148, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStopBwd) == 0x000150, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStopBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStopLF) == 0x000158, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStopLF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStopLB) == 0x000160, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStopLB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStopRF) == 0x000168, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStopRF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkStopRB) == 0x000170, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkStopRB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkLoopAddPose) == 0x000178, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkLoopAddPose' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASWalkLoopAdditiveList) == 0x000180, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASWalkLoopAdditiveList' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartFwd) == 0x000190, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartBwd) == 0x000198, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartLeftMin) == 0x0001A0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartLeftMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartLeftMax) == 0x0001A8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartLeftMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartRightMin) == 0x0001B0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartRightMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartRightMax) == 0x0001B8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartRightMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartLF) == 0x0001C0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartLF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartLB) == 0x0001C8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartLB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartRF) == 0x0001D0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartRF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStartRB) == 0x0001D8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStartRB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunLoopFwd) == 0x0001E0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunLoopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunLoopBwd) == 0x0001E8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunLoopBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunLoopLF) == 0x0001F0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunLoopLF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunLoopLB) == 0x0001F8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunLoopLB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunLoopRF) == 0x000200, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunLoopRF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunLoopRB) == 0x000208, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunLoopRB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunSharpturnLeftMin) == 0x000210, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunSharpturnLeftMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunSharpturnLeftMax) == 0x000218, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunSharpturnLeftMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunSharpturnRightMin) == 0x000220, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunSharpturnRightMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunSharpturnRightMax) == 0x000228, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunSharpturnRightMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunPivotFwd) == 0x000230, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunPivotFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunPivotBwd) == 0x000238, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunPivotBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunPivotLF) == 0x000240, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunPivotLF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunPivotLB) == 0x000248, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunPivotLB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunPivotRF) == 0x000250, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunPivotRF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunPivotRB) == 0x000258, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunPivotRB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunTransFRToBR) == 0x000260, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunTransFRToBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunTransBRToFR) == 0x000268, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunTransBRToFR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunTransFLToBL) == 0x000270, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunTransFLToBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunTransBLToFL) == 0x000278, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunTransBLToFL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStopFwd) == 0x000280, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStopBwd) == 0x000288, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStopBwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStopLF) == 0x000290, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStopLF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStopLB) == 0x000298, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStopLB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStopRF) == 0x0002A0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStopRF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunStopRB) == 0x0002A8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunStopRB' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunLoopAddPose) == 0x0002B0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunLoopAddPose' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRunLoopAdditiveList) == 0x0002B8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRunLoopAdditiveList' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushStartFwd) == 0x0002C8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushStartLeftMin) == 0x0002D0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushStartLeftMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushStartLeftMax) == 0x0002D8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushStartLeftMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushStartRightMin) == 0x0002E0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushStartRightMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushStartRightMax) == 0x0002E8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushStartRightMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushLoopFwd) == 0x0002F0, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushLoopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushSharpturnLeftMin) == 0x0002F8, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushSharpturnLeftMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushSharpturnLeftMax) == 0x000300, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushSharpturnLeftMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushSharpturnRightMin) == 0x000308, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushSharpturnRightMin' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushSharpturnRightMax) == 0x000310, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushSharpturnRightMax' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushStopFwd) == 0x000318, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushStopFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushLoopAddPose) == 0x000320, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushLoopAddPose' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_AdvancedMonsterLocomotion, ASRushLoopAdditiveList) == 0x000328, "Member 'FAnimHumanoidSetting_AdvancedMonsterLocomotion::ASRushLoopAdditiveList' has a wrong offset!");

// SharpStruct b1-Managed.CompositeTransitionCondition_Guide
// 0x00B0 (0x00B0 - 0x0000)
struct FCompositeTransitionCondition_Guide final
{
public:
	struct FTransitionCondition_Guide             Single;                                            // 0x0000(0x0080)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCompositeCondition : 1;                        // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransitionCondition_Guide>     Conditions;                                        // 0x0088(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x0099(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompositeTransitionCondition_Guide) == 0x000008, "Wrong alignment on FCompositeTransitionCondition_Guide");
static_assert(sizeof(FCompositeTransitionCondition_Guide) == 0x0000B0, "Wrong size on FCompositeTransitionCondition_Guide");
static_assert(offsetof(FCompositeTransitionCondition_Guide, Single) == 0x000000, "Member 'FCompositeTransitionCondition_Guide::Single' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Guide, Conditions) == 0x000088, "Member 'FCompositeTransitionCondition_Guide::Conditions' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Guide, ConditionalRelation) == 0x000098, "Member 'FCompositeTransitionCondition_Guide::ConditionalRelation' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Guide, Comment) == 0x0000A0, "Member 'FCompositeTransitionCondition_Guide::Comment' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove
// 0x0098 (0x0098 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove final
{
public:
	uint8                                         bEnableParkourAnim : 1;                            // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ASStrideUpLeftFootLow;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpRightFootLow;                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpLeftFootHigh;                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpRightFootHigh;                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpLeftFootFall;                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpRightFootFall;                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpLeftFootEnd;                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpRightFootEnd;                            // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpLeftFootLandMove;                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideUpRightFootLandMove;                       // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideDownLeftFoot;                              // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideDownRightFoot;                             // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideDownLeftFootFall;                          // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideDownRightFootFall;                         // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideDownLeftFootEnd;                           // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideDownRightFootEnd;                          // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideDownLeftFootLandMove;                      // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASStrideDownRightFootLandMove;                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove) == 0x000098, "Wrong size on FAnimHumanoidSetting_ParkourMove");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpLeftFootLow) == 0x000008, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpLeftFootLow' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpRightFootLow) == 0x000010, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpRightFootLow' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpLeftFootHigh) == 0x000018, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpLeftFootHigh' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpRightFootHigh) == 0x000020, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpRightFootHigh' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpLeftFootFall) == 0x000028, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpLeftFootFall' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpRightFootFall) == 0x000030, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpRightFootFall' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpLeftFootEnd) == 0x000038, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpLeftFootEnd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpRightFootEnd) == 0x000040, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpRightFootEnd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpLeftFootLandMove) == 0x000048, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpLeftFootLandMove' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideUpRightFootLandMove) == 0x000050, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideUpRightFootLandMove' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideDownLeftFoot) == 0x000058, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideDownLeftFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideDownRightFoot) == 0x000060, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideDownRightFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideDownLeftFootFall) == 0x000068, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideDownLeftFootFall' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideDownRightFootFall) == 0x000070, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideDownRightFootFall' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideDownLeftFootEnd) == 0x000078, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideDownLeftFootEnd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideDownRightFootEnd) == 0x000080, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideDownRightFootEnd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideDownLeftFootLandMove) == 0x000088, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideDownLeftFootLandMove' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove, ASStrideDownRightFootLandMove) == 0x000090, "Member 'FAnimHumanoidSetting_ParkourMove::ASStrideDownRightFootLandMove' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove_Climb_Low
// 0x0028 (0x0028 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove_Climb_Low final
{
public:
	class UAnimSequence*                          ASParkourLowClimbStart;                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourLowClimbGetUp;                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourLowClimbFallLoop;                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourLowClimbLand;                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourLowClimbLandMove;                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove_Climb_Low) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove_Climb_Low");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove_Climb_Low) == 0x000028, "Wrong size on FAnimHumanoidSetting_ParkourMove_Climb_Low");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Low, ASParkourLowClimbStart) == 0x000000, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Low::ASParkourLowClimbStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Low, ASParkourLowClimbGetUp) == 0x000008, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Low::ASParkourLowClimbGetUp' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Low, ASParkourLowClimbFallLoop) == 0x000010, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Low::ASParkourLowClimbFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Low, ASParkourLowClimbLand) == 0x000018, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Low::ASParkourLowClimbLand' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Low, ASParkourLowClimbLandMove) == 0x000020, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Low::ASParkourLowClimbLandMove' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove_Climb_Normal
// 0x0028 (0x0028 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove_Climb_Normal final
{
public:
	class UAnimSequence*                          ASParkourNormalClimbStart;                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourNormalClimbGetUp;                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourNormalClimbFallLoop;                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourNormalClimbLand;                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourNormalClimbLandMove;                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove_Climb_Normal) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove_Climb_Normal");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove_Climb_Normal) == 0x000028, "Wrong size on FAnimHumanoidSetting_ParkourMove_Climb_Normal");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Normal, ASParkourNormalClimbStart) == 0x000000, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Normal::ASParkourNormalClimbStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Normal, ASParkourNormalClimbGetUp) == 0x000008, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Normal::ASParkourNormalClimbGetUp' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Normal, ASParkourNormalClimbFallLoop) == 0x000010, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Normal::ASParkourNormalClimbFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Normal, ASParkourNormalClimbLand) == 0x000018, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Normal::ASParkourNormalClimbLand' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb_Normal, ASParkourNormalClimbLandMove) == 0x000020, "Member 'FAnimHumanoidSetting_ParkourMove_Climb_Normal::ASParkourNormalClimbLandMove' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove_Climb
// 0x0078 (0x0078 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove_Climb final
{
public:
	struct FAnimHumanoidSetting_ParkourMove_Climb_Low Low;                                               // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_ParkourMove_Climb_Normal Normal;                                            // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_ParkourMove_Climb_High High;                                              // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove_Climb) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove_Climb");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove_Climb) == 0x000078, "Wrong size on FAnimHumanoidSetting_ParkourMove_Climb");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb, Low) == 0x000000, "Member 'FAnimHumanoidSetting_ParkourMove_Climb::Low' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb, Normal) == 0x000028, "Member 'FAnimHumanoidSetting_ParkourMove_Climb::Normal' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Climb, High) == 0x000050, "Member 'FAnimHumanoidSetting_ParkourMove_Climb::High' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove_Across_Low
// 0x0028 (0x0028 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove_Across_Low final
{
public:
	class UAnimSequence*                          ASParkourLowAcrossStart;                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourLowAcrossThrough;                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourLowAcrossFallLoop;                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourLowAcrossLand;                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourLowAcrossLandMove;                        // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove_Across_Low) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove_Across_Low");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove_Across_Low) == 0x000028, "Wrong size on FAnimHumanoidSetting_ParkourMove_Across_Low");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Low, ASParkourLowAcrossStart) == 0x000000, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Low::ASParkourLowAcrossStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Low, ASParkourLowAcrossThrough) == 0x000008, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Low::ASParkourLowAcrossThrough' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Low, ASParkourLowAcrossFallLoop) == 0x000010, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Low::ASParkourLowAcrossFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Low, ASParkourLowAcrossLand) == 0x000018, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Low::ASParkourLowAcrossLand' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Low, ASParkourLowAcrossLandMove) == 0x000020, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Low::ASParkourLowAcrossLandMove' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove_Across_Normal
// 0x0028 (0x0028 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove_Across_Normal final
{
public:
	class UAnimSequence*                          ASParkourNormalAcrossStart;                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourNormalAcrossThrough;                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourNormalAcrossFallLoop;                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourNormalAcrossLand;                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourNormalAcrossLandMove;                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove_Across_Normal) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove_Across_Normal");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove_Across_Normal) == 0x000028, "Wrong size on FAnimHumanoidSetting_ParkourMove_Across_Normal");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Normal, ASParkourNormalAcrossStart) == 0x000000, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Normal::ASParkourNormalAcrossStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Normal, ASParkourNormalAcrossThrough) == 0x000008, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Normal::ASParkourNormalAcrossThrough' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Normal, ASParkourNormalAcrossFallLoop) == 0x000010, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Normal::ASParkourNormalAcrossFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Normal, ASParkourNormalAcrossLand) == 0x000018, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Normal::ASParkourNormalAcrossLand' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_Normal, ASParkourNormalAcrossLandMove) == 0x000020, "Member 'FAnimHumanoidSetting_ParkourMove_Across_Normal::ASParkourNormalAcrossLandMove' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove_Across_High
// 0x0028 (0x0028 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove_Across_High final
{
public:
	class UAnimSequence*                          ASParkourHighAcrossStart;                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourHighAcrossThrough;                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourHighAcrossFallLoop;                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourHighAcrossLand;                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASParkourHighAcrossLandMove;                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove_Across_High) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove_Across_High");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove_Across_High) == 0x000028, "Wrong size on FAnimHumanoidSetting_ParkourMove_Across_High");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_High, ASParkourHighAcrossStart) == 0x000000, "Member 'FAnimHumanoidSetting_ParkourMove_Across_High::ASParkourHighAcrossStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_High, ASParkourHighAcrossThrough) == 0x000008, "Member 'FAnimHumanoidSetting_ParkourMove_Across_High::ASParkourHighAcrossThrough' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_High, ASParkourHighAcrossFallLoop) == 0x000010, "Member 'FAnimHumanoidSetting_ParkourMove_Across_High::ASParkourHighAcrossFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_High, ASParkourHighAcrossLand) == 0x000018, "Member 'FAnimHumanoidSetting_ParkourMove_Across_High::ASParkourHighAcrossLand' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across_High, ASParkourHighAcrossLandMove) == 0x000020, "Member 'FAnimHumanoidSetting_ParkourMove_Across_High::ASParkourHighAcrossLandMove' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_ParkourMove_Across
// 0x0078 (0x0078 - 0x0000)
struct FAnimHumanoidSetting_ParkourMove_Across final
{
public:
	struct FAnimHumanoidSetting_ParkourMove_Across_Low Low;                                               // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_ParkourMove_Across_Normal Normal;                                            // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_ParkourMove_Across_High High;                                              // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_ParkourMove_Across) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_ParkourMove_Across");
static_assert(sizeof(FAnimHumanoidSetting_ParkourMove_Across) == 0x000078, "Wrong size on FAnimHumanoidSetting_ParkourMove_Across");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across, Low) == 0x000000, "Member 'FAnimHumanoidSetting_ParkourMove_Across::Low' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across, Normal) == 0x000028, "Member 'FAnimHumanoidSetting_ParkourMove_Across::Normal' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_ParkourMove_Across, High) == 0x000050, "Member 'FAnimHumanoidSetting_ParkourMove_Across::High' has a wrong offset!");

// SharpStruct b1-Managed.StateNodeChildActorControl
// 0x0010 (0x0010 - 0x0000)
struct FStateNodeChildActorControl final
{
public:
	TArray<struct FStateNodeChildActorControlJJSObstacle> JJSObstacleCollection;                             // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateNodeChildActorControl) == 0x000008, "Wrong alignment on FStateNodeChildActorControl");
static_assert(sizeof(FStateNodeChildActorControl) == 0x000010, "Wrong size on FStateNodeChildActorControl");
static_assert(offsetof(FStateNodeChildActorControl, JJSObstacleCollection) == 0x000000, "Member 'FStateNodeChildActorControl::JJSObstacleCollection' has a wrong offset!");

// SharpStruct b1-Managed.CloudMoveGroundEffectConfig
// 0x0010 (0x0010 - 0x0000)
struct FCloudMoveGroundEffectConfig final
{
public:
	class UBGWDataAsset_B1DBC*                    RunEffectDBC;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWDataAsset_B1DBC*                    RushEffectDBC;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudMoveGroundEffectConfig) == 0x000008, "Wrong alignment on FCloudMoveGroundEffectConfig");
static_assert(sizeof(FCloudMoveGroundEffectConfig) == 0x000010, "Wrong size on FCloudMoveGroundEffectConfig");
static_assert(offsetof(FCloudMoveGroundEffectConfig, RunEffectDBC) == 0x000000, "Member 'FCloudMoveGroundEffectConfig::RunEffectDBC' has a wrong offset!");
static_assert(offsetof(FCloudMoveGroundEffectConfig, RushEffectDBC) == 0x000008, "Member 'FCloudMoveGroundEffectConfig::RushEffectDBC' has a wrong offset!");

// SharpStruct b1-Managed.MagicallyChangeConfig_TFXConfig
// 0x0030 (0x0030 - 0x0000)
struct FMagicallyChangeConfig_TFXConfig final
{
public:
	class UTressFXAsset*                          TFXAsset;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HairMaterial;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTressFXShadeSettings                  ShadeSettings;                                     // 0x0010(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LodScreenSize;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableSimulation : 1;                             // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FMagicallyChangeConfig_TFXConfig) == 0x000008, "Wrong alignment on FMagicallyChangeConfig_TFXConfig");
static_assert(sizeof(FMagicallyChangeConfig_TFXConfig) == 0x000030, "Wrong size on FMagicallyChangeConfig_TFXConfig");
static_assert(offsetof(FMagicallyChangeConfig_TFXConfig, TFXAsset) == 0x000000, "Member 'FMagicallyChangeConfig_TFXConfig::TFXAsset' has a wrong offset!");
static_assert(offsetof(FMagicallyChangeConfig_TFXConfig, HairMaterial) == 0x000008, "Member 'FMagicallyChangeConfig_TFXConfig::HairMaterial' has a wrong offset!");
static_assert(offsetof(FMagicallyChangeConfig_TFXConfig, ShadeSettings) == 0x000010, "Member 'FMagicallyChangeConfig_TFXConfig::ShadeSettings' has a wrong offset!");
static_assert(offsetof(FMagicallyChangeConfig_TFXConfig, LodScreenSize) == 0x000024, "Member 'FMagicallyChangeConfig_TFXConfig::LodScreenSize' has a wrong offset!");

// SharpStruct b1-Managed.AnimWheelSetting_WheelMove
// 0x0038 (0x0038 - 0x0000)
struct FAnimWheelSetting_WheelMove final
{
public:
	class UCurveVector*                           MoveNearParamCurve;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           MoveFarParamCurve;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASIdle;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSpeedUp;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSpeedDown;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASMoveLoop;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRotationAdditive;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimWheelSetting_WheelMove) == 0x000008, "Wrong alignment on FAnimWheelSetting_WheelMove");
static_assert(sizeof(FAnimWheelSetting_WheelMove) == 0x000038, "Wrong size on FAnimWheelSetting_WheelMove");
static_assert(offsetof(FAnimWheelSetting_WheelMove, MoveNearParamCurve) == 0x000000, "Member 'FAnimWheelSetting_WheelMove::MoveNearParamCurve' has a wrong offset!");
static_assert(offsetof(FAnimWheelSetting_WheelMove, MoveFarParamCurve) == 0x000008, "Member 'FAnimWheelSetting_WheelMove::MoveFarParamCurve' has a wrong offset!");
static_assert(offsetof(FAnimWheelSetting_WheelMove, ASIdle) == 0x000010, "Member 'FAnimWheelSetting_WheelMove::ASIdle' has a wrong offset!");
static_assert(offsetof(FAnimWheelSetting_WheelMove, ASSpeedUp) == 0x000018, "Member 'FAnimWheelSetting_WheelMove::ASSpeedUp' has a wrong offset!");
static_assert(offsetof(FAnimWheelSetting_WheelMove, ASSpeedDown) == 0x000020, "Member 'FAnimWheelSetting_WheelMove::ASSpeedDown' has a wrong offset!");
static_assert(offsetof(FAnimWheelSetting_WheelMove, ASMoveLoop) == 0x000028, "Member 'FAnimWheelSetting_WheelMove::ASMoveLoop' has a wrong offset!");
static_assert(offsetof(FAnimWheelSetting_WheelMove, BSRotationAdditive) == 0x000030, "Member 'FAnimWheelSetting_WheelMove::BSRotationAdditive' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_StriderMove
// 0x0014 (0x0014 - 0x0000)
struct FAnimHumanoidSetting_StriderMove final
{
public:
	float                                         StriderStopTime;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StriderStopDistance;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StriderLoopAnimTimeStart;                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StriderGuiChuTime;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StriderSingleStep;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_StriderMove) == 0x000004, "Wrong alignment on FAnimHumanoidSetting_StriderMove");
static_assert(sizeof(FAnimHumanoidSetting_StriderMove) == 0x000014, "Wrong size on FAnimHumanoidSetting_StriderMove");
static_assert(offsetof(FAnimHumanoidSetting_StriderMove, StriderStopTime) == 0x000000, "Member 'FAnimHumanoidSetting_StriderMove::StriderStopTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_StriderMove, StriderStopDistance) == 0x000004, "Member 'FAnimHumanoidSetting_StriderMove::StriderStopDistance' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_StriderMove, StriderLoopAnimTimeStart) == 0x000008, "Member 'FAnimHumanoidSetting_StriderMove::StriderLoopAnimTimeStart' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_StriderMove, StriderGuiChuTime) == 0x00000C, "Member 'FAnimHumanoidSetting_StriderMove::StriderGuiChuTime' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_StriderMove, StriderSingleStep) == 0x000010, "Member 'FAnimHumanoidSetting_StriderMove::StriderSingleStep' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_MonsterLocomotion_Free
// 0x0050 (0x0050 - 0x0000)
struct FAnimHumanoidSetting_MonsterLocomotion_Free final
{
public:
	class UAnimSequence*                          ASFreeRunFwd;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeRunStartFwd;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeRunStartFR;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeRunStartBR;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeRunStartFL;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeRunStartBL;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSFreeLeanAdditive;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSFreeRotAdditive;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeRunStopLeftFoot;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASFreeRunStopRightFoot;                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_MonsterLocomotion_Free) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_MonsterLocomotion_Free");
static_assert(sizeof(FAnimHumanoidSetting_MonsterLocomotion_Free) == 0x000050, "Wrong size on FAnimHumanoidSetting_MonsterLocomotion_Free");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, ASFreeRunFwd) == 0x000000, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::ASFreeRunFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, ASFreeRunStartFwd) == 0x000008, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::ASFreeRunStartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, ASFreeRunStartFR) == 0x000010, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::ASFreeRunStartFR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, ASFreeRunStartBR) == 0x000018, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::ASFreeRunStartBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, ASFreeRunStartFL) == 0x000020, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::ASFreeRunStartFL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, ASFreeRunStartBL) == 0x000028, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::ASFreeRunStartBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, BSFreeLeanAdditive) == 0x000030, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::BSFreeLeanAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, BSFreeRotAdditive) == 0x000038, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::BSFreeRotAdditive' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, ASFreeRunStopLeftFoot) == 0x000040, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::ASFreeRunStopLeftFoot' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion_Free, ASFreeRunStopRightFoot) == 0x000048, "Member 'FAnimHumanoidSetting_MonsterLocomotion_Free::ASFreeRunStopRightFoot' has a wrong offset!");

// SharpStruct b1-Managed.UnitsAndSpawners
// 0x0030 (0x0030 - 0x0000)
struct FUnitsAndSpawners final
{
public:
	struct FGsSmartParamArray                     UnitList;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGsSmartParamArray                     SpawnerList;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGsSmartParamArray                     GroupUnitList;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitsAndSpawners) == 0x000008, "Wrong alignment on FUnitsAndSpawners");
static_assert(sizeof(FUnitsAndSpawners) == 0x000030, "Wrong size on FUnitsAndSpawners");
static_assert(offsetof(FUnitsAndSpawners, UnitList) == 0x000000, "Member 'FUnitsAndSpawners::UnitList' has a wrong offset!");
static_assert(offsetof(FUnitsAndSpawners, SpawnerList) == 0x000010, "Member 'FUnitsAndSpawners::SpawnerList' has a wrong offset!");
static_assert(offsetof(FUnitsAndSpawners, GroupUnitList) == 0x000020, "Member 'FUnitsAndSpawners::GroupUnitList' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_MonsterLocomotion
// 0x00E0 (0x00E0 - 0x0000)
struct FAnimHumanoidSetting_MonsterLocomotion final
{
public:
	struct FAnimHumanoidSetting_MonsterLocomotion_Free Free;                                              // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_MonsterLocomotion_Lock Lock;                                              // 0x0050(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_MonsterLocomotion) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_MonsterLocomotion");
static_assert(sizeof(FAnimHumanoidSetting_MonsterLocomotion) == 0x0000E0, "Wrong size on FAnimHumanoidSetting_MonsterLocomotion");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion, Free) == 0x000000, "Member 'FAnimHumanoidSetting_MonsterLocomotion::Free' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_MonsterLocomotion, Lock) == 0x000050, "Member 'FAnimHumanoidSetting_MonsterLocomotion::Lock' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Spider_Speed
// 0x0030 (0x0030 - 0x0000)
struct FAnimHumanoidSetting_Spider_Speed final
{
public:
	float                                         ForwardSpeed;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideStepSpeed;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetForwardSpeed;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTurnSpeed;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSideStepSpeed;                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardSpeedScale;                                 // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeedScale;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideStepSpeedScale;                                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedLerpSpeed;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IKInterpSpeedFast;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IKInterpSpeedSlow;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Spider_Speed) == 0x000004, "Wrong alignment on FAnimHumanoidSetting_Spider_Speed");
static_assert(sizeof(FAnimHumanoidSetting_Spider_Speed) == 0x000030, "Wrong size on FAnimHumanoidSetting_Spider_Speed");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, ForwardSpeed) == 0x000000, "Member 'FAnimHumanoidSetting_Spider_Speed::ForwardSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, TurnSpeed) == 0x000004, "Member 'FAnimHumanoidSetting_Spider_Speed::TurnSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, SideStepSpeed) == 0x000008, "Member 'FAnimHumanoidSetting_Spider_Speed::SideStepSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, TargetForwardSpeed) == 0x00000C, "Member 'FAnimHumanoidSetting_Spider_Speed::TargetForwardSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, TargetTurnSpeed) == 0x000010, "Member 'FAnimHumanoidSetting_Spider_Speed::TargetTurnSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, TargetSideStepSpeed) == 0x000014, "Member 'FAnimHumanoidSetting_Spider_Speed::TargetSideStepSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, ForwardSpeedScale) == 0x000018, "Member 'FAnimHumanoidSetting_Spider_Speed::ForwardSpeedScale' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, TurnSpeedScale) == 0x00001C, "Member 'FAnimHumanoidSetting_Spider_Speed::TurnSpeedScale' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, SideStepSpeedScale) == 0x000020, "Member 'FAnimHumanoidSetting_Spider_Speed::SideStepSpeedScale' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, SpeedLerpSpeed) == 0x000024, "Member 'FAnimHumanoidSetting_Spider_Speed::SpeedLerpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, IKInterpSpeedFast) == 0x000028, "Member 'FAnimHumanoidSetting_Spider_Speed::IKInterpSpeedFast' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Speed, IKInterpSpeedSlow) == 0x00002C, "Member 'FAnimHumanoidSetting_Spider_Speed::IKInterpSpeedSlow' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Spider_Character
// 0x00F0 (0x00F0 - 0x0000)
struct FAnimHumanoidSetting_Spider_Character final
{
public:
	struct FTransform                             bodyTransOffset;                                   // 0x0000(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             TargetTransform;                                   // 0x0060(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         bodyTransLerpSpeed;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeanHeadHeight;                                    // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeanGroundNormal;                                  // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeadHeight;                                     // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundedFootNum;                                   // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandardHeadHeight;                                // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHeightOffset;                               // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Spider_Character) == 0x000010, "Wrong alignment on FAnimHumanoidSetting_Spider_Character");
static_assert(sizeof(FAnimHumanoidSetting_Spider_Character) == 0x0000F0, "Wrong size on FAnimHumanoidSetting_Spider_Character");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, bodyTransOffset) == 0x000000, "Member 'FAnimHumanoidSetting_Spider_Character::bodyTransOffset' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, TargetTransform) == 0x000060, "Member 'FAnimHumanoidSetting_Spider_Character::TargetTransform' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, bodyTransLerpSpeed) == 0x0000C0, "Member 'FAnimHumanoidSetting_Spider_Character::bodyTransLerpSpeed' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, MeanHeadHeight) == 0x0000C4, "Member 'FAnimHumanoidSetting_Spider_Character::MeanHeadHeight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, MeanGroundNormal) == 0x0000C8, "Member 'FAnimHumanoidSetting_Spider_Character::MeanGroundNormal' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, MaxHeadHeight) == 0x0000E0, "Member 'FAnimHumanoidSetting_Spider_Character::MaxHeadHeight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, GroundedFootNum) == 0x0000E4, "Member 'FAnimHumanoidSetting_Spider_Character::GroundedFootNum' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, StandardHeadHeight) == 0x0000E8, "Member 'FAnimHumanoidSetting_Spider_Character::StandardHeadHeight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Character, CapsuleHeightOffset) == 0x0000EC, "Member 'FAnimHumanoidSetting_Spider_Character::CapsuleHeightOffset' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_Spider_Trace
// 0x0028 (0x0028 - 0x0000)
struct FAnimHumanoidSetting_Spider_Trace final
{
public:
	float                                         TraceHeadDistance;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHalfHeight;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHalfWidth;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceGridHeight;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceGridWidth;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTraceNumber;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VerticalDivisionNumber;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HorizontalDivisionNumber;                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IKTraceDistance;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLegIkOffset;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_Spider_Trace) == 0x000004, "Wrong alignment on FAnimHumanoidSetting_Spider_Trace");
static_assert(sizeof(FAnimHumanoidSetting_Spider_Trace) == 0x000028, "Wrong size on FAnimHumanoidSetting_Spider_Trace");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, TraceHeadDistance) == 0x000000, "Member 'FAnimHumanoidSetting_Spider_Trace::TraceHeadDistance' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, TraceHalfHeight) == 0x000004, "Member 'FAnimHumanoidSetting_Spider_Trace::TraceHalfHeight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, TraceHalfWidth) == 0x000008, "Member 'FAnimHumanoidSetting_Spider_Trace::TraceHalfWidth' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, TraceGridHeight) == 0x00000C, "Member 'FAnimHumanoidSetting_Spider_Trace::TraceGridHeight' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, TraceGridWidth) == 0x000010, "Member 'FAnimHumanoidSetting_Spider_Trace::TraceGridWidth' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, MaxTraceNumber) == 0x000014, "Member 'FAnimHumanoidSetting_Spider_Trace::MaxTraceNumber' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, VerticalDivisionNumber) == 0x000018, "Member 'FAnimHumanoidSetting_Spider_Trace::VerticalDivisionNumber' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, HorizontalDivisionNumber) == 0x00001C, "Member 'FAnimHumanoidSetting_Spider_Trace::HorizontalDivisionNumber' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, IKTraceDistance) == 0x000020, "Member 'FAnimHumanoidSetting_Spider_Trace::IKTraceDistance' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_Spider_Trace, MaxLegIkOffset) == 0x000024, "Member 'FAnimHumanoidSetting_Spider_Trace::MaxLegIkOffset' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_QuadrupedLocomotion
// 0x0160 (0x0160 - 0x0000)
struct FAnimHumanoidSetting_QuadrupedLocomotion final
{
public:
	TArray<class UAnimSequence*>                  AnimIdleList;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSMove;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSMoveBack;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASWalkStop;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartF;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartL;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartR;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartBL;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStartBR;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnStop;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnL;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnR;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnBL;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunTurnBR;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunStop;                                         // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartF;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartL;                                      // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartR;                                      // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartBL;                                     // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStartBR;                                     // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushTurnStop;                                    // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushTurnL;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushTurnR;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushTurnBL;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushTurnBR;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushStop;                                        // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunJump;                                         // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushJump;                                        // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunJumpSlope;                                    // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushJumpSlope;                                   // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpSlopeAngleThreahold;                           // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          ASRunFall;                                         // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushFall;                                        // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunFallSlope;                                    // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushFallSlope;                                   // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLandMove;                                     // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushLandMove;                                    // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLandMoveSlope;                                // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushLandMoveSlope;                               // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLandStop;                                     // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushLandStop;                                    // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRunLandStopSlope;                                // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASRushLandStopSlope;                               // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_QuadrupedLocomotion) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_QuadrupedLocomotion");
static_assert(sizeof(FAnimHumanoidSetting_QuadrupedLocomotion) == 0x000160, "Wrong size on FAnimHumanoidSetting_QuadrupedLocomotion");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, AnimIdleList) == 0x000000, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::AnimIdleList' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, BSMove) == 0x000010, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::BSMove' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, BSMoveBack) == 0x000018, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::BSMoveBack' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASWalkStop) == 0x000020, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASWalkStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunStartF) == 0x000028, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunStartF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunStartL) == 0x000030, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunStartL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunStartR) == 0x000038, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunStartR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunStartBL) == 0x000040, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunStartBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunStartBR) == 0x000048, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunStartBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunTurnStop) == 0x000050, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunTurnStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunTurnL) == 0x000058, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunTurnL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunTurnR) == 0x000060, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunTurnR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunTurnBL) == 0x000068, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunTurnBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunTurnBR) == 0x000070, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunTurnBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunStop) == 0x000078, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushStartF) == 0x000080, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushStartF' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushStartL) == 0x000088, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushStartL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushStartR) == 0x000090, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushStartR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushStartBL) == 0x000098, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushStartBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushStartBR) == 0x0000A0, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushStartBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushTurnStop) == 0x0000A8, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushTurnStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushTurnL) == 0x0000B0, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushTurnL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushTurnR) == 0x0000B8, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushTurnR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushTurnBL) == 0x0000C0, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushTurnBL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushTurnBR) == 0x0000C8, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushTurnBR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushStop) == 0x0000D0, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunJump) == 0x0000D8, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunJump' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushJump) == 0x0000E0, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushJump' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunJumpSlope) == 0x0000E8, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunJumpSlope' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushJumpSlope) == 0x0000F0, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushJumpSlope' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, JumpSlopeAngleThreahold) == 0x0000F8, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::JumpSlopeAngleThreahold' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunFall) == 0x000100, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunFall' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushFall) == 0x000108, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushFall' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunFallSlope) == 0x000110, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunFallSlope' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushFallSlope) == 0x000118, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushFallSlope' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunLandMove) == 0x000120, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunLandMove' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushLandMove) == 0x000128, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushLandMove' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunLandMoveSlope) == 0x000130, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunLandMoveSlope' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushLandMoveSlope) == 0x000138, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushLandMoveSlope' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunLandStop) == 0x000140, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunLandStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushLandStop) == 0x000148, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushLandStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRunLandStopSlope) == 0x000150, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRunLandStopSlope' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_QuadrupedLocomotion, ASRushLandStopSlope) == 0x000158, "Member 'FAnimHumanoidSetting_QuadrupedLocomotion::ASRushLandStopSlope' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_CloudLocomotion
// 0x0128 (0x0128 - 0x0000)
struct FAnimHumanoidSetting_CloudLocomotion final
{
public:
	class UCurveFloat*                            RotationSpeedCurve;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AnimIdleList;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeanPitchAdditvie_Up;                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeanPitchAdditvie_Down;                            // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartFwd;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartFwdL;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartFwdR;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartBwdL;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StartBwdR;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunLoop;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RushLoop;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunLoopAdditvie_Left;                              // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunLoopAdditvie_Right;                             // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RushLoopAdditvie_Left;                             // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RushLoopAdditvie_Right;                            // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RunStop;                                           // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RushStop;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CloudFallLoop;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Jump_Land         CloudLand_High;                                    // 0x0098(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimHumanoidSetting_Jump_Land         CloudLand_Low;                                     // 0x00B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FCloudBreakAnimSetting>    CloudBreakAnimSettings;                            // 0x00D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_CloudLocomotion) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_CloudLocomotion");
static_assert(sizeof(FAnimHumanoidSetting_CloudLocomotion) == 0x000128, "Wrong size on FAnimHumanoidSetting_CloudLocomotion");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RotationSpeedCurve) == 0x000000, "Member 'FAnimHumanoidSetting_CloudLocomotion::RotationSpeedCurve' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, AnimIdleList) == 0x000008, "Member 'FAnimHumanoidSetting_CloudLocomotion::AnimIdleList' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, LeanPitchAdditvie_Up) == 0x000018, "Member 'FAnimHumanoidSetting_CloudLocomotion::LeanPitchAdditvie_Up' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, LeanPitchAdditvie_Down) == 0x000020, "Member 'FAnimHumanoidSetting_CloudLocomotion::LeanPitchAdditvie_Down' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, StartFwd) == 0x000028, "Member 'FAnimHumanoidSetting_CloudLocomotion::StartFwd' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, StartFwdL) == 0x000030, "Member 'FAnimHumanoidSetting_CloudLocomotion::StartFwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, StartFwdR) == 0x000038, "Member 'FAnimHumanoidSetting_CloudLocomotion::StartFwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, StartBwdL) == 0x000040, "Member 'FAnimHumanoidSetting_CloudLocomotion::StartBwdL' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, StartBwdR) == 0x000048, "Member 'FAnimHumanoidSetting_CloudLocomotion::StartBwdR' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RunLoop) == 0x000050, "Member 'FAnimHumanoidSetting_CloudLocomotion::RunLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RushLoop) == 0x000058, "Member 'FAnimHumanoidSetting_CloudLocomotion::RushLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RunLoopAdditvie_Left) == 0x000060, "Member 'FAnimHumanoidSetting_CloudLocomotion::RunLoopAdditvie_Left' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RunLoopAdditvie_Right) == 0x000068, "Member 'FAnimHumanoidSetting_CloudLocomotion::RunLoopAdditvie_Right' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RushLoopAdditvie_Left) == 0x000070, "Member 'FAnimHumanoidSetting_CloudLocomotion::RushLoopAdditvie_Left' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RushLoopAdditvie_Right) == 0x000078, "Member 'FAnimHumanoidSetting_CloudLocomotion::RushLoopAdditvie_Right' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RunStop) == 0x000080, "Member 'FAnimHumanoidSetting_CloudLocomotion::RunStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, RushStop) == 0x000088, "Member 'FAnimHumanoidSetting_CloudLocomotion::RushStop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, CloudFallLoop) == 0x000090, "Member 'FAnimHumanoidSetting_CloudLocomotion::CloudFallLoop' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, CloudLand_High) == 0x000098, "Member 'FAnimHumanoidSetting_CloudLocomotion::CloudLand_High' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, CloudLand_Low) == 0x0000B8, "Member 'FAnimHumanoidSetting_CloudLocomotion::CloudLand_Low' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_CloudLocomotion, CloudBreakAnimSettings) == 0x0000D8, "Member 'FAnimHumanoidSetting_CloudLocomotion::CloudBreakAnimSettings' has a wrong offset!");

// SharpStruct b1-Managed.AnimHumanoidSetting_SpecialAdditive
// 0x0020 (0x0020 - 0x0000)
struct FAnimHumanoidSetting_SpecialAdditive final
{
public:
	float                                         MinSlopeAngle;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlopeAngle;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSlopeAdditiveLocalSpace;                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ASSlopeAdditiveMeshSpace;                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSMoveSpeedAdditive;                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimHumanoidSetting_SpecialAdditive) == 0x000008, "Wrong alignment on FAnimHumanoidSetting_SpecialAdditive");
static_assert(sizeof(FAnimHumanoidSetting_SpecialAdditive) == 0x000020, "Wrong size on FAnimHumanoidSetting_SpecialAdditive");
static_assert(offsetof(FAnimHumanoidSetting_SpecialAdditive, MinSlopeAngle) == 0x000000, "Member 'FAnimHumanoidSetting_SpecialAdditive::MinSlopeAngle' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpecialAdditive, MaxSlopeAngle) == 0x000004, "Member 'FAnimHumanoidSetting_SpecialAdditive::MaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpecialAdditive, ASSlopeAdditiveLocalSpace) == 0x000008, "Member 'FAnimHumanoidSetting_SpecialAdditive::ASSlopeAdditiveLocalSpace' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpecialAdditive, ASSlopeAdditiveMeshSpace) == 0x000010, "Member 'FAnimHumanoidSetting_SpecialAdditive::ASSlopeAdditiveMeshSpace' has a wrong offset!");
static_assert(offsetof(FAnimHumanoidSetting_SpecialAdditive, BSMoveSpeedAdditive) == 0x000018, "Member 'FAnimHumanoidSetting_SpecialAdditive::BSMoveSpeedAdditive' has a wrong offset!");

// SharpStruct b1-Managed.AnimMotionMatchingConfig
// 0x0000 (0x0000 - 0x0000)
struct FAnimMotionMatchingConfig final
{
};
static_assert(alignof(FAnimMotionMatchingConfig) == 0x000001, "Wrong alignment on FAnimMotionMatchingConfig");
static_assert(sizeof(FAnimMotionMatchingConfig) == 0x000001, "Wrong size on FAnimMotionMatchingConfig");

// SharpStruct b1-Managed.UnitWeapon
// 0x0018 (0x0018 - 0x0000)
struct FUnitWeapon final
{
public:
	class UClass*                                 Weapon;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDefaultInactive : 1;                              // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FUnitWeapon) == 0x000008, "Wrong alignment on FUnitWeapon");
static_assert(sizeof(FUnitWeapon) == 0x000018, "Wrong size on FUnitWeapon");
static_assert(offsetof(FUnitWeapon, Weapon) == 0x000000, "Member 'FUnitWeapon::Weapon' has a wrong offset!");
static_assert(offsetof(FUnitWeapon, SocketName) == 0x000008, "Member 'FUnitWeapon::SocketName' has a wrong offset!");

// SharpStruct b1-Managed.UnitSealthSkillIDPair
// 0x0008 (0x0008 - 0x0000)
struct FUnitSealthSkillIDPair final
{
public:
	int32                                         BeginStealthSkillID;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndStealthSkillID;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitSealthSkillIDPair) == 0x000004, "Wrong alignment on FUnitSealthSkillIDPair");
static_assert(sizeof(FUnitSealthSkillIDPair) == 0x000008, "Wrong size on FUnitSealthSkillIDPair");
static_assert(offsetof(FUnitSealthSkillIDPair, BeginStealthSkillID) == 0x000000, "Member 'FUnitSealthSkillIDPair::BeginStealthSkillID' has a wrong offset!");
static_assert(offsetof(FUnitSealthSkillIDPair, EndStealthSkillID) == 0x000004, "Member 'FUnitSealthSkillIDPair::EndStealthSkillID' has a wrong offset!");

// SharpStruct b1-Managed.PhysicBlendInfo
// 0x0018 (0x0018 - 0x0000)
struct FPhysicBlendInfo final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicBlendInType                            PhysicBlendInType;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInTime;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicBlendOutType                           PhysicBlendOutType;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicBlendInfo) == 0x000004, "Wrong alignment on FPhysicBlendInfo");
static_assert(sizeof(FPhysicBlendInfo) == 0x000018, "Wrong size on FPhysicBlendInfo");
static_assert(offsetof(FPhysicBlendInfo, BoneName) == 0x000000, "Member 'FPhysicBlendInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FPhysicBlendInfo, PhysicBlendInType) == 0x000008, "Member 'FPhysicBlendInfo::PhysicBlendInType' has a wrong offset!");
static_assert(offsetof(FPhysicBlendInfo, BlendInTime) == 0x00000C, "Member 'FPhysicBlendInfo::BlendInTime' has a wrong offset!");
static_assert(offsetof(FPhysicBlendInfo, PhysicBlendOutType) == 0x000010, "Member 'FPhysicBlendInfo::PhysicBlendOutType' has a wrong offset!");
static_assert(offsetof(FPhysicBlendInfo, BlendOutTime) == 0x000014, "Member 'FPhysicBlendInfo::BlendOutTime' has a wrong offset!");

// SharpStruct b1-Managed.UnitCDesc
// 0x0058 (0x0058 - 0x0000)
struct FUnitCDesc final
{
public:
	TArray<struct FUnitWeapon>                    Weapons;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         ResID;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideID;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BirthBuffs;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUnitSealthSkillIDPair                 StealthSkillIDPair;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPhysicBlendInfo>               PhysicBlendInfos;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         PhysicBlendWeight;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeAttackedDirForwardRight;                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeAttackedDirForwardLeft;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeAttackedDirBackwardLeft;                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeAttackedDirBackwardRight;                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSurfaceTypeTraceFromPelvis : 1;                   // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FUnitCDesc) == 0x000008, "Wrong alignment on FUnitCDesc");
static_assert(sizeof(FUnitCDesc) == 0x000058, "Wrong size on FUnitCDesc");
static_assert(offsetof(FUnitCDesc, Weapons) == 0x000000, "Member 'FUnitCDesc::Weapons' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, ResID) == 0x000010, "Member 'FUnitCDesc::ResID' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, OverrideID) == 0x000014, "Member 'FUnitCDesc::OverrideID' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, BirthBuffs) == 0x000018, "Member 'FUnitCDesc::BirthBuffs' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, StealthSkillIDPair) == 0x000028, "Member 'FUnitCDesc::StealthSkillIDPair' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, PhysicBlendInfos) == 0x000030, "Member 'FUnitCDesc::PhysicBlendInfos' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, PhysicBlendWeight) == 0x000040, "Member 'FUnitCDesc::PhysicBlendWeight' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, BeAttackedDirForwardRight) == 0x000044, "Member 'FUnitCDesc::BeAttackedDirForwardRight' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, BeAttackedDirForwardLeft) == 0x000048, "Member 'FUnitCDesc::BeAttackedDirForwardLeft' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, BeAttackedDirBackwardLeft) == 0x00004C, "Member 'FUnitCDesc::BeAttackedDirBackwardLeft' has a wrong offset!");
static_assert(offsetof(FUnitCDesc, BeAttackedDirBackwardRight) == 0x000050, "Member 'FUnitCDesc::BeAttackedDirBackwardRight' has a wrong offset!");

// SharpStruct b1-Managed.ActorAttachConfig
// 0x0010 (0x0010 - 0x0000)
struct FActorAttachConfig final
{
public:
	class FString                                 AttachBone;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorAttachConfig) == 0x000008, "Wrong alignment on FActorAttachConfig");
static_assert(sizeof(FActorAttachConfig) == 0x000010, "Wrong size on FActorAttachConfig");
static_assert(offsetof(FActorAttachConfig, AttachBone) == 0x000000, "Member 'FActorAttachConfig::AttachBone' has a wrong offset!");

// SharpStruct b1-Managed.DispInteractSolverConfig
// 0x0008 (0x0008 - 0x0000)
struct FDispInteractSolverConfig final
{
public:
	uint8                                         SpawnDSDFSolver : 1;                               // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Pority;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDispInteractSolverConfig) == 0x000004, "Wrong alignment on FDispInteractSolverConfig");
static_assert(sizeof(FDispInteractSolverConfig) == 0x000008, "Wrong size on FDispInteractSolverConfig");
static_assert(offsetof(FDispInteractSolverConfig, Pority) == 0x000004, "Member 'FDispInteractSolverConfig::Pority' has a wrong offset!");

// SharpStruct b1-Managed.StalemateInfo
// 0x0018 (0x0018 - 0x0000)
struct FStalemateInfo final
{
public:
	TArray<int32>                                 StalemateSkillID;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ReturnHomeSkillID;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnHomeBuffID;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStalemateInfo) == 0x000008, "Wrong alignment on FStalemateInfo");
static_assert(sizeof(FStalemateInfo) == 0x000018, "Wrong size on FStalemateInfo");
static_assert(offsetof(FStalemateInfo, StalemateSkillID) == 0x000000, "Member 'FStalemateInfo::StalemateSkillID' has a wrong offset!");
static_assert(offsetof(FStalemateInfo, ReturnHomeSkillID) == 0x000010, "Member 'FStalemateInfo::ReturnHomeSkillID' has a wrong offset!");
static_assert(offsetof(FStalemateInfo, ReturnHomeBuffID) == 0x000014, "Member 'FStalemateInfo::ReturnHomeBuffID' has a wrong offset!");

// SharpStruct b1-Managed.UnitAIDesc
// 0x0070 (0x0070 - 0x0000)
struct FUnitAIDesc final
{
public:
	uint8                                         bOverrideEnableLoSVisualizationInTable : 1;        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_0_1 : 7;                                    // 0x0000(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bEnableLoSVisualization : 1;                       // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightRange;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionAngleDegrees;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearRange;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PursuitRange;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIWatchTimeMin;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIWatchTimeMax;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideUnitAIAttackType : 1;                     // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EUnitAIAttackType                             UnitAIAttackType;                                  // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FStalemateInfo>            StalemateInfoMap;                                  // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitAIDesc) == 0x000008, "Wrong alignment on FUnitAIDesc");
static_assert(sizeof(FUnitAIDesc) == 0x000070, "Wrong size on FUnitAIDesc");
static_assert(offsetof(FUnitAIDesc, SightRange) == 0x000004, "Member 'FUnitAIDesc::SightRange' has a wrong offset!");
static_assert(offsetof(FUnitAIDesc, VisionAngleDegrees) == 0x000008, "Member 'FUnitAIDesc::VisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(FUnitAIDesc, HearRange) == 0x00000C, "Member 'FUnitAIDesc::HearRange' has a wrong offset!");
static_assert(offsetof(FUnitAIDesc, PursuitRange) == 0x000010, "Member 'FUnitAIDesc::PursuitRange' has a wrong offset!");
static_assert(offsetof(FUnitAIDesc, AIWatchTimeMin) == 0x000014, "Member 'FUnitAIDesc::AIWatchTimeMin' has a wrong offset!");
static_assert(offsetof(FUnitAIDesc, AIWatchTimeMax) == 0x000018, "Member 'FUnitAIDesc::AIWatchTimeMax' has a wrong offset!");
static_assert(offsetof(FUnitAIDesc, UnitAIAttackType) == 0x00001D, "Member 'FUnitAIDesc::UnitAIAttackType' has a wrong offset!");
static_assert(offsetof(FUnitAIDesc, StalemateInfoMap) == 0x000020, "Member 'FUnitAIDesc::StalemateInfoMap' has a wrong offset!");

// SharpStruct b1-Managed.LimbIKEffectorsInfo
// 0x0000 (0x0000 - 0x0000)
struct FLimbIKEffectorsInfo final
{
};
static_assert(alignof(FLimbIKEffectorsInfo) == 0x000001, "Wrong alignment on FLimbIKEffectorsInfo");
static_assert(sizeof(FLimbIKEffectorsInfo) == 0x000001, "Wrong size on FLimbIKEffectorsInfo");

// SharpStruct b1-Managed.UnitPhysicsDesc
// 0x0008 (0x0008 - 0x0000)
struct FUnitPhysicsDesc final
{
public:
	class UBGWDataAsset_TigerWoodsConfig*         DefaultTigerWoodsConfig;                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitPhysicsDesc) == 0x000008, "Wrong alignment on FUnitPhysicsDesc");
static_assert(sizeof(FUnitPhysicsDesc) == 0x000008, "Wrong size on FUnitPhysicsDesc");
static_assert(offsetof(FUnitPhysicsDesc, DefaultTigerWoodsConfig) == 0x000000, "Member 'FUnitPhysicsDesc::DefaultTigerWoodsConfig' has a wrong offset!");

// SharpStruct b1-Managed.CircusConfig
// 0x0018 (0x0018 - 0x0000)
struct FCircusConfig final
{
public:
	uint8                                         SpawnByDefault : 1;                                // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   NickName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCircusConfig) == 0x000008, "Wrong alignment on FCircusConfig");
static_assert(sizeof(FCircusConfig) == 0x000018, "Wrong size on FCircusConfig");
static_assert(offsetof(FCircusConfig, NickName) == 0x000008, "Member 'FCircusConfig::NickName' has a wrong offset!");

// SharpStruct b1-Managed.CircusConfigNonCharacter
// 0x0010 (0x0010 - 0x0000)
struct FCircusConfigNonCharacter final
{
public:
	TArray<struct FGameplayTag>                   NickName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCircusConfigNonCharacter) == 0x000008, "Wrong alignment on FCircusConfigNonCharacter");
static_assert(sizeof(FCircusConfigNonCharacter) == 0x000010, "Wrong size on FCircusConfigNonCharacter");
static_assert(offsetof(FCircusConfigNonCharacter, NickName) == 0x000000, "Member 'FCircusConfigNonCharacter::NickName' has a wrong offset!");

// SharpStruct b1-Managed.TireMarkUnit
// 0x0038 (0x0038 - 0x0000)
struct FTireMarkUnit final
{
public:
	class UDecalComponent*                        DecalComp;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnPos;                                          // 0x0010(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriDecalLength;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayFadeTimer;                                    // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTireMarkUnit) == 0x000008, "Wrong alignment on FTireMarkUnit");
static_assert(sizeof(FTireMarkUnit) == 0x000038, "Wrong size on FTireMarkUnit");
static_assert(offsetof(FTireMarkUnit, DecalComp) == 0x000000, "Member 'FTireMarkUnit::DecalComp' has a wrong offset!");
static_assert(offsetof(FTireMarkUnit, SocketName) == 0x000008, "Member 'FTireMarkUnit::SocketName' has a wrong offset!");
static_assert(offsetof(FTireMarkUnit, SpawnPos) == 0x000010, "Member 'FTireMarkUnit::SpawnPos' has a wrong offset!");
static_assert(offsetof(FTireMarkUnit, OriDecalLength) == 0x000028, "Member 'FTireMarkUnit::OriDecalLength' has a wrong offset!");
static_assert(offsetof(FTireMarkUnit, DelayFadeTimer) == 0x00002C, "Member 'FTireMarkUnit::DelayFadeTimer' has a wrong offset!");
static_assert(offsetof(FTireMarkUnit, FadeTime) == 0x000030, "Member 'FTireMarkUnit::FadeTime' has a wrong offset!");

// SharpStruct b1-Managed.ExponentialHeightFogConfig
// 0x0000 (0x0000 - 0x0000)
struct FExponentialHeightFogConfig final
{
};
static_assert(alignof(FExponentialHeightFogConfig) == 0x000001, "Wrong alignment on FExponentialHeightFogConfig");
static_assert(sizeof(FExponentialHeightFogConfig) == 0x000001, "Wrong size on FExponentialHeightFogConfig");

// SharpStruct b1-Managed.MaterialLayerMappingInfo
// 0x000C (0x000C - 0x0000)
struct FMaterialLayerMappingInfo final
{
public:
	int32                                         LayerMappingIdx;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LayerMappingName;                                  // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialLayerMappingInfo) == 0x000004, "Wrong alignment on FMaterialLayerMappingInfo");
static_assert(sizeof(FMaterialLayerMappingInfo) == 0x00000C, "Wrong size on FMaterialLayerMappingInfo");
static_assert(offsetof(FMaterialLayerMappingInfo, LayerMappingIdx) == 0x000000, "Member 'FMaterialLayerMappingInfo::LayerMappingIdx' has a wrong offset!");
static_assert(offsetof(FMaterialLayerMappingInfo, LayerMappingName) == 0x000004, "Member 'FMaterialLayerMappingInfo::LayerMappingName' has a wrong offset!");

// SharpStruct b1-Managed.FTWForceData
// 0x0048 (0x0048 - 0x0000)
struct FFTWForceData final
{
public:
	ETWVectorUseType                              VectorUseType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseRandomVector : 1;                              // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VectorBaseLow;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                VectorBaseHigh;                                    // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            BlendCurve;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScalarMultiplier;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFTWForceData) == 0x000008, "Wrong alignment on FFTWForceData");
static_assert(sizeof(FFTWForceData) == 0x000048, "Wrong size on FFTWForceData");
static_assert(offsetof(FFTWForceData, VectorUseType) == 0x000000, "Member 'FFTWForceData::VectorUseType' has a wrong offset!");
static_assert(offsetof(FFTWForceData, VectorBaseLow) == 0x000008, "Member 'FFTWForceData::VectorBaseLow' has a wrong offset!");
static_assert(offsetof(FFTWForceData, VectorBaseHigh) == 0x000020, "Member 'FFTWForceData::VectorBaseHigh' has a wrong offset!");
static_assert(offsetof(FFTWForceData, BlendCurve) == 0x000038, "Member 'FFTWForceData::BlendCurve' has a wrong offset!");
static_assert(offsetof(FFTWForceData, ScalarMultiplier) == 0x000040, "Member 'FFTWForceData::ScalarMultiplier' has a wrong offset!");

// SharpStruct b1-Managed.FTWImpulseData
// 0x0050 (0x0050 - 0x0000)
struct FFTWImpulseData final
{
public:
	ETWVectorUseType                              VectorUseType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseRandomVector : 1;                              // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VectorBaseLow;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                VectorBaseHigh;                                    // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZAmplitudeRatio;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendCurve;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScalarMultiplier;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFTWImpulseData) == 0x000008, "Wrong alignment on FFTWImpulseData");
static_assert(sizeof(FFTWImpulseData) == 0x000050, "Wrong size on FFTWImpulseData");
static_assert(offsetof(FFTWImpulseData, VectorUseType) == 0x000000, "Member 'FFTWImpulseData::VectorUseType' has a wrong offset!");
static_assert(offsetof(FFTWImpulseData, VectorBaseLow) == 0x000008, "Member 'FFTWImpulseData::VectorBaseLow' has a wrong offset!");
static_assert(offsetof(FFTWImpulseData, VectorBaseHigh) == 0x000020, "Member 'FFTWImpulseData::VectorBaseHigh' has a wrong offset!");
static_assert(offsetof(FFTWImpulseData, ZAmplitudeRatio) == 0x000038, "Member 'FFTWImpulseData::ZAmplitudeRatio' has a wrong offset!");
static_assert(offsetof(FFTWImpulseData, BlendCurve) == 0x000040, "Member 'FFTWImpulseData::BlendCurve' has a wrong offset!");
static_assert(offsetof(FFTWImpulseData, ScalarMultiplier) == 0x000048, "Member 'FFTWImpulseData::ScalarMultiplier' has a wrong offset!");

// SharpStruct b1-Managed.SpawnBulletMinMaxValue
// 0x000C (0x000C - 0x0000)
struct FSpawnBulletMinMaxValue final
{
public:
	float                                         LeftValue;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightValue;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsEquidistance : 1;                                // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FSpawnBulletMinMaxValue) == 0x000004, "Wrong alignment on FSpawnBulletMinMaxValue");
static_assert(sizeof(FSpawnBulletMinMaxValue) == 0x00000C, "Wrong size on FSpawnBulletMinMaxValue");
static_assert(offsetof(FSpawnBulletMinMaxValue, LeftValue) == 0x000000, "Member 'FSpawnBulletMinMaxValue::LeftValue' has a wrong offset!");
static_assert(offsetof(FSpawnBulletMinMaxValue, RightValue) == 0x000004, "Member 'FSpawnBulletMinMaxValue::RightValue' has a wrong offset!");

// SharpStruct b1-Managed.ProjectileBornDirOffsetStruct
// 0x0050 (0x0050 - 0x0000)
struct FProjectileBornDirOffsetStruct final
{
public:
	uint8                                         UseExtraAimPoint : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_0_1 : 7;                                    // 0x0000(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         ExtraAimPointUseSocket : 1;                        // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExtraAimPointName;                                 // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDiffAngle;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimConstraintAxis;                                 // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpawnBulletMinMaxValue                BornDirOffsetX;                                    // 0x0028(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpawnBulletMinMaxValue                BornDirOffsetY;                                    // 0x0034(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpawnBulletMinMaxValue                BornDirOffsetZ;                                    // 0x0040(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileBornDirOffsetStruct) == 0x000008, "Wrong alignment on FProjectileBornDirOffsetStruct");
static_assert(sizeof(FProjectileBornDirOffsetStruct) == 0x000050, "Wrong size on FProjectileBornDirOffsetStruct");
static_assert(offsetof(FProjectileBornDirOffsetStruct, ExtraAimPointName) == 0x000004, "Member 'FProjectileBornDirOffsetStruct::ExtraAimPointName' has a wrong offset!");
static_assert(offsetof(FProjectileBornDirOffsetStruct, MaxDiffAngle) == 0x00000C, "Member 'FProjectileBornDirOffsetStruct::MaxDiffAngle' has a wrong offset!");
static_assert(offsetof(FProjectileBornDirOffsetStruct, AimConstraintAxis) == 0x000010, "Member 'FProjectileBornDirOffsetStruct::AimConstraintAxis' has a wrong offset!");
static_assert(offsetof(FProjectileBornDirOffsetStruct, BornDirOffsetX) == 0x000028, "Member 'FProjectileBornDirOffsetStruct::BornDirOffsetX' has a wrong offset!");
static_assert(offsetof(FProjectileBornDirOffsetStruct, BornDirOffsetY) == 0x000034, "Member 'FProjectileBornDirOffsetStruct::BornDirOffsetY' has a wrong offset!");
static_assert(offsetof(FProjectileBornDirOffsetStruct, BornDirOffsetZ) == 0x000040, "Member 'FProjectileBornDirOffsetStruct::BornDirOffsetZ' has a wrong offset!");

// SharpStruct b1-Managed.ProjectileBornDirStruct
// 0x0008 (0x0008 - 0x0000)
struct FProjectileBornDirStruct final
{
public:
	EProjectileBornDirType                        BornDirType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         JustUseYawInfo : 1;                                // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PointSetCachedReqID;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileBornDirStruct) == 0x000004, "Wrong alignment on FProjectileBornDirStruct");
static_assert(sizeof(FProjectileBornDirStruct) == 0x000008, "Wrong size on FProjectileBornDirStruct");
static_assert(offsetof(FProjectileBornDirStruct, BornDirType) == 0x000000, "Member 'FProjectileBornDirStruct::BornDirType' has a wrong offset!");
static_assert(offsetof(FProjectileBornDirStruct, PointSetCachedReqID) == 0x000004, "Member 'FProjectileBornDirStruct::PointSetCachedReqID' has a wrong offset!");

// SharpStruct b1-Managed.ProjectileBaseStruct
// 0x0020 (0x0020 - 0x0000)
struct FProjectileBaseStruct final
{
public:
	EProjectileBaseType                           BaseType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseSocket : 1;                                     // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointSetCachedReqID;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              EQSTemplate;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DontUpdatePosPerWave : 1;                          // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_18_1 : 7;                                   // 0x0018(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         DontUpdateBornIndexPerWave : 1;                    // 0x0019(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FProjectileBaseStruct) == 0x000008, "Wrong alignment on FProjectileBaseStruct");
static_assert(sizeof(FProjectileBaseStruct) == 0x000020, "Wrong size on FProjectileBaseStruct");
static_assert(offsetof(FProjectileBaseStruct, BaseType) == 0x000000, "Member 'FProjectileBaseStruct::BaseType' has a wrong offset!");
static_assert(offsetof(FProjectileBaseStruct, SocketName) == 0x000004, "Member 'FProjectileBaseStruct::SocketName' has a wrong offset!");
static_assert(offsetof(FProjectileBaseStruct, PointSetCachedReqID) == 0x00000C, "Member 'FProjectileBaseStruct::PointSetCachedReqID' has a wrong offset!");
static_assert(offsetof(FProjectileBaseStruct, EQSTemplate) == 0x000010, "Member 'FProjectileBaseStruct::EQSTemplate' has a wrong offset!");

// SharpStruct b1-Managed.UnitZBBInfo
// 0x0000 (0x0000 - 0x0000)
struct FUnitZBBInfo final
{
};
static_assert(alignof(FUnitZBBInfo) == 0x000001, "Wrong alignment on FUnitZBBInfo");
static_assert(sizeof(FUnitZBBInfo) == 0x000001, "Wrong size on FUnitZBBInfo");

// SharpStruct b1-Managed.FSCDCollisionInfo
// 0x000C (0x000C - 0x0000)
struct FFSCDCollisionInfo final
{
public:
	float                                         ScaleRate;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepTime;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 CollisionColor;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFSCDCollisionInfo) == 0x000004, "Wrong alignment on FFSCDCollisionInfo");
static_assert(sizeof(FFSCDCollisionInfo) == 0x00000C, "Wrong size on FFSCDCollisionInfo");
static_assert(offsetof(FFSCDCollisionInfo, ScaleRate) == 0x000000, "Member 'FFSCDCollisionInfo::ScaleRate' has a wrong offset!");
static_assert(offsetof(FFSCDCollisionInfo, KeepTime) == 0x000004, "Member 'FFSCDCollisionInfo::KeepTime' has a wrong offset!");
static_assert(offsetof(FFSCDCollisionInfo, CollisionColor) == 0x000008, "Member 'FFSCDCollisionInfo::CollisionColor' has a wrong offset!");

// SharpStruct b1-Managed.BoneUseForDispMap
// 0x001C (0x001C - 0x0000)
struct FBoneUseForDispMap final
{
public:
	int32                                         WeaponIndex;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstBoneName;                                     // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstRadius;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextBoneName;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextRadius;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneUseForDispMap) == 0x000004, "Wrong alignment on FBoneUseForDispMap");
static_assert(sizeof(FBoneUseForDispMap) == 0x00001C, "Wrong size on FBoneUseForDispMap");
static_assert(offsetof(FBoneUseForDispMap, WeaponIndex) == 0x000000, "Member 'FBoneUseForDispMap::WeaponIndex' has a wrong offset!");
static_assert(offsetof(FBoneUseForDispMap, FirstBoneName) == 0x000004, "Member 'FBoneUseForDispMap::FirstBoneName' has a wrong offset!");
static_assert(offsetof(FBoneUseForDispMap, FirstRadius) == 0x00000C, "Member 'FBoneUseForDispMap::FirstRadius' has a wrong offset!");
static_assert(offsetof(FBoneUseForDispMap, NextBoneName) == 0x000010, "Member 'FBoneUseForDispMap::NextBoneName' has a wrong offset!");
static_assert(offsetof(FBoneUseForDispMap, NextRadius) == 0x000018, "Member 'FBoneUseForDispMap::NextRadius' has a wrong offset!");

// SharpStruct b1-Managed.BoneUseForDispList
// 0x0010 (0x0010 - 0x0000)
struct FBoneUseForDispList final
{
public:
	TArray<struct FBoneUseForDispMap>             InfoList;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneUseForDispList) == 0x000008, "Wrong alignment on FBoneUseForDispList");
static_assert(sizeof(FBoneUseForDispList) == 0x000010, "Wrong size on FBoneUseForDispList");
static_assert(offsetof(FBoneUseForDispList, InfoList) == 0x000000, "Member 'FBoneUseForDispList::InfoList' has a wrong offset!");

// SharpStruct b1-Managed.UnitCompFlagConfig
// 0x00F8 (0x00F8 - 0x0000)
struct FUnitCompFlagConfig final
{
public:
	EUnitTagType                                  UnitTemplateType;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, uint8>                    PlayerAlterTags;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, uint8>                    MonsterAlterTags;                                  // 0x0058(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, uint8>                    MonsterRejectTags;                                 // 0x00A8(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitCompFlagConfig) == 0x000008, "Wrong alignment on FUnitCompFlagConfig");
static_assert(sizeof(FUnitCompFlagConfig) == 0x0000F8, "Wrong size on FUnitCompFlagConfig");
static_assert(offsetof(FUnitCompFlagConfig, UnitTemplateType) == 0x000000, "Member 'FUnitCompFlagConfig::UnitTemplateType' has a wrong offset!");
static_assert(offsetof(FUnitCompFlagConfig, PlayerAlterTags) == 0x000008, "Member 'FUnitCompFlagConfig::PlayerAlterTags' has a wrong offset!");
static_assert(offsetof(FUnitCompFlagConfig, MonsterAlterTags) == 0x000058, "Member 'FUnitCompFlagConfig::MonsterAlterTags' has a wrong offset!");
static_assert(offsetof(FUnitCompFlagConfig, MonsterRejectTags) == 0x0000A8, "Member 'FUnitCompFlagConfig::MonsterRejectTags' has a wrong offset!");

// SharpStruct b1-Managed.EnvChangeConfig
// 0x0000 (0x0000 - 0x0000)
struct FEnvChangeConfig final
{
};
static_assert(alignof(FEnvChangeConfig) == 0x000001, "Wrong alignment on FEnvChangeConfig");
static_assert(sizeof(FEnvChangeConfig) == 0x000001, "Wrong size on FEnvChangeConfig");

// SharpStruct b1-Managed.PointsGenExtParam
// 0x0080 (0x0080 - 0x0000)
struct FPointsGenExtParam final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SocketNameList;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 EQSPath;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              EQSTemplate;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SceneItemTag;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Explode_DesiredNum;                                // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Explode_LineTraceMaxLength;                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               Explode_TraceTypeQuery;                            // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Explode_PointMinBetween;                           // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            Explode_RangeDir_X;                                // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            Explode_RangeDir_Y;                                // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            Explode_RangeDir_Z;                                // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPointsGenExtParam) == 0x000008, "Wrong alignment on FPointsGenExtParam");
static_assert(sizeof(FPointsGenExtParam) == 0x000080, "Wrong size on FPointsGenExtParam");
static_assert(offsetof(FPointsGenExtParam, SocketName) == 0x000000, "Member 'FPointsGenExtParam::SocketName' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, SocketNameList) == 0x000008, "Member 'FPointsGenExtParam::SocketNameList' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, EQSPath) == 0x000018, "Member 'FPointsGenExtParam::EQSPath' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, EQSTemplate) == 0x000028, "Member 'FPointsGenExtParam::EQSTemplate' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, SceneItemTag) == 0x000030, "Member 'FPointsGenExtParam::SceneItemTag' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, Explode_DesiredNum) == 0x000040, "Member 'FPointsGenExtParam::Explode_DesiredNum' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, Explode_LineTraceMaxLength) == 0x000044, "Member 'FPointsGenExtParam::Explode_LineTraceMaxLength' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, Explode_TraceTypeQuery) == 0x000048, "Member 'FPointsGenExtParam::Explode_TraceTypeQuery' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, Explode_PointMinBetween) == 0x00004C, "Member 'FPointsGenExtParam::Explode_PointMinBetween' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, Explode_RangeDir_X) == 0x000050, "Member 'FPointsGenExtParam::Explode_RangeDir_X' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, Explode_RangeDir_Y) == 0x000060, "Member 'FPointsGenExtParam::Explode_RangeDir_Y' has a wrong offset!");
static_assert(offsetof(FPointsGenExtParam, Explode_RangeDir_Z) == 0x000070, "Member 'FPointsGenExtParam::Explode_RangeDir_Z' has a wrong offset!");

// SharpStruct b1-Managed.ProjectileSpawnEventInfo
// 0x0008 (0x0008 - 0x0000)
struct FProjectileSpawnEventInfo final
{
public:
	int32                                         TotalNumInAWave;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelfIndexInAWave;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileSpawnEventInfo) == 0x000004, "Wrong alignment on FProjectileSpawnEventInfo");
static_assert(sizeof(FProjectileSpawnEventInfo) == 0x000008, "Wrong size on FProjectileSpawnEventInfo");
static_assert(offsetof(FProjectileSpawnEventInfo, TotalNumInAWave) == 0x000000, "Member 'FProjectileSpawnEventInfo::TotalNumInAWave' has a wrong offset!");
static_assert(offsetof(FProjectileSpawnEventInfo, SelfIndexInAWave) == 0x000004, "Member 'FProjectileSpawnEventInfo::SelfIndexInAWave' has a wrong offset!");

// SharpStruct b1-Managed.ProjectileMulTargetRule
// 0x000C (0x000C - 0x0000)
struct FProjectileMulTargetRule final
{
public:
	float                                         HalfAngle;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTargetNum;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileMulTargetRule) == 0x000004, "Wrong alignment on FProjectileMulTargetRule");
static_assert(sizeof(FProjectileMulTargetRule) == 0x00000C, "Wrong size on FProjectileMulTargetRule");
static_assert(offsetof(FProjectileMulTargetRule, HalfAngle) == 0x000000, "Member 'FProjectileMulTargetRule::HalfAngle' has a wrong offset!");
static_assert(offsetof(FProjectileMulTargetRule, MaxDistance) == 0x000004, "Member 'FProjectileMulTargetRule::MaxDistance' has a wrong offset!");
static_assert(offsetof(FProjectileMulTargetRule, MaxTargetNum) == 0x000008, "Member 'FProjectileMulTargetRule::MaxTargetNum' has a wrong offset!");

// SharpStruct b1-Managed.SeqSimpleStatePair
// 0x0002 (0x0002 - 0x0000)
struct FSeqSimpleStatePair final
{
public:
	EBGUSimpleState                               SimpleState;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsRemoving : 1;                                    // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FSeqSimpleStatePair) == 0x000001, "Wrong alignment on FSeqSimpleStatePair");
static_assert(sizeof(FSeqSimpleStatePair) == 0x000002, "Wrong size on FSeqSimpleStatePair");
static_assert(offsetof(FSeqSimpleStatePair, SimpleState) == 0x000000, "Member 'FSeqSimpleStatePair::SimpleState' has a wrong offset!");

// SharpStruct b1-Managed.EnvironmentMaskMappingData
// 0x0030 (0x0030 - 0x0000)
struct FEnvironmentMaskMappingData final
{
public:
	class FString                                 ParamName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LayerMappingName_Layer;                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulateSpeed;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulateMaxValue;                                // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeSpeed;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentMaskMappingData) == 0x000008, "Wrong alignment on FEnvironmentMaskMappingData");
static_assert(sizeof(FEnvironmentMaskMappingData) == 0x000030, "Wrong size on FEnvironmentMaskMappingData");
static_assert(offsetof(FEnvironmentMaskMappingData, ParamName) == 0x000000, "Member 'FEnvironmentMaskMappingData::ParamName' has a wrong offset!");
static_assert(offsetof(FEnvironmentMaskMappingData, LayerMappingName_Layer) == 0x000010, "Member 'FEnvironmentMaskMappingData::LayerMappingName_Layer' has a wrong offset!");
static_assert(offsetof(FEnvironmentMaskMappingData, AccumulateSpeed) == 0x000020, "Member 'FEnvironmentMaskMappingData::AccumulateSpeed' has a wrong offset!");
static_assert(offsetof(FEnvironmentMaskMappingData, AccumulateMaxValue) == 0x000024, "Member 'FEnvironmentMaskMappingData::AccumulateMaxValue' has a wrong offset!");
static_assert(offsetof(FEnvironmentMaskMappingData, FadeSpeed) == 0x000028, "Member 'FEnvironmentMaskMappingData::FadeSpeed' has a wrong offset!");

// SharpStruct b1-Managed.CastSkillInfo
// 0x0018 (0x0018 - 0x0000)
struct FCastSkillInfo final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NeedCheckSkillCanCast : 1;                         // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MontageStartSectionName;                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillMontageBeginPos;                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillDirection                               SkillDirection;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HasSetSkillBaseTarget : 1;                         // 0x0015(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EMontageBindReason                            Reason;                                            // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECastSkillSourceType                          SourceType;                                        // 0x0017(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCastSkillInfo) == 0x000004, "Wrong alignment on FCastSkillInfo");
static_assert(sizeof(FCastSkillInfo) == 0x000018, "Wrong size on FCastSkillInfo");
static_assert(offsetof(FCastSkillInfo, SkillID) == 0x000000, "Member 'FCastSkillInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FCastSkillInfo, MontageStartSectionName) == 0x000008, "Member 'FCastSkillInfo::MontageStartSectionName' has a wrong offset!");
static_assert(offsetof(FCastSkillInfo, SkillMontageBeginPos) == 0x000010, "Member 'FCastSkillInfo::SkillMontageBeginPos' has a wrong offset!");
static_assert(offsetof(FCastSkillInfo, SkillDirection) == 0x000014, "Member 'FCastSkillInfo::SkillDirection' has a wrong offset!");
static_assert(offsetof(FCastSkillInfo, Reason) == 0x000016, "Member 'FCastSkillInfo::Reason' has a wrong offset!");
static_assert(offsetof(FCastSkillInfo, SourceType) == 0x000017, "Member 'FCastSkillInfo::SourceType' has a wrong offset!");

// SharpStruct b1-Managed.SkillPreviewConfig
// 0x0000 (0x0000 - 0x0000)
struct FSkillPreviewConfig final
{
};
static_assert(alignof(FSkillPreviewConfig) == 0x000001, "Wrong alignment on FSkillPreviewConfig");
static_assert(sizeof(FSkillPreviewConfig) == 0x000001, "Wrong size on FSkillPreviewConfig");

// SharpStruct b1-Managed.MapProceduralInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FMapProceduralInfo final
{
public:
	TArray<struct FMapAttrNode>                   MapInfoMatrix;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EMapCatFlag, struct FSoftObjectPath>     MapBlockMapping;                                   // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                MapCustomLightConfigs;                             // 0x0060(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         EntranceX;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntranceY;                                         // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExitX;                                             // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExitY;                                             // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpectedPointNumber;                               // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapWidth;                                          // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapHeight;                                         // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockWidth;                                        // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockHeight;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPointWidth;                                     // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPointHeight;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPointWidth;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPointHeight;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsUsingRanEE : 1;                                  // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EProceduralMapType                            MapType;                                           // 0x00A5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        PathCount;                                         // 0x00A6(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapProceduralInfo) == 0x000008, "Wrong alignment on FMapProceduralInfo");
static_assert(sizeof(FMapProceduralInfo) == 0x0000A8, "Wrong size on FMapProceduralInfo");
static_assert(offsetof(FMapProceduralInfo, MapInfoMatrix) == 0x000000, "Member 'FMapProceduralInfo::MapInfoMatrix' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MapBlockMapping) == 0x000010, "Member 'FMapProceduralInfo::MapBlockMapping' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MapCustomLightConfigs) == 0x000060, "Member 'FMapProceduralInfo::MapCustomLightConfigs' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, EntranceX) == 0x000070, "Member 'FMapProceduralInfo::EntranceX' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, EntranceY) == 0x000074, "Member 'FMapProceduralInfo::EntranceY' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, ExitX) == 0x000078, "Member 'FMapProceduralInfo::ExitX' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, ExitY) == 0x00007C, "Member 'FMapProceduralInfo::ExitY' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, ExpectedPointNumber) == 0x000080, "Member 'FMapProceduralInfo::ExpectedPointNumber' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MapWidth) == 0x000084, "Member 'FMapProceduralInfo::MapWidth' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MapHeight) == 0x000088, "Member 'FMapProceduralInfo::MapHeight' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, BlockWidth) == 0x00008C, "Member 'FMapProceduralInfo::BlockWidth' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, BlockHeight) == 0x000090, "Member 'FMapProceduralInfo::BlockHeight' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MaxPointWidth) == 0x000094, "Member 'FMapProceduralInfo::MaxPointWidth' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MaxPointHeight) == 0x000098, "Member 'FMapProceduralInfo::MaxPointHeight' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MinPointWidth) == 0x00009C, "Member 'FMapProceduralInfo::MinPointWidth' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MinPointHeight) == 0x0000A0, "Member 'FMapProceduralInfo::MinPointHeight' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, MapType) == 0x0000A5, "Member 'FMapProceduralInfo::MapType' has a wrong offset!");
static_assert(offsetof(FMapProceduralInfo, PathCount) == 0x0000A6, "Member 'FMapProceduralInfo::PathCount' has a wrong offset!");

// SharpStruct b1-Managed.MapPointData
// 0x0000 (0x0000 - 0x0000)
struct FMapPointData final
{
};
static_assert(alignof(FMapPointData) == 0x000001, "Wrong alignment on FMapPointData");
static_assert(sizeof(FMapPointData) == 0x000001, "Wrong size on FMapPointData");

// SharpStruct b1-Managed.PatrolBlendSpaceSetting
// 0x0048 (0x0048 - 0x0000)
struct FPatrolBlendSpaceSetting final
{
public:
	uint8                                         UseExPatrol : 1;                                   // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpace*                            BSRunFwdPatrol;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunBwdPatrol;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunLeftPatrol;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSRunRightPatrol;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSJogFwdSlopeLeanPatrol;                           // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSJogBwdSlopeLeanPatrol;                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSJogLeftSlopeLeanPatrol;                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BSJogRightSlopeLeanPatrol;                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPatrolBlendSpaceSetting) == 0x000008, "Wrong alignment on FPatrolBlendSpaceSetting");
static_assert(sizeof(FPatrolBlendSpaceSetting) == 0x000048, "Wrong size on FPatrolBlendSpaceSetting");
static_assert(offsetof(FPatrolBlendSpaceSetting, BSRunFwdPatrol) == 0x000008, "Member 'FPatrolBlendSpaceSetting::BSRunFwdPatrol' has a wrong offset!");
static_assert(offsetof(FPatrolBlendSpaceSetting, BSRunBwdPatrol) == 0x000010, "Member 'FPatrolBlendSpaceSetting::BSRunBwdPatrol' has a wrong offset!");
static_assert(offsetof(FPatrolBlendSpaceSetting, BSRunLeftPatrol) == 0x000018, "Member 'FPatrolBlendSpaceSetting::BSRunLeftPatrol' has a wrong offset!");
static_assert(offsetof(FPatrolBlendSpaceSetting, BSRunRightPatrol) == 0x000020, "Member 'FPatrolBlendSpaceSetting::BSRunRightPatrol' has a wrong offset!");
static_assert(offsetof(FPatrolBlendSpaceSetting, BSJogFwdSlopeLeanPatrol) == 0x000028, "Member 'FPatrolBlendSpaceSetting::BSJogFwdSlopeLeanPatrol' has a wrong offset!");
static_assert(offsetof(FPatrolBlendSpaceSetting, BSJogBwdSlopeLeanPatrol) == 0x000030, "Member 'FPatrolBlendSpaceSetting::BSJogBwdSlopeLeanPatrol' has a wrong offset!");
static_assert(offsetof(FPatrolBlendSpaceSetting, BSJogLeftSlopeLeanPatrol) == 0x000038, "Member 'FPatrolBlendSpaceSetting::BSJogLeftSlopeLeanPatrol' has a wrong offset!");
static_assert(offsetof(FPatrolBlendSpaceSetting, BSJogRightSlopeLeanPatrol) == 0x000040, "Member 'FPatrolBlendSpaceSetting::BSJogRightSlopeLeanPatrol' has a wrong offset!");

// SharpStruct b1-Managed.NormalDeadAMInfo
// 0x0028 (0x0028 - 0x0000)
struct FNormalDeadAMInfo final
{
public:
	int32                                         StiffLevelID;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsEnableStiffContinue : 1;                         // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_4_1 : 7;                                    // 0x0004(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsEnableReuse : 1;                                 // 0x0005(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StiffLevelReuseID;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeadEllipsisType                             DeadEllipsisType;                                  // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableBeAttackedRotate : 1;                        // 0x000D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ENormalStiffSectorsType                       SectorsType;                                       // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalStiffRotateForwardLeft_FNB;                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateForwardRight_FNB;                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateForwardLeft_FourDir;              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateForwardRight_FourDir;             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateBackwardLeft_FourDir;             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalStiffRotateBackwardRight_FourDir;            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNormalDeadAMInfo) == 0x000004, "Wrong alignment on FNormalDeadAMInfo");
static_assert(sizeof(FNormalDeadAMInfo) == 0x000028, "Wrong size on FNormalDeadAMInfo");
static_assert(offsetof(FNormalDeadAMInfo, StiffLevelID) == 0x000000, "Member 'FNormalDeadAMInfo::StiffLevelID' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, StiffLevelReuseID) == 0x000008, "Member 'FNormalDeadAMInfo::StiffLevelReuseID' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, DeadEllipsisType) == 0x00000C, "Member 'FNormalDeadAMInfo::DeadEllipsisType' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, SectorsType) == 0x00000E, "Member 'FNormalDeadAMInfo::SectorsType' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, NormalStiffRotateForwardLeft_FNB) == 0x000010, "Member 'FNormalDeadAMInfo::NormalStiffRotateForwardLeft_FNB' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, NormalStiffRotateForwardRight_FNB) == 0x000014, "Member 'FNormalDeadAMInfo::NormalStiffRotateForwardRight_FNB' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, NormalStiffRotateForwardLeft_FourDir) == 0x000018, "Member 'FNormalDeadAMInfo::NormalStiffRotateForwardLeft_FourDir' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, NormalStiffRotateForwardRight_FourDir) == 0x00001C, "Member 'FNormalDeadAMInfo::NormalStiffRotateForwardRight_FourDir' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, NormalStiffRotateBackwardLeft_FourDir) == 0x000020, "Member 'FNormalDeadAMInfo::NormalStiffRotateBackwardLeft_FourDir' has a wrong offset!");
static_assert(offsetof(FNormalDeadAMInfo, NormalStiffRotateBackwardRight_FourDir) == 0x000024, "Member 'FNormalDeadAMInfo::NormalStiffRotateBackwardRight_FourDir' has a wrong offset!");

// SharpStruct b1-Managed.CustomDepthStencilInfo
// 0x0010 (0x0010 - 0x0000)
struct FCustomDepthStencilInfo final
{
public:
	class FName                                   ComponentTag;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRenderCustomDepth : 1;                            // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomDepthStencilValue;                           // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomDepthStencilInfo) == 0x000004, "Wrong alignment on FCustomDepthStencilInfo");
static_assert(sizeof(FCustomDepthStencilInfo) == 0x000010, "Wrong size on FCustomDepthStencilInfo");
static_assert(offsetof(FCustomDepthStencilInfo, ComponentTag) == 0x000000, "Member 'FCustomDepthStencilInfo::ComponentTag' has a wrong offset!");
static_assert(offsetof(FCustomDepthStencilInfo, CustomDepthStencilValue) == 0x00000C, "Member 'FCustomDepthStencilInfo::CustomDepthStencilValue' has a wrong offset!");

// SharpStruct b1-Managed.ProcBarConfig
// 0x0008 (0x0008 - 0x0000)
struct FProcBarConfig final
{
public:
	float                                         DefValue;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProcBarConfig) == 0x000004, "Wrong alignment on FProcBarConfig");
static_assert(sizeof(FProcBarConfig) == 0x000008, "Wrong size on FProcBarConfig");
static_assert(offsetof(FProcBarConfig, DefValue) == 0x000000, "Member 'FProcBarConfig::DefValue' has a wrong offset!");
static_assert(offsetof(FProcBarConfig, MaxValue) == 0x000004, "Member 'FProcBarConfig::MaxValue' has a wrong offset!");

// SharpStruct b1-Managed.InputTipsLeftRightCfg
// 0x00C0 (0x00C0 - 0x0000)
struct FInputTipsLeftRightCfg final
{
public:
	struct FInputTipsCfg                          LeftInputTipsCfg;                                  // 0x0000(0x0060)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputTipsCfg                          RightInputTipsCfg;                                 // 0x0060(0x0060)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputTipsLeftRightCfg) == 0x000008, "Wrong alignment on FInputTipsLeftRightCfg");
static_assert(sizeof(FInputTipsLeftRightCfg) == 0x0000C0, "Wrong size on FInputTipsLeftRightCfg");
static_assert(offsetof(FInputTipsLeftRightCfg, LeftInputTipsCfg) == 0x000000, "Member 'FInputTipsLeftRightCfg::LeftInputTipsCfg' has a wrong offset!");
static_assert(offsetof(FInputTipsLeftRightCfg, RightInputTipsCfg) == 0x000060, "Member 'FInputTipsLeftRightCfg::RightInputTipsCfg' has a wrong offset!");

// SharpStruct b1-Managed.SettingHpConfig
// 0x0018 (0x0018 - 0x0000)
struct FSettingHpConfig final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPLowPostProcessPercent;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPLimitPostProcessPercent;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSettingHpConfig) == 0x000008, "Wrong alignment on FSettingHpConfig");
static_assert(sizeof(FSettingHpConfig) == 0x000018, "Wrong size on FSettingHpConfig");
static_assert(offsetof(FSettingHpConfig, Name) == 0x000000, "Member 'FSettingHpConfig::Name' has a wrong offset!");
static_assert(offsetof(FSettingHpConfig, HPLowPostProcessPercent) == 0x000010, "Member 'FSettingHpConfig::HPLowPostProcessPercent' has a wrong offset!");
static_assert(offsetof(FSettingHpConfig, HPLimitPostProcessPercent) == 0x000014, "Member 'FSettingHpConfig::HPLimitPostProcessPercent' has a wrong offset!");

// SharpStruct b1-Managed.MapLevelConfig
// 0x0024 (0x0024 - 0x0000)
struct FMapLevelConfig final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScale;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsCanSelect : 1;                                   // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelectedScale;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCanShowScale;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapLevelConfig) == 0x000004, "Wrong alignment on FMapLevelConfig");
static_assert(sizeof(FMapLevelConfig) == 0x000024, "Wrong size on FMapLevelConfig");
static_assert(offsetof(FMapLevelConfig, Priority) == 0x000000, "Member 'FMapLevelConfig::Priority' has a wrong offset!");
static_assert(offsetof(FMapLevelConfig, Size) == 0x000004, "Member 'FMapLevelConfig::Size' has a wrong offset!");
static_assert(offsetof(FMapLevelConfig, Range) == 0x000008, "Member 'FMapLevelConfig::Range' has a wrong offset!");
static_assert(offsetof(FMapLevelConfig, Friction) == 0x00000C, "Member 'FMapLevelConfig::Friction' has a wrong offset!");
static_assert(offsetof(FMapLevelConfig, MinScale) == 0x000010, "Member 'FMapLevelConfig::MinScale' has a wrong offset!");
static_assert(offsetof(FMapLevelConfig, MaxScale) == 0x000014, "Member 'FMapLevelConfig::MaxScale' has a wrong offset!");
static_assert(offsetof(FMapLevelConfig, SelectedScale) == 0x00001C, "Member 'FMapLevelConfig::SelectedScale' has a wrong offset!");
static_assert(offsetof(FMapLevelConfig, MinCanShowScale) == 0x000020, "Member 'FMapLevelConfig::MinCanShowScale' has a wrong offset!");

// SharpStruct b1-Managed.LevelNameConfig
// 0x0010 (0x0010 - 0x0000)
struct FLevelNameConfig final
{
public:
	TArray<int32>                                 NameList;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelNameConfig) == 0x000008, "Wrong alignment on FLevelNameConfig");
static_assert(sizeof(FLevelNameConfig) == 0x000010, "Wrong size on FLevelNameConfig");
static_assert(offsetof(FLevelNameConfig, NameList) == 0x000000, "Member 'FLevelNameConfig::NameList' has a wrong offset!");

// SharpStruct b1-Managed.MonsterManualInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FMonsterManualInfo final
{
public:
	TMap<class FName, float>                      ScalarParameterMap;                                // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        VectorParameterMap;                                // 0x0050(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMonsterManualInfo) == 0x000008, "Wrong alignment on FMonsterManualInfo");
static_assert(sizeof(FMonsterManualInfo) == 0x0000A0, "Wrong size on FMonsterManualInfo");
static_assert(offsetof(FMonsterManualInfo, ScalarParameterMap) == 0x000000, "Member 'FMonsterManualInfo::ScalarParameterMap' has a wrong offset!");
static_assert(offsetof(FMonsterManualInfo, VectorParameterMap) == 0x000050, "Member 'FMonsterManualInfo::VectorParameterMap' has a wrong offset!");

// SharpStruct b1-Managed.SingleBattleBGMConfig
// 0x0020 (0x0020 - 0x0000)
struct FSingleBattleBGMConfig final
{
public:
	class UAkAudioEvent*                          AkEventBegin;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventStop;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStopEventConditionConfig              StopEventConditionConfig;                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleBattleBGMConfig) == 0x000008, "Wrong alignment on FSingleBattleBGMConfig");
static_assert(sizeof(FSingleBattleBGMConfig) == 0x000020, "Wrong size on FSingleBattleBGMConfig");
static_assert(offsetof(FSingleBattleBGMConfig, AkEventBegin) == 0x000000, "Member 'FSingleBattleBGMConfig::AkEventBegin' has a wrong offset!");
static_assert(offsetof(FSingleBattleBGMConfig, AkEventStop) == 0x000008, "Member 'FSingleBattleBGMConfig::AkEventStop' has a wrong offset!");
static_assert(offsetof(FSingleBattleBGMConfig, StopEventConditionConfig) == 0x000010, "Member 'FSingleBattleBGMConfig::StopEventConditionConfig' has a wrong offset!");

// SharpStruct b1-Managed.SingleTransBGMConfig
// 0x0018 (0x0018 - 0x0000)
struct FSingleTransBGMConfig final
{
public:
	class UAkAudioEvent*                          AkEventBegin;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventStop;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          LeaveBattleEventStop;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSingleTransBGMConfig) == 0x000008, "Wrong alignment on FSingleTransBGMConfig");
static_assert(sizeof(FSingleTransBGMConfig) == 0x000018, "Wrong size on FSingleTransBGMConfig");
static_assert(offsetof(FSingleTransBGMConfig, AkEventBegin) == 0x000000, "Member 'FSingleTransBGMConfig::AkEventBegin' has a wrong offset!");
static_assert(offsetof(FSingleTransBGMConfig, AkEventStop) == 0x000008, "Member 'FSingleTransBGMConfig::AkEventStop' has a wrong offset!");
static_assert(offsetof(FSingleTransBGMConfig, LeaveBattleEventStop) == 0x000010, "Member 'FSingleTransBGMConfig::LeaveBattleEventStop' has a wrong offset!");

// SharpStruct b1-Managed.AbnomalAttrConfigInfo
// 0x0018 (0x0018 - 0x0000)
struct FAbnomalAttrConfigInfo final
{
public:
	int32                                         DefaultAccumulatedValue;                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultAccValueDecreaseSpd;                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BRKAbnormalNeedHP_INV10000;                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BRKAbnormalTriggerSkillEffectID;                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAccumulatedValue_Increase_PerINV10000;          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAccumulatedValue_Increase_CounterMax;           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbnomalAttrConfigInfo) == 0x000004, "Wrong alignment on FAbnomalAttrConfigInfo");
static_assert(sizeof(FAbnomalAttrConfigInfo) == 0x000018, "Wrong size on FAbnomalAttrConfigInfo");
static_assert(offsetof(FAbnomalAttrConfigInfo, DefaultAccumulatedValue) == 0x000000, "Member 'FAbnomalAttrConfigInfo::DefaultAccumulatedValue' has a wrong offset!");
static_assert(offsetof(FAbnomalAttrConfigInfo, DefaultAccValueDecreaseSpd) == 0x000004, "Member 'FAbnomalAttrConfigInfo::DefaultAccValueDecreaseSpd' has a wrong offset!");
static_assert(offsetof(FAbnomalAttrConfigInfo, BRKAbnormalNeedHP_INV10000) == 0x000008, "Member 'FAbnomalAttrConfigInfo::BRKAbnormalNeedHP_INV10000' has a wrong offset!");
static_assert(offsetof(FAbnomalAttrConfigInfo, BRKAbnormalTriggerSkillEffectID) == 0x00000C, "Member 'FAbnomalAttrConfigInfo::BRKAbnormalTriggerSkillEffectID' has a wrong offset!");
static_assert(offsetof(FAbnomalAttrConfigInfo, MaxAccumulatedValue_Increase_PerINV10000) == 0x000010, "Member 'FAbnomalAttrConfigInfo::MaxAccumulatedValue_Increase_PerINV10000' has a wrong offset!");
static_assert(offsetof(FAbnomalAttrConfigInfo, MaxAccumulatedValue_Increase_CounterMax) == 0x000014, "Member 'FAbnomalAttrConfigInfo::MaxAccumulatedValue_Increase_CounterMax' has a wrong offset!");

// SharpStruct b1-Managed.AttackIKBonePairs
// 0x0040 (0x0040 - 0x0000)
struct FAttackIKBonePairs final
{
public:
	class FName                                   AttackIKRootBoneName;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttackIKLimbBoneName;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackIKRoll;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackIKPitch;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttackIKTargetActorBoneName;                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackIKBlendMinDistance;                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackIKBlendMaxDistance;                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttackIKLimitEnable : 1;                           // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AttackIKPitchLimit;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackIKBonePairs) == 0x000008, "Wrong alignment on FAttackIKBonePairs");
static_assert(sizeof(FAttackIKBonePairs) == 0x000040, "Wrong size on FAttackIKBonePairs");
static_assert(offsetof(FAttackIKBonePairs, AttackIKRootBoneName) == 0x000000, "Member 'FAttackIKBonePairs::AttackIKRootBoneName' has a wrong offset!");
static_assert(offsetof(FAttackIKBonePairs, AttackIKLimbBoneName) == 0x000008, "Member 'FAttackIKBonePairs::AttackIKLimbBoneName' has a wrong offset!");
static_assert(offsetof(FAttackIKBonePairs, AttackIKRoll) == 0x000010, "Member 'FAttackIKBonePairs::AttackIKRoll' has a wrong offset!");
static_assert(offsetof(FAttackIKBonePairs, AttackIKPitch) == 0x000014, "Member 'FAttackIKBonePairs::AttackIKPitch' has a wrong offset!");
static_assert(offsetof(FAttackIKBonePairs, AttackIKTargetActorBoneName) == 0x000018, "Member 'FAttackIKBonePairs::AttackIKTargetActorBoneName' has a wrong offset!");
static_assert(offsetof(FAttackIKBonePairs, AttackIKBlendMinDistance) == 0x000020, "Member 'FAttackIKBonePairs::AttackIKBlendMinDistance' has a wrong offset!");
static_assert(offsetof(FAttackIKBonePairs, AttackIKBlendMaxDistance) == 0x000024, "Member 'FAttackIKBonePairs::AttackIKBlendMaxDistance' has a wrong offset!");
static_assert(offsetof(FAttackIKBonePairs, AttackIKPitchLimit) == 0x000030, "Member 'FAttackIKBonePairs::AttackIKPitchLimit' has a wrong offset!");

// SharpStruct b1-Managed.OneBlockListInfo
// 0x0020 (0x0020 - 0x0000)
struct FOneBlockListInfo final
{
public:
	uint8                                         IsUseSkill2Block : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Skill2Block;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AM2Block;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsUseSkill2BlockBounce : 1;                        // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Skill2BlockBounce;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BlockBounceAM;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOneBlockListInfo) == 0x000008, "Wrong alignment on FOneBlockListInfo");
static_assert(sizeof(FOneBlockListInfo) == 0x000020, "Wrong size on FOneBlockListInfo");
static_assert(offsetof(FOneBlockListInfo, Skill2Block) == 0x000004, "Member 'FOneBlockListInfo::Skill2Block' has a wrong offset!");
static_assert(offsetof(FOneBlockListInfo, AM2Block) == 0x000008, "Member 'FOneBlockListInfo::AM2Block' has a wrong offset!");
static_assert(offsetof(FOneBlockListInfo, Skill2BlockBounce) == 0x000014, "Member 'FOneBlockListInfo::Skill2BlockBounce' has a wrong offset!");
static_assert(offsetof(FOneBlockListInfo, BlockBounceAM) == 0x000018, "Member 'FOneBlockListInfo::BlockBounceAM' has a wrong offset!");

// SharpStruct b1-Managed.OneDirectBlockAMInfo
// 0x0038 (0x0038 - 0x0000)
struct FOneDirectBlockAMInfo final
{
public:
	uint8                                         IsUseSkill2Block : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Skill2Block;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AM2Block;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsUseSkill2BlockBounce : 1;                        // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Skill2BlockBounce;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BlockBounceAM;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsUseBlockListInfo : 1;                            // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOneBlockListInfo>              OneBlockListInfo;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOneDirectBlockAMInfo) == 0x000008, "Wrong alignment on FOneDirectBlockAMInfo");
static_assert(sizeof(FOneDirectBlockAMInfo) == 0x000038, "Wrong size on FOneDirectBlockAMInfo");
static_assert(offsetof(FOneDirectBlockAMInfo, Skill2Block) == 0x000004, "Member 'FOneDirectBlockAMInfo::Skill2Block' has a wrong offset!");
static_assert(offsetof(FOneDirectBlockAMInfo, AM2Block) == 0x000008, "Member 'FOneDirectBlockAMInfo::AM2Block' has a wrong offset!");
static_assert(offsetof(FOneDirectBlockAMInfo, Skill2BlockBounce) == 0x000014, "Member 'FOneDirectBlockAMInfo::Skill2BlockBounce' has a wrong offset!");
static_assert(offsetof(FOneDirectBlockAMInfo, BlockBounceAM) == 0x000018, "Member 'FOneDirectBlockAMInfo::BlockBounceAM' has a wrong offset!");
static_assert(offsetof(FOneDirectBlockAMInfo, OneBlockListInfo) == 0x000028, "Member 'FOneDirectBlockAMInfo::OneBlockListInfo' has a wrong offset!");

// SharpStruct b1-Managed.StiffLevelInfo
// 0x0018 (0x0018 - 0x0000)
struct FStiffLevelInfo final
{
public:
	float                                         StiffLevelValue;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StiffLevelName;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStiffLevelInfo) == 0x000008, "Wrong alignment on FStiffLevelInfo");
static_assert(sizeof(FStiffLevelInfo) == 0x000018, "Wrong size on FStiffLevelInfo");
static_assert(offsetof(FStiffLevelInfo, StiffLevelValue) == 0x000000, "Member 'FStiffLevelInfo::StiffLevelValue' has a wrong offset!");
static_assert(offsetof(FStiffLevelInfo, StiffLevelName) == 0x000008, "Member 'FStiffLevelInfo::StiffLevelName' has a wrong offset!");

// SharpStruct b1-Managed.DirectBlockAMInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FDirectBlockAMInfo final
{
public:
	struct FOneDirectBlockAMInfo                  ForwardBlockAMInfo;                                // 0x0000(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOneDirectBlockAMInfo                  BackwardBlockAMInfo;                               // 0x0038(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOneDirectBlockAMInfo                  LeftSideBlockAMInfo;                               // 0x0070(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FOneDirectBlockAMInfo                  RightSideBlockAMInfo;                              // 0x00A8(0x0038)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectBlockAMInfo) == 0x000008, "Wrong alignment on FDirectBlockAMInfo");
static_assert(sizeof(FDirectBlockAMInfo) == 0x0000E0, "Wrong size on FDirectBlockAMInfo");
static_assert(offsetof(FDirectBlockAMInfo, ForwardBlockAMInfo) == 0x000000, "Member 'FDirectBlockAMInfo::ForwardBlockAMInfo' has a wrong offset!");
static_assert(offsetof(FDirectBlockAMInfo, BackwardBlockAMInfo) == 0x000038, "Member 'FDirectBlockAMInfo::BackwardBlockAMInfo' has a wrong offset!");
static_assert(offsetof(FDirectBlockAMInfo, LeftSideBlockAMInfo) == 0x000070, "Member 'FDirectBlockAMInfo::LeftSideBlockAMInfo' has a wrong offset!");
static_assert(offsetof(FDirectBlockAMInfo, RightSideBlockAMInfo) == 0x0000A8, "Member 'FDirectBlockAMInfo::RightSideBlockAMInfo' has a wrong offset!");

// SharpStruct b1-Managed.BlockAMInfo
// 0x0100 (0x0100 - 0x0000)
struct FBlockAMInfo final
{
public:
	TArray<int32>                                 BlockBuffList;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 BlockBouncedBuffList;                              // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDirectBlockAMInfo                     DirectBlockAMInfo;                                 // 0x0020(0x00E0)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockAMInfo) == 0x000008, "Wrong alignment on FBlockAMInfo");
static_assert(sizeof(FBlockAMInfo) == 0x000100, "Wrong size on FBlockAMInfo");
static_assert(offsetof(FBlockAMInfo, BlockBuffList) == 0x000000, "Member 'FBlockAMInfo::BlockBuffList' has a wrong offset!");
static_assert(offsetof(FBlockAMInfo, BlockBouncedBuffList) == 0x000010, "Member 'FBlockAMInfo::BlockBouncedBuffList' has a wrong offset!");
static_assert(offsetof(FBlockAMInfo, DirectBlockAMInfo) == 0x000020, "Member 'FBlockAMInfo::DirectBlockAMInfo' has a wrong offset!");

// SharpStruct b1-Managed.BlockInfoByHitLevel
// 0x0018 (0x0018 - 0x0000)
struct FBlockInfoByHitLevel final
{
public:
	int32                                         HitLevel;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBlockAMInfo>                   BlockAMInfoList;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockInfoByHitLevel) == 0x000008, "Wrong alignment on FBlockInfoByHitLevel");
static_assert(sizeof(FBlockInfoByHitLevel) == 0x000018, "Wrong size on FBlockInfoByHitLevel");
static_assert(offsetof(FBlockInfoByHitLevel, HitLevel) == 0x000000, "Member 'FBlockInfoByHitLevel::HitLevel' has a wrong offset!");
static_assert(offsetof(FBlockInfoByHitLevel, BlockAMInfoList) == 0x000008, "Member 'FBlockInfoByHitLevel::BlockAMInfoList' has a wrong offset!");

// SharpStruct b1-Managed.ComboSkill
// 0x0010 (0x0010 - 0x0000)
struct FComboSkill final
{
public:
	TArray<int32>                                 SkillID;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComboSkill) == 0x000008, "Wrong alignment on FComboSkill");
static_assert(sizeof(FComboSkill) == 0x000010, "Wrong size on FComboSkill");
static_assert(offsetof(FComboSkill, SkillID) == 0x000000, "Member 'FComboSkill::SkillID' has a wrong offset!");

// SharpStruct b1-Managed.PerfectBlockDamageInfo
// 0x0008 (0x0008 - 0x0000)
struct FPerfectBlockDamageInfo final
{
public:
	int32                                         TriggerDeductPerfectBlockValueHitWeight;           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeductPerfectBlockValueRadio;                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerfectBlockDamageInfo) == 0x000004, "Wrong alignment on FPerfectBlockDamageInfo");
static_assert(sizeof(FPerfectBlockDamageInfo) == 0x000008, "Wrong size on FPerfectBlockDamageInfo");
static_assert(offsetof(FPerfectBlockDamageInfo, TriggerDeductPerfectBlockValueHitWeight) == 0x000000, "Member 'FPerfectBlockDamageInfo::TriggerDeductPerfectBlockValueHitWeight' has a wrong offset!");
static_assert(offsetof(FPerfectBlockDamageInfo, DeductPerfectBlockValueRadio) == 0x000004, "Member 'FPerfectBlockDamageInfo::DeductPerfectBlockValueRadio' has a wrong offset!");

// SharpStruct b1-Managed.BehaviorNodeGroupSkillList
// 0x0020 (0x0020 - 0x0000)
struct FBehaviorNodeGroupSkillList final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CheckBuffId;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CheckReverse : 1;                                  // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_8_1 : 7;                                    // 0x0008(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         ForceCast : 1;                                     // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MontagePath;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBehaviorNodeGroupSkillList) == 0x000008, "Wrong alignment on FBehaviorNodeGroupSkillList");
static_assert(sizeof(FBehaviorNodeGroupSkillList) == 0x000020, "Wrong size on FBehaviorNodeGroupSkillList");
static_assert(offsetof(FBehaviorNodeGroupSkillList, SkillID) == 0x000000, "Member 'FBehaviorNodeGroupSkillList::SkillID' has a wrong offset!");
static_assert(offsetof(FBehaviorNodeGroupSkillList, CheckBuffId) == 0x000004, "Member 'FBehaviorNodeGroupSkillList::CheckBuffId' has a wrong offset!");
static_assert(offsetof(FBehaviorNodeGroupSkillList, MontagePath) == 0x000010, "Member 'FBehaviorNodeGroupSkillList::MontagePath' has a wrong offset!");

// SharpStruct b1-Managed.BeAttackedBlockDamageInfo
// 0x0008 (0x0008 - 0x0000)
struct FBeAttackedBlockDamageInfo final
{
public:
	int32                                         TriggerDeductBlockArmorLevel;                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeductBlockArmorValue;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBeAttackedBlockDamageInfo) == 0x000004, "Wrong alignment on FBeAttackedBlockDamageInfo");
static_assert(sizeof(FBeAttackedBlockDamageInfo) == 0x000008, "Wrong size on FBeAttackedBlockDamageInfo");
static_assert(offsetof(FBeAttackedBlockDamageInfo, TriggerDeductBlockArmorLevel) == 0x000000, "Member 'FBeAttackedBlockDamageInfo::TriggerDeductBlockArmorLevel' has a wrong offset!");
static_assert(offsetof(FBeAttackedBlockDamageInfo, DeductBlockArmorValue) == 0x000004, "Member 'FBeAttackedBlockDamageInfo::DeductBlockArmorValue' has a wrong offset!");

// SharpStruct b1-Managed.BlockInfoWarp_Perfect
// 0x0038 (0x0038 - 0x0000)
struct FBlockInfoWarp_Perfect final
{
public:
	TArray<struct FPerfectBlockDamageInfo>        PerfectBlockDamageInfoList;                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBlockAMInfo>                   BlockAMInfoList;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BreakBlockAM;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerBlock2WeakMinHitWeight;                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           BreakBlock2WeakAM;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockInfoWarp_Perfect) == 0x000008, "Wrong alignment on FBlockInfoWarp_Perfect");
static_assert(sizeof(FBlockInfoWarp_Perfect) == 0x000038, "Wrong size on FBlockInfoWarp_Perfect");
static_assert(offsetof(FBlockInfoWarp_Perfect, PerfectBlockDamageInfoList) == 0x000000, "Member 'FBlockInfoWarp_Perfect::PerfectBlockDamageInfoList' has a wrong offset!");
static_assert(offsetof(FBlockInfoWarp_Perfect, BlockAMInfoList) == 0x000010, "Member 'FBlockInfoWarp_Perfect::BlockAMInfoList' has a wrong offset!");
static_assert(offsetof(FBlockInfoWarp_Perfect, BreakBlockAM) == 0x000020, "Member 'FBlockInfoWarp_Perfect::BreakBlockAM' has a wrong offset!");
static_assert(offsetof(FBlockInfoWarp_Perfect, TriggerBlock2WeakMinHitWeight) == 0x000028, "Member 'FBlockInfoWarp_Perfect::TriggerBlock2WeakMinHitWeight' has a wrong offset!");
static_assert(offsetof(FBlockInfoWarp_Perfect, BreakBlock2WeakAM) == 0x000030, "Member 'FBlockInfoWarp_Perfect::BreakBlock2WeakAM' has a wrong offset!");

// SharpStruct b1-Managed.BlockInfoWarp_Normal
// 0x0028 (0x0028 - 0x0000)
struct FBlockInfoWarp_Normal final
{
public:
	TArray<struct FBlockInfoByHitLevel>           BlockInfoByHitLevelList;                           // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BreakBlockAM;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerBlock2WeakMinHitWeight;                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           BreakBlock2WeakAM;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockInfoWarp_Normal) == 0x000008, "Wrong alignment on FBlockInfoWarp_Normal");
static_assert(sizeof(FBlockInfoWarp_Normal) == 0x000028, "Wrong size on FBlockInfoWarp_Normal");
static_assert(offsetof(FBlockInfoWarp_Normal, BlockInfoByHitLevelList) == 0x000000, "Member 'FBlockInfoWarp_Normal::BlockInfoByHitLevelList' has a wrong offset!");
static_assert(offsetof(FBlockInfoWarp_Normal, BreakBlockAM) == 0x000010, "Member 'FBlockInfoWarp_Normal::BreakBlockAM' has a wrong offset!");
static_assert(offsetof(FBlockInfoWarp_Normal, TriggerBlock2WeakMinHitWeight) == 0x000018, "Member 'FBlockInfoWarp_Normal::TriggerBlock2WeakMinHitWeight' has a wrong offset!");
static_assert(offsetof(FBlockInfoWarp_Normal, BreakBlock2WeakAM) == 0x000020, "Member 'FBlockInfoWarp_Normal::BreakBlock2WeakAM' has a wrong offset!");

// SharpStruct b1-Managed.BlockInfoWarp_BeAttacked
// 0x0020 (0x0020 - 0x0000)
struct FBlockInfoWarp_BeAttacked final
{
public:
	TArray<struct FBeAttackedBlockDamageInfo>     BeAttackedBlockDamageInfo;                         // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBeAttackedBlockDamageInfo>     BeAttackedBlockDamageInfoByStiffLevel;             // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockInfoWarp_BeAttacked) == 0x000008, "Wrong alignment on FBlockInfoWarp_BeAttacked");
static_assert(sizeof(FBlockInfoWarp_BeAttacked) == 0x000020, "Wrong size on FBlockInfoWarp_BeAttacked");
static_assert(offsetof(FBlockInfoWarp_BeAttacked, BeAttackedBlockDamageInfo) == 0x000000, "Member 'FBlockInfoWarp_BeAttacked::BeAttackedBlockDamageInfo' has a wrong offset!");
static_assert(offsetof(FBlockInfoWarp_BeAttacked, BeAttackedBlockDamageInfoByStiffLevel) == 0x000010, "Member 'FBlockInfoWarp_BeAttacked::BeAttackedBlockDamageInfoByStiffLevel' has a wrong offset!");

// SharpStruct b1-Managed.EnvironmentAbnormalRecoverRate
// 0x0008 (0x0008 - 0x0000)
struct FEnvironmentAbnormalRecoverRate final
{
public:
	EAbnormalStateType                            AbnormalStateType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoRecoverRate;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentAbnormalRecoverRate) == 0x000004, "Wrong alignment on FEnvironmentAbnormalRecoverRate");
static_assert(sizeof(FEnvironmentAbnormalRecoverRate) == 0x000008, "Wrong size on FEnvironmentAbnormalRecoverRate");
static_assert(offsetof(FEnvironmentAbnormalRecoverRate, AbnormalStateType) == 0x000000, "Member 'FEnvironmentAbnormalRecoverRate::AbnormalStateType' has a wrong offset!");
static_assert(offsetof(FEnvironmentAbnormalRecoverRate, AutoRecoverRate) == 0x000004, "Member 'FEnvironmentAbnormalRecoverRate::AutoRecoverRate' has a wrong offset!");

// SharpStruct b1-Managed.FGSGroupPatrolConfig
// 0x0070 (0x0070 - 0x0000)
struct FFGSGroupPatrolConfig final
{
public:
	TMap<int32, struct FFGSSplinePatrolWaitPoint> SplineWaitPointConfig;                             // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFGSGroupFollowConfig                  GroupFollowConfig;                                 // 0x0050(0x001C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSGroupPatrolConfig) == 0x000008, "Wrong alignment on FFGSGroupPatrolConfig");
static_assert(sizeof(FFGSGroupPatrolConfig) == 0x000070, "Wrong size on FFGSGroupPatrolConfig");
static_assert(offsetof(FFGSGroupPatrolConfig, SplineWaitPointConfig) == 0x000000, "Member 'FFGSGroupPatrolConfig::SplineWaitPointConfig' has a wrong offset!");
static_assert(offsetof(FFGSGroupPatrolConfig, GroupFollowConfig) == 0x000050, "Member 'FFGSGroupPatrolConfig::GroupFollowConfig' has a wrong offset!");

// SharpStruct b1-Managed.SummonSetting
// 0x000C (0x000C - 0x0000)
struct FSummonSetting final
{
public:
	int32                                         SummonID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SummonWeight;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SummonPointIndex;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummonSetting) == 0x000004, "Wrong alignment on FSummonSetting");
static_assert(sizeof(FSummonSetting) == 0x00000C, "Wrong size on FSummonSetting");
static_assert(offsetof(FSummonSetting, SummonID) == 0x000000, "Member 'FSummonSetting::SummonID' has a wrong offset!");
static_assert(offsetof(FSummonSetting, SummonWeight) == 0x000004, "Member 'FSummonSetting::SummonWeight' has a wrong offset!");
static_assert(offsetof(FSummonSetting, SummonPointIndex) == 0x000008, "Member 'FSummonSetting::SummonPointIndex' has a wrong offset!");

// SharpStruct b1-Managed.ChargeLevelConfig
// 0x0010 (0x0010 - 0x0000)
struct FChargeLevelConfig final
{
public:
	TArray<struct FChargeLevelUnitInfo>           InfoList;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChargeLevelConfig) == 0x000008, "Wrong alignment on FChargeLevelConfig");
static_assert(sizeof(FChargeLevelConfig) == 0x000010, "Wrong size on FChargeLevelConfig");
static_assert(offsetof(FChargeLevelConfig, InfoList) == 0x000000, "Member 'FChargeLevelConfig::InfoList' has a wrong offset!");

// SharpStruct b1-Managed.GroupAIBPConfig
// 0x0048 (0x0048 - 0x0000)
struct FGroupAIBPConfig final
{
public:
	uint8                                         IsForceDisableGroupAI : 1;                         // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_0_1 : 7;                                    // 0x0000(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsBossUnit : 1;                                    // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_1_1 : 7;                                    // 0x0001(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         OnlyUseOnceOnFightSkill : 1;                       // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 GroupAIOnFightSkillList;                           // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         OnlyTriggerOnceAddBuffWhenReceiveToken : 1;        // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 BuffListWhenReceiveToken;                          // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         OnlyTriggerOnceAddBuffWhenLostToken : 1;           // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 BuffListWhenLostToken;                             // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroupAIBPConfig) == 0x000008, "Wrong alignment on FGroupAIBPConfig");
static_assert(sizeof(FGroupAIBPConfig) == 0x000048, "Wrong size on FGroupAIBPConfig");
static_assert(offsetof(FGroupAIBPConfig, GroupAIOnFightSkillList) == 0x000008, "Member 'FGroupAIBPConfig::GroupAIOnFightSkillList' has a wrong offset!");
static_assert(offsetof(FGroupAIBPConfig, BuffListWhenReceiveToken) == 0x000020, "Member 'FGroupAIBPConfig::BuffListWhenReceiveToken' has a wrong offset!");
static_assert(offsetof(FGroupAIBPConfig, BuffListWhenLostToken) == 0x000038, "Member 'FGroupAIBPConfig::BuffListWhenLostToken' has a wrong offset!");

// SharpStruct b1-Managed.DetailLevelInfo
// 0x0018 (0x0018 - 0x0000)
struct FDetailLevelInfo final
{
public:
	int32                                         MainMenuLevelId;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SetConfigLevelId;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrologueLevelId;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterPrologueLevelId;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StandAlonePartyId;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnlinePartyId;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetailLevelInfo) == 0x000004, "Wrong alignment on FDetailLevelInfo");
static_assert(sizeof(FDetailLevelInfo) == 0x000018, "Wrong size on FDetailLevelInfo");
static_assert(offsetof(FDetailLevelInfo, MainMenuLevelId) == 0x000000, "Member 'FDetailLevelInfo::MainMenuLevelId' has a wrong offset!");
static_assert(offsetof(FDetailLevelInfo, SetConfigLevelId) == 0x000004, "Member 'FDetailLevelInfo::SetConfigLevelId' has a wrong offset!");
static_assert(offsetof(FDetailLevelInfo, PrologueLevelId) == 0x000008, "Member 'FDetailLevelInfo::PrologueLevelId' has a wrong offset!");
static_assert(offsetof(FDetailLevelInfo, AfterPrologueLevelId) == 0x00000C, "Member 'FDetailLevelInfo::AfterPrologueLevelId' has a wrong offset!");
static_assert(offsetof(FDetailLevelInfo, StandAlonePartyId) == 0x000010, "Member 'FDetailLevelInfo::StandAlonePartyId' has a wrong offset!");
static_assert(offsetof(FDetailLevelInfo, OnlinePartyId) == 0x000014, "Member 'FDetailLevelInfo::OnlinePartyId' has a wrong offset!");

// SharpStruct b1-Managed.KillUnitMapConfig
// 0x0002 (0x0002 - 0x0000)
struct FKillUnitMapConfig final
{
public:
	EKillUnitMapCond                              Cond;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillUnitMapResult                            Result;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillUnitMapConfig) == 0x000001, "Wrong alignment on FKillUnitMapConfig");
static_assert(sizeof(FKillUnitMapConfig) == 0x000002, "Wrong size on FKillUnitMapConfig");
static_assert(offsetof(FKillUnitMapConfig, Cond) == 0x000000, "Member 'FKillUnitMapConfig::Cond' has a wrong offset!");
static_assert(offsetof(FKillUnitMapConfig, Result) == 0x000001, "Member 'FKillUnitMapConfig::Result' has a wrong offset!");

// SharpStruct b1-Managed.IKRigBoneDefinition
// 0x0070 (0x0070 - 0x0000)
struct FIKRigBoneDefinition final
{
public:
	struct FTransform                             TargetTransform;                                   // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKRigBoneDefinition) == 0x000010, "Wrong alignment on FIKRigBoneDefinition");
static_assert(sizeof(FIKRigBoneDefinition) == 0x000070, "Wrong size on FIKRigBoneDefinition");
static_assert(offsetof(FIKRigBoneDefinition, TargetTransform) == 0x000000, "Member 'FIKRigBoneDefinition::TargetTransform' has a wrong offset!");
static_assert(offsetof(FIKRigBoneDefinition, BoneName) == 0x000060, "Member 'FIKRigBoneDefinition::BoneName' has a wrong offset!");

// SharpStruct b1-Managed.FTPModeStickerImage
// 0x0020 (0x0020 - 0x0000)
struct FFTPModeStickerImage final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             ImageTex;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFTPModeStickerImage) == 0x000008, "Wrong alignment on FFTPModeStickerImage");
static_assert(sizeof(FFTPModeStickerImage) == 0x000020, "Wrong size on FFTPModeStickerImage");
static_assert(offsetof(FFTPModeStickerImage, DisplayName) == 0x000000, "Member 'FFTPModeStickerImage::DisplayName' has a wrong offset!");
static_assert(offsetof(FFTPModeStickerImage, ImageTex) == 0x000018, "Member 'FFTPModeStickerImage::ImageTex' has a wrong offset!");

// SharpStruct b1-Managed.BulletSweepReactionInfo
// 0x0018 (0x0018 - 0x0000)
struct FBulletSweepReactionInfo final
{
public:
	int32                                         CheckID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TriggerEffectID;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletSweepReactionInfo) == 0x000008, "Wrong alignment on FBulletSweepReactionInfo");
static_assert(sizeof(FBulletSweepReactionInfo) == 0x000018, "Wrong size on FBulletSweepReactionInfo");
static_assert(offsetof(FBulletSweepReactionInfo, CheckID) == 0x000000, "Member 'FBulletSweepReactionInfo::CheckID' has a wrong offset!");
static_assert(offsetof(FBulletSweepReactionInfo, TriggerEffectID) == 0x000008, "Member 'FBulletSweepReactionInfo::TriggerEffectID' has a wrong offset!");

// SharpStruct b1-Managed.BulletSweepSimpleStateReactionInfo
// 0x0018 (0x0018 - 0x0000)
struct FBulletSweepSimpleStateReactionInfo final
{
public:
	EBGUSimpleState                               ConditionSimpleState;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 TriggerEffectID;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletSweepSimpleStateReactionInfo) == 0x000008, "Wrong alignment on FBulletSweepSimpleStateReactionInfo");
static_assert(sizeof(FBulletSweepSimpleStateReactionInfo) == 0x000018, "Wrong size on FBulletSweepSimpleStateReactionInfo");
static_assert(offsetof(FBulletSweepSimpleStateReactionInfo, ConditionSimpleState) == 0x000000, "Member 'FBulletSweepSimpleStateReactionInfo::ConditionSimpleState' has a wrong offset!");
static_assert(offsetof(FBulletSweepSimpleStateReactionInfo, TriggerEffectID) == 0x000008, "Member 'FBulletSweepSimpleStateReactionInfo::TriggerEffectID' has a wrong offset!");

// SharpStruct b1-Managed.GamepadCustomizedInputConfig
// 0x0010 (0x0010 - 0x0000)
struct FGamepadCustomizedInputConfig final
{
public:
	TArray<struct FGamepadCustomizedInputDetailConfig> DetailConfigs;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamepadCustomizedInputConfig) == 0x000008, "Wrong alignment on FGamepadCustomizedInputConfig");
static_assert(sizeof(FGamepadCustomizedInputConfig) == 0x000010, "Wrong size on FGamepadCustomizedInputConfig");
static_assert(offsetof(FGamepadCustomizedInputConfig, DetailConfigs) == 0x000000, "Member 'FGamepadCustomizedInputConfig::DetailConfigs' has a wrong offset!");

// SharpStruct b1-Managed.CustomizedKeyConfig
// 0x0030 (0x0030 - 0x0000)
struct FCustomizedKeyConfig final
{
public:
	class FString                                 ActionName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UIWordID;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSInputChangeType                            ChangeType;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSInputTab                                   InputTab;                                          // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSKeyMappingType                             KeyMappingType;                                    // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GroupName;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupNameUIWordID;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizedKeyUnlockCondition                 UnlockCondition;                                   // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizedKeyConfig) == 0x000008, "Wrong alignment on FCustomizedKeyConfig");
static_assert(sizeof(FCustomizedKeyConfig) == 0x000030, "Wrong size on FCustomizedKeyConfig");
static_assert(offsetof(FCustomizedKeyConfig, ActionName) == 0x000000, "Member 'FCustomizedKeyConfig::ActionName' has a wrong offset!");
static_assert(offsetof(FCustomizedKeyConfig, UIWordID) == 0x000010, "Member 'FCustomizedKeyConfig::UIWordID' has a wrong offset!");
static_assert(offsetof(FCustomizedKeyConfig, ChangeType) == 0x000014, "Member 'FCustomizedKeyConfig::ChangeType' has a wrong offset!");
static_assert(offsetof(FCustomizedKeyConfig, InputTab) == 0x000015, "Member 'FCustomizedKeyConfig::InputTab' has a wrong offset!");
static_assert(offsetof(FCustomizedKeyConfig, KeyMappingType) == 0x000016, "Member 'FCustomizedKeyConfig::KeyMappingType' has a wrong offset!");
static_assert(offsetof(FCustomizedKeyConfig, GroupName) == 0x000018, "Member 'FCustomizedKeyConfig::GroupName' has a wrong offset!");
static_assert(offsetof(FCustomizedKeyConfig, GroupNameUIWordID) == 0x000028, "Member 'FCustomizedKeyConfig::GroupNameUIWordID' has a wrong offset!");
static_assert(offsetof(FCustomizedKeyConfig, UnlockCondition) == 0x00002C, "Member 'FCustomizedKeyConfig::UnlockCondition' has a wrong offset!");

// SharpStruct b1-Managed.MontageTestUnit
// 0x0018 (0x0018 - 0x0000)
struct FMontageTestUnit final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Describe;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMontageTestUnit) == 0x000008, "Wrong alignment on FMontageTestUnit");
static_assert(sizeof(FMontageTestUnit) == 0x000018, "Wrong size on FMontageTestUnit");
static_assert(offsetof(FMontageTestUnit, Montage) == 0x000000, "Member 'FMontageTestUnit::Montage' has a wrong offset!");
static_assert(offsetof(FMontageTestUnit, Describe) == 0x000008, "Member 'FMontageTestUnit::Describe' has a wrong offset!");

// SharpStruct b1-Managed.FPEConfig
// 0x0038 (0x0038 - 0x0000)
struct FFPEConfig final
{
public:
	float                                         ProtectTime;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseValuePerSecond;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelValue;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBGWDataAsset_B1DBC*                    DBC_EnterLevel;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BuffIDList;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 BuffIDList_LevelUp;                                // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFPEConfig) == 0x000008, "Wrong alignment on FFPEConfig");
static_assert(sizeof(FFPEConfig) == 0x000038, "Wrong size on FFPEConfig");
static_assert(offsetof(FFPEConfig, ProtectTime) == 0x000000, "Member 'FFPEConfig::ProtectTime' has a wrong offset!");
static_assert(offsetof(FFPEConfig, DecreaseValuePerSecond) == 0x000004, "Member 'FFPEConfig::DecreaseValuePerSecond' has a wrong offset!");
static_assert(offsetof(FFPEConfig, LevelValue) == 0x000008, "Member 'FFPEConfig::LevelValue' has a wrong offset!");
static_assert(offsetof(FFPEConfig, DBC_EnterLevel) == 0x000010, "Member 'FFPEConfig::DBC_EnterLevel' has a wrong offset!");
static_assert(offsetof(FFPEConfig, BuffIDList) == 0x000018, "Member 'FFPEConfig::BuffIDList' has a wrong offset!");
static_assert(offsetof(FFPEConfig, BuffIDList_LevelUp) == 0x000028, "Member 'FFPEConfig::BuffIDList_LevelUp' has a wrong offset!");

// SharpStruct b1-Managed.FieldBuffInfo
// 0x0010 (0x0010 - 0x0000)
struct FFieldBuffInfo final
{
public:
	uint8                                         bIgnoreTypeFilter : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetTeamFilter;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetTypeFilter;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffID;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldBuffInfo) == 0x000004, "Wrong alignment on FFieldBuffInfo");
static_assert(sizeof(FFieldBuffInfo) == 0x000010, "Wrong size on FFieldBuffInfo");
static_assert(offsetof(FFieldBuffInfo, TargetTeamFilter) == 0x000004, "Member 'FFieldBuffInfo::TargetTeamFilter' has a wrong offset!");
static_assert(offsetof(FFieldBuffInfo, TargetTypeFilter) == 0x000008, "Member 'FFieldBuffInfo::TargetTypeFilter' has a wrong offset!");
static_assert(offsetof(FFieldBuffInfo, BuffID) == 0x00000C, "Member 'FFieldBuffInfo::BuffID' has a wrong offset!");

// SharpStruct b1-Managed.MaterialParameterConfig
// 0x0028 (0x0028 - 0x0000)
struct FMaterialParameterConfig final
{
public:
	float                                         InterpSpeed;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AttrValueMapCurve;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParameterAssociation                 ParameterAssociation;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0014(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialFunctionInterface*             ParameterLayerFunction;                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialParameterConfig) == 0x000008, "Wrong alignment on FMaterialParameterConfig");
static_assert(sizeof(FMaterialParameterConfig) == 0x000028, "Wrong size on FMaterialParameterConfig");
static_assert(offsetof(FMaterialParameterConfig, InterpSpeed) == 0x000000, "Member 'FMaterialParameterConfig::InterpSpeed' has a wrong offset!");
static_assert(offsetof(FMaterialParameterConfig, AttrValueMapCurve) == 0x000008, "Member 'FMaterialParameterConfig::AttrValueMapCurve' has a wrong offset!");
static_assert(offsetof(FMaterialParameterConfig, ParameterAssociation) == 0x000010, "Member 'FMaterialParameterConfig::ParameterAssociation' has a wrong offset!");
static_assert(offsetof(FMaterialParameterConfig, ParameterName) == 0x000014, "Member 'FMaterialParameterConfig::ParameterName' has a wrong offset!");
static_assert(offsetof(FMaterialParameterConfig, ParameterLayerFunction) == 0x000020, "Member 'FMaterialParameterConfig::ParameterLayerFunction' has a wrong offset!");

// SharpStruct b1-Managed.ChangeMaterialByUnitAttrConfig
// 0x0018 (0x0018 - 0x0000)
struct FChangeMaterialByUnitAttrConfig final
{
public:
	EChangeMatUnitAttrType                        UnitAttrType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialParameterConfig>       MaterialParameterConfig;                           // 0x0008(0x0010)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChangeMaterialByUnitAttrConfig) == 0x000008, "Wrong alignment on FChangeMaterialByUnitAttrConfig");
static_assert(sizeof(FChangeMaterialByUnitAttrConfig) == 0x000018, "Wrong size on FChangeMaterialByUnitAttrConfig");
static_assert(offsetof(FChangeMaterialByUnitAttrConfig, UnitAttrType) == 0x000000, "Member 'FChangeMaterialByUnitAttrConfig::UnitAttrType' has a wrong offset!");
static_assert(offsetof(FChangeMaterialByUnitAttrConfig, MaterialParameterConfig) == 0x000008, "Member 'FChangeMaterialByUnitAttrConfig::MaterialParameterConfig' has a wrong offset!");

// SharpStruct b1-Managed.FGSSplineFlyMoveWaitPoint
// 0x0020 (0x0020 - 0x0000)
struct FFGSSplineFlyMoveWaitPoint final
{
public:
	uint8                                         IsUnlimitedNeedWaitTime : 1;                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTime;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WaitAM;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardSplineRangeAfterWaiting;                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionInterpSpeed;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSplineFlyMoveWaitPoint) == 0x000008, "Wrong alignment on FFGSSplineFlyMoveWaitPoint");
static_assert(sizeof(FFGSSplineFlyMoveWaitPoint) == 0x000020, "Wrong size on FFGSSplineFlyMoveWaitPoint");
static_assert(offsetof(FFGSSplineFlyMoveWaitPoint, WaitTime) == 0x000004, "Member 'FFGSSplineFlyMoveWaitPoint::WaitTime' has a wrong offset!");
static_assert(offsetof(FFGSSplineFlyMoveWaitPoint, WaitAM) == 0x000008, "Member 'FFGSSplineFlyMoveWaitPoint::WaitAM' has a wrong offset!");
static_assert(offsetof(FFGSSplineFlyMoveWaitPoint, ForwardSplineRangeAfterWaiting) == 0x000010, "Member 'FFGSSplineFlyMoveWaitPoint::ForwardSplineRangeAfterWaiting' has a wrong offset!");
static_assert(offsetof(FFGSSplineFlyMoveWaitPoint, TransitionInterpSpeed) == 0x000014, "Member 'FFGSSplineFlyMoveWaitPoint::TransitionInterpSpeed' has a wrong offset!");
static_assert(offsetof(FFGSSplineFlyMoveWaitPoint, RotationInterpSpeed) == 0x000018, "Member 'FFGSSplineFlyMoveWaitPoint::RotationInterpSpeed' has a wrong offset!");

// SharpStruct b1-Managed.FGSSplineFlyMoveInfo
// 0x0050 (0x0050 - 0x0000)
struct FFGSSplineFlyMoveInfo final
{
public:
	TMap<int32, struct FFGSSplineFlyMoveWaitPoint> WaitPointDict;                                     // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSplineFlyMoveInfo) == 0x000008, "Wrong alignment on FFGSSplineFlyMoveInfo");
static_assert(sizeof(FFGSSplineFlyMoveInfo) == 0x000050, "Wrong size on FFGSSplineFlyMoveInfo");
static_assert(offsetof(FFGSSplineFlyMoveInfo, WaitPointDict) == 0x000000, "Member 'FFGSSplineFlyMoveInfo::WaitPointDict' has a wrong offset!");

// SharpStruct b1-Managed.CloudMoveBreakSkillConfig
// 0x0008 (0x0008 - 0x0000)
struct FCloudMoveBreakSkillConfig final
{
public:
	int32                                         BreakSkill_Low;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BreakSkill_High;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudMoveBreakSkillConfig) == 0x000004, "Wrong alignment on FCloudMoveBreakSkillConfig");
static_assert(sizeof(FCloudMoveBreakSkillConfig) == 0x000008, "Wrong size on FCloudMoveBreakSkillConfig");
static_assert(offsetof(FCloudMoveBreakSkillConfig, BreakSkill_Low) == 0x000000, "Member 'FCloudMoveBreakSkillConfig::BreakSkill_Low' has a wrong offset!");
static_assert(offsetof(FCloudMoveBreakSkillConfig, BreakSkill_High) == 0x000004, "Member 'FCloudMoveBreakSkillConfig::BreakSkill_High' has a wrong offset!");

// SharpStruct b1-Managed.AiBreakInteractionConversationInfo
// 0x0018 (0x0018 - 0x0000)
struct FAiBreakInteractionConversationInfo final
{
public:
	EAiBreakInteractionType                       AiBreakInteractionType;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AiConversationIDList;                              // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAiBreakInteractionConversationInfo) == 0x000008, "Wrong alignment on FAiBreakInteractionConversationInfo");
static_assert(sizeof(FAiBreakInteractionConversationInfo) == 0x000018, "Wrong size on FAiBreakInteractionConversationInfo");
static_assert(offsetof(FAiBreakInteractionConversationInfo, AiBreakInteractionType) == 0x000000, "Member 'FAiBreakInteractionConversationInfo::AiBreakInteractionType' has a wrong offset!");
static_assert(offsetof(FAiBreakInteractionConversationInfo, AiConversationIDList) == 0x000008, "Member 'FAiBreakInteractionConversationInfo::AiConversationIDList' has a wrong offset!");

// SharpStruct b1-Managed.FollowPartnerIdleWaitingInfo
// 0x0018 (0x0018 - 0x0000)
struct FFollowPartnerIdleWaitingInfo final
{
public:
	uint8                                         CanTrigger : 1;                                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TriggerCD;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   IdleRandomMontageList;                             // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFollowPartnerIdleWaitingInfo) == 0x000008, "Wrong alignment on FFollowPartnerIdleWaitingInfo");
static_assert(sizeof(FFollowPartnerIdleWaitingInfo) == 0x000018, "Wrong size on FFollowPartnerIdleWaitingInfo");
static_assert(offsetof(FFollowPartnerIdleWaitingInfo, TriggerCD) == 0x000004, "Member 'FFollowPartnerIdleWaitingInfo::TriggerCD' has a wrong offset!");
static_assert(offsetof(FFollowPartnerIdleWaitingInfo, IdleRandomMontageList) == 0x000008, "Member 'FFollowPartnerIdleWaitingInfo::IdleRandomMontageList' has a wrong offset!");

// SharpStruct b1-Managed.SilkEntangleNiagaraParamMapping
// 0x0018 (0x0018 - 0x0000)
struct FSilkEntangleNiagaraParamMapping final
{
public:
	class FName                                   NiagaraParamName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MappingCurve_CountTotal;                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSilkEntangleNiagaraParamMapping) == 0x000008, "Wrong alignment on FSilkEntangleNiagaraParamMapping");
static_assert(sizeof(FSilkEntangleNiagaraParamMapping) == 0x000018, "Wrong size on FSilkEntangleNiagaraParamMapping");
static_assert(offsetof(FSilkEntangleNiagaraParamMapping, NiagaraParamName) == 0x000000, "Member 'FSilkEntangleNiagaraParamMapping::NiagaraParamName' has a wrong offset!");
static_assert(offsetof(FSilkEntangleNiagaraParamMapping, Ratio) == 0x000008, "Member 'FSilkEntangleNiagaraParamMapping::Ratio' has a wrong offset!");
static_assert(offsetof(FSilkEntangleNiagaraParamMapping, MappingCurve_CountTotal) == 0x000010, "Member 'FSilkEntangleNiagaraParamMapping::MappingCurve_CountTotal' has a wrong offset!");

// SharpStruct b1-Managed.MatLayerFunctionInfo
// 0x0010 (0x0010 - 0x0000)
struct FMatLayerFunctionInfo final
{
public:
	EMaterialParameterAssociation                 Association;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialFunctionInterface*             LayerFunction;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatLayerFunctionInfo) == 0x000008, "Wrong alignment on FMatLayerFunctionInfo");
static_assert(sizeof(FMatLayerFunctionInfo) == 0x000010, "Wrong size on FMatLayerFunctionInfo");
static_assert(offsetof(FMatLayerFunctionInfo, Association) == 0x000000, "Member 'FMatLayerFunctionInfo::Association' has a wrong offset!");
static_assert(offsetof(FMatLayerFunctionInfo, LayerFunction) == 0x000008, "Member 'FMatLayerFunctionInfo::LayerFunction' has a wrong offset!");

// SharpStruct b1-Managed.CricketJumpPlayerAnimConfig
// 0x0010 (0x0010 - 0x0000)
struct FCricketJumpPlayerAnimConfig final
{
public:
	class UAnimMontage*                           AMPlayerJump;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimDummyMeshJump;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCricketJumpPlayerAnimConfig) == 0x000008, "Wrong alignment on FCricketJumpPlayerAnimConfig");
static_assert(sizeof(FCricketJumpPlayerAnimConfig) == 0x000010, "Wrong size on FCricketJumpPlayerAnimConfig");
static_assert(offsetof(FCricketJumpPlayerAnimConfig, AMPlayerJump) == 0x000000, "Member 'FCricketJumpPlayerAnimConfig::AMPlayerJump' has a wrong offset!");
static_assert(offsetof(FCricketJumpPlayerAnimConfig, AnimDummyMeshJump) == 0x000008, "Member 'FCricketJumpPlayerAnimConfig::AnimDummyMeshJump' has a wrong offset!");

// SharpStruct b1-Managed.HiAltFxAnimalSpawnTemplate
// 0x0060 (0x0060 - 0x0000)
struct FHiAltFxAnimalSpawnTemplate final
{
public:
	TArray<class UClass*>                         FXAnimalTemplateList;                              // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UEnvQuery*>                      EQSTemplateList;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFloatRange                            ZOffset;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseHighestScorePoint : 1;                         // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHiAltFxAnimalRotInfo                  RotInfo;                                           // 0x0038(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReSpawnCoolDown;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiAltFxAnimalSpawnTemplate) == 0x000008, "Wrong alignment on FHiAltFxAnimalSpawnTemplate");
static_assert(sizeof(FHiAltFxAnimalSpawnTemplate) == 0x000060, "Wrong size on FHiAltFxAnimalSpawnTemplate");
static_assert(offsetof(FHiAltFxAnimalSpawnTemplate, FXAnimalTemplateList) == 0x000000, "Member 'FHiAltFxAnimalSpawnTemplate::FXAnimalTemplateList' has a wrong offset!");
static_assert(offsetof(FHiAltFxAnimalSpawnTemplate, EQSTemplateList) == 0x000010, "Member 'FHiAltFxAnimalSpawnTemplate::EQSTemplateList' has a wrong offset!");
static_assert(offsetof(FHiAltFxAnimalSpawnTemplate, ZOffset) == 0x000020, "Member 'FHiAltFxAnimalSpawnTemplate::ZOffset' has a wrong offset!");
static_assert(offsetof(FHiAltFxAnimalSpawnTemplate, RotInfo) == 0x000038, "Member 'FHiAltFxAnimalSpawnTemplate::RotInfo' has a wrong offset!");
static_assert(offsetof(FHiAltFxAnimalSpawnTemplate, ReSpawnCoolDown) == 0x000058, "Member 'FHiAltFxAnimalSpawnTemplate::ReSpawnCoolDown' has a wrong offset!");

// SharpStruct b1-Managed.BulletSkillTestInfo
// 0x0018 (0x0018 - 0x0000)
struct FBulletSkillTestInfo final
{
public:
	class ABUTamerActor*                          TamerActor;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillIdList;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletSkillTestInfo) == 0x000008, "Wrong alignment on FBulletSkillTestInfo");
static_assert(sizeof(FBulletSkillTestInfo) == 0x000018, "Wrong size on FBulletSkillTestInfo");
static_assert(offsetof(FBulletSkillTestInfo, TamerActor) == 0x000000, "Member 'FBulletSkillTestInfo::TamerActor' has a wrong offset!");
static_assert(offsetof(FBulletSkillTestInfo, SkillIdList) == 0x000008, "Member 'FBulletSkillTestInfo::SkillIdList' has a wrong offset!");

// SharpStruct b1-Managed.ResourceID_PreloadOutlaws
// 0x0010 (0x0010 - 0x0000)
struct FResourceID_PreloadOutlaws final
{
public:
	TArray<struct FResourceID_PreloadOutlaw>      Array;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceID_PreloadOutlaws) == 0x000008, "Wrong alignment on FResourceID_PreloadOutlaws");
static_assert(sizeof(FResourceID_PreloadOutlaws) == 0x000010, "Wrong size on FResourceID_PreloadOutlaws");
static_assert(offsetof(FResourceID_PreloadOutlaws, Array) == 0x000000, "Member 'FResourceID_PreloadOutlaws::Array' has a wrong offset!");

// SharpStruct b1-Managed.BattleAttrSnapShot
// 0x0024 (0x0024 - 0x0000)
struct FBattleAttrSnapShot final
{
public:
	float                                         Attr_CritRate;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attr_Atk;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attr_CritMultiplier;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attr_DmgAddition;                                  // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attr_FreezeAtk;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attr_BurnAtk;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attr_PoisonAtk;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attr_ThunderAtk;                                   // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Attr_IgnoreTargetElemDef : 1;                      // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_20_1 : 7;                                   // 0x0020(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bSettedFlag : 1;                                   // 0x0021(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_21_1 : 7;                                   // 0x0021(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bDmgFromAbnormal : 1;                              // 0x0022(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         BitPad_22_1 : 7;                                   // 0x0022(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bAttackerIsPlayer_ForDmgNumer : 1;                 // 0x0023(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
};
static_assert(alignof(FBattleAttrSnapShot) == 0x000004, "Wrong alignment on FBattleAttrSnapShot");
static_assert(sizeof(FBattleAttrSnapShot) == 0x000024, "Wrong size on FBattleAttrSnapShot");
static_assert(offsetof(FBattleAttrSnapShot, Attr_CritRate) == 0x000000, "Member 'FBattleAttrSnapShot::Attr_CritRate' has a wrong offset!");
static_assert(offsetof(FBattleAttrSnapShot, Attr_Atk) == 0x000004, "Member 'FBattleAttrSnapShot::Attr_Atk' has a wrong offset!");
static_assert(offsetof(FBattleAttrSnapShot, Attr_CritMultiplier) == 0x000008, "Member 'FBattleAttrSnapShot::Attr_CritMultiplier' has a wrong offset!");
static_assert(offsetof(FBattleAttrSnapShot, Attr_DmgAddition) == 0x00000C, "Member 'FBattleAttrSnapShot::Attr_DmgAddition' has a wrong offset!");
static_assert(offsetof(FBattleAttrSnapShot, Attr_FreezeAtk) == 0x000010, "Member 'FBattleAttrSnapShot::Attr_FreezeAtk' has a wrong offset!");
static_assert(offsetof(FBattleAttrSnapShot, Attr_BurnAtk) == 0x000014, "Member 'FBattleAttrSnapShot::Attr_BurnAtk' has a wrong offset!");
static_assert(offsetof(FBattleAttrSnapShot, Attr_PoisonAtk) == 0x000018, "Member 'FBattleAttrSnapShot::Attr_PoisonAtk' has a wrong offset!");
static_assert(offsetof(FBattleAttrSnapShot, Attr_ThunderAtk) == 0x00001C, "Member 'FBattleAttrSnapShot::Attr_ThunderAtk' has a wrong offset!");

// SharpStruct b1-Managed.PhysicBlendInfoForDeath
// 0x0010 (0x0010 - 0x0000)
struct FPhysicBlendInfoForDeath final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicBlendInType                            PhysicBlendInType;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendFinalValue;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicBlendInfoForDeath) == 0x000004, "Wrong alignment on FPhysicBlendInfoForDeath");
static_assert(sizeof(FPhysicBlendInfoForDeath) == 0x000010, "Wrong size on FPhysicBlendInfoForDeath");
static_assert(offsetof(FPhysicBlendInfoForDeath, BoneName) == 0x000000, "Member 'FPhysicBlendInfoForDeath::BoneName' has a wrong offset!");
static_assert(offsetof(FPhysicBlendInfoForDeath, PhysicBlendInType) == 0x000008, "Member 'FPhysicBlendInfoForDeath::PhysicBlendInType' has a wrong offset!");
static_assert(offsetof(FPhysicBlendInfoForDeath, BlendFinalValue) == 0x00000C, "Member 'FPhysicBlendInfoForDeath::BlendFinalValue' has a wrong offset!");

// SharpStruct b1-Managed.MFOverlapEvent
// 0x0040 (0x0040 - 0x0000)
struct FMFOverlapEvent final
{
public:
	EMFOverlapEventType                           OverlapEventType;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetTeamFilter;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetTypeFilter;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFGSBuffInfo>                   BuffList;                                          // 0x0010(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillEffectList;                                   // 0x0020(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FString                                 Note;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMFOverlapEvent) == 0x000008, "Wrong alignment on FMFOverlapEvent");
static_assert(sizeof(FMFOverlapEvent) == 0x000040, "Wrong size on FMFOverlapEvent");
static_assert(offsetof(FMFOverlapEvent, OverlapEventType) == 0x000000, "Member 'FMFOverlapEvent::OverlapEventType' has a wrong offset!");
static_assert(offsetof(FMFOverlapEvent, TargetTeamFilter) == 0x000004, "Member 'FMFOverlapEvent::TargetTeamFilter' has a wrong offset!");
static_assert(offsetof(FMFOverlapEvent, TargetTypeFilter) == 0x000008, "Member 'FMFOverlapEvent::TargetTypeFilter' has a wrong offset!");
static_assert(offsetof(FMFOverlapEvent, BuffList) == 0x000010, "Member 'FMFOverlapEvent::BuffList' has a wrong offset!");
static_assert(offsetof(FMFOverlapEvent, SkillEffectList) == 0x000020, "Member 'FMFOverlapEvent::SkillEffectList' has a wrong offset!");
static_assert(offsetof(FMFOverlapEvent, Note) == 0x000030, "Member 'FMFOverlapEvent::Note' has a wrong offset!");

// SharpStruct b1-Managed.MFDirectionEffect
// 0x0070 (0x0070 - 0x0000)
struct FMFDirectionEffect final
{
public:
	EMagicFieldEffectTriggerEvent                 TriggerEvent;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIgnoreTypeFilter : 1;                             // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetTeamFilter;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetTypeFilter;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMagicFieldEffectDirectionType                EffectDirectionType;                               // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardAngle;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardAngle;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftSideAngle;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightSideAngle;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMFEffect>                      ForwardEffects;                                    // 0x0020(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FMFEffect>                      BackwardEffects;                                   // 0x0030(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FMFEffect>                      LeftSideEffects;                                   // 0x0040(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FMFEffect>                      RightSideEffects;                                  // 0x0050(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FString                                 DisplayNote;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMFDirectionEffect) == 0x000008, "Wrong alignment on FMFDirectionEffect");
static_assert(sizeof(FMFDirectionEffect) == 0x000070, "Wrong size on FMFDirectionEffect");
static_assert(offsetof(FMFDirectionEffect, TriggerEvent) == 0x000000, "Member 'FMFDirectionEffect::TriggerEvent' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, TargetTeamFilter) == 0x000004, "Member 'FMFDirectionEffect::TargetTeamFilter' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, TargetTypeFilter) == 0x000008, "Member 'FMFDirectionEffect::TargetTypeFilter' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, EffectDirectionType) == 0x00000C, "Member 'FMFDirectionEffect::EffectDirectionType' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, ForwardAngle) == 0x000010, "Member 'FMFDirectionEffect::ForwardAngle' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, BackwardAngle) == 0x000014, "Member 'FMFDirectionEffect::BackwardAngle' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, LeftSideAngle) == 0x000018, "Member 'FMFDirectionEffect::LeftSideAngle' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, RightSideAngle) == 0x00001C, "Member 'FMFDirectionEffect::RightSideAngle' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, ForwardEffects) == 0x000020, "Member 'FMFDirectionEffect::ForwardEffects' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, BackwardEffects) == 0x000030, "Member 'FMFDirectionEffect::BackwardEffects' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, LeftSideEffects) == 0x000040, "Member 'FMFDirectionEffect::LeftSideEffects' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, RightSideEffects) == 0x000050, "Member 'FMFDirectionEffect::RightSideEffects' has a wrong offset!");
static_assert(offsetof(FMFDirectionEffect, DisplayNote) == 0x000060, "Member 'FMFDirectionEffect::DisplayNote' has a wrong offset!");

// SharpStruct b1-Managed.UnitTeam
// 0x0010 (0x0010 - 0x0000)
struct FUnitTeam final
{
public:
	TArray<class ABGUCharacterCS*>                CharacterList;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitTeam) == 0x000008, "Wrong alignment on FUnitTeam");
static_assert(sizeof(FUnitTeam) == 0x000010, "Wrong size on FUnitTeam");
static_assert(offsetof(FUnitTeam, CharacterList) == 0x000000, "Member 'FUnitTeam::CharacterList' has a wrong offset!");

// SharpStruct b1-Managed.CameraBlendData
// 0x00B8 (0x00B8 - 0x0000)
struct FCameraBlendData final
{
public:
	struct FRotator                               ControllerRotation;                                // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpringArmTargetLength;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringArmTargetLengthOffset;                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SprintArmSocketOffset;                             // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SprintArmTargetOffset;                             // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraOffset;                                      // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation;                                    // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FieldOfView;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldOfViewOffset;                                 // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControllerYawInput;                                // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsXAxisSmoothed : 1;                               // 0x008C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_8C_1 : 7;                                   // 0x008C(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsYAxisSmoothed : 1;                               // 0x008D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_8D_1 : 7;                                   // 0x008D(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsZAxisSmoothed : 1;                               // 0x008E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_8F[0x1];                                       // 0x008F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpringArmRelativeLocation;                         // 0x0090(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCameraLagSpeed;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocalDistance;                                     // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBlurKM;                                       // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthBlurRadius;                                   // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraBlendData) == 0x000008, "Wrong alignment on FCameraBlendData");
static_assert(sizeof(FCameraBlendData) == 0x0000B8, "Wrong size on FCameraBlendData");
static_assert(offsetof(FCameraBlendData, ControllerRotation) == 0x000000, "Member 'FCameraBlendData::ControllerRotation' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, SpringArmTargetLength) == 0x000018, "Member 'FCameraBlendData::SpringArmTargetLength' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, SpringArmTargetLengthOffset) == 0x00001C, "Member 'FCameraBlendData::SpringArmTargetLengthOffset' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, SprintArmSocketOffset) == 0x000020, "Member 'FCameraBlendData::SprintArmSocketOffset' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, SprintArmTargetOffset) == 0x000038, "Member 'FCameraBlendData::SprintArmTargetOffset' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, CameraOffset) == 0x000050, "Member 'FCameraBlendData::CameraOffset' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, CameraRotation) == 0x000068, "Member 'FCameraBlendData::CameraRotation' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, FieldOfView) == 0x000080, "Member 'FCameraBlendData::FieldOfView' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, FieldOfViewOffset) == 0x000084, "Member 'FCameraBlendData::FieldOfViewOffset' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, ControllerYawInput) == 0x000088, "Member 'FCameraBlendData::ControllerYawInput' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, SpringArmRelativeLocation) == 0x000090, "Member 'FCameraBlendData::SpringArmRelativeLocation' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, CurrentCameraLagSpeed) == 0x0000A8, "Member 'FCameraBlendData::CurrentCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, FocalDistance) == 0x0000AC, "Member 'FCameraBlendData::FocalDistance' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, DepthBlurKM) == 0x0000B0, "Member 'FCameraBlendData::DepthBlurKM' has a wrong offset!");
static_assert(offsetof(FCameraBlendData, DepthBlurRadius) == 0x0000B4, "Member 'FCameraBlendData::DepthBlurRadius' has a wrong offset!");

// SharpStruct b1-Managed.FGSArmorSettingInBP
// 0x0050 (0x0050 - 0x0000)
struct FFGSArmorSettingInBP final
{
public:
	uint8                                         Armor_Enable : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_0_1 : 7;                                    // 0x0000(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         IsGetTopRandomSkill : 1;                           // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TopRandomSkillPercent;                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Armor_SkillID;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Armor_Timer;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFightBackCountType                           BeHitCountType;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OriBeHitNum_Min;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriBeHitNum_Max;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFGSArmorCounterWithBlood>      CounterWithBloodConfig;                            // 0x0028(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MaxBlockTimes;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerfectBlockTimes;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockCoolDownTime;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResetBlockCounterTime;                             // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWDataAsset_BlockInfoConfig*          DefaultBlockInfoConfig;                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSArmorSettingInBP) == 0x000008, "Wrong alignment on FFGSArmorSettingInBP");
static_assert(sizeof(FFGSArmorSettingInBP) == 0x000050, "Wrong size on FFGSArmorSettingInBP");
static_assert(offsetof(FFGSArmorSettingInBP, TopRandomSkillPercent) == 0x000004, "Member 'FFGSArmorSettingInBP::TopRandomSkillPercent' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, Armor_SkillID) == 0x000008, "Member 'FFGSArmorSettingInBP::Armor_SkillID' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, Armor_Timer) == 0x000018, "Member 'FFGSArmorSettingInBP::Armor_Timer' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, BeHitCountType) == 0x00001C, "Member 'FFGSArmorSettingInBP::BeHitCountType' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, OriBeHitNum_Min) == 0x000020, "Member 'FFGSArmorSettingInBP::OriBeHitNum_Min' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, OriBeHitNum_Max) == 0x000024, "Member 'FFGSArmorSettingInBP::OriBeHitNum_Max' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, CounterWithBloodConfig) == 0x000028, "Member 'FFGSArmorSettingInBP::CounterWithBloodConfig' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, MaxBlockTimes) == 0x000038, "Member 'FFGSArmorSettingInBP::MaxBlockTimes' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, PerfectBlockTimes) == 0x00003C, "Member 'FFGSArmorSettingInBP::PerfectBlockTimes' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, BlockCoolDownTime) == 0x000040, "Member 'FFGSArmorSettingInBP::BlockCoolDownTime' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, ResetBlockCounterTime) == 0x000044, "Member 'FFGSArmorSettingInBP::ResetBlockCounterTime' has a wrong offset!");
static_assert(offsetof(FFGSArmorSettingInBP, DefaultBlockInfoConfig) == 0x000048, "Member 'FFGSArmorSettingInBP::DefaultBlockInfoConfig' has a wrong offset!");

// SharpStruct b1-Managed.FGSWakeUpConfig
// 0x0078 (0x0078 - 0x0000)
struct FFGSWakeUpConfig final
{
public:
	int32                                         OnFightSkillID;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFGSWakeUpDirectionOnFightSkillConfig  DirectionOnFightSkillConfig;                       // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bJustUseOnFightSkillFirstTime : 1;                 // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SurpriseSkillID;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         WakeUpLinkEnable : 1;                              // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_28_1 : 7;                                   // 0x0028(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         CanTriggerWakeUpLinkWhenDead : 1;                  // 0x0029(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_29_1 : 7;                                   // 0x0029(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         UseManualSelect : 1;                               // 0x002A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABGUCharacter*>                  TargetList;                                        // 0x0030(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<class ABUTamerActor*>                  TargetTamerList;                                   // 0x0040(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         UseRangeSelect : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ERangeType                                    RangeType;                                         // 0x0051(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangeParam_1;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeParam_2;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeParam_3;                                      // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ResIDList;                                         // 0x0060(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         bSelectUnitHasTarget : 1;                          // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_70_1 : 7;                                   // 0x0070(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bSelectPassiveUnit : 1;                            // 0x0071(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FFGSWakeUpConfig) == 0x000008, "Wrong alignment on FFGSWakeUpConfig");
static_assert(sizeof(FFGSWakeUpConfig) == 0x000078, "Wrong size on FFGSWakeUpConfig");
static_assert(offsetof(FFGSWakeUpConfig, OnFightSkillID) == 0x000000, "Member 'FFGSWakeUpConfig::OnFightSkillID' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, DirectionOnFightSkillConfig) == 0x000004, "Member 'FFGSWakeUpConfig::DirectionOnFightSkillConfig' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, SurpriseSkillID) == 0x000018, "Member 'FFGSWakeUpConfig::SurpriseSkillID' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, TargetList) == 0x000030, "Member 'FFGSWakeUpConfig::TargetList' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, TargetTamerList) == 0x000040, "Member 'FFGSWakeUpConfig::TargetTamerList' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, RangeType) == 0x000051, "Member 'FFGSWakeUpConfig::RangeType' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, RangeParam_1) == 0x000054, "Member 'FFGSWakeUpConfig::RangeParam_1' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, RangeParam_2) == 0x000058, "Member 'FFGSWakeUpConfig::RangeParam_2' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, RangeParam_3) == 0x00005C, "Member 'FFGSWakeUpConfig::RangeParam_3' has a wrong offset!");
static_assert(offsetof(FFGSWakeUpConfig, ResIDList) == 0x000060, "Member 'FFGSWakeUpConfig::ResIDList' has a wrong offset!");

// SharpStruct b1-Managed.FGSMeleeAutoLockSetting
// 0x0010 (0x0010 - 0x0000)
struct FFGSMeleeAutoLockSetting final
{
public:
	float                                         Range;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleMax;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSpeed;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreferActorDistTolerance;                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSMeleeAutoLockSetting) == 0x000004, "Wrong alignment on FFGSMeleeAutoLockSetting");
static_assert(sizeof(FFGSMeleeAutoLockSetting) == 0x000010, "Wrong size on FFGSMeleeAutoLockSetting");
static_assert(offsetof(FFGSMeleeAutoLockSetting, Range) == 0x000000, "Member 'FFGSMeleeAutoLockSetting::Range' has a wrong offset!");
static_assert(offsetof(FFGSMeleeAutoLockSetting, AngleMax) == 0x000004, "Member 'FFGSMeleeAutoLockSetting::AngleMax' has a wrong offset!");
static_assert(offsetof(FFGSMeleeAutoLockSetting, TurnSpeed) == 0x000008, "Member 'FFGSMeleeAutoLockSetting::TurnSpeed' has a wrong offset!");
static_assert(offsetof(FFGSMeleeAutoLockSetting, PreferActorDistTolerance) == 0x00000C, "Member 'FFGSMeleeAutoLockSetting::PreferActorDistTolerance' has a wrong offset!");

// SharpStruct b1-Managed.FGSMotionMatchingSetting
// 0x0038 (0x0038 - 0x0000)
struct FFGSMotionMatchingSetting final
{
public:
	uint8                                         UseMotionMatching : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EState_MM                                     DefaultMMState;                                    // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAnalyzer*                     AA_Locking;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAnalyzer*                     AA_Free;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationAnalyzerBlendTime;                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBlendTime;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControllerInputReactionSpeed;                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControllerRotationReactionSpeed;                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeginStandRotateAngleOffset;                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandRotateReactionSpeed;                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceSetRotAnimSpeed;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableRotVerifyAnimSpeed;                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSMotionMatchingSetting) == 0x000008, "Wrong alignment on FFGSMotionMatchingSetting");
static_assert(sizeof(FFGSMotionMatchingSetting) == 0x000038, "Wrong size on FFGSMotionMatchingSetting");
static_assert(offsetof(FFGSMotionMatchingSetting, DefaultMMState) == 0x000001, "Member 'FFGSMotionMatchingSetting::DefaultMMState' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, AA_Locking) == 0x000008, "Member 'FFGSMotionMatchingSetting::AA_Locking' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, AA_Free) == 0x000010, "Member 'FFGSMotionMatchingSetting::AA_Free' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, AnimationAnalyzerBlendTime) == 0x000018, "Member 'FFGSMotionMatchingSetting::AnimationAnalyzerBlendTime' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, MotionBlendTime) == 0x00001C, "Member 'FFGSMotionMatchingSetting::MotionBlendTime' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, ControllerInputReactionSpeed) == 0x000020, "Member 'FFGSMotionMatchingSetting::ControllerInputReactionSpeed' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, ControllerRotationReactionSpeed) == 0x000024, "Member 'FFGSMotionMatchingSetting::ControllerRotationReactionSpeed' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, BeginStandRotateAngleOffset) == 0x000028, "Member 'FFGSMotionMatchingSetting::BeginStandRotateAngleOffset' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, StandRotateReactionSpeed) == 0x00002C, "Member 'FFGSMotionMatchingSetting::StandRotateReactionSpeed' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, ForceSetRotAnimSpeed) == 0x000030, "Member 'FFGSMotionMatchingSetting::ForceSetRotAnimSpeed' has a wrong offset!");
static_assert(offsetof(FFGSMotionMatchingSetting, DisableRotVerifyAnimSpeed) == 0x000034, "Member 'FFGSMotionMatchingSetting::DisableRotVerifyAnimSpeed' has a wrong offset!");

// SharpStruct b1-Managed.FGSTurnSkillConfig
// 0x001C (0x001C - 0x0000)
struct FFGSTurnSkillConfig final
{
public:
	int32                                         TurnDegreeThresholdLow;                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TurnDegreeThresholdHigh;                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftSmallTurnSkillID;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftBigTurnSkillID;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightSmallTurnSkillID;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightBigTurnSkillID;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDisableImmediatePathfinding : 1;                  // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FFGSTurnSkillConfig) == 0x000004, "Wrong alignment on FFGSTurnSkillConfig");
static_assert(sizeof(FFGSTurnSkillConfig) == 0x00001C, "Wrong size on FFGSTurnSkillConfig");
static_assert(offsetof(FFGSTurnSkillConfig, TurnDegreeThresholdLow) == 0x000000, "Member 'FFGSTurnSkillConfig::TurnDegreeThresholdLow' has a wrong offset!");
static_assert(offsetof(FFGSTurnSkillConfig, TurnDegreeThresholdHigh) == 0x000004, "Member 'FFGSTurnSkillConfig::TurnDegreeThresholdHigh' has a wrong offset!");
static_assert(offsetof(FFGSTurnSkillConfig, LeftSmallTurnSkillID) == 0x000008, "Member 'FFGSTurnSkillConfig::LeftSmallTurnSkillID' has a wrong offset!");
static_assert(offsetof(FFGSTurnSkillConfig, LeftBigTurnSkillID) == 0x00000C, "Member 'FFGSTurnSkillConfig::LeftBigTurnSkillID' has a wrong offset!");
static_assert(offsetof(FFGSTurnSkillConfig, RightSmallTurnSkillID) == 0x000010, "Member 'FFGSTurnSkillConfig::RightSmallTurnSkillID' has a wrong offset!");
static_assert(offsetof(FFGSTurnSkillConfig, RightBigTurnSkillID) == 0x000014, "Member 'FFGSTurnSkillConfig::RightBigTurnSkillID' has a wrong offset!");

// SharpStruct b1-Managed.FGSSpawnProbabilityConfig
// 0x0078 (0x0078 - 0x0000)
struct FFGSSpawnProbabilityConfig final
{
public:
	class FString                                 Describe;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNum;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNum;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlusRate;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChiefRate;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreshDelta;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class FString>                    ActorDict;                                         // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSpawnProbabilityConfig) == 0x000008, "Wrong alignment on FFGSSpawnProbabilityConfig");
static_assert(sizeof(FFGSSpawnProbabilityConfig) == 0x000078, "Wrong size on FFGSSpawnProbabilityConfig");
static_assert(offsetof(FFGSSpawnProbabilityConfig, Describe) == 0x000000, "Member 'FFGSSpawnProbabilityConfig::Describe' has a wrong offset!");
static_assert(offsetof(FFGSSpawnProbabilityConfig, MaxNum) == 0x000010, "Member 'FFGSSpawnProbabilityConfig::MaxNum' has a wrong offset!");
static_assert(offsetof(FFGSSpawnProbabilityConfig, MinNum) == 0x000014, "Member 'FFGSSpawnProbabilityConfig::MinNum' has a wrong offset!");
static_assert(offsetof(FFGSSpawnProbabilityConfig, PlusRate) == 0x000018, "Member 'FFGSSpawnProbabilityConfig::PlusRate' has a wrong offset!");
static_assert(offsetof(FFGSSpawnProbabilityConfig, ChiefRate) == 0x00001C, "Member 'FFGSSpawnProbabilityConfig::ChiefRate' has a wrong offset!");
static_assert(offsetof(FFGSSpawnProbabilityConfig, FreshDelta) == 0x000020, "Member 'FFGSSpawnProbabilityConfig::FreshDelta' has a wrong offset!");
static_assert(offsetof(FFGSSpawnProbabilityConfig, ActorDict) == 0x000028, "Member 'FFGSSpawnProbabilityConfig::ActorDict' has a wrong offset!");

// SharpStruct b1-Managed.FGSSpawnProbabilityGroup
// 0x0050 (0x0050 - 0x0000)
struct FFGSSpawnProbabilityGroup final
{
public:
	TMap<int32, struct FFGSSpawnProbabilityConfig> SpawnProbabilityGroup;                             // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSpawnProbabilityGroup) == 0x000008, "Wrong alignment on FFGSSpawnProbabilityGroup");
static_assert(sizeof(FFGSSpawnProbabilityGroup) == 0x000050, "Wrong size on FFGSSpawnProbabilityGroup");
static_assert(offsetof(FFGSSpawnProbabilityGroup, SpawnProbabilityGroup) == 0x000000, "Member 'FFGSSpawnProbabilityGroup::SpawnProbabilityGroup' has a wrong offset!");

// SharpStruct b1-Managed.OnlineSpawnConfig
// 0x000C (0x000C - 0x0000)
struct FOnlineSpawnConfig final
{
public:
	int32                                         SpawnNumOnline;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LowerLimitNumOnline;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReSpawnNumOnline;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineSpawnConfig) == 0x000004, "Wrong alignment on FOnlineSpawnConfig");
static_assert(sizeof(FOnlineSpawnConfig) == 0x00000C, "Wrong size on FOnlineSpawnConfig");
static_assert(offsetof(FOnlineSpawnConfig, SpawnNumOnline) == 0x000000, "Member 'FOnlineSpawnConfig::SpawnNumOnline' has a wrong offset!");
static_assert(offsetof(FOnlineSpawnConfig, LowerLimitNumOnline) == 0x000004, "Member 'FOnlineSpawnConfig::LowerLimitNumOnline' has a wrong offset!");
static_assert(offsetof(FOnlineSpawnConfig, ReSpawnNumOnline) == 0x000008, "Member 'FOnlineSpawnConfig::ReSpawnNumOnline' has a wrong offset!");

// SharpStruct b1-Managed.GamePlusSpawnerConfig
// 0x0010 (0x0010 - 0x0000)
struct FGamePlusSpawnerConfig final
{
public:
	int32                                         Rate;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ActorClass;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamePlusSpawnerConfig) == 0x000008, "Wrong alignment on FGamePlusSpawnerConfig");
static_assert(sizeof(FGamePlusSpawnerConfig) == 0x000010, "Wrong size on FGamePlusSpawnerConfig");
static_assert(offsetof(FGamePlusSpawnerConfig, Rate) == 0x000000, "Member 'FGamePlusSpawnerConfig::Rate' has a wrong offset!");
static_assert(offsetof(FGamePlusSpawnerConfig, ActorClass) == 0x000008, "Member 'FGamePlusSpawnerConfig::ActorClass' has a wrong offset!");

// SharpStruct b1-Managed.GamePlusSpawnConfig
// 0x0018 (0x0018 - 0x0000)
struct FGamePlusSpawnConfig final
{
public:
	int32                                         GamePlusCount;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGamePlusSpawnerConfig>         SpawnerConfig;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGamePlusSpawnConfig) == 0x000008, "Wrong alignment on FGamePlusSpawnConfig");
static_assert(sizeof(FGamePlusSpawnConfig) == 0x000018, "Wrong size on FGamePlusSpawnConfig");
static_assert(offsetof(FGamePlusSpawnConfig, GamePlusCount) == 0x000000, "Member 'FGamePlusSpawnConfig::GamePlusCount' has a wrong offset!");
static_assert(offsetof(FGamePlusSpawnConfig, SpawnerConfig) == 0x000008, "Member 'FGamePlusSpawnConfig::SpawnerConfig' has a wrong offset!");

// SharpStruct b1-Managed.FGSTurnSkillRange
// 0x0008 (0x0008 - 0x0000)
struct FFGSTurnSkillRange final
{
public:
	float                                         AngleLow;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHigh;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSTurnSkillRange) == 0x000004, "Wrong alignment on FFGSTurnSkillRange");
static_assert(sizeof(FFGSTurnSkillRange) == 0x000008, "Wrong size on FFGSTurnSkillRange");
static_assert(offsetof(FFGSTurnSkillRange, AngleLow) == 0x000000, "Member 'FFGSTurnSkillRange::AngleLow' has a wrong offset!");
static_assert(offsetof(FFGSTurnSkillRange, AngleHigh) == 0x000004, "Member 'FFGSTurnSkillRange::AngleHigh' has a wrong offset!");

// SharpStruct b1-Managed.FGSLeisureRandomConfig
// 0x0018 (0x0018 - 0x0000)
struct FFGSLeisureRandomConfig final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           RandomAnim;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CD_Time;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSLeisureRandomConfig) == 0x000008, "Wrong alignment on FFGSLeisureRandomConfig");
static_assert(sizeof(FFGSLeisureRandomConfig) == 0x000018, "Wrong size on FFGSLeisureRandomConfig");
static_assert(offsetof(FFGSLeisureRandomConfig, Weight) == 0x000000, "Member 'FFGSLeisureRandomConfig::Weight' has a wrong offset!");
static_assert(offsetof(FFGSLeisureRandomConfig, RandomAnim) == 0x000008, "Member 'FFGSLeisureRandomConfig::RandomAnim' has a wrong offset!");
static_assert(offsetof(FFGSLeisureRandomConfig, CD_Time) == 0x000010, "Member 'FFGSLeisureRandomConfig::CD_Time' has a wrong offset!");

// SharpStruct b1-Managed.FGSLeisureConfig
// 0x0020 (0x0020 - 0x0000)
struct FFGSLeisureConfig final
{
public:
	class UAnimMontage*                           LeisureAnim;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGroupSyncLeisure : 1;                             // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_8_1 : 7;                                    // 0x0008(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bRandomStartTime : 1;                              // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFGSLeisureRandomConfig>        RandomConfig;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSLeisureConfig) == 0x000008, "Wrong alignment on FFGSLeisureConfig");
static_assert(sizeof(FFGSLeisureConfig) == 0x000020, "Wrong size on FFGSLeisureConfig");
static_assert(offsetof(FFGSLeisureConfig, LeisureAnim) == 0x000000, "Member 'FFGSLeisureConfig::LeisureAnim' has a wrong offset!");
static_assert(offsetof(FFGSLeisureConfig, RandomConfig) == 0x000010, "Member 'FFGSLeisureConfig::RandomConfig' has a wrong offset!");

// SharpStruct b1-Managed.FGSSplinePatrolJumpPoint
// 0x0010 (0x0010 - 0x0000)
struct FFGSSplinePatrolJumpPoint final
{
public:
	class UAnimMontage*                           JumpAM;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpForce;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSplinePatrolJumpPoint) == 0x000008, "Wrong alignment on FFGSSplinePatrolJumpPoint");
static_assert(sizeof(FFGSSplinePatrolJumpPoint) == 0x000010, "Wrong size on FFGSSplinePatrolJumpPoint");
static_assert(offsetof(FFGSSplinePatrolJumpPoint, JumpAM) == 0x000000, "Member 'FFGSSplinePatrolJumpPoint::JumpAM' has a wrong offset!");
static_assert(offsetof(FFGSSplinePatrolJumpPoint, JumpForce) == 0x000008, "Member 'FFGSSplinePatrolJumpPoint::JumpForce' has a wrong offset!");

// SharpStruct b1-Managed.FGSSplinePatrolConfig
// 0x00B8 (0x00B8 - 0x0000)
struct FFGSSplinePatrolConfig final
{
public:
	class AActor*                                 SplineActor;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SingleDirection : 1;                               // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATriggerBase*                           TriggerBox;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FFGSSplinePatrolWaitPoint> WaitPointConfig;                                   // 0x0018(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, struct FFGSSplinePatrolJumpPoint> JumpPointConfig;                                   // 0x0068(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSplinePatrolConfig) == 0x000008, "Wrong alignment on FFGSSplinePatrolConfig");
static_assert(sizeof(FFGSSplinePatrolConfig) == 0x0000B8, "Wrong size on FFGSSplinePatrolConfig");
static_assert(offsetof(FFGSSplinePatrolConfig, SplineActor) == 0x000000, "Member 'FFGSSplinePatrolConfig::SplineActor' has a wrong offset!");
static_assert(offsetof(FFGSSplinePatrolConfig, TriggerBox) == 0x000010, "Member 'FFGSSplinePatrolConfig::TriggerBox' has a wrong offset!");
static_assert(offsetof(FFGSSplinePatrolConfig, WaitPointConfig) == 0x000018, "Member 'FFGSSplinePatrolConfig::WaitPointConfig' has a wrong offset!");
static_assert(offsetof(FFGSSplinePatrolConfig, JumpPointConfig) == 0x000068, "Member 'FFGSSplinePatrolConfig::JumpPointConfig' has a wrong offset!");

// SharpStruct b1-Managed.FGSMultiSplinePatrolConfig
// 0x00B8 (0x00B8 - 0x0000)
struct FFGSMultiSplinePatrolConfig final
{
public:
	TArray<TSoftObjectPtr<class AActor>>          SplineList;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class ATriggerBase*                           TriggerBox;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FFGSSplinePatrolWaitPoint> WaitPointConfig;                                   // 0x0018(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<int32, struct FFGSSplinePatrolJumpPoint> JumpPointConfig;                                   // 0x0068(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSMultiSplinePatrolConfig) == 0x000008, "Wrong alignment on FFGSMultiSplinePatrolConfig");
static_assert(sizeof(FFGSMultiSplinePatrolConfig) == 0x0000B8, "Wrong size on FFGSMultiSplinePatrolConfig");
static_assert(offsetof(FFGSMultiSplinePatrolConfig, SplineList) == 0x000000, "Member 'FFGSMultiSplinePatrolConfig::SplineList' has a wrong offset!");
static_assert(offsetof(FFGSMultiSplinePatrolConfig, TriggerBox) == 0x000010, "Member 'FFGSMultiSplinePatrolConfig::TriggerBox' has a wrong offset!");
static_assert(offsetof(FFGSMultiSplinePatrolConfig, WaitPointConfig) == 0x000018, "Member 'FFGSMultiSplinePatrolConfig::WaitPointConfig' has a wrong offset!");
static_assert(offsetof(FFGSMultiSplinePatrolConfig, JumpPointConfig) == 0x000068, "Member 'FFGSMultiSplinePatrolConfig::JumpPointConfig' has a wrong offset!");

// SharpStruct b1-Managed.SpawnBulletSpeed
// 0x0018 (0x0018 - 0x0000)
struct FSpawnBulletSpeed final
{
public:
	struct FSpawnBulletMinMaxValue                Spd;                                               // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTime;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpdCurve;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnBulletSpeed) == 0x000008, "Wrong alignment on FSpawnBulletSpeed");
static_assert(sizeof(FSpawnBulletSpeed) == 0x000018, "Wrong size on FSpawnBulletSpeed");
static_assert(offsetof(FSpawnBulletSpeed, Spd) == 0x000000, "Member 'FSpawnBulletSpeed::Spd' has a wrong offset!");
static_assert(offsetof(FSpawnBulletSpeed, AccelerationTime) == 0x00000C, "Member 'FSpawnBulletSpeed::AccelerationTime' has a wrong offset!");
static_assert(offsetof(FSpawnBulletSpeed, SpdCurve) == 0x000010, "Member 'FSpawnBulletSpeed::SpdCurve' has a wrong offset!");

// SharpStruct b1-Managed.SpeedGroupValue
// 0x000C (0x000C - 0x0000)
struct FSpeedGroupValue final
{
public:
	float                                         LeftValue;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightValue;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTime;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpeedGroupValue) == 0x000004, "Wrong alignment on FSpeedGroupValue");
static_assert(sizeof(FSpeedGroupValue) == 0x00000C, "Wrong size on FSpeedGroupValue");
static_assert(offsetof(FSpeedGroupValue, LeftValue) == 0x000000, "Member 'FSpeedGroupValue::LeftValue' has a wrong offset!");
static_assert(offsetof(FSpeedGroupValue, RightValue) == 0x000004, "Member 'FSpeedGroupValue::RightValue' has a wrong offset!");
static_assert(offsetof(FSpeedGroupValue, AccelerationTime) == 0x000008, "Member 'FSpeedGroupValue::AccelerationTime' has a wrong offset!");

// SharpStruct b1-Managed.SpawnBulletSpeedGroup
// 0x0010 (0x0010 - 0x0000)
struct FSpawnBulletSpeedGroup final
{
public:
	TArray<struct FSpeedGroupValue>               SpdGroup;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnBulletSpeedGroup) == 0x000008, "Wrong alignment on FSpawnBulletSpeedGroup");
static_assert(sizeof(FSpawnBulletSpeedGroup) == 0x000010, "Wrong size on FSpawnBulletSpeedGroup");
static_assert(offsetof(FSpawnBulletSpeedGroup, SpdGroup) == 0x000000, "Member 'FSpawnBulletSpeedGroup::SpdGroup' has a wrong offset!");

// SharpStruct b1-Managed.FGSCastDingShenSetting
// 0x001C (0x001C - 0x0000)
struct FFGSCastDingShenSetting final
{
public:
	int32                                         DingShenBuffID;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnableRangeSelect : 1;                             // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectCount;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RangeRadius;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetFilter;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetTypeFilter;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AffiliationTypeFilter;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSCastDingShenSetting) == 0x000004, "Wrong alignment on FFGSCastDingShenSetting");
static_assert(sizeof(FFGSCastDingShenSetting) == 0x00001C, "Wrong size on FFGSCastDingShenSetting");
static_assert(offsetof(FFGSCastDingShenSetting, DingShenBuffID) == 0x000000, "Member 'FFGSCastDingShenSetting::DingShenBuffID' has a wrong offset!");
static_assert(offsetof(FFGSCastDingShenSetting, SelectCount) == 0x000008, "Member 'FFGSCastDingShenSetting::SelectCount' has a wrong offset!");
static_assert(offsetof(FFGSCastDingShenSetting, RangeRadius) == 0x00000C, "Member 'FFGSCastDingShenSetting::RangeRadius' has a wrong offset!");
static_assert(offsetof(FFGSCastDingShenSetting, TargetFilter) == 0x000010, "Member 'FFGSCastDingShenSetting::TargetFilter' has a wrong offset!");
static_assert(offsetof(FFGSCastDingShenSetting, TargetTypeFilter) == 0x000014, "Member 'FFGSCastDingShenSetting::TargetTypeFilter' has a wrong offset!");
static_assert(offsetof(FFGSCastDingShenSetting, AffiliationTypeFilter) == 0x000018, "Member 'FFGSCastDingShenSetting::AffiliationTypeFilter' has a wrong offset!");

// SharpStruct b1-Managed.FGSMontageMoveData
// 0x0020 (0x0020 - 0x0000)
struct FFGSMontageMoveData final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayTimeRate;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontagePosOffset;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSectionName;                                  // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSMontageMoveData) == 0x000008, "Wrong alignment on FFGSMontageMoveData");
static_assert(sizeof(FFGSMontageMoveData) == 0x000020, "Wrong size on FFGSMontageMoveData");
static_assert(offsetof(FFGSMontageMoveData, Montage) == 0x000000, "Member 'FFGSMontageMoveData::Montage' has a wrong offset!");
static_assert(offsetof(FFGSMontageMoveData, Scale) == 0x000008, "Member 'FFGSMontageMoveData::Scale' has a wrong offset!");
static_assert(offsetof(FFGSMontageMoveData, PlayTimeRate) == 0x00000C, "Member 'FFGSMontageMoveData::PlayTimeRate' has a wrong offset!");
static_assert(offsetof(FFGSMontageMoveData, MontagePosOffset) == 0x000010, "Member 'FFGSMontageMoveData::MontagePosOffset' has a wrong offset!");
static_assert(offsetof(FFGSMontageMoveData, StartSectionName) == 0x000014, "Member 'FFGSMontageMoveData::StartSectionName' has a wrong offset!");

// SharpStruct b1-Managed.SummonSpawnQuene
// 0x0010 (0x0010 - 0x0000)
struct FSummonSpawnQuene final
{
public:
	TArray<struct FSummonSpawnPoints>             SpawnQuenes;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummonSpawnQuene) == 0x000008, "Wrong alignment on FSummonSpawnQuene");
static_assert(sizeof(FSummonSpawnQuene) == 0x000010, "Wrong size on FSummonSpawnQuene");
static_assert(offsetof(FSummonSpawnQuene, SpawnQuenes) == 0x000000, "Member 'FSummonSpawnQuene::SpawnQuenes' has a wrong offset!");

// SharpStruct b1-Managed.UltimateSkillConfigInfo
// 0x000C (0x000C - 0x0000)
struct FUltimateSkillConfigInfo final
{
public:
	int32                                         TeamID;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxUltimateValue;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UltimateCastingCountDown;                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUltimateSkillConfigInfo) == 0x000004, "Wrong alignment on FUltimateSkillConfigInfo");
static_assert(sizeof(FUltimateSkillConfigInfo) == 0x00000C, "Wrong size on FUltimateSkillConfigInfo");
static_assert(offsetof(FUltimateSkillConfigInfo, TeamID) == 0x000000, "Member 'FUltimateSkillConfigInfo::TeamID' has a wrong offset!");
static_assert(offsetof(FUltimateSkillConfigInfo, MaxUltimateValue) == 0x000004, "Member 'FUltimateSkillConfigInfo::MaxUltimateValue' has a wrong offset!");
static_assert(offsetof(FUltimateSkillConfigInfo, UltimateCastingCountDown) == 0x000008, "Member 'FUltimateSkillConfigInfo::UltimateCastingCountDown' has a wrong offset!");

// SharpStruct b1-Managed.Demo820LevelInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FDemo820LevelInfo final
{
public:
	int32                                         LevelIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelID;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BossID;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Desc;                                              // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   VictoryDesc;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         LevelImageIndex;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoleDataConfId;                                    // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDesiredHp;                                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DefaultPos;                                        // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DefaultRot;                                        // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RebrithPoint;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDemo820LevelInfo) == 0x000008, "Wrong alignment on FDemo820LevelInfo");
static_assert(sizeof(FDemo820LevelInfo) == 0x0000A0, "Wrong size on FDemo820LevelInfo");
static_assert(offsetof(FDemo820LevelInfo, LevelIndex) == 0x000000, "Member 'FDemo820LevelInfo::LevelIndex' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, LevelID) == 0x000004, "Member 'FDemo820LevelInfo::LevelID' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, BossID) == 0x000008, "Member 'FDemo820LevelInfo::BossID' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, Name) == 0x000010, "Member 'FDemo820LevelInfo::Name' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, Desc) == 0x000028, "Member 'FDemo820LevelInfo::Desc' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, VictoryDesc) == 0x000040, "Member 'FDemo820LevelInfo::VictoryDesc' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, LevelImageIndex) == 0x000058, "Member 'FDemo820LevelInfo::LevelImageIndex' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, RoleDataConfId) == 0x00005C, "Member 'FDemo820LevelInfo::RoleDataConfId' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, PlayerDesiredHp) == 0x000060, "Member 'FDemo820LevelInfo::PlayerDesiredHp' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, DefaultPos) == 0x000068, "Member 'FDemo820LevelInfo::DefaultPos' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, DefaultRot) == 0x000080, "Member 'FDemo820LevelInfo::DefaultRot' has a wrong offset!");
static_assert(offsetof(FDemo820LevelInfo, RebrithPoint) == 0x000098, "Member 'FDemo820LevelInfo::RebrithPoint' has a wrong offset!");

// SharpStruct b1-Managed.RectParam
// 0x000C (0x000C - 0x0000)
struct FRectParam final
{
public:
	float                                         Height;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAngle;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRectParam) == 0x000004, "Wrong alignment on FRectParam");
static_assert(sizeof(FRectParam) == 0x00000C, "Wrong size on FRectParam");
static_assert(offsetof(FRectParam, Height) == 0x000000, "Member 'FRectParam::Height' has a wrong offset!");
static_assert(offsetof(FRectParam, Width) == 0x000004, "Member 'FRectParam::Width' has a wrong offset!");
static_assert(offsetof(FRectParam, RotateAngle) == 0x000008, "Member 'FRectParam::RotateAngle' has a wrong offset!");

// SharpStruct b1-Managed.RoundParam
// 0x0004 (0x0004 - 0x0000)
struct FRoundParam final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoundParam) == 0x000004, "Wrong alignment on FRoundParam");
static_assert(sizeof(FRoundParam) == 0x000004, "Wrong size on FRoundParam");
static_assert(offsetof(FRoundParam, Radius) == 0x000000, "Member 'FRoundParam::Radius' has a wrong offset!");

// SharpStruct b1-Managed.HeroIconInfo
// 0x0010 (0x0010 - 0x0000)
struct FHeroIconInfo final
{
public:
	int32                                         ResID;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconTexture;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHeroIconInfo) == 0x000008, "Wrong alignment on FHeroIconInfo");
static_assert(sizeof(FHeroIconInfo) == 0x000010, "Wrong size on FHeroIconInfo");
static_assert(offsetof(FHeroIconInfo, ResID) == 0x000000, "Member 'FHeroIconInfo::ResID' has a wrong offset!");
static_assert(offsetof(FHeroIconInfo, IconTexture) == 0x000008, "Member 'FHeroIconInfo::IconTexture' has a wrong offset!");

// SharpStruct b1-Managed.RingPointGenerate
// 0x0010 (0x0010 - 0x0000)
struct FRingPointGenerate final
{
public:
	float                                         MinR;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxR;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RingNum;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointNumPerRing;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRingPointGenerate) == 0x000004, "Wrong alignment on FRingPointGenerate");
static_assert(sizeof(FRingPointGenerate) == 0x000010, "Wrong size on FRingPointGenerate");
static_assert(offsetof(FRingPointGenerate, MinR) == 0x000000, "Member 'FRingPointGenerate::MinR' has a wrong offset!");
static_assert(offsetof(FRingPointGenerate, MaxR) == 0x000004, "Member 'FRingPointGenerate::MaxR' has a wrong offset!");
static_assert(offsetof(FRingPointGenerate, RingNum) == 0x000008, "Member 'FRingPointGenerate::RingNum' has a wrong offset!");
static_assert(offsetof(FRingPointGenerate, PointNumPerRing) == 0x00000C, "Member 'FRingPointGenerate::PointNumPerRing' has a wrong offset!");

// SharpStruct b1-Managed.CheckAngleTest
// 0x000C (0x000C - 0x0000)
struct FCheckAngleTest final
{
public:
	float                                         LeftAngle;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightAngle;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngleBaseType                                AngleBaseType;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCheckAngleTest) == 0x000004, "Wrong alignment on FCheckAngleTest");
static_assert(sizeof(FCheckAngleTest) == 0x00000C, "Wrong size on FCheckAngleTest");
static_assert(offsetof(FCheckAngleTest, LeftAngle) == 0x000000, "Member 'FCheckAngleTest::LeftAngle' has a wrong offset!");
static_assert(offsetof(FCheckAngleTest, RightAngle) == 0x000004, "Member 'FCheckAngleTest::RightAngle' has a wrong offset!");
static_assert(offsetof(FCheckAngleTest, AngleBaseType) == 0x000008, "Member 'FCheckAngleTest::AngleBaseType' has a wrong offset!");

// SharpStruct b1-Managed.DistanceTest
// 0x0002 (0x0002 - 0x0000)
struct FDistanceTest final
{
public:
	EDisTestFilterType                            DisTestType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDisTestBaseType                              DisBaseType;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDistanceTest) == 0x000001, "Wrong alignment on FDistanceTest");
static_assert(sizeof(FDistanceTest) == 0x000002, "Wrong size on FDistanceTest");
static_assert(offsetof(FDistanceTest, DisTestType) == 0x000000, "Member 'FDistanceTest::DisTestType' has a wrong offset!");
static_assert(offsetof(FDistanceTest, DisBaseType) == 0x000001, "Member 'FDistanceTest::DisBaseType' has a wrong offset!");

// SharpStruct b1-Managed.PriorityActionQueInfo
// 0x0048 (0x0048 - 0x0000)
struct FPriorityActionQueInfo final
{
public:
	int32                                         ExecutorNum;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResID;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFPAQI_SelectUnitTypeInfo              SelectUnitTypeInfo;                                // 0x0008(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPriorityActionUnitType                       UnitType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOnePriorityActionInfo>         Actions;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPriorityActionQueInfo) == 0x000008, "Wrong alignment on FPriorityActionQueInfo");
static_assert(sizeof(FPriorityActionQueInfo) == 0x000048, "Wrong size on FPriorityActionQueInfo");
static_assert(offsetof(FPriorityActionQueInfo, ExecutorNum) == 0x000000, "Member 'FPriorityActionQueInfo::ExecutorNum' has a wrong offset!");
static_assert(offsetof(FPriorityActionQueInfo, ResID) == 0x000004, "Member 'FPriorityActionQueInfo::ResID' has a wrong offset!");
static_assert(offsetof(FPriorityActionQueInfo, SelectUnitTypeInfo) == 0x000008, "Member 'FPriorityActionQueInfo::SelectUnitTypeInfo' has a wrong offset!");
static_assert(offsetof(FPriorityActionQueInfo, UnitType) == 0x000030, "Member 'FPriorityActionQueInfo::UnitType' has a wrong offset!");
static_assert(offsetof(FPriorityActionQueInfo, Actions) == 0x000038, "Member 'FPriorityActionQueInfo::Actions' has a wrong offset!");

// SharpStruct b1-Managed.HitModifySkillScoreInfo
// 0x0008 (0x0008 - 0x0000)
struct FHitModifySkillScoreInfo final
{
public:
	int32                                         SkillID;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModifyScore;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitModifySkillScoreInfo) == 0x000004, "Wrong alignment on FHitModifySkillScoreInfo");
static_assert(sizeof(FHitModifySkillScoreInfo) == 0x000008, "Wrong size on FHitModifySkillScoreInfo");
static_assert(offsetof(FHitModifySkillScoreInfo, SkillID) == 0x000000, "Member 'FHitModifySkillScoreInfo::SkillID' has a wrong offset!");
static_assert(offsetof(FHitModifySkillScoreInfo, ModifyScore) == 0x000004, "Member 'FHitModifySkillScoreInfo::ModifyScore' has a wrong offset!");

// SharpStruct b1-Managed.FGSBeamFXPlaySetting
// 0x0070 (0x0070 - 0x0000)
struct FFGSBeamFXPlaySetting final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          BeamTemplate;                                      // 0x0000(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsAttach : 1;                                      // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocketName;                                  // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBeamFXTargetActorType                        GSBeamTargetType;                                  // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GSBeamTargetParamName;                             // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSocketName;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSBeamFXPlaySetting) == 0x000008, "Wrong alignment on FFGSBeamFXPlaySetting");
static_assert(sizeof(FFGSBeamFXPlaySetting) == 0x000070, "Wrong size on FFGSBeamFXPlaySetting");
static_assert(offsetof(FFGSBeamFXPlaySetting, BeamTemplate) == 0x000000, "Member 'FFGSBeamFXPlaySetting::BeamTemplate' has a wrong offset!");
static_assert(offsetof(FFGSBeamFXPlaySetting, AttachSocketName) == 0x00002C, "Member 'FFGSBeamFXPlaySetting::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FFGSBeamFXPlaySetting, Scale) == 0x000038, "Member 'FFGSBeamFXPlaySetting::Scale' has a wrong offset!");
static_assert(offsetof(FFGSBeamFXPlaySetting, GSBeamTargetType) == 0x000050, "Member 'FFGSBeamFXPlaySetting::GSBeamTargetType' has a wrong offset!");
static_assert(offsetof(FFGSBeamFXPlaySetting, GSBeamTargetParamName) == 0x000058, "Member 'FFGSBeamFXPlaySetting::GSBeamTargetParamName' has a wrong offset!");
static_assert(offsetof(FFGSBeamFXPlaySetting, TargetSocketName) == 0x000068, "Member 'FFGSBeamFXPlaySetting::TargetSocketName' has a wrong offset!");

// SharpStruct b1-Managed.MaterialLayerKeyData
// 0x0014 (0x0014 - 0x0000)
struct FMaterialLayerKeyData final
{
public:
	struct FMaterialLayerMappingInfo              LayerMappingInfo;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialLayerKeyData) == 0x000004, "Wrong alignment on FMaterialLayerKeyData");
static_assert(sizeof(FMaterialLayerKeyData) == 0x000014, "Wrong size on FMaterialLayerKeyData");
static_assert(offsetof(FMaterialLayerKeyData, LayerMappingInfo) == 0x000000, "Member 'FMaterialLayerKeyData::LayerMappingInfo' has a wrong offset!");
static_assert(offsetof(FMaterialLayerKeyData, ParamName) == 0x00000C, "Member 'FMaterialLayerKeyData::ParamName' has a wrong offset!");

// SharpStruct b1-Managed.MaterialLayerParamData
// 0x0058 (0x0058 - 0x0000)
struct FMaterialLayerParamData final
{
public:
	struct FMaterialLayerKeyData                  LayerKeyData;                                      // 0x0000(0x0014)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialLayerParamType                       ParamType;                                         // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScalarValue;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorValue;                                        // 0x001C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ScalarCurve;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      ColorCurve;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableAutoBlendOut : 1;                           // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoBlendOutScalarValue;                           // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AutoBlendOutColorValue;                            // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialLayerParamData) == 0x000008, "Wrong alignment on FMaterialLayerParamData");
static_assert(sizeof(FMaterialLayerParamData) == 0x000058, "Wrong size on FMaterialLayerParamData");
static_assert(offsetof(FMaterialLayerParamData, LayerKeyData) == 0x000000, "Member 'FMaterialLayerParamData::LayerKeyData' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamData, ParamType) == 0x000014, "Member 'FMaterialLayerParamData::ParamType' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamData, ScalarValue) == 0x000018, "Member 'FMaterialLayerParamData::ScalarValue' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamData, ColorValue) == 0x00001C, "Member 'FMaterialLayerParamData::ColorValue' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamData, ScalarCurve) == 0x000030, "Member 'FMaterialLayerParamData::ScalarCurve' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamData, ColorCurve) == 0x000038, "Member 'FMaterialLayerParamData::ColorCurve' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamData, AutoBlendOutScalarValue) == 0x000044, "Member 'FMaterialLayerParamData::AutoBlendOutScalarValue' has a wrong offset!");
static_assert(offsetof(FMaterialLayerParamData, AutoBlendOutColorValue) == 0x000048, "Member 'FMaterialLayerParamData::AutoBlendOutColorValue' has a wrong offset!");

// SharpStruct b1-Managed.UAkEventConfig
// 0x0028 (0x0028 - 0x0000)
struct FUAkEventConfig final
{
public:
	EAkEventStopMode                              StopMode;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachPointName;                                   // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkEvent;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFollowAttachPoint : 1;                            // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StopTimeMs;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FadeOutTimeMs;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkCurveInterpolationCS                       CurveInterpolation;                                // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUAkEventConfig) == 0x000008, "Wrong alignment on FUAkEventConfig");
static_assert(sizeof(FUAkEventConfig) == 0x000028, "Wrong size on FUAkEventConfig");
static_assert(offsetof(FUAkEventConfig, StopMode) == 0x000000, "Member 'FUAkEventConfig::StopMode' has a wrong offset!");
static_assert(offsetof(FUAkEventConfig, AttachPointName) == 0x000004, "Member 'FUAkEventConfig::AttachPointName' has a wrong offset!");
static_assert(offsetof(FUAkEventConfig, AkEvent) == 0x000010, "Member 'FUAkEventConfig::AkEvent' has a wrong offset!");
static_assert(offsetof(FUAkEventConfig, StopTimeMs) == 0x00001C, "Member 'FUAkEventConfig::StopTimeMs' has a wrong offset!");
static_assert(offsetof(FUAkEventConfig, FadeOutTimeMs) == 0x000020, "Member 'FUAkEventConfig::FadeOutTimeMs' has a wrong offset!");
static_assert(offsetof(FUAkEventConfig, CurveInterpolation) == 0x000024, "Member 'FUAkEventConfig::CurveInterpolation' has a wrong offset!");

// SharpStruct b1-Managed.DetectUnitCondition
// 0x0048 (0x0048 - 0x0000)
struct FDetectUnitCondition final
{
public:
	EDetectedUnitType                             UnitType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          SmartUnit;                                         // 0x0004(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDetectCondition>               Conditions;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBossPhaseInfo                         BossPhaseInfo;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetectUnitCondition) == 0x000008, "Wrong alignment on FDetectUnitCondition");
static_assert(sizeof(FDetectUnitCondition) == 0x000048, "Wrong size on FDetectUnitCondition");
static_assert(offsetof(FDetectUnitCondition, UnitType) == 0x000000, "Member 'FDetectUnitCondition::UnitType' has a wrong offset!");
static_assert(offsetof(FDetectUnitCondition, SmartUnit) == 0x000004, "Member 'FDetectUnitCondition::SmartUnit' has a wrong offset!");
static_assert(offsetof(FDetectUnitCondition, Conditions) == 0x000018, "Member 'FDetectUnitCondition::Conditions' has a wrong offset!");
static_assert(offsetof(FDetectUnitCondition, ConditionalRelation) == 0x000028, "Member 'FDetectUnitCondition::ConditionalRelation' has a wrong offset!");
static_assert(offsetof(FDetectUnitCondition, Comment) == 0x000030, "Member 'FDetectUnitCondition::Comment' has a wrong offset!");
static_assert(offsetof(FDetectUnitCondition, BossPhaseInfo) == 0x000040, "Member 'FDetectUnitCondition::BossPhaseInfo' has a wrong offset!");

// SharpStruct b1-Managed.MovieSequencePlaySettings
// 0x0068 (0x0068 - 0x0000)
struct FMovieSequencePlaySettings final
{
public:
	TArray<class ULevelSequence*>                 Sequences;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     CameraTransforms;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         CameraTags;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         RailTags;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         CraneTags;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bUseCinematicCamera : 1;                           // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_50_1 : 7;                                   // 0x0050(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bUseRail : 1;                                      // 0x0051(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_51_1 : 7;                                   // 0x0051(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bUseCrane : 1;                                     // 0x0052(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTimeSeconds;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InCameraBlendTime;                                 // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      InCameraBlendFunction;                             // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InCameraBlendFactor;                               // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoopPlay : 1;                                     // 0x0064(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FMovieSequencePlaySettings) == 0x000008, "Wrong alignment on FMovieSequencePlaySettings");
static_assert(sizeof(FMovieSequencePlaySettings) == 0x000068, "Wrong size on FMovieSequencePlaySettings");
static_assert(offsetof(FMovieSequencePlaySettings, Sequences) == 0x000000, "Member 'FMovieSequencePlaySettings::Sequences' has a wrong offset!");
static_assert(offsetof(FMovieSequencePlaySettings, CameraTransforms) == 0x000010, "Member 'FMovieSequencePlaySettings::CameraTransforms' has a wrong offset!");
static_assert(offsetof(FMovieSequencePlaySettings, CameraTags) == 0x000020, "Member 'FMovieSequencePlaySettings::CameraTags' has a wrong offset!");
static_assert(offsetof(FMovieSequencePlaySettings, RailTags) == 0x000030, "Member 'FMovieSequencePlaySettings::RailTags' has a wrong offset!");
static_assert(offsetof(FMovieSequencePlaySettings, CraneTags) == 0x000040, "Member 'FMovieSequencePlaySettings::CraneTags' has a wrong offset!");
static_assert(offsetof(FMovieSequencePlaySettings, StartTimeSeconds) == 0x000054, "Member 'FMovieSequencePlaySettings::StartTimeSeconds' has a wrong offset!");
static_assert(offsetof(FMovieSequencePlaySettings, InCameraBlendTime) == 0x000058, "Member 'FMovieSequencePlaySettings::InCameraBlendTime' has a wrong offset!");
static_assert(offsetof(FMovieSequencePlaySettings, InCameraBlendFunction) == 0x00005C, "Member 'FMovieSequencePlaySettings::InCameraBlendFunction' has a wrong offset!");
static_assert(offsetof(FMovieSequencePlaySettings, InCameraBlendFactor) == 0x000060, "Member 'FMovieSequencePlaySettings::InCameraBlendFactor' has a wrong offset!");

// SharpStruct b1-Managed.TextWidget
// 0x0178 (0x0178 - 0x0000)
struct FTextWidget final
{
public:
	class FString                                 WidgetName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTextConfig                            TextConfig;                                        // 0x0010(0x0168)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextWidget) == 0x000008, "Wrong alignment on FTextWidget");
static_assert(sizeof(FTextWidget) == 0x000178, "Wrong size on FTextWidget");
static_assert(offsetof(FTextWidget, WidgetName) == 0x000000, "Member 'FTextWidget::WidgetName' has a wrong offset!");
static_assert(offsetof(FTextWidget, TextConfig) == 0x000010, "Member 'FTextWidget::TextConfig' has a wrong offset!");

// SharpStruct b1-Managed.FUIData
// 0x0048 (0x0048 - 0x0000)
struct FFUIData final
{
public:
	TArray<struct FWidgetConfig>                  Con;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FImageWidget>                   Img;                                               // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTextWidget>                    Text;                                              // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             AdvancedHitTexture;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             AdvancedHitDA;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdvancedHitAlpha;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFUIData) == 0x000008, "Wrong alignment on FFUIData");
static_assert(sizeof(FFUIData) == 0x000048, "Wrong size on FFUIData");
static_assert(offsetof(FFUIData, Con) == 0x000000, "Member 'FFUIData::Con' has a wrong offset!");
static_assert(offsetof(FFUIData, Img) == 0x000010, "Member 'FFUIData::Img' has a wrong offset!");
static_assert(offsetof(FFUIData, Text) == 0x000020, "Member 'FFUIData::Text' has a wrong offset!");
static_assert(offsetof(FFUIData, AdvancedHitTexture) == 0x000030, "Member 'FFUIData::AdvancedHitTexture' has a wrong offset!");
static_assert(offsetof(FFUIData, AdvancedHitDA) == 0x000038, "Member 'FFUIData::AdvancedHitDA' has a wrong offset!");
static_assert(offsetof(FFUIData, AdvancedHitAlpha) == 0x000040, "Member 'FFUIData::AdvancedHitAlpha' has a wrong offset!");

// SharpStruct b1-Managed.IntimidateBPConfig
// 0x0030 (0x0030 - 0x0000)
struct FIntimidateBPConfig final
{
public:
	int32                                         IntimidatingProbability;                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntimidatingMinStiffLevel;                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntimidatingCD;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntimidatingRange;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntimidatingInfluenceMaxNum;                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 IntimidatedSkillList;                              // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         IntimidatedProbability;                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntimidatedCD;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntimidateBPConfig) == 0x000008, "Wrong alignment on FIntimidateBPConfig");
static_assert(sizeof(FIntimidateBPConfig) == 0x000030, "Wrong size on FIntimidateBPConfig");
static_assert(offsetof(FIntimidateBPConfig, IntimidatingProbability) == 0x000000, "Member 'FIntimidateBPConfig::IntimidatingProbability' has a wrong offset!");
static_assert(offsetof(FIntimidateBPConfig, IntimidatingMinStiffLevel) == 0x000004, "Member 'FIntimidateBPConfig::IntimidatingMinStiffLevel' has a wrong offset!");
static_assert(offsetof(FIntimidateBPConfig, IntimidatingCD) == 0x000008, "Member 'FIntimidateBPConfig::IntimidatingCD' has a wrong offset!");
static_assert(offsetof(FIntimidateBPConfig, IntimidatingRange) == 0x00000C, "Member 'FIntimidateBPConfig::IntimidatingRange' has a wrong offset!");
static_assert(offsetof(FIntimidateBPConfig, IntimidatingInfluenceMaxNum) == 0x000010, "Member 'FIntimidateBPConfig::IntimidatingInfluenceMaxNum' has a wrong offset!");
static_assert(offsetof(FIntimidateBPConfig, IntimidatedSkillList) == 0x000018, "Member 'FIntimidateBPConfig::IntimidatedSkillList' has a wrong offset!");
static_assert(offsetof(FIntimidateBPConfig, IntimidatedProbability) == 0x000028, "Member 'FIntimidateBPConfig::IntimidatedProbability' has a wrong offset!");
static_assert(offsetof(FIntimidateBPConfig, IntimidatedCD) == 0x00002C, "Member 'FIntimidateBPConfig::IntimidatedCD' has a wrong offset!");

// SharpStruct b1-Managed.FGSDataTableRowHandle
// 0x0010 (0x0010 - 0x0000)
struct FFGSDataTableRowHandle final
{
public:
	class FName                                   RowName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DataTable;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSDataTableRowHandle) == 0x000008, "Wrong alignment on FFGSDataTableRowHandle");
static_assert(sizeof(FFGSDataTableRowHandle) == 0x000010, "Wrong size on FFGSDataTableRowHandle");
static_assert(offsetof(FFGSDataTableRowHandle, RowName) == 0x000000, "Member 'FFGSDataTableRowHandle::RowName' has a wrong offset!");
static_assert(offsetof(FFGSDataTableRowHandle, DataTable) == 0x000008, "Member 'FFGSDataTableRowHandle::DataTable' has a wrong offset!");

// SharpStruct b1-Managed.FGSDescRowHandle
// 0x0018 (0x0018 - 0x0000)
struct FFGSDescRowHandle final
{
public:
	int32                                         DescID;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 DescCustomizationHelperClass;                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSDescRowHandle) == 0x000008, "Wrong alignment on FFGSDescRowHandle");
static_assert(sizeof(FFGSDescRowHandle) == 0x000018, "Wrong size on FFGSDescRowHandle");
static_assert(offsetof(FFGSDescRowHandle, DescID) == 0x000000, "Member 'FFGSDescRowHandle::DescID' has a wrong offset!");
static_assert(offsetof(FFGSDescRowHandle, RowName) == 0x000004, "Member 'FFGSDescRowHandle::RowName' has a wrong offset!");
static_assert(offsetof(FFGSDescRowHandle, DescCustomizationHelperClass) == 0x000010, "Member 'FFGSDescRowHandle::DescCustomizationHelperClass' has a wrong offset!");

// SharpStruct b1-Managed.TransitionCondition_Battle
// 0x0098 (0x0098 - 0x0000)
struct FTransitionCondition_Battle final
{
public:
	ETransitionConditionType_Battle               ConditionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParamArray                     UnitList;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          UnitSpawner;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Unit;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Buff;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParamArray                     UnitKillOrder;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          GroupUnit;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Overlap;                                           // 0x0068(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         UnitDeadNum;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountdownTime;                                     // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransitionCondition_Battle) == 0x000008, "Wrong alignment on FTransitionCondition_Battle");
static_assert(sizeof(FTransitionCondition_Battle) == 0x000098, "Wrong size on FTransitionCondition_Battle");
static_assert(offsetof(FTransitionCondition_Battle, ConditionType) == 0x000000, "Member 'FTransitionCondition_Battle::ConditionType' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, UnitList) == 0x000008, "Member 'FTransitionCondition_Battle::UnitList' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, UnitSpawner) == 0x000018, "Member 'FTransitionCondition_Battle::UnitSpawner' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, Unit) == 0x000028, "Member 'FTransitionCondition_Battle::Unit' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, Buff) == 0x000038, "Member 'FTransitionCondition_Battle::Buff' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, UnitKillOrder) == 0x000048, "Member 'FTransitionCondition_Battle::UnitKillOrder' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, GroupUnit) == 0x000058, "Member 'FTransitionCondition_Battle::GroupUnit' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, Overlap) == 0x000068, "Member 'FTransitionCondition_Battle::Overlap' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, UnitDeadNum) == 0x000078, "Member 'FTransitionCondition_Battle::UnitDeadNum' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, CountdownTime) == 0x00007C, "Member 'FTransitionCondition_Battle::CountdownTime' has a wrong offset!");
static_assert(offsetof(FTransitionCondition_Battle, Comment) == 0x000088, "Member 'FTransitionCondition_Battle::Comment' has a wrong offset!");

// SharpStruct b1-Managed.CompositeTransitionCondition_Battle
// 0x00C8 (0x00C8 - 0x0000)
struct FCompositeTransitionCondition_Battle final
{
public:
	struct FTransitionCondition_Battle            Single;                                            // 0x0000(0x0098)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseCompositeCondition : 1;                        // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransitionCondition_Battle>    Conditions;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x00B1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompositeTransitionCondition_Battle) == 0x000008, "Wrong alignment on FCompositeTransitionCondition_Battle");
static_assert(sizeof(FCompositeTransitionCondition_Battle) == 0x0000C8, "Wrong size on FCompositeTransitionCondition_Battle");
static_assert(offsetof(FCompositeTransitionCondition_Battle, Single) == 0x000000, "Member 'FCompositeTransitionCondition_Battle::Single' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Battle, Conditions) == 0x0000A0, "Member 'FCompositeTransitionCondition_Battle::Conditions' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Battle, ConditionalRelation) == 0x0000B0, "Member 'FCompositeTransitionCondition_Battle::ConditionalRelation' has a wrong offset!");
static_assert(offsetof(FCompositeTransitionCondition_Battle, Comment) == 0x0000B8, "Member 'FCompositeTransitionCondition_Battle::Comment' has a wrong offset!");

// SharpStruct b1-Managed.BattleTriggerConfig
// 0x0010 (0x0010 - 0x0000)
struct FBattleTriggerConfig final
{
public:
	TArray<struct FBattleTriggerUnitConfig>       BattleUnitConfigs;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleTriggerConfig) == 0x000008, "Wrong alignment on FBattleTriggerConfig");
static_assert(sizeof(FBattleTriggerConfig) == 0x000010, "Wrong size on FBattleTriggerConfig");
static_assert(offsetof(FBattleTriggerConfig, BattleUnitConfigs) == 0x000000, "Member 'FBattleTriggerConfig::BattleUnitConfigs' has a wrong offset!");

// SharpStruct b1-Managed.FBGMVolumeConditionConfig
// 0x0040 (0x0040 - 0x0000)
struct FFBGMVolumeConditionConfig final
{
public:
	TArray<struct FFBGMVolumeConditionGroup>      ConditionGroups;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventBegin;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventStop;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWBGMConfigDataAsset*                 VolumeBGMConfigDA;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFBGMVolumeGroupConfig                 VolumeGroupConfig;                                 // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFBGMVolumeConditionConfig) == 0x000008, "Wrong alignment on FFBGMVolumeConditionConfig");
static_assert(sizeof(FFBGMVolumeConditionConfig) == 0x000040, "Wrong size on FFBGMVolumeConditionConfig");
static_assert(offsetof(FFBGMVolumeConditionConfig, ConditionGroups) == 0x000000, "Member 'FFBGMVolumeConditionConfig::ConditionGroups' has a wrong offset!");
static_assert(offsetof(FFBGMVolumeConditionConfig, AkEventBegin) == 0x000010, "Member 'FFBGMVolumeConditionConfig::AkEventBegin' has a wrong offset!");
static_assert(offsetof(FFBGMVolumeConditionConfig, AkEventStop) == 0x000018, "Member 'FFBGMVolumeConditionConfig::AkEventStop' has a wrong offset!");
static_assert(offsetof(FFBGMVolumeConditionConfig, VolumeBGMConfigDA) == 0x000020, "Member 'FFBGMVolumeConditionConfig::VolumeBGMConfigDA' has a wrong offset!");
static_assert(offsetof(FFBGMVolumeConditionConfig, VolumeGroupConfig) == 0x000028, "Member 'FFBGMVolumeConditionConfig::VolumeGroupConfig' has a wrong offset!");

// SharpStruct b1-Managed.LimbIKBonePair
// 0x0010 (0x0010 - 0x0000)
struct FLimbIKBonePair final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VBoneName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLimbIKBonePair) == 0x000004, "Wrong alignment on FLimbIKBonePair");
static_assert(sizeof(FLimbIKBonePair) == 0x000010, "Wrong size on FLimbIKBonePair");
static_assert(offsetof(FLimbIKBonePair, BoneName) == 0x000000, "Member 'FLimbIKBonePair::BoneName' has a wrong offset!");
static_assert(offsetof(FLimbIKBonePair, VBoneName) == 0x000008, "Member 'FLimbIKBonePair::VBoneName' has a wrong offset!");

// SharpStruct b1-Managed.TrainDummySpecialDamageTypeConfig
// 0x0070 (0x0070 - 0x0000)
struct FTrainDummySpecialDamageTypeConfig final
{
public:
	class FString                                 Describe;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SkillID;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<int32>                                 AttackerResIdCondition;                            // 0x0020(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EBGUSimpleState>                       AttackerSimpleStateCondition;                      // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EBGUUnitState>                         AttackerUnitStateCondition;                        // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EBGUSimpleState>                       VictimSimpleStateCondition;                        // 0x0050(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EBGUUnitState>                         VictimUnitStateCondition;                          // 0x0060(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrainDummySpecialDamageTypeConfig) == 0x000008, "Wrong alignment on FTrainDummySpecialDamageTypeConfig");
static_assert(sizeof(FTrainDummySpecialDamageTypeConfig) == 0x000070, "Wrong size on FTrainDummySpecialDamageTypeConfig");
static_assert(offsetof(FTrainDummySpecialDamageTypeConfig, Describe) == 0x000000, "Member 'FTrainDummySpecialDamageTypeConfig::Describe' has a wrong offset!");
static_assert(offsetof(FTrainDummySpecialDamageTypeConfig, SkillID) == 0x000010, "Member 'FTrainDummySpecialDamageTypeConfig::SkillID' has a wrong offset!");
static_assert(offsetof(FTrainDummySpecialDamageTypeConfig, AttackerResIdCondition) == 0x000020, "Member 'FTrainDummySpecialDamageTypeConfig::AttackerResIdCondition' has a wrong offset!");
static_assert(offsetof(FTrainDummySpecialDamageTypeConfig, AttackerSimpleStateCondition) == 0x000030, "Member 'FTrainDummySpecialDamageTypeConfig::AttackerSimpleStateCondition' has a wrong offset!");
static_assert(offsetof(FTrainDummySpecialDamageTypeConfig, AttackerUnitStateCondition) == 0x000040, "Member 'FTrainDummySpecialDamageTypeConfig::AttackerUnitStateCondition' has a wrong offset!");
static_assert(offsetof(FTrainDummySpecialDamageTypeConfig, VictimSimpleStateCondition) == 0x000050, "Member 'FTrainDummySpecialDamageTypeConfig::VictimSimpleStateCondition' has a wrong offset!");
static_assert(offsetof(FTrainDummySpecialDamageTypeConfig, VictimUnitStateCondition) == 0x000060, "Member 'FTrainDummySpecialDamageTypeConfig::VictimUnitStateCondition' has a wrong offset!");

// SharpStruct b1-Managed.PlayNiagaraConditions
// 0x0020 (0x0020 - 0x0000)
struct FPlayNiagaraConditions final
{
public:
	EDetectedUnitType                             UnitType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDetectCondition>               Conditions;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EConditionalRelation                          ConditionalRelation;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsReverseCondition : 1;                            // 0x0019(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_19_1 : 7;                                   // 0x0019(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         bForDebug : 1;                                     // 0x001A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FPlayNiagaraConditions) == 0x000008, "Wrong alignment on FPlayNiagaraConditions");
static_assert(sizeof(FPlayNiagaraConditions) == 0x000020, "Wrong size on FPlayNiagaraConditions");
static_assert(offsetof(FPlayNiagaraConditions, UnitType) == 0x000000, "Member 'FPlayNiagaraConditions::UnitType' has a wrong offset!");
static_assert(offsetof(FPlayNiagaraConditions, Conditions) == 0x000008, "Member 'FPlayNiagaraConditions::Conditions' has a wrong offset!");
static_assert(offsetof(FPlayNiagaraConditions, ConditionalRelation) == 0x000018, "Member 'FPlayNiagaraConditions::ConditionalRelation' has a wrong offset!");

// SharpStruct b1-Managed.FGSTimeScaleSetting
// 0x0020 (0x0020 - 0x0000)
struct FFGSTimeScaleSetting final
{
public:
	float                                         TimeScale;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInRealTime;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSBlendTypeG                                 BlendInType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInExp;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutRealTime;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSBlendTypeG                                 BlendOutType;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutExp;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ExceptSelf : 1;                                    // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FFGSTimeScaleSetting) == 0x000004, "Wrong alignment on FFGSTimeScaleSetting");
static_assert(sizeof(FFGSTimeScaleSetting) == 0x000020, "Wrong size on FFGSTimeScaleSetting");
static_assert(offsetof(FFGSTimeScaleSetting, TimeScale) == 0x000000, "Member 'FFGSTimeScaleSetting::TimeScale' has a wrong offset!");
static_assert(offsetof(FFGSTimeScaleSetting, BlendInRealTime) == 0x000004, "Member 'FFGSTimeScaleSetting::BlendInRealTime' has a wrong offset!");
static_assert(offsetof(FFGSTimeScaleSetting, BlendInType) == 0x000008, "Member 'FFGSTimeScaleSetting::BlendInType' has a wrong offset!");
static_assert(offsetof(FFGSTimeScaleSetting, BlendInExp) == 0x00000C, "Member 'FFGSTimeScaleSetting::BlendInExp' has a wrong offset!");
static_assert(offsetof(FFGSTimeScaleSetting, BlendOutRealTime) == 0x000010, "Member 'FFGSTimeScaleSetting::BlendOutRealTime' has a wrong offset!");
static_assert(offsetof(FFGSTimeScaleSetting, BlendOutType) == 0x000014, "Member 'FFGSTimeScaleSetting::BlendOutType' has a wrong offset!");
static_assert(offsetof(FFGSTimeScaleSetting, BlendOutExp) == 0x000018, "Member 'FFGSTimeScaleSetting::BlendOutExp' has a wrong offset!");

// SharpStruct b1-Managed.ObservationModeConfig
// 0x0070 (0x0070 - 0x0000)
struct FObservationModeConfig final
{
public:
	EModelOperateType                             ObserveOpType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationRangeYaw;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotationAccMultipleFactorMouse;                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotationAccMultipleFactorGamepad;               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotationMaxAcc;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotationStopAcc;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawRotationMaxSpeed;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRangePitch;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRotationAccMultipleFactorMouse;               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRotationAccMultipleFactorGamepad;             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRotationMaxAcc;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRotationStopAcc;                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRotationMaxSpeed;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUpRange;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDownRange;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomSpeedMouse;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomSpeedGamepad;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DragAreaName;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObsDragAreaName;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopJudgmentTime;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftStickXInputThreshold;                          // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObservationModeConfig) == 0x000008, "Wrong alignment on FObservationModeConfig");
static_assert(sizeof(FObservationModeConfig) == 0x000070, "Wrong size on FObservationModeConfig");
static_assert(offsetof(FObservationModeConfig, ObserveOpType) == 0x000000, "Member 'FObservationModeConfig::ObserveOpType' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, RotationRangeYaw) == 0x000004, "Member 'FObservationModeConfig::RotationRangeYaw' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, YawRotationAccMultipleFactorMouse) == 0x000008, "Member 'FObservationModeConfig::YawRotationAccMultipleFactorMouse' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, YawRotationAccMultipleFactorGamepad) == 0x00000C, "Member 'FObservationModeConfig::YawRotationAccMultipleFactorGamepad' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, YawRotationMaxAcc) == 0x000010, "Member 'FObservationModeConfig::YawRotationMaxAcc' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, YawRotationStopAcc) == 0x000014, "Member 'FObservationModeConfig::YawRotationStopAcc' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, YawRotationMaxSpeed) == 0x000018, "Member 'FObservationModeConfig::YawRotationMaxSpeed' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, RotationRangePitch) == 0x00001C, "Member 'FObservationModeConfig::RotationRangePitch' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, PitchRotationAccMultipleFactorMouse) == 0x000020, "Member 'FObservationModeConfig::PitchRotationAccMultipleFactorMouse' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, PitchRotationAccMultipleFactorGamepad) == 0x000024, "Member 'FObservationModeConfig::PitchRotationAccMultipleFactorGamepad' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, PitchRotationMaxAcc) == 0x000028, "Member 'FObservationModeConfig::PitchRotationMaxAcc' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, PitchRotationStopAcc) == 0x00002C, "Member 'FObservationModeConfig::PitchRotationStopAcc' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, PitchRotationMaxSpeed) == 0x000030, "Member 'FObservationModeConfig::PitchRotationMaxSpeed' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, ZoomUpRange) == 0x000034, "Member 'FObservationModeConfig::ZoomUpRange' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, ZoomDownRange) == 0x000038, "Member 'FObservationModeConfig::ZoomDownRange' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, ZoomSpeedMouse) == 0x00003C, "Member 'FObservationModeConfig::ZoomSpeedMouse' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, ZoomSpeedGamepad) == 0x000040, "Member 'FObservationModeConfig::ZoomSpeedGamepad' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, DragAreaName) == 0x000048, "Member 'FObservationModeConfig::DragAreaName' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, ObsDragAreaName) == 0x000058, "Member 'FObservationModeConfig::ObsDragAreaName' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, StopJudgmentTime) == 0x000068, "Member 'FObservationModeConfig::StopJudgmentTime' has a wrong offset!");
static_assert(offsetof(FObservationModeConfig, LeftStickXInputThreshold) == 0x00006C, "Member 'FObservationModeConfig::LeftStickXInputThreshold' has a wrong offset!");

// SharpStruct b1-Managed.SpecialItemObModeConfig
// 0x0050 (0x0050 - 0x0000)
struct FSpecialItemObModeConfig final
{
public:
	TMap<EObModeSource, struct FObservationModeConfig> SpecialItemConfigMap;                              // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialItemObModeConfig) == 0x000008, "Wrong alignment on FSpecialItemObModeConfig");
static_assert(sizeof(FSpecialItemObModeConfig) == 0x000050, "Wrong size on FSpecialItemObModeConfig");
static_assert(offsetof(FSpecialItemObModeConfig, SpecialItemConfigMap) == 0x000000, "Member 'FSpecialItemObModeConfig::SpecialItemConfigMap' has a wrong offset!");

// SharpStruct b1-Managed.FTPModeFilterInfo
// 0x0020 (0x0020 - 0x0000)
struct FFTPModeFilterInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture*                               LUTTexture;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFTPModeFilterInfo) == 0x000008, "Wrong alignment on FFTPModeFilterInfo");
static_assert(sizeof(FFTPModeFilterInfo) == 0x000020, "Wrong size on FFTPModeFilterInfo");
static_assert(offsetof(FFTPModeFilterInfo, DisplayName) == 0x000000, "Member 'FFTPModeFilterInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FFTPModeFilterInfo, LUTTexture) == 0x000018, "Member 'FFTPModeFilterInfo::LUTTexture' has a wrong offset!");

// SharpStruct b1-Managed.FTPModeFrame
// 0x0028 (0x0028 - 0x0000)
struct FFTPModeFrame final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 TargetAKB;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFTPModeFrame) == 0x000008, "Wrong alignment on FFTPModeFrame");
static_assert(sizeof(FFTPModeFrame) == 0x000028, "Wrong size on FFTPModeFrame");
static_assert(offsetof(FFTPModeFrame, DisplayName) == 0x000000, "Member 'FFTPModeFrame::DisplayName' has a wrong offset!");
static_assert(offsetof(FFTPModeFrame, TargetAKB) == 0x000018, "Member 'FFTPModeFrame::TargetAKB' has a wrong offset!");

// SharpStruct b1-Managed.FTPModeConfigTabInfo
// 0x0008 (0x0008 - 0x0000)
struct FFTPModeConfigTabInfo final
{
public:
	class UTexture2D*                             ImageTex;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFTPModeConfigTabInfo) == 0x000008, "Wrong alignment on FFTPModeConfigTabInfo");
static_assert(sizeof(FFTPModeConfigTabInfo) == 0x000008, "Wrong size on FFTPModeConfigTabInfo");
static_assert(offsetof(FFTPModeConfigTabInfo, ImageTex) == 0x000000, "Member 'FFTPModeConfigTabInfo::ImageTex' has a wrong offset!");

// SharpStruct b1-Managed.LevelSkeletalMeshCheckActorInfoHelper
// 0x0020 (0x0020 - 0x0000)
struct FLevelSkeletalMeshCheckActorInfoHelper final
{
public:
	class FString                                 ActorLabel;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelSkeletalMeshCheckActorInfoHelper) == 0x000008, "Wrong alignment on FLevelSkeletalMeshCheckActorInfoHelper");
static_assert(sizeof(FLevelSkeletalMeshCheckActorInfoHelper) == 0x000020, "Wrong size on FLevelSkeletalMeshCheckActorInfoHelper");
static_assert(offsetof(FLevelSkeletalMeshCheckActorInfoHelper, ActorLabel) == 0x000000, "Member 'FLevelSkeletalMeshCheckActorInfoHelper::ActorLabel' has a wrong offset!");
static_assert(offsetof(FLevelSkeletalMeshCheckActorInfoHelper, Path) == 0x000010, "Member 'FLevelSkeletalMeshCheckActorInfoHelper::Path' has a wrong offset!");

// SharpStruct b1-Managed.LevelSkeletalMeshCheckInfoHelper
// 0x0020 (0x0020 - 0x0000)
struct FLevelSkeletalMeshCheckInfoHelper final
{
public:
	class FString                                 LevelPath;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLevelSkeletalMeshCheckActorInfoHelper> ActorWithoutPerfInfos;                             // 0x0010(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelSkeletalMeshCheckInfoHelper) == 0x000008, "Wrong alignment on FLevelSkeletalMeshCheckInfoHelper");
static_assert(sizeof(FLevelSkeletalMeshCheckInfoHelper) == 0x000020, "Wrong size on FLevelSkeletalMeshCheckInfoHelper");
static_assert(offsetof(FLevelSkeletalMeshCheckInfoHelper, LevelPath) == 0x000000, "Member 'FLevelSkeletalMeshCheckInfoHelper::LevelPath' has a wrong offset!");
static_assert(offsetof(FLevelSkeletalMeshCheckInfoHelper, ActorWithoutPerfInfos) == 0x000010, "Member 'FLevelSkeletalMeshCheckInfoHelper::ActorWithoutPerfInfos' has a wrong offset!");

// SharpStruct b1-Managed.InterpSpeed
// 0x0008 (0x0008 - 0x0000)
struct FInterpSpeed final
{
public:
	ESpeedInterpMode                              InterpMode;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpSpeed) == 0x000004, "Wrong alignment on FInterpSpeed");
static_assert(sizeof(FInterpSpeed) == 0x000008, "Wrong size on FInterpSpeed");
static_assert(offsetof(FInterpSpeed, InterpMode) == 0x000000, "Member 'FInterpSpeed::InterpMode' has a wrong offset!");
static_assert(offsetof(FInterpSpeed, Speed) == 0x000004, "Member 'FInterpSpeed::Speed' has a wrong offset!");

// SharpStruct b1-Managed.CollisionProfileInfo
// 0x000C (0x000C - 0x0000)
struct FCollisionProfileInfo final
{
public:
	ECollisionBodyType                            Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProfileName;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollisionProfileInfo) == 0x000004, "Wrong alignment on FCollisionProfileInfo");
static_assert(sizeof(FCollisionProfileInfo) == 0x00000C, "Wrong size on FCollisionProfileInfo");
static_assert(offsetof(FCollisionProfileInfo, Type) == 0x000000, "Member 'FCollisionProfileInfo::Type' has a wrong offset!");
static_assert(offsetof(FCollisionProfileInfo, ProfileName) == 0x000004, "Member 'FCollisionProfileInfo::ProfileName' has a wrong offset!");

// SharpStruct b1-Managed.PointsRegisterReq
// 0x0088 (0x0088 - 0x0000)
struct FPointsRegisterReq final
{
public:
	int32                                         RegistID;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPointsGenType                                GenType;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPointsGenExtParam                     ExtParam;                                          // 0x0008(0x0080)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPointsRegisterReq) == 0x000008, "Wrong alignment on FPointsRegisterReq");
static_assert(sizeof(FPointsRegisterReq) == 0x000088, "Wrong size on FPointsRegisterReq");
static_assert(offsetof(FPointsRegisterReq, RegistID) == 0x000000, "Member 'FPointsRegisterReq::RegistID' has a wrong offset!");
static_assert(offsetof(FPointsRegisterReq, GenType) == 0x000004, "Member 'FPointsRegisterReq::GenType' has a wrong offset!");
static_assert(offsetof(FPointsRegisterReq, ExtParam) == 0x000008, "Member 'FPointsRegisterReq::ExtParam' has a wrong offset!");

// SharpStruct b1-Managed.FGSSeqAnimKeyStateBlendCfg
// 0x0040 (0x0040 - 0x0000)
struct FFGSSeqAnimKeyStateBlendCfg final
{
public:
	class FString                                 FromStateName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToStateName;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EasingTime;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFunc;                                        // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NeedEasingBlendExp : 1;                            // 0x0025(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EasingBlendExp;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NeedEasingSteps : 1;                               // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EasingSteps;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayEasingTime;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSAnimKBEnumBoolEasing                       EnumValEasingType;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSAnimKBEnumBoolEasing                       BoolValEasingType;                                 // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFGSSeqAnimKeyStateBlendCfg) == 0x000008, "Wrong alignment on FFGSSeqAnimKeyStateBlendCfg");
static_assert(sizeof(FFGSSeqAnimKeyStateBlendCfg) == 0x000040, "Wrong size on FFGSSeqAnimKeyStateBlendCfg");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, FromStateName) == 0x000000, "Member 'FFGSSeqAnimKeyStateBlendCfg::FromStateName' has a wrong offset!");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, ToStateName) == 0x000010, "Member 'FFGSSeqAnimKeyStateBlendCfg::ToStateName' has a wrong offset!");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, EasingTime) == 0x000020, "Member 'FFGSSeqAnimKeyStateBlendCfg::EasingTime' has a wrong offset!");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, EasingFunc) == 0x000024, "Member 'FFGSSeqAnimKeyStateBlendCfg::EasingFunc' has a wrong offset!");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, EasingBlendExp) == 0x000028, "Member 'FFGSSeqAnimKeyStateBlendCfg::EasingBlendExp' has a wrong offset!");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, EasingSteps) == 0x000030, "Member 'FFGSSeqAnimKeyStateBlendCfg::EasingSteps' has a wrong offset!");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, DelayEasingTime) == 0x000034, "Member 'FFGSSeqAnimKeyStateBlendCfg::DelayEasingTime' has a wrong offset!");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, EnumValEasingType) == 0x000038, "Member 'FFGSSeqAnimKeyStateBlendCfg::EnumValEasingType' has a wrong offset!");
static_assert(offsetof(FFGSSeqAnimKeyStateBlendCfg, BoolValEasingType) == 0x000039, "Member 'FFGSSeqAnimKeyStateBlendCfg::BoolValEasingType' has a wrong offset!");

// SharpStruct b1-Managed.B1DBC_ExtraSetting
// 0x0001 (0x0001 - 0x0000)
struct FB1DBC_ExtraSetting final
{
public:
	EDBCTransformType                             TransformType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FB1DBC_ExtraSetting) == 0x000001, "Wrong alignment on FB1DBC_ExtraSetting");
static_assert(sizeof(FB1DBC_ExtraSetting) == 0x000001, "Wrong size on FB1DBC_ExtraSetting");
static_assert(offsetof(FB1DBC_ExtraSetting, TransformType) == 0x000000, "Member 'FB1DBC_ExtraSetting::TransformType' has a wrong offset!");

// SharpStruct b1-Managed.ProcessQueryConditionInfo
// 0x0040 (0x0040 - 0x0000)
struct FProcessQueryConditionInfo final
{
public:
	ETaskQueryCompoundConditionType               TaskQueryConditionType;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TaskStageID;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETaskStageStateType                           TaskStageStateType;                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InteractionGroupID;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionStep;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsPlayer : 1;                                      // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDetectCondition>               QueryUnitConditions;                               // 0x0018(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         OwningItemID;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwningItemNum;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProcessQueryConditionInfo) == 0x000008, "Wrong alignment on FProcessQueryConditionInfo");
static_assert(sizeof(FProcessQueryConditionInfo) == 0x000040, "Wrong size on FProcessQueryConditionInfo");
static_assert(offsetof(FProcessQueryConditionInfo, TaskQueryConditionType) == 0x000000, "Member 'FProcessQueryConditionInfo::TaskQueryConditionType' has a wrong offset!");
static_assert(offsetof(FProcessQueryConditionInfo, TaskStageID) == 0x000004, "Member 'FProcessQueryConditionInfo::TaskStageID' has a wrong offset!");
static_assert(offsetof(FProcessQueryConditionInfo, TaskStageStateType) == 0x000008, "Member 'FProcessQueryConditionInfo::TaskStageStateType' has a wrong offset!");
static_assert(offsetof(FProcessQueryConditionInfo, InteractionGroupID) == 0x00000C, "Member 'FProcessQueryConditionInfo::InteractionGroupID' has a wrong offset!");
static_assert(offsetof(FProcessQueryConditionInfo, InteractionStep) == 0x000010, "Member 'FProcessQueryConditionInfo::InteractionStep' has a wrong offset!");
static_assert(offsetof(FProcessQueryConditionInfo, QueryUnitConditions) == 0x000018, "Member 'FProcessQueryConditionInfo::QueryUnitConditions' has a wrong offset!");
static_assert(offsetof(FProcessQueryConditionInfo, OwningItemID) == 0x000028, "Member 'FProcessQueryConditionInfo::OwningItemID' has a wrong offset!");
static_assert(offsetof(FProcessQueryConditionInfo, OwningItemNum) == 0x00002C, "Member 'FProcessQueryConditionInfo::OwningItemNum' has a wrong offset!");
static_assert(offsetof(FProcessQueryConditionInfo, Comment) == 0x000030, "Member 'FProcessQueryConditionInfo::Comment' has a wrong offset!");

// SharpStruct b1-Managed.TaskStageConditionInfo
// 0x0010 (0x0010 - 0x0000)
struct FTaskStageConditionInfo final
{
public:
	int32                                         TaskStageID;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETaskStageConditionType                       TaskStageConditionType;                            // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomConditionDisplayName;                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTaskStageConditionInfo) == 0x000004, "Wrong alignment on FTaskStageConditionInfo");
static_assert(sizeof(FTaskStageConditionInfo) == 0x000010, "Wrong size on FTaskStageConditionInfo");
static_assert(offsetof(FTaskStageConditionInfo, TaskStageID) == 0x000000, "Member 'FTaskStageConditionInfo::TaskStageID' has a wrong offset!");
static_assert(offsetof(FTaskStageConditionInfo, TaskStageConditionType) == 0x000004, "Member 'FTaskStageConditionInfo::TaskStageConditionType' has a wrong offset!");
static_assert(offsetof(FTaskStageConditionInfo, CustomConditionDisplayName) == 0x000008, "Member 'FTaskStageConditionInfo::CustomConditionDisplayName' has a wrong offset!");

// SharpStruct b1-Managed.TaskQueryConditionInfo
// 0x0068 (0x0068 - 0x0000)
struct FTaskQueryConditionInfo final
{
public:
	ETaskQueryCompoundConditionType               TaskQueryConditionType;                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReverseCondition : 1;                             // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          TaskStage;                                         // 0x0004(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ETaskStageStateType                           TaskStageStateType;                                // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          InteractionGroup;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InteractionStep;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Unit;                                              // 0x002C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDetectCondition>               QueryUnitConditions;                               // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         OwningItemID;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OwningItemNum;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTaskQueryConditionInfo) == 0x000008, "Wrong alignment on FTaskQueryConditionInfo");
static_assert(sizeof(FTaskQueryConditionInfo) == 0x000068, "Wrong size on FTaskQueryConditionInfo");
static_assert(offsetof(FTaskQueryConditionInfo, TaskQueryConditionType) == 0x000000, "Member 'FTaskQueryConditionInfo::TaskQueryConditionType' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, TaskStage) == 0x000004, "Member 'FTaskQueryConditionInfo::TaskStage' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, TaskStageStateType) == 0x000014, "Member 'FTaskQueryConditionInfo::TaskStageStateType' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, InteractionGroup) == 0x000018, "Member 'FTaskQueryConditionInfo::InteractionGroup' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, InteractionStep) == 0x000028, "Member 'FTaskQueryConditionInfo::InteractionStep' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, Unit) == 0x00002C, "Member 'FTaskQueryConditionInfo::Unit' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, QueryUnitConditions) == 0x000040, "Member 'FTaskQueryConditionInfo::QueryUnitConditions' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, OwningItemID) == 0x000050, "Member 'FTaskQueryConditionInfo::OwningItemID' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, OwningItemNum) == 0x000054, "Member 'FTaskQueryConditionInfo::OwningItemNum' has a wrong offset!");
static_assert(offsetof(FTaskQueryConditionInfo, Comment) == 0x000058, "Member 'FTaskQueryConditionInfo::Comment' has a wrong offset!");

// SharpStruct b1-Managed.ScrollInputData
// 0x0014 (0x0014 - 0x0000)
struct FScrollInputData final
{
public:
	float                                         KeyboardInputTime;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeyboardScrollMultiplier;                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadInputTime;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadScrollOriSpeed;                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadScrollMultiplier;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScrollInputData) == 0x000004, "Wrong alignment on FScrollInputData");
static_assert(sizeof(FScrollInputData) == 0x000014, "Wrong size on FScrollInputData");
static_assert(offsetof(FScrollInputData, KeyboardInputTime) == 0x000000, "Member 'FScrollInputData::KeyboardInputTime' has a wrong offset!");
static_assert(offsetof(FScrollInputData, KeyboardScrollMultiplier) == 0x000004, "Member 'FScrollInputData::KeyboardScrollMultiplier' has a wrong offset!");
static_assert(offsetof(FScrollInputData, GamepadInputTime) == 0x000008, "Member 'FScrollInputData::GamepadInputTime' has a wrong offset!");
static_assert(offsetof(FScrollInputData, GamepadScrollOriSpeed) == 0x00000C, "Member 'FScrollInputData::GamepadScrollOriSpeed' has a wrong offset!");
static_assert(offsetof(FScrollInputData, GamepadScrollMultiplier) == 0x000010, "Member 'FScrollInputData::GamepadScrollMultiplier' has a wrong offset!");

// SharpStruct b1-Managed.ScrollData
// 0x0018 (0x0018 - 0x0000)
struct FScrollData final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Resistance;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseSecOrdDyn : 1;                                  // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Frequency;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitResponse;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScrollData) == 0x000004, "Wrong alignment on FScrollData");
static_assert(sizeof(FScrollData) == 0x000018, "Wrong size on FScrollData");
static_assert(offsetof(FScrollData, MaxSpeed) == 0x000000, "Member 'FScrollData::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FScrollData, Resistance) == 0x000004, "Member 'FScrollData::Resistance' has a wrong offset!");
static_assert(offsetof(FScrollData, Frequency) == 0x00000C, "Member 'FScrollData::Frequency' has a wrong offset!");
static_assert(offsetof(FScrollData, Damping) == 0x000010, "Member 'FScrollData::Damping' has a wrong offset!");
static_assert(offsetof(FScrollData, InitResponse) == 0x000014, "Member 'FScrollData::InitResponse' has a wrong offset!");

// SharpStruct b1-Managed.TileItemConfig
// 0x0030 (0x0030 - 0x0000)
struct FTileItemConfig final
{
public:
	struct FVector2D                              Size;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Spacer;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemPath;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTileItemConfig) == 0x000008, "Wrong alignment on FTileItemConfig");
static_assert(sizeof(FTileItemConfig) == 0x000030, "Wrong size on FTileItemConfig");
static_assert(offsetof(FTileItemConfig, Size) == 0x000000, "Member 'FTileItemConfig::Size' has a wrong offset!");
static_assert(offsetof(FTileItemConfig, Spacer) == 0x000010, "Member 'FTileItemConfig::Spacer' has a wrong offset!");
static_assert(offsetof(FTileItemConfig, ItemPath) == 0x000020, "Member 'FTileItemConfig::ItemPath' has a wrong offset!");

// SharpStruct b1-Managed.ObserveActorInfo
// 0x002C (0x002C - 0x0000)
struct FObserveActorInfo final
{
public:
	EObserveConditionType                         ConditionType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGsSmartParam                          ObservedPlayerOrUnitOrActor;                       // 0x0004(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EBGUUnitState                                 UnitState;                                         // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUSimpleState                               SimpleState;                                       // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGUAttrFloat                                 AttrFloatType;                                     // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueCompareOperations                       CompareOperation;                                  // 0x0017(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompareValue;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGsSmartParam                          Buff;                                              // 0x001C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObserveActorInfo) == 0x000004, "Wrong alignment on FObserveActorInfo");
static_assert(sizeof(FObserveActorInfo) == 0x00002C, "Wrong size on FObserveActorInfo");
static_assert(offsetof(FObserveActorInfo, ConditionType) == 0x000000, "Member 'FObserveActorInfo::ConditionType' has a wrong offset!");
static_assert(offsetof(FObserveActorInfo, ObservedPlayerOrUnitOrActor) == 0x000004, "Member 'FObserveActorInfo::ObservedPlayerOrUnitOrActor' has a wrong offset!");
static_assert(offsetof(FObserveActorInfo, UnitState) == 0x000014, "Member 'FObserveActorInfo::UnitState' has a wrong offset!");
static_assert(offsetof(FObserveActorInfo, SimpleState) == 0x000015, "Member 'FObserveActorInfo::SimpleState' has a wrong offset!");
static_assert(offsetof(FObserveActorInfo, AttrFloatType) == 0x000016, "Member 'FObserveActorInfo::AttrFloatType' has a wrong offset!");
static_assert(offsetof(FObserveActorInfo, CompareOperation) == 0x000017, "Member 'FObserveActorInfo::CompareOperation' has a wrong offset!");
static_assert(offsetof(FObserveActorInfo, CompareValue) == 0x000018, "Member 'FObserveActorInfo::CompareValue' has a wrong offset!");
static_assert(offsetof(FObserveActorInfo, Buff) == 0x00001C, "Member 'FObserveActorInfo::Buff' has a wrong offset!");

// SharpStruct b1-Managed.AutoSizeScrollData
// 0x0010 (0x0010 - 0x0000)
struct FAutoSizeScrollData final
{
public:
	float                                         StopSpeed;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollTime;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttractTime;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoSizeScrollData) == 0x000004, "Wrong alignment on FAutoSizeScrollData");
static_assert(sizeof(FAutoSizeScrollData) == 0x000010, "Wrong size on FAutoSizeScrollData");
static_assert(offsetof(FAutoSizeScrollData, StopSpeed) == 0x000000, "Member 'FAutoSizeScrollData::StopSpeed' has a wrong offset!");
static_assert(offsetof(FAutoSizeScrollData, Acceleration) == 0x000004, "Member 'FAutoSizeScrollData::Acceleration' has a wrong offset!");
static_assert(offsetof(FAutoSizeScrollData, ScrollTime) == 0x000008, "Member 'FAutoSizeScrollData::ScrollTime' has a wrong offset!");
static_assert(offsetof(FAutoSizeScrollData, AttractTime) == 0x00000C, "Member 'FAutoSizeScrollData::AttractTime' has a wrong offset!");

// SharpStruct b1-Managed.DebugDrawPoint
// 0x0038 (0x0038 - 0x0000)
struct FDebugDrawPoint final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Point;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebugDrawPoint) == 0x000008, "Wrong alignment on FDebugDrawPoint");
static_assert(sizeof(FDebugDrawPoint) == 0x000038, "Wrong size on FDebugDrawPoint");
static_assert(offsetof(FDebugDrawPoint, Name) == 0x000000, "Member 'FDebugDrawPoint::Name' has a wrong offset!");
static_assert(offsetof(FDebugDrawPoint, Point) == 0x000010, "Member 'FDebugDrawPoint::Point' has a wrong offset!");
static_assert(offsetof(FDebugDrawPoint, Color) == 0x000020, "Member 'FDebugDrawPoint::Color' has a wrong offset!");
static_assert(offsetof(FDebugDrawPoint, Size) == 0x000030, "Member 'FDebugDrawPoint::Size' has a wrong offset!");

// SharpStruct b1-Managed.IL2CPPUnitTestStructOuter
// 0x0028 (0x0028 - 0x0000)
struct FIL2CPPUnitTestStructOuter final
{
public:
	int32                                         TestInt;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIL2CPPUnitTestStructInner>     ItemStructs;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Anim;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestInt2;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIL2CPPUnitTestStructOuter) == 0x000008, "Wrong alignment on FIL2CPPUnitTestStructOuter");
static_assert(sizeof(FIL2CPPUnitTestStructOuter) == 0x000028, "Wrong size on FIL2CPPUnitTestStructOuter");
static_assert(offsetof(FIL2CPPUnitTestStructOuter, TestInt) == 0x000000, "Member 'FIL2CPPUnitTestStructOuter::TestInt' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStructOuter, ItemStructs) == 0x000008, "Member 'FIL2CPPUnitTestStructOuter::ItemStructs' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStructOuter, Anim) == 0x000018, "Member 'FIL2CPPUnitTestStructOuter::Anim' has a wrong offset!");
static_assert(offsetof(FIL2CPPUnitTestStructOuter, TestInt2) == 0x000020, "Member 'FIL2CPPUnitTestStructOuter::TestInt2' has a wrong offset!");

// SharpStruct b1-Managed.InputBrushStruct
// 0x0270 (0x0270 - 0x0000)
struct FInputBrushStruct final
{
public:
	struct FSlateBrush                            ImgIconBGBrush;                                    // 0x0000(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ImgProgBarBrush;                                   // 0x00D0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ImgProgressBrush;                                  // 0x01A0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputBrushStruct) == 0x000010, "Wrong alignment on FInputBrushStruct");
static_assert(sizeof(FInputBrushStruct) == 0x000270, "Wrong size on FInputBrushStruct");
static_assert(offsetof(FInputBrushStruct, ImgIconBGBrush) == 0x000000, "Member 'FInputBrushStruct::ImgIconBGBrush' has a wrong offset!");
static_assert(offsetof(FInputBrushStruct, ImgProgBarBrush) == 0x0000D0, "Member 'FInputBrushStruct::ImgProgBarBrush' has a wrong offset!");
static_assert(offsetof(FInputBrushStruct, ImgProgressBrush) == 0x0001A0, "Member 'FInputBrushStruct::ImgProgressBrush' has a wrong offset!");

// SharpStruct b1-Managed.AnimationRestoreInfo
// 0x0001 (0x0001 - 0x0000)
struct FAnimationRestoreInfo final
{
public:
	uint8                                         RestoreState : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FAnimationRestoreInfo) == 0x000001, "Wrong alignment on FAnimationRestoreInfo");
static_assert(sizeof(FAnimationRestoreInfo) == 0x000001, "Wrong size on FAnimationRestoreInfo");

// SharpStruct b1-Managed.AnimKeyStateBlendCfg
// 0x0030 (0x0030 - 0x0000)
struct FAnimKeyStateBlendCfg final
{
public:
	class FString                                 AnimationName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EasingFullTime;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFunc;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NeedEasingBlendExp : 1;                            // 0x0015(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EasingBlendExp;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NeedEasingSteps : 1;                               // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EasingSteps;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayEasingTime;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSAnimKBEnumBoolEasing                       EnumValEasingType;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSAnimKBEnumBoolEasing                       BoolValEasingType;                                 // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimKeyStateBlendCfg) == 0x000008, "Wrong alignment on FAnimKeyStateBlendCfg");
static_assert(sizeof(FAnimKeyStateBlendCfg) == 0x000030, "Wrong size on FAnimKeyStateBlendCfg");
static_assert(offsetof(FAnimKeyStateBlendCfg, AnimationName) == 0x000000, "Member 'FAnimKeyStateBlendCfg::AnimationName' has a wrong offset!");
static_assert(offsetof(FAnimKeyStateBlendCfg, EasingFullTime) == 0x000010, "Member 'FAnimKeyStateBlendCfg::EasingFullTime' has a wrong offset!");
static_assert(offsetof(FAnimKeyStateBlendCfg, EasingFunc) == 0x000014, "Member 'FAnimKeyStateBlendCfg::EasingFunc' has a wrong offset!");
static_assert(offsetof(FAnimKeyStateBlendCfg, EasingBlendExp) == 0x000018, "Member 'FAnimKeyStateBlendCfg::EasingBlendExp' has a wrong offset!");
static_assert(offsetof(FAnimKeyStateBlendCfg, EasingSteps) == 0x000020, "Member 'FAnimKeyStateBlendCfg::EasingSteps' has a wrong offset!");
static_assert(offsetof(FAnimKeyStateBlendCfg, DelayEasingTime) == 0x000024, "Member 'FAnimKeyStateBlendCfg::DelayEasingTime' has a wrong offset!");
static_assert(offsetof(FAnimKeyStateBlendCfg, EnumValEasingType) == 0x000028, "Member 'FAnimKeyStateBlendCfg::EnumValEasingType' has a wrong offset!");
static_assert(offsetof(FAnimKeyStateBlendCfg, BoolValEasingType) == 0x000029, "Member 'FAnimKeyStateBlendCfg::BoolValEasingType' has a wrong offset!");

// SharpStruct b1-Managed.AnimationInfoWithRef
// 0x0028 (0x0028 - 0x0000)
struct FAnimationInfoWithRef final
{
public:
	class UWidgetAnimation*                       WidgetAnimationRef;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimationInfo                         AnimInfo;                                          // 0x0008(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationInfoWithRef) == 0x000008, "Wrong alignment on FAnimationInfoWithRef");
static_assert(sizeof(FAnimationInfoWithRef) == 0x000028, "Wrong size on FAnimationInfoWithRef");
static_assert(offsetof(FAnimationInfoWithRef, WidgetAnimationRef) == 0x000000, "Member 'FAnimationInfoWithRef::WidgetAnimationRef' has a wrong offset!");
static_assert(offsetof(FAnimationInfoWithRef, AnimInfo) == 0x000008, "Member 'FAnimationInfoWithRef::AnimInfo' has a wrong offset!");

// SharpStruct b1-Managed.GMCharaterConfig
// 0x0000 (0x0000 - 0x0000)
struct FGMCharaterConfig final
{
};
static_assert(alignof(FGMCharaterConfig) == 0x000001, "Wrong alignment on FGMCharaterConfig");
static_assert(sizeof(FGMCharaterConfig) == 0x000001, "Wrong size on FGMCharaterConfig");

// SharpStruct b1-Managed.BaskstabUIInfo
// 0x0010 (0x0010 - 0x0000)
struct FBaskstabUIInfo final
{
public:
	class UMaterialInstance*                      BackstabMatArrayA;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      BackstabMatArrayB;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaskstabUIInfo) == 0x000008, "Wrong alignment on FBaskstabUIInfo");
static_assert(sizeof(FBaskstabUIInfo) == 0x000010, "Wrong size on FBaskstabUIInfo");
static_assert(offsetof(FBaskstabUIInfo, BackstabMatArrayA) == 0x000000, "Member 'FBaskstabUIInfo::BackstabMatArrayA' has a wrong offset!");
static_assert(offsetof(FBaskstabUIInfo, BackstabMatArrayB) == 0x000008, "Member 'FBaskstabUIInfo::BackstabMatArrayB' has a wrong offset!");

// SharpStruct b1-Managed.STBarUninterruptData
// 0x0000 (0x0000 - 0x0000)
struct FSTBarUninterruptData final
{
};
static_assert(alignof(FSTBarUninterruptData) == 0x000001, "Wrong alignment on FSTBarUninterruptData");
static_assert(sizeof(FSTBarUninterruptData) == 0x000001, "Wrong size on FSTBarUninterruptData");

// SharpStruct b1-Managed.UnitDeadPhysicsConfig
// 0x000C (0x000C - 0x0000)
struct FUnitDeadPhysicsConfig final
{
public:
	int32                                         DistanceToWall;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StiffLevel;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitActionDir                                 HitActionDir;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnitDeadPhysicsConfig) == 0x000004, "Wrong alignment on FUnitDeadPhysicsConfig");
static_assert(sizeof(FUnitDeadPhysicsConfig) == 0x00000C, "Wrong size on FUnitDeadPhysicsConfig");
static_assert(offsetof(FUnitDeadPhysicsConfig, DistanceToWall) == 0x000000, "Member 'FUnitDeadPhysicsConfig::DistanceToWall' has a wrong offset!");
static_assert(offsetof(FUnitDeadPhysicsConfig, StiffLevel) == 0x000004, "Member 'FUnitDeadPhysicsConfig::StiffLevel' has a wrong offset!");
static_assert(offsetof(FUnitDeadPhysicsConfig, HitActionDir) == 0x000008, "Member 'FUnitDeadPhysicsConfig::HitActionDir' has a wrong offset!");

}

