#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: b1

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "b1_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "ReplicationGraph_structs.hpp"
#include "ReplicationGraph_classes.hpp"
#include "UnrealExtent_structs.hpp"
#include "UnrealExtent_classes.hpp"
#include "ProceduralMeshComponent_structs.hpp"
#include "AkAudio_structs.hpp"
#include "LevelSequence_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "MovieScene_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "AsyncLoadingScreen_structs.hpp"
#include "NetCore_structs.hpp"


namespace SDK
{

// Class b1.ActorDataContainer
// 0x0010 (0x00C0 - 0x00B0)
class UActorDataContainer : public UActorComponent
{
public:
	TArray<class UObject*>                        MDatas;                                            // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void AddDataObjInCS(class UObject* Obj);
	void ClearDataObj();
	void InitOnNewInCS();
	void LateECSBeginPlay();
	void OnDestoryInCS();
	void PreECSBeginPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDataContainer">();
	}
	static class UActorDataContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorDataContainer>();
	}
};
static_assert(alignof(UActorDataContainer) == 0x000008, "Wrong alignment on UActorDataContainer");
static_assert(sizeof(UActorDataContainer) == 0x0000C0, "Wrong size on UActorDataContainer");
static_assert(offsetof(UActorDataContainer, MDatas) == 0x0000B0, "Member 'UActorDataContainer::MDatas' has a wrong offset!");

// Class b1.ActorCompContainer
// 0x0018 (0x00C8 - 0x00B0)
class UActorCompContainer final : public UActorComponent
{
public:
	class UActorDataContainer*                    DataContainer;                                     // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                EventCollection;                                   // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TeamID;                                            // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FillDataContainer(class UActorDataContainer* DataObj);
	void FillEventCollection(class UObject* DataObj);
	void SetTeamID(int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorCompContainer">();
	}
	static class UActorCompContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorCompContainer>();
	}
};
static_assert(alignof(UActorCompContainer) == 0x000008, "Wrong alignment on UActorCompContainer");
static_assert(sizeof(UActorCompContainer) == 0x0000C8, "Wrong size on UActorCompContainer");
static_assert(offsetof(UActorCompContainer, DataContainer) == 0x0000B0, "Member 'UActorCompContainer::DataContainer' has a wrong offset!");
static_assert(offsetof(UActorCompContainer, EventCollection) == 0x0000B8, "Member 'UActorCompContainer::EventCollection' has a wrong offset!");
static_assert(offsetof(UActorCompContainer, TeamID) == 0x0000C0, "Member 'UActorCompContainer::TeamID' has a wrong offset!");

// Class b1.BGUCrowdFollowingComponent
// 0x0090 (0x03A8 - 0x0318)
class UBGUCrowdFollowingComponent final : public UGSCrowdFollowingComponent
{
public:
	float                                         RotationSpeed;                                     // 0x0318(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x031C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31D[0x3];                                      // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DesiredVelocity;                                   // 0x0320(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredAngleDelta;                                 // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RequestedVelocity;                                 // 0x0340(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawDelta;                                          // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TerrainRotation;                                   // 0x0360(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpeedLimit;                                        // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DeltaPosition;                                     // 0x0380(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedMax;                                  // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedAcc;                                  // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportFlock;                                     // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCrowdFollowingEnabled(bool bEnabled, bool bIsObstacle);
	void SetCrowdFollowingParam(float FSeparationWeight, float FCollisionQueryRange, float FPathOptimizationRange, int32 IAvoidanceQualityLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUCrowdFollowingComponent">();
	}
	static class UBGUCrowdFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUCrowdFollowingComponent>();
	}
};
static_assert(alignof(UBGUCrowdFollowingComponent) == 0x000008, "Wrong alignment on UBGUCrowdFollowingComponent");
static_assert(sizeof(UBGUCrowdFollowingComponent) == 0x0003A8, "Wrong size on UBGUCrowdFollowingComponent");
static_assert(offsetof(UBGUCrowdFollowingComponent, RotationSpeed) == 0x000318, "Member 'UBGUCrowdFollowingComponent::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, bPause) == 0x00031C, "Member 'UBGUCrowdFollowingComponent::bPause' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, DesiredVelocity) == 0x000320, "Member 'UBGUCrowdFollowingComponent::DesiredVelocity' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, DesiredAngleDelta) == 0x000338, "Member 'UBGUCrowdFollowingComponent::DesiredAngleDelta' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, RequestedVelocity) == 0x000340, "Member 'UBGUCrowdFollowingComponent::RequestedVelocity' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, YawDelta) == 0x000358, "Member 'UBGUCrowdFollowingComponent::YawDelta' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, TerrainRotation) == 0x000360, "Member 'UBGUCrowdFollowingComponent::TerrainRotation' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, SpeedLimit) == 0x000378, "Member 'UBGUCrowdFollowingComponent::SpeedLimit' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, DeltaPosition) == 0x000380, "Member 'UBGUCrowdFollowingComponent::DeltaPosition' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, RotationSpeedMax) == 0x000398, "Member 'UBGUCrowdFollowingComponent::RotationSpeedMax' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, RotationSpeedAcc) == 0x00039C, "Member 'UBGUCrowdFollowingComponent::RotationSpeedAcc' has a wrong offset!");
static_assert(offsetof(UBGUCrowdFollowingComponent, bSupportFlock) == 0x0003A0, "Member 'UBGUCrowdFollowingComponent::bSupportFlock' has a wrong offset!");

// Class b1.AnimNotifyFuncLibrary
// 0x0000 (0x0028 - 0x0028)
class UAnimNotifyFuncLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DeleteAnimNotifyAndAnimNotifyState(class UAnimMontage* AnimMontage, const TArray<EGsEnAnimN>& NotifyTypeList, const TArray<EGsEnAnimNS>& NotifyStateTypeList);
	static void GetAllAnimNotifySoftAsset(class UAnimSequenceBase* AnimBase, TMap<class UAnimNotify_GSBase*, struct FNotifySoftRefs>* OutNotifyRefs, TMap<class UAnimNotifyState_GSBase*, struct FNotifySoftRefs>* OutNotifyStateRefs);
	static void PrepareAnimationsNotifySoftAsset(const TArray<class UAnimSequenceBase*>& AnimBases, TMap<class UAnimNotify_GSBase*, struct FNotifySoftRefs>* OutNotifyRefs, TMap<class UAnimNotifyState_GSBase*, struct FNotifySoftRefs>* OutNotifyStateRefs);
	static void PrepareAnimNotifySoftAsset(class UAnimSequenceBase* AnimBase, TMap<class UAnimNotify_GSBase*, struct FNotifySoftRefs>* OutNotifyRefs, TMap<class UAnimNotifyState_GSBase*, struct FNotifySoftRefs>* OutNotifyStateRefs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyFuncLibrary">();
	}
	static class UAnimNotifyFuncLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyFuncLibrary>();
	}
};
static_assert(alignof(UAnimNotifyFuncLibrary) == 0x000008, "Wrong alignment on UAnimNotifyFuncLibrary");
static_assert(sizeof(UAnimNotifyFuncLibrary) == 0x000028, "Wrong size on UAnimNotifyFuncLibrary");

// Class b1.BGUDataComp
// 0x0010 (0x00D0 - 0x00C0)
class UBGUDataComp : public UActorDataContainer
{
public:
	class UBUC_AIComponent*                       MUBUC_AIComponent;                                 // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBUC_ACharacterComponent*               MUBUC_ACharacterComponent;                         // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWithAIController(class ABGUAIController* AIController);
	void InitWithCharacter(class ABGUCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUDataComp">();
	}
	static class UBGUDataComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUDataComp>();
	}
};
static_assert(alignof(UBGUDataComp) == 0x000008, "Wrong alignment on UBGUDataComp");
static_assert(sizeof(UBGUDataComp) == 0x0000D0, "Wrong size on UBGUDataComp");
static_assert(offsetof(UBGUDataComp, MUBUC_AIComponent) == 0x0000C0, "Member 'UBGUDataComp::MUBUC_AIComponent' has a wrong offset!");
static_assert(offsetof(UBGUDataComp, MUBUC_ACharacterComponent) == 0x0000C8, "Member 'UBGUDataComp::MUBUC_ACharacterComponent' has a wrong offset!");

// Class b1.AnimNotifyState_GSBase
// 0x0018 (0x0048 - 0x0030)
class UAnimNotifyState_GSBase : public UAnimNotifyState
{
public:
	EGsEnAnimNS                                   AnimNSType;                                        // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanTriggerEndByCrossMontageBegin;                 // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCheckAnimInstance;                               // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanBePlacedInASCS;                                 // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanUseQueuedType;                                  // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPreload;                                         // 0x0035(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        PreloadedAssets;                                   // 0x0038(0x0010)(BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void AddPreloadedAsset(class UObject* Obj) const;
	EGsEnAnimNS GetAnimNSType() const;
	class FString GetJumpableSectionPrefix() const;
	float GetModifySpeedRate() const;
	TArray<class UObject*> GetPreloadedAssets() const;
	TArray<struct FSoftObjectPath> GetSoftReferences() const;
	bool GSAllowCrossSection() const;
	void GSNotifyBeginCS(const struct FUStGSNotifyParam& NotifyParam, float TotalDuration) const;
	int32 GSNotifyDebugPostBeginCS(const struct FUStGSNotifyParam& NotifyParam) const;
	int32 GSNotifyDebugPostEndCS(const struct FUStGSNotifyParam& NotifyParam) const;
	int32 GSNotifyDebugPostTickCS(const struct FUStGSNotifyParam& NotifyParam) const;
	int32 GSNotifyDebugPreBeginCS(const struct FUStGSNotifyParam& NotifyParam) const;
	int32 GSNotifyDebugPreEndCS(const struct FUStGSNotifyParam& NotifyParam) const;
	int32 GSNotifyDebugPreTickCS(const struct FUStGSNotifyParam& NotifyParam) const;
	void GSNotifyEndCS(const struct FUStGSNotifyParam& NotifyParam) const;
	void GSNotifyTickCS(const struct FUStGSNotifyParam& NotifyParam, float FrameDeltaTime) const;
	void GSOnSectionManuallyChanged(class ABGUCharacter* OwnerChar, float RemainingDuration) const;
	void GSValidateInputCS(class AActor* Actor) const;
	void UpdateDataOnNotifyStateReplace(const class UAnimNotifyState* NewNotifyState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSBase">();
	}
	static class UAnimNotifyState_GSBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSBase>();
	}
};
static_assert(alignof(UAnimNotifyState_GSBase) == 0x000008, "Wrong alignment on UAnimNotifyState_GSBase");
static_assert(sizeof(UAnimNotifyState_GSBase) == 0x000048, "Wrong size on UAnimNotifyState_GSBase");
static_assert(offsetof(UAnimNotifyState_GSBase, AnimNSType) == 0x000030, "Member 'UAnimNotifyState_GSBase::AnimNSType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSBase, bCanTriggerEndByCrossMontageBegin) == 0x000031, "Member 'UAnimNotifyState_GSBase::bCanTriggerEndByCrossMontageBegin' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSBase, IsCheckAnimInstance) == 0x000032, "Member 'UAnimNotifyState_GSBase::IsCheckAnimInstance' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSBase, CanBePlacedInASCS) == 0x000033, "Member 'UAnimNotifyState_GSBase::CanBePlacedInASCS' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSBase, CanUseQueuedType) == 0x000034, "Member 'UAnimNotifyState_GSBase::CanUseQueuedType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSBase, IsPreload) == 0x000035, "Member 'UAnimNotifyState_GSBase::IsPreload' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSBase, PreloadedAssets) == 0x000038, "Member 'UAnimNotifyState_GSBase::PreloadedAssets' has a wrong offset!");

// Class b1.BGUDebugCircleComponent
// 0x0010 (0x0580 - 0x0570)
class UBGUDebugCircleComponent final : public UShapeComponent
{
public:
	float                                         CircleRadius;                                      // 0x0570(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CircleThickness;                                   // 0x0574(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCircleRadius(float InCircleRadius);

	float GetScaledCircleRadius() const;
	float GetShapeScale() const;
	float GetUnscaledCircleRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUDebugCircleComponent">();
	}
	static class UBGUDebugCircleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUDebugCircleComponent>();
	}
};
static_assert(alignof(UBGUDebugCircleComponent) == 0x000010, "Wrong alignment on UBGUDebugCircleComponent");
static_assert(sizeof(UBGUDebugCircleComponent) == 0x000580, "Wrong size on UBGUDebugCircleComponent");
static_assert(offsetof(UBGUDebugCircleComponent, CircleRadius) == 0x000570, "Member 'UBGUDebugCircleComponent::CircleRadius' has a wrong offset!");
static_assert(offsetof(UBGUDebugCircleComponent, CircleThickness) == 0x000574, "Member 'UBGUDebugCircleComponent::CircleThickness' has a wrong offset!");

// Class b1.AnimNotifyState_GSDevLineHit
// 0x0018 (0x0060 - 0x0048)
class UAnimNotifyState_GSDevLineHit : public UAnimNotifyState_GSBase
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x0048(0x0001)(BlueprintReadOnly, ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESweepCheckHitFilterType                      ResultFilterType;                                  // 0x0049(0x0001)(BlueprintReadOnly, ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitVEffectID;                                      // 0x004C(0x0004)(BlueprintReadOnly, ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHitFromActorLocation : 1;                         // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitCheckRadius;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRenderDebugShape : 1;                             // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintReadOnly, Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSDevLineHit">();
	}
	static class UAnimNotifyState_GSDevLineHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSDevLineHit>();
	}
};
static_assert(alignof(UAnimNotifyState_GSDevLineHit) == 0x000008, "Wrong alignment on UAnimNotifyState_GSDevLineHit");
static_assert(sizeof(UAnimNotifyState_GSDevLineHit) == 0x000060, "Wrong size on UAnimNotifyState_GSDevLineHit");
static_assert(offsetof(UAnimNotifyState_GSDevLineHit, CollisionChannel) == 0x000048, "Member 'UAnimNotifyState_GSDevLineHit::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSDevLineHit, ResultFilterType) == 0x000049, "Member 'UAnimNotifyState_GSDevLineHit::ResultFilterType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSDevLineHit, HitVEffectID) == 0x00004C, "Member 'UAnimNotifyState_GSDevLineHit::HitVEffectID' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSDevLineHit, HitCheckRadius) == 0x000054, "Member 'UAnimNotifyState_GSDevLineHit::HitCheckRadius' has a wrong offset!");

// Class b1.BGUDebugSectorComponent
// 0x0010 (0x0580 - 0x0570)
class UBGUDebugSectorComponent final : public UShapeComponent
{
public:
	float                                         SectorRadius;                                      // 0x0570(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorMinAngle;                                    // 0x0574(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorMaxAngle;                                    // 0x0578(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SectorThickness;                                   // 0x057C(0x0004)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSectorMaxAngle(float InMaxAngle);
	void SetSectorMinAngle(float InMinAngle);
	void SetSectorRadius(float InSectorRadius);

	float GetScaledSectorRadius() const;
	float GetShapeScale() const;
	float GetUnscaledSectorRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUDebugSectorComponent">();
	}
	static class UBGUDebugSectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUDebugSectorComponent>();
	}
};
static_assert(alignof(UBGUDebugSectorComponent) == 0x000010, "Wrong alignment on UBGUDebugSectorComponent");
static_assert(sizeof(UBGUDebugSectorComponent) == 0x000580, "Wrong size on UBGUDebugSectorComponent");
static_assert(offsetof(UBGUDebugSectorComponent, SectorRadius) == 0x000570, "Member 'UBGUDebugSectorComponent::SectorRadius' has a wrong offset!");
static_assert(offsetof(UBGUDebugSectorComponent, SectorMinAngle) == 0x000574, "Member 'UBGUDebugSectorComponent::SectorMinAngle' has a wrong offset!");
static_assert(offsetof(UBGUDebugSectorComponent, SectorMaxAngle) == 0x000578, "Member 'UBGUDebugSectorComponent::SectorMaxAngle' has a wrong offset!");
static_assert(offsetof(UBGUDebugSectorComponent, SectorThickness) == 0x00057C, "Member 'UBGUDebugSectorComponent::SectorThickness' has a wrong offset!");

// Class b1.AnimNotifyState_GSEditorHelper
// 0x0000 (0x0048 - 0x0048)
class UAnimNotifyState_GSEditorHelper : public UAnimNotifyState_GSBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSEditorHelper">();
	}
	static class UAnimNotifyState_GSEditorHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSEditorHelper>();
	}
};
static_assert(alignof(UAnimNotifyState_GSEditorHelper) == 0x000008, "Wrong alignment on UAnimNotifyState_GSEditorHelper");
static_assert(sizeof(UAnimNotifyState_GSEditorHelper) == 0x000048, "Wrong size on UAnimNotifyState_GSEditorHelper");

// Class b1.BGUEditorTickableActor
// 0x0018 (0x0290 - 0x0278)
class ABGUEditorTickableActor final : public AActor
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetViewportCameraLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUEditorTickableActor">();
	}
	static class ABGUEditorTickableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUEditorTickableActor>();
	}
};
static_assert(alignof(ABGUEditorTickableActor) == 0x000008, "Wrong alignment on ABGUEditorTickableActor");
static_assert(sizeof(ABGUEditorTickableActor) == 0x000290, "Wrong size on ABGUEditorTickableActor");

// Class b1.AnimNotifyState_GSHeadLock
// 0x0008 (0x0050 - 0x0048)
class UAnimNotifyState_GSHeadLock : public UAnimNotifyState_GSBase
{
public:
	float                                         ReduceHeadLockAlphaScale;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSHeadLock">();
	}
	static class UAnimNotifyState_GSHeadLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSHeadLock>();
	}
};
static_assert(alignof(UAnimNotifyState_GSHeadLock) == 0x000008, "Wrong alignment on UAnimNotifyState_GSHeadLock");
static_assert(sizeof(UAnimNotifyState_GSHeadLock) == 0x000050, "Wrong size on UAnimNotifyState_GSHeadLock");
static_assert(offsetof(UAnimNotifyState_GSHeadLock, ReduceHeadLockAlphaScale) == 0x000048, "Member 'UAnimNotifyState_GSHeadLock::ReduceHeadLockAlphaScale' has a wrong offset!");

// Class b1.BGUEQSObject
// 0x00D8 (0x0100 - 0x0028)
class UBGUEQSObject final : public UObject
{
public:
	class UEnvQuery*                              EnvQuery;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FEnvQueryRequest                       EvnQueryReq;                                       // 0x0030(0x0068)(NativeAccessSpecifierPrivate)
	class AActor*                                 QuerierObject;                                     // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, struct FGSEQSExParam>             Req_ExParamMap;                                    // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             FBUE_RunEQSFinish;                                 // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 EQSObjRun(const class UEnvQuery* EnvQueryObj, class AActor* Querier, EBGURunEQSObjReason Reason, const struct FGSEQSExParam& _ExParam);
	void EQSObjRunInstant(const class UEnvQuery* EnvQueryObj, class AActor* Querier, TArray<struct FVector>* Locations, TArray<float>* Scores);
	void EQSObjRunInstantWithCustomParams(const class UEnvQuery* EnvQueryObj, class AActor* Querier, const TArray<struct FGSEnvNamedValue>& NamedParams, TArray<struct FVector>* Locations, TArray<float>* Scores);
	int32 EQSObjRunWithCustomParams(const class UEnvQuery* EnvQueryObj, class AActor* Querier, EBGURunEQSObjReason Reason, const TArray<struct FGSEnvNamedValue>& NamedParams);
	int32 EQSRun(const class FString& EQSPath, class AActor* Querier, EBGURunEQSObjReason Reason, const struct FGSEQSExParam& _ExParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUEQSObject">();
	}
	static class UBGUEQSObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUEQSObject>();
	}
};
static_assert(alignof(UBGUEQSObject) == 0x000008, "Wrong alignment on UBGUEQSObject");
static_assert(sizeof(UBGUEQSObject) == 0x000100, "Wrong size on UBGUEQSObject");
static_assert(offsetof(UBGUEQSObject, EnvQuery) == 0x000028, "Member 'UBGUEQSObject::EnvQuery' has a wrong offset!");
static_assert(offsetof(UBGUEQSObject, EvnQueryReq) == 0x000030, "Member 'UBGUEQSObject::EvnQueryReq' has a wrong offset!");
static_assert(offsetof(UBGUEQSObject, QuerierObject) == 0x000098, "Member 'UBGUEQSObject::QuerierObject' has a wrong offset!");
static_assert(offsetof(UBGUEQSObject, Req_ExParamMap) == 0x0000A0, "Member 'UBGUEQSObject::Req_ExParamMap' has a wrong offset!");
static_assert(offsetof(UBGUEQSObject, FBUE_RunEQSFinish) == 0x0000F0, "Member 'UBGUEQSObject::FBUE_RunEQSFinish' has a wrong offset!");

// Class b1.AnimNotifyState_GSLockHandFoot
// 0x0008 (0x0050 - 0x0048)
class UAnimNotifyState_GSLockHandFoot : public UAnimNotifyState_GSBase
{
public:
	EBUHandFootType                               NeedLockType;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeginReduceScale;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSLockHandFoot">();
	}
	static class UAnimNotifyState_GSLockHandFoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSLockHandFoot>();
	}
};
static_assert(alignof(UAnimNotifyState_GSLockHandFoot) == 0x000008, "Wrong alignment on UAnimNotifyState_GSLockHandFoot");
static_assert(sizeof(UAnimNotifyState_GSLockHandFoot) == 0x000050, "Wrong size on UAnimNotifyState_GSLockHandFoot");
static_assert(offsetof(UAnimNotifyState_GSLockHandFoot, NeedLockType) == 0x000048, "Member 'UAnimNotifyState_GSLockHandFoot::NeedLockType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSLockHandFoot, BeginReduceScale) == 0x00004C, "Member 'UAnimNotifyState_GSLockHandFoot::BeginReduceScale' has a wrong offset!");

// Class b1.BGUFluid2DComponent
// 0x0218 (0x02C8 - 0x00B0)
class UBGUFluid2DComponent final : public UActorComponent
{
public:
	bool                                          ToggleSim;                                         // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPostProcessCollisionData;                         // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          blueprintDrivenParameters;                         // 0x00B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovedCheck;                                       // 0x00B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          blocationCheck;                                    // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocalSim;                                         // 0x00B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHighQualitySim;                                   // 0x00B6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimAreaClamp;                                     // 0x00B7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxIteration;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SimulationResX;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SimulationResY;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimAreaSizeInCM;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SnappedPosParameterName;                           // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           DynamicSDFMpc;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOffsetThreshold;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveThreadhold;                                    // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgeExtendSize;                                    // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExportVeloDensity;                                // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExportPressureDivergence;                         // 0x00E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 VeloDensityOutput;                                 // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 PressureDivergenceOutput;                          // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CollisionQueryMaterial;                            // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PPCollisionQueryMaterial;                          // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CompositeMaterial;                                 // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     AdvectMaterial;                                    // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DivergenceMaterial;                                // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PressureStep1Material;                             // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PressureStep2Material;                             // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushPuncture;                                     // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloDirNoise;                                      // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloFromSimAreaMotion;                             // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimEdgeBouncyness;                                 // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeDensityAtSimEdge;                              // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloDirNoiseSize;                                  // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloDirNoiseSpeed;                                 // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloOffsetX;                                       // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloOffsetY;                                       // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloFromBrushMotion;                               // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloStrength;                                      // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloRotate;                                        // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloAmpNoise;                                      // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InputFeedback;                                     // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlowFeedback;                                      // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Divergence;                                        // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushSize;                                         // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushStrength;                                     // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EraserMode;                                        // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushHardness;                                     // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DensityTemplate;                                   // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             VelocityTemplate;                                  // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityOffsetSpeed;                               // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgeMaskWidth;                                     // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityTxtMult;                                    // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityTxtScale;                                   // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityTxtOffsetX;                                 // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityTxtOffsetY;                                 // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushNoise;                                        // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloInputTile;                                     // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityInputNoiseAmp;                              // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityInputNoiseOffset;                           // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityInputNoiseTile;                             // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushRnd;                                          // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOffsetX;                                      // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOffsetY;                                      // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x90];                                     // 0x01D0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RT_CollisionResult;                                // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_PPCollisionResult;                              // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_Advection;                                      // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_PressureDivergence;                             // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_Composite;                                      // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_PressureDivergenceTemp;                         // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CollisionQueryMaterialInstance;                    // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PPCollisionQueryMaterialInstance;                  // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CompositeMaterialInstance;                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               AdvectMaterialInstance;                            // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DivergenceMaterialInstance;                        // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PressureStep1MaterialInstance;                     // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PressureStep2MaterialInstance;                     // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UTextureRenderTarget2D* GetPressureDivergenceTexture();
	class UTextureRenderTarget2D* GetVeloDensityTexture();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFluid2DComponent">();
	}
	static class UBGUFluid2DComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFluid2DComponent>();
	}
};
static_assert(alignof(UBGUFluid2DComponent) == 0x000008, "Wrong alignment on UBGUFluid2DComponent");
static_assert(sizeof(UBGUFluid2DComponent) == 0x0002C8, "Wrong size on UBGUFluid2DComponent");
static_assert(offsetof(UBGUFluid2DComponent, ToggleSim) == 0x0000B0, "Member 'UBGUFluid2DComponent::ToggleSim' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, bPostProcessCollisionData) == 0x0000B1, "Member 'UBGUFluid2DComponent::bPostProcessCollisionData' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, blueprintDrivenParameters) == 0x0000B2, "Member 'UBGUFluid2DComponent::blueprintDrivenParameters' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, bMovedCheck) == 0x0000B3, "Member 'UBGUFluid2DComponent::bMovedCheck' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, blocationCheck) == 0x0000B4, "Member 'UBGUFluid2DComponent::blocationCheck' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, bLocalSim) == 0x0000B5, "Member 'UBGUFluid2DComponent::bLocalSim' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, bHighQualitySim) == 0x0000B6, "Member 'UBGUFluid2DComponent::bHighQualitySim' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, bSimAreaClamp) == 0x0000B7, "Member 'UBGUFluid2DComponent::bSimAreaClamp' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, MaxIteration) == 0x0000B8, "Member 'UBGUFluid2DComponent::MaxIteration' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, SimulationResX) == 0x0000BC, "Member 'UBGUFluid2DComponent::SimulationResX' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, SimulationResY) == 0x0000C0, "Member 'UBGUFluid2DComponent::SimulationResY' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, SimAreaSizeInCM) == 0x0000C4, "Member 'UBGUFluid2DComponent::SimAreaSizeInCM' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, SnappedPosParameterName) == 0x0000C8, "Member 'UBGUFluid2DComponent::SnappedPosParameterName' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DynamicSDFMpc) == 0x0000D0, "Member 'UBGUFluid2DComponent::DynamicSDFMpc' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, WorldOffsetThreshold) == 0x0000D8, "Member 'UBGUFluid2DComponent::WorldOffsetThreshold' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, MoveThreadhold) == 0x0000DC, "Member 'UBGUFluid2DComponent::MoveThreadhold' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, EdgeExtendSize) == 0x0000E0, "Member 'UBGUFluid2DComponent::EdgeExtendSize' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, bExportVeloDensity) == 0x0000E4, "Member 'UBGUFluid2DComponent::bExportVeloDensity' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, bExportPressureDivergence) == 0x0000E5, "Member 'UBGUFluid2DComponent::bExportPressureDivergence' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloDensityOutput) == 0x0000E8, "Member 'UBGUFluid2DComponent::VeloDensityOutput' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, PressureDivergenceOutput) == 0x0000F0, "Member 'UBGUFluid2DComponent::PressureDivergenceOutput' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, CollisionQueryMaterial) == 0x0000F8, "Member 'UBGUFluid2DComponent::CollisionQueryMaterial' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, PPCollisionQueryMaterial) == 0x000100, "Member 'UBGUFluid2DComponent::PPCollisionQueryMaterial' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, CompositeMaterial) == 0x000108, "Member 'UBGUFluid2DComponent::CompositeMaterial' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, AdvectMaterial) == 0x000110, "Member 'UBGUFluid2DComponent::AdvectMaterial' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DivergenceMaterial) == 0x000118, "Member 'UBGUFluid2DComponent::DivergenceMaterial' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, PressureStep1Material) == 0x000120, "Member 'UBGUFluid2DComponent::PressureStep1Material' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, PressureStep2Material) == 0x000128, "Member 'UBGUFluid2DComponent::PressureStep2Material' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, BrushPuncture) == 0x000130, "Member 'UBGUFluid2DComponent::BrushPuncture' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloDirNoise) == 0x000134, "Member 'UBGUFluid2DComponent::VeloDirNoise' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, Speed) == 0x000138, "Member 'UBGUFluid2DComponent::Speed' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloFromSimAreaMotion) == 0x00013C, "Member 'UBGUFluid2DComponent::VeloFromSimAreaMotion' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, SimEdgeBouncyness) == 0x000140, "Member 'UBGUFluid2DComponent::SimEdgeBouncyness' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, FadeDensityAtSimEdge) == 0x000144, "Member 'UBGUFluid2DComponent::FadeDensityAtSimEdge' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloDirNoiseSize) == 0x000148, "Member 'UBGUFluid2DComponent::VeloDirNoiseSize' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloDirNoiseSpeed) == 0x00014C, "Member 'UBGUFluid2DComponent::VeloDirNoiseSpeed' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloOffsetX) == 0x000150, "Member 'UBGUFluid2DComponent::VeloOffsetX' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloOffsetY) == 0x000154, "Member 'UBGUFluid2DComponent::VeloOffsetY' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloFromBrushMotion) == 0x000158, "Member 'UBGUFluid2DComponent::VeloFromBrushMotion' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloStrength) == 0x00015C, "Member 'UBGUFluid2DComponent::VeloStrength' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloRotate) == 0x000160, "Member 'UBGUFluid2DComponent::VeloRotate' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloAmpNoise) == 0x000164, "Member 'UBGUFluid2DComponent::VeloAmpNoise' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, InputFeedback) == 0x000168, "Member 'UBGUFluid2DComponent::InputFeedback' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, FlowFeedback) == 0x00016C, "Member 'UBGUFluid2DComponent::FlowFeedback' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, Divergence) == 0x000170, "Member 'UBGUFluid2DComponent::Divergence' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, BrushSize) == 0x000174, "Member 'UBGUFluid2DComponent::BrushSize' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, BrushStrength) == 0x000178, "Member 'UBGUFluid2DComponent::BrushStrength' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, EraserMode) == 0x00017C, "Member 'UBGUFluid2DComponent::EraserMode' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, BrushHardness) == 0x000180, "Member 'UBGUFluid2DComponent::BrushHardness' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DensityTemplate) == 0x000188, "Member 'UBGUFluid2DComponent::DensityTemplate' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VelocityTemplate) == 0x000190, "Member 'UBGUFluid2DComponent::VelocityTemplate' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VelocityOffsetSpeed) == 0x000198, "Member 'UBGUFluid2DComponent::VelocityOffsetSpeed' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, EdgeMaskWidth) == 0x00019C, "Member 'UBGUFluid2DComponent::EdgeMaskWidth' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DensityTxtMult) == 0x0001A0, "Member 'UBGUFluid2DComponent::DensityTxtMult' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DensityTxtScale) == 0x0001A4, "Member 'UBGUFluid2DComponent::DensityTxtScale' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DensityTxtOffsetX) == 0x0001A8, "Member 'UBGUFluid2DComponent::DensityTxtOffsetX' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DensityTxtOffsetY) == 0x0001AC, "Member 'UBGUFluid2DComponent::DensityTxtOffsetY' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, BrushNoise) == 0x0001B0, "Member 'UBGUFluid2DComponent::BrushNoise' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, VeloInputTile) == 0x0001B4, "Member 'UBGUFluid2DComponent::VeloInputTile' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DensityInputNoiseAmp) == 0x0001B8, "Member 'UBGUFluid2DComponent::DensityInputNoiseAmp' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DensityInputNoiseOffset) == 0x0001BC, "Member 'UBGUFluid2DComponent::DensityInputNoiseOffset' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DensityInputNoiseTile) == 0x0001C0, "Member 'UBGUFluid2DComponent::DensityInputNoiseTile' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, BrushRnd) == 0x0001C4, "Member 'UBGUFluid2DComponent::BrushRnd' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, WorldOffsetX) == 0x0001C8, "Member 'UBGUFluid2DComponent::WorldOffsetX' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, WorldOffsetY) == 0x0001CC, "Member 'UBGUFluid2DComponent::WorldOffsetY' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, RT_CollisionResult) == 0x000260, "Member 'UBGUFluid2DComponent::RT_CollisionResult' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, RT_PPCollisionResult) == 0x000268, "Member 'UBGUFluid2DComponent::RT_PPCollisionResult' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, RT_Advection) == 0x000270, "Member 'UBGUFluid2DComponent::RT_Advection' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, RT_PressureDivergence) == 0x000278, "Member 'UBGUFluid2DComponent::RT_PressureDivergence' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, RT_Composite) == 0x000280, "Member 'UBGUFluid2DComponent::RT_Composite' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, RT_PressureDivergenceTemp) == 0x000288, "Member 'UBGUFluid2DComponent::RT_PressureDivergenceTemp' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, CollisionQueryMaterialInstance) == 0x000290, "Member 'UBGUFluid2DComponent::CollisionQueryMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, PPCollisionQueryMaterialInstance) == 0x000298, "Member 'UBGUFluid2DComponent::PPCollisionQueryMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, CompositeMaterialInstance) == 0x0002A0, "Member 'UBGUFluid2DComponent::CompositeMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, AdvectMaterialInstance) == 0x0002A8, "Member 'UBGUFluid2DComponent::AdvectMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, DivergenceMaterialInstance) == 0x0002B0, "Member 'UBGUFluid2DComponent::DivergenceMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, PressureStep1MaterialInstance) == 0x0002B8, "Member 'UBGUFluid2DComponent::PressureStep1MaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGUFluid2DComponent, PressureStep2MaterialInstance) == 0x0002C0, "Member 'UBGUFluid2DComponent::PressureStep2MaterialInstance' has a wrong offset!");

// Class b1.AnimNotifyState_GSNvFlow
// 0x0008 (0x0050 - 0x0048)
class UAnimNotifyState_GSNvFlow : public UAnimNotifyState_GSBase
{
public:
	bool                                          bFlowEmit;                                         // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlowCollision;                                    // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CollisionIndex;                                    // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSNvFlow">();
	}
	static class UAnimNotifyState_GSNvFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSNvFlow>();
	}
};
static_assert(alignof(UAnimNotifyState_GSNvFlow) == 0x000008, "Wrong alignment on UAnimNotifyState_GSNvFlow");
static_assert(sizeof(UAnimNotifyState_GSNvFlow) == 0x000050, "Wrong size on UAnimNotifyState_GSNvFlow");
static_assert(offsetof(UAnimNotifyState_GSNvFlow, bFlowEmit) == 0x000048, "Member 'UAnimNotifyState_GSNvFlow::bFlowEmit' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSNvFlow, bFlowCollision) == 0x000049, "Member 'UAnimNotifyState_GSNvFlow::bFlowCollision' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSNvFlow, CollisionIndex) == 0x00004C, "Member 'UAnimNotifyState_GSNvFlow::CollisionIndex' has a wrong offset!");

// Class b1.BGUFuncLibData
// 0x0000 (0x0028 - 0x0028)
class UBGUFuncLibData final : public UBlueprintFunctionLibrary
{
public:
	static void BGUGetTagEnum(class AActor* Unit, const struct FGameplayTag& Tag, bool* IsValid, uint8* Out);
	static void BGUGetTagFloat(class AActor* Unit, const struct FGameplayTag& Tag, bool* IsValid, float* Out);
	static void BGUGetTagFloatByName(class AActor* Unit, const class FName& TagName, bool* IsValid, float* Out);
	static void BGUGetTagInt(class AActor* Unit, const struct FGameplayTag& Tag, bool* IsValid, int32* Out);
	static void BGUGetTagIntByName(class AActor* Unit, const class FName& TagName, bool* IsValid, int32* Out);
	static void BGUGetTagName(class AActor* Unit, const struct FGameplayTag& Tag, bool* IsValid, class FName* Out);
	static class UObject* BGUGetTagObject(class AActor* Unit, const struct FGameplayTag& Tag);
	static void BGUGetTagVector(class AActor* Unit, const struct FGameplayTag& Tag, bool* IsValid, struct FVector* Out);
	static void BGUSetTagEnum(class AActor* Unit, const struct FGameplayTag& Tag, uint8 Val);
	static void BGUSetTagFloat(class AActor* Unit, const struct FGameplayTag& Tag, float Val);
	static void BGUSetTagFloatByName(class AActor* Unit, const class FName& TagName, float Val);
	static void BGUSetTagInt(class AActor* Unit, const struct FGameplayTag& Tag, int32 Val);
	static void BGUSetTagIntByName(class AActor* Unit, const class FName& TagName, float Val);
	static void BGUSetTagName(class AActor* Unit, const struct FGameplayTag& Tag, const class FName& Val);
	static void BGUSetTagNameWithGameplayTag(class AActor* Unit, const struct FGameplayTag& Tag, const struct FGameplayTag& Val);
	static void BGUSetTagObject(class AActor* Unit, const struct FGameplayTag& Tag, class UObject* Val);
	static void BGUSetTagVector(class AActor* Unit, const struct FGameplayTag& Tag, const struct FVector& Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFuncLibData">();
	}
	static class UBGUFuncLibData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFuncLibData>();
	}
};
static_assert(alignof(UBGUFuncLibData) == 0x000008, "Wrong alignment on UBGUFuncLibData");
static_assert(sizeof(UBGUFuncLibData) == 0x000028, "Wrong size on UBGUFuncLibData");

// Class b1.AnimNotifyState_GSTimedParticleEffect
// 0x0018 (0x0090 - 0x0078)
class UAnimNotifyState_GSTimedParticleEffect : public UAnimNotifyState_TimedParticleEffect
{
public:
	EAttachLocation                               AttachRule;                                        // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleSysParam>              InstanceParameters;                                // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSTimedParticleEffect">();
	}
	static class UAnimNotifyState_GSTimedParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSTimedParticleEffect>();
	}
};
static_assert(alignof(UAnimNotifyState_GSTimedParticleEffect) == 0x000008, "Wrong alignment on UAnimNotifyState_GSTimedParticleEffect");
static_assert(sizeof(UAnimNotifyState_GSTimedParticleEffect) == 0x000090, "Wrong size on UAnimNotifyState_GSTimedParticleEffect");
static_assert(offsetof(UAnimNotifyState_GSTimedParticleEffect, AttachRule) == 0x000078, "Member 'UAnimNotifyState_GSTimedParticleEffect::AttachRule' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSTimedParticleEffect, InstanceParameters) == 0x000080, "Member 'UAnimNotifyState_GSTimedParticleEffect::InstanceParameters' has a wrong offset!");

// Class b1.BGUFuncLibMove
// 0x0000 (0x0028 - 0x0028)
class UBGUFuncLibMove final : public UBlueprintFunctionLibrary
{
public:
	static void BGUMovementForceSaveBaseLocation(class UCharacterMovementComponent* MoveComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFuncLibMove">();
	}
	static class UBGUFuncLibMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFuncLibMove>();
	}
};
static_assert(alignof(UBGUFuncLibMove) == 0x000008, "Wrong alignment on UBGUFuncLibMove");
static_assert(sizeof(UBGUFuncLibMove) == 0x000028, "Wrong size on UBGUFuncLibMove");

// Class b1.AnimNotifyState_GSTrail
// 0x0008 (0x0060 - 0x0058)
class UAnimNotifyState_GSTrail : public UAnimNotifyState_Trail
{
public:
	uint8                                         bIsNeedPauseWithOwner : 1;                         // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSTrail">();
	}
	static class UAnimNotifyState_GSTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSTrail>();
	}
};
static_assert(alignof(UAnimNotifyState_GSTrail) == 0x000008, "Wrong alignment on UAnimNotifyState_GSTrail");
static_assert(sizeof(UAnimNotifyState_GSTrail) == 0x000060, "Wrong size on UAnimNotifyState_GSTrail");

// Class b1.BGUFuncLibAI
// 0x0000 (0x0028 - 0x0028)
class UBGUFuncLibAI final : public UBlueprintFunctionLibrary
{
public:
	static float BGUAICaculateTargetAngle(class AActor* Target, class AActor* MySelf);
	static bool BGUIsAIRequestActive(class AActor* Unit, int32 RequestID);
	static int32 BGURequestAITurnTo(class AActor* Unit, const struct FVector& Position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFuncLibAI">();
	}
	static class UBGUFuncLibAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFuncLibAI>();
	}
};
static_assert(alignof(UBGUFuncLibAI) == 0x000008, "Wrong alignment on UBGUFuncLibAI");
static_assert(sizeof(UBGUFuncLibAI) == 0x000028, "Wrong size on UBGUFuncLibAI");

// Class b1.AnimNotifyState_GSTrailWithArray
// 0x0028 (0x0058 - 0x0030)
class UAnimNotifyState_GSTrailWithArray : public UAnimNotifyState
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSocketName>                    SocketNameList;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	ETrailWidthMode                               WidthScaleMode;                                    // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidthScaleCurve;                                   // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRecycleSpawnedSystems : 1;                        // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UParticleSystem* OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GSTrailWithArray">();
	}
	static class UAnimNotifyState_GSTrailWithArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GSTrailWithArray>();
	}
};
static_assert(alignof(UAnimNotifyState_GSTrailWithArray) == 0x000008, "Wrong alignment on UAnimNotifyState_GSTrailWithArray");
static_assert(sizeof(UAnimNotifyState_GSTrailWithArray) == 0x000058, "Wrong size on UAnimNotifyState_GSTrailWithArray");
static_assert(offsetof(UAnimNotifyState_GSTrailWithArray, PSTemplate) == 0x000030, "Member 'UAnimNotifyState_GSTrailWithArray::PSTemplate' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSTrailWithArray, SocketNameList) == 0x000038, "Member 'UAnimNotifyState_GSTrailWithArray::SocketNameList' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSTrailWithArray, WidthScaleMode) == 0x000048, "Member 'UAnimNotifyState_GSTrailWithArray::WidthScaleMode' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GSTrailWithArray, WidthScaleCurve) == 0x00004C, "Member 'UAnimNotifyState_GSTrailWithArray::WidthScaleCurve' has a wrong offset!");

// Class b1.BGUFuncLibSkill
// 0x0000 (0x0028 - 0x0028)
class UBGUFuncLibSkill final : public UBlueprintFunctionLibrary
{
public:
	static float BGUCalcMontageNeedModifyTotalTime(class ACharacter* Unit, int32 FromAMInstanceID);
	static float BGUCalcMontageSpecificRangeTime(class AActor* Unit, int32 FromAMInstanceID, float LeftTime, float RightTime, class UAnimMontage* CurMontage);
	static float BGUCalcNotifyNeedModifyTotalTime(class ACharacter* Unit, const class UAnimNotifyState* NotifyEvent, int32 FromAMInstanceID, float CurNSLeftTime, float CurNSRightTime);
	static int32 BGUGetActiveInstanceIDForMontage(class UAnimInstance* AnimInstance, const class UAnimMontage* Montage);
	static bool BGUGetMontageHasRootMotion(const class UAnimMontage* Montage);
	static void BGUGetMontageNotifies(const class UAnimMontage* Montage, TArray<struct FAnimNotifyEvent>* OutActiveNotifies);
	static struct FVector BGUGetMotionDirFromSkill(int32 SkillID);
	static bool MontageInstanceBindUFunctionToMontageBlendOutDel(class UAnimInstance* AnimInstance, const class UAnimMontage* Montage, class UObject* Object, const class FName FunctionName);
	static bool MontageInstanceBindUFunctionToMontegeEndDel(class UAnimInstance* AnimInstance, const class UAnimMontage* Montage, class UObject* Object, const class FName FunctionName);
	static bool MontageInstanceUnBindUFunctionToMontageBlendOutDel(class UAnimInstance* AnimInstance, const class UAnimMontage* Montage);
	static bool MontageInstanceUnBindUFunctionToMontegeEndDel(class UAnimInstance* AnimInstance, const class UAnimMontage* Montage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFuncLibSkill">();
	}
	static class UBGUFuncLibSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFuncLibSkill>();
	}
};
static_assert(alignof(UBGUFuncLibSkill) == 0x000008, "Wrong alignment on UBGUFuncLibSkill");
static_assert(sizeof(UBGUFuncLibSkill) == 0x000028, "Wrong size on UBGUFuncLibSkill");

// Class b1.AnimNotify_GSBase
// 0x0018 (0x0050 - 0x0038)
class UAnimNotify_GSBase : public UAnimNotify
{
public:
	bool                                          CanBePlacedInASCS;                                 // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPreload;                                         // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        PreloadedAssets;                                   // 0x0040(0x0010)(BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void AddPreloadedAsset(class UObject* Obj) const;
	bool bIsNativeBranchingPointCS() const;
	EGsEnAnimN GetAnimNType() const;
	class FString GetJumpableSectionPrefix() const;
	TArray<class UObject*> GetPreloadedAssets() const;
	TArray<struct FSoftObjectPath> GetSoftReferences() const;
	void GSNotifyCS(const struct FUStGSNotifyParam& NotifyParam) const;
	int32 GSPostNotifyDebugCS(const struct FUStGSNotifyParam& NotifyParam) const;
	int32 GSPreNotifyDebugCS(const struct FUStGSNotifyParam& NotifyParam) const;
	void GSValidateInputCS(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GSBase">();
	}
	static class UAnimNotify_GSBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GSBase>();
	}
};
static_assert(alignof(UAnimNotify_GSBase) == 0x000008, "Wrong alignment on UAnimNotify_GSBase");
static_assert(sizeof(UAnimNotify_GSBase) == 0x000050, "Wrong size on UAnimNotify_GSBase");
static_assert(offsetof(UAnimNotify_GSBase, CanBePlacedInASCS) == 0x000038, "Member 'UAnimNotify_GSBase::CanBePlacedInASCS' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSBase, IsPreload) == 0x000039, "Member 'UAnimNotify_GSBase::IsPreload' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSBase, PreloadedAssets) == 0x000040, "Member 'UAnimNotify_GSBase::PreloadedAssets' has a wrong offset!");

// Class b1.BGUFuncLibGM
// 0x0000 (0x0028 - 0x0028)
class UBGUFuncLibGM final : public UBlueprintFunctionLibrary
{
public:
	static struct FIntPtr TestIntPtr(int32 Count, const struct FIntPtr& InputPtr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFuncLibGM">();
	}
	static class UBGUFuncLibGM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFuncLibGM>();
	}
};
static_assert(alignof(UBGUFuncLibGM) == 0x000008, "Wrong alignment on UBGUFuncLibGM");
static_assert(sizeof(UBGUFuncLibGM) == 0x000028, "Wrong size on UBGUFuncLibGM");

// Class b1.AnimNotify_GSPlayCameraSequence
// 0x0030 (0x0068 - 0x0038)
class UAnimNotify_GSPlayCameraSequence : public UAnimNotify
{
public:
	class ULevelSequence*                         LevelSequenceForCamera;                            // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RebindingObjName;                                  // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWithCameraFilterPitchMin : 1;                     // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerFollowCameraPitchMin;                        // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWithCameraFilterPitchMax : 1;                     // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerFollowCameraPitchMax;                        // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWithCameraFilterYawMin : 1;                       // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerFollowCameraYawMin;                          // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWithCameraFilterYawMax : 1;                       // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerFollowCameraYawMax;                          // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GSPlayCameraSequence">();
	}
	static class UAnimNotify_GSPlayCameraSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GSPlayCameraSequence>();
	}
};
static_assert(alignof(UAnimNotify_GSPlayCameraSequence) == 0x000008, "Wrong alignment on UAnimNotify_GSPlayCameraSequence");
static_assert(sizeof(UAnimNotify_GSPlayCameraSequence) == 0x000068, "Wrong size on UAnimNotify_GSPlayCameraSequence");
static_assert(offsetof(UAnimNotify_GSPlayCameraSequence, LevelSequenceForCamera) == 0x000038, "Member 'UAnimNotify_GSPlayCameraSequence::LevelSequenceForCamera' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayCameraSequence, RebindingObjName) == 0x000040, "Member 'UAnimNotify_GSPlayCameraSequence::RebindingObjName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayCameraSequence, PlayerFollowCameraPitchMin) == 0x00004C, "Member 'UAnimNotify_GSPlayCameraSequence::PlayerFollowCameraPitchMin' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayCameraSequence, PlayerFollowCameraPitchMax) == 0x000054, "Member 'UAnimNotify_GSPlayCameraSequence::PlayerFollowCameraPitchMax' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayCameraSequence, PlayerFollowCameraYawMin) == 0x00005C, "Member 'UAnimNotify_GSPlayCameraSequence::PlayerFollowCameraYawMin' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayCameraSequence, PlayerFollowCameraYawMax) == 0x000064, "Member 'UAnimNotify_GSPlayCameraSequence::PlayerFollowCameraYawMax' has a wrong offset!");

// Class b1.BGUFuncLibSelectTargets
// 0x0000 (0x0028 - 0x0028)
class UBGUFuncLibSelectTargets final : public UBlueprintFunctionLibrary
{
public:
	static bool BGUComponentSweepMulti(class UObject* WorldContextObject, ECollisionChannel TraceChannel, class UPrimitiveComponent* PrimComp, const struct FVector& Start, const struct FVector& End, const struct FQuat& Rot, TArray<struct FUStGSHitResult>* SweepResults, const TArray<class AActor*>& IgnoreActors, const TArray<ECollisionChannel>& BlockChannelsForFilter, const TArray<ECollisionChannel>& OverlapChannelsForFilter);
	static bool BGUCompOverlapCompsByChannel(class UPrimitiveComponent* Component, ECollisionChannel TraceChannel, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static bool BGUCompOverlapCompsByObjectType(class UPrimitiveComponent* Component, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static bool BGUComputePenetration(class UPrimitiveComponent* SelfComponent, struct FVector* Direction, float* Distance, class UPrimitiveComponent* OtherComponent, const struct FVector& Pos, const struct FQuat& Rot);
	static TArray<class AActor*> BGUGetPerceivedActors(const class UAIPerceptionComponent* PerceptionComp);
	static TArray<class AActor*> BGUGetSightPerceivedActors(const class UAIPerceptionComponent* PerceptionComp);
	static void BGUGetSweepCheckResultsByCollisionChannel(class UObject* WorldContextObject, const struct FTransform& PreTransform, const struct FTransform& CurTransform, const struct FQuat& Rot, ECollisionChannel CollisionChannel, const struct FGSSweepCheckShapeInfo& SweepCheckShapeInfo, TArray<struct FUStGSHitResult>* SweepResults, const TArray<class AActor*>& IgnoreActors, const TArray<ECollisionChannel>& BlockChannelsForFilter, const TArray<ECollisionChannel>& OverlapChannelsForFilter, bool IsDrawDebugShape);
	static void BGUGetSweepCheckResultsByCollisionChannelWithCaster(class UObject* WorldContextObject, const struct FTransform& PreTransform, const struct FTransform& CurTransform, const struct FQuat& Rot, ECollisionChannel CollisionChannel, const struct FGSSweepCheckShapeInfo& SweepCheckShapeInfo, TArray<struct FUStGSHitResult>* SweepResults, const TArray<class AActor*>& IgnoreActors, const TArray<ECollisionChannel>& BlockChannelsForFilter, const TArray<ECollisionChannel>& OverlapChannelsForFilter, bool IsDrawDebugShape, class AActor* Caster, int32 GroupId, ESweepCheckType SweepCheckType);
	static bool BGUIsSelectTargetInFilterBP(class AActor* Caster, class AActor* Target, int32 Filter);
	static bool BGULineTraceMultiByCollisionChannel(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ECollisionChannel CollisionChannel, TArray<struct FUStGSHitResult>* SweepResults, const TArray<class AActor*>& IgnoreActors, const TArray<ECollisionChannel>& BlockChannelsForFilter, const TArray<ECollisionChannel>& OverlapChannelsForFilter, bool IsDrawDebug);
	static bool BGULineTraceSingleByCollisionChannel(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ECollisionChannel CollisionChannel, struct FUStGSHitResult* SweepResult, const TArray<class AActor*>& IgnoreActors, const TArray<ECollisionChannel>& BlockChannelsForFilter, const TArray<ECollisionChannel>& OverlapChannelsForFilter, bool IsDrawDebug);
	static bool BGUMultiCompOverlapByObjectType(class UObject* WorldContextObject, const TArray<class UShapeComponent*>& OverlapShapeComponents, const TArray<EObjectTypeQuery>& ObjectTypes, const TArray<class AActor*>& IgnoreActors, TArray<class UShapeComponent*>* OverlapComps, TArray<class AActor*>* OverlapOtherActors, TArray<class UPrimitiveComponent*>* OverlapOtherComps);
	static bool BGUOverlapAnyTestByObjectType(class UWorld* WorldContextObject, const struct FVector& Pos, const TArray<EObjectTypeQuery>& ObjectTypes, EGSSweepCheckShapeType CollisionShape, const struct FVector& ShapeExtent);
	static void BGUOverlapMultiByObjectType(class UObject* WorldContextObject, const struct FVector& Origin, const struct FQuat& Rot, const TArray<EObjectTypeQuery>& ObjectTypes, const struct FGSSweepCheckShapeInfo& OverlapShapeInfo, const TArray<class AActor*>& IgnoreActors, TArray<struct FUStGSOverlapResult>* OverlapResults, bool IsDrawDebugShape);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFuncLibSelectTargets">();
	}
	static class UBGUFuncLibSelectTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFuncLibSelectTargets>();
	}
};
static_assert(alignof(UBGUFuncLibSelectTargets) == 0x000008, "Wrong alignment on UBGUFuncLibSelectTargets");
static_assert(sizeof(UBGUFuncLibSelectTargets) == 0x000028, "Wrong size on UBGUFuncLibSelectTargets");

// Class b1.AnimNotify_GSPlayCameraShake
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_GSPlayCameraShake final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GSPlayCameraShake">();
	}
	static class UAnimNotify_GSPlayCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GSPlayCameraShake>();
	}
};
static_assert(alignof(UAnimNotify_GSPlayCameraShake) == 0x000008, "Wrong alignment on UAnimNotify_GSPlayCameraShake");
static_assert(sizeof(UAnimNotify_GSPlayCameraShake) == 0x000038, "Wrong size on UAnimNotify_GSPlayCameraShake");

// Class b1.AnimNotify_GSPlayFX
// 0x0060 (0x0120 - 0x00C0)
class UAnimNotify_GSPlayFX final : public UAnimNotify_PlayParticleEffect
{
public:
	bool                                          TemporaryClose;                                    // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               AttachRule;                                        // 0x00C1(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleSysParam>              InstanceParameters;                                // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTraceObject;                                    // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebug;                                          // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      TraceObjectType;                                   // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         TraceObjectClass;                                  // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                TraceOffset;                                       // 0x0108(0x0018)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GSPlayFX">();
	}
	static class UAnimNotify_GSPlayFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GSPlayFX>();
	}
};
static_assert(alignof(UAnimNotify_GSPlayFX) == 0x000010, "Wrong alignment on UAnimNotify_GSPlayFX");
static_assert(sizeof(UAnimNotify_GSPlayFX) == 0x000120, "Wrong size on UAnimNotify_GSPlayFX");
static_assert(offsetof(UAnimNotify_GSPlayFX, TemporaryClose) == 0x0000C0, "Member 'UAnimNotify_GSPlayFX::TemporaryClose' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayFX, AttachRule) == 0x0000C1, "Member 'UAnimNotify_GSPlayFX::AttachRule' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayFX, InstanceParameters) == 0x0000C8, "Member 'UAnimNotify_GSPlayFX::InstanceParameters' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayFX, NiagaraSystem) == 0x0000D8, "Member 'UAnimNotify_GSPlayFX::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayFX, bIsTraceObject) == 0x0000E0, "Member 'UAnimNotify_GSPlayFX::bIsTraceObject' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayFX, bIsDebug) == 0x0000E1, "Member 'UAnimNotify_GSPlayFX::bIsDebug' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayFX, TraceObjectType) == 0x0000E8, "Member 'UAnimNotify_GSPlayFX::TraceObjectType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayFX, TraceObjectClass) == 0x0000F8, "Member 'UAnimNotify_GSPlayFX::TraceObjectClass' has a wrong offset!");
static_assert(offsetof(UAnimNotify_GSPlayFX, TraceOffset) == 0x000108, "Member 'UAnimNotify_GSPlayFX::TraceOffset' has a wrong offset!");

// Class b1.AutoMovePerfEditorVisualizer
// 0x00E8 (0x0360 - 0x0278)
class AAutoMovePerfEditorVisualizer final : public AActor
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            BaseImageBrush;                                    // 0x0280(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearVisualizedPerfInfo();
	void DisplayVisualizedPerfInfo(const TArray<float>& InTileSourceInfoArray, const struct FVector2D& InResolution, const struct FIntPoint& InTileCount, float InIntensityScaleFactor, const class FString& InBaseImagePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoMovePerfEditorVisualizer">();
	}
	static class AAutoMovePerfEditorVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAutoMovePerfEditorVisualizer>();
	}
};
static_assert(alignof(AAutoMovePerfEditorVisualizer) == 0x000010, "Wrong alignment on AAutoMovePerfEditorVisualizer");
static_assert(sizeof(AAutoMovePerfEditorVisualizer) == 0x000360, "Wrong size on AAutoMovePerfEditorVisualizer");
static_assert(offsetof(AAutoMovePerfEditorVisualizer, BaseImageBrush) == 0x000280, "Member 'AAutoMovePerfEditorVisualizer::BaseImageBrush' has a wrong offset!");

// Class b1.B1ActorChannel
// 0x0000 (0x0290 - 0x0290)
class UB1ActorChannel final : public UActorChannel
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1ActorChannel">();
	}
	static class UB1ActorChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1ActorChannel>();
	}
};
static_assert(alignof(UB1ActorChannel) == 0x000008, "Wrong alignment on UB1ActorChannel");
static_assert(sizeof(UB1ActorChannel) == 0x000290, "Wrong size on UB1ActorChannel");

// Class b1.B1DebugUtil
// 0x0000 (0x0028 - 0x0028)
class UB1DebugUtil final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1DebugUtil">();
	}
	static class UB1DebugUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1DebugUtil>();
	}
};
static_assert(alignof(UB1DebugUtil) == 0x000008, "Wrong alignment on UB1DebugUtil");
static_assert(sizeof(UB1DebugUtil) == 0x000028, "Wrong size on UB1DebugUtil");

// Class b1.B1IpNetDriver
// 0x0018 (0x0808 - 0x07F0)
class UB1IpNetDriver final : public UIpNetDriver
{
public:
	uint8                                         Pad_7F0[0x18];                                     // 0x07F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1IpNetDriver">();
	}
	static class UB1IpNetDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1IpNetDriver>();
	}
};
static_assert(alignof(UB1IpNetDriver) == 0x000008, "Wrong alignment on UB1IpNetDriver");
static_assert(sizeof(UB1IpNetDriver) == 0x000808, "Wrong size on UB1IpNetDriver");

// Class b1.B1NetDriverForStandAloneHookBase
// 0x0000 (0x0780 - 0x0780)
class UB1NetDriverForStandAloneHookBase final : public UNetDriver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1NetDriverForStandAloneHookBase">();
	}
	static class UB1NetDriverForStandAloneHookBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1NetDriverForStandAloneHookBase>();
	}
};
static_assert(alignof(UB1NetDriverForStandAloneHookBase) == 0x000008, "Wrong alignment on UB1NetDriverForStandAloneHookBase");
static_assert(sizeof(UB1NetDriverForStandAloneHookBase) == 0x000780, "Wrong size on UB1NetDriverForStandAloneHookBase");

// Class b1.GSE_OnlineFuncLib
// 0x0000 (0x0028 - 0x0028)
class UGSE_OnlineFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorChannelOpenAcked(class AActor* Actor, class APlayerController* PlayerController);
	static bool ActorChannelValid(class AActor* Actor, class APlayerController* PlayerController);
	static bool CloseActorChannelByActorAndPlayerController(class AActor* Actor, class APlayerController* PlayerController, int32 CloseReason);
	static void CloseClientConnection(EGSNetCloseResult CloseResult, class APlayerController* ClientPlayerController);
	static void CloseServerConnection(EGSNetCloseResult CloseResult, class UObject* WorldContext);
	static bool ForceRemoveNetGuid(class UObject* Obj);
	static void GEngineHandleDisconnect(class UWorld* World);
	static class AActor* GetActorChannelActor(class UActorChannel* Channel);
	static class FString GetGameDefaultMap();
	static class UObject* GetObjByNetGuid(class UObject* WorldCtx, int64 Guid);
	static int64 GetObjNetGuid(class UObject* Obj);
	static int64 GetObjNetGuidByChannel(class UActorChannel* Channel);
	static class UObject* GetReplicationGraph(class UObject* WorldCtx);
	static class FString GetUniqueNetIdStringByFUniqueNetIdRepl(const struct FUniqueNetIdRepl& UniqueId);
	static class FString GetUniqueNetIdStringByPlayerController(class APlayerController* Controller);
	static class FString GetUniqueNetIdStringByPlayerState(class APlayerState* PlayerState);
	static bool InServerReal(class UObject* WorldCtx);
	static bool IsActorChannelReadyForClient(class AActor* Actor);
	static bool IsActorChannelReadyForServer(class AActor* Actor, class APlayerController* PlayerController);
	static void MarkActorRoleDirty(class AActor* Actor);
	static void RegisterNetGuid(int64 Guid, class UObject* Obj);
	static void ResetNetGuidAckStat(int64 Guid, class UNetConnection* NetConnection);
	static int64 ServerReplicateOneActorToPlayer(class AActor* Actor, class APlayerController* PlayerController);
	static void SetGameDefaultMap(const class FString& NewMap);
	static class FName SlowMakeUniqueObjectName(class UObject* Parent, const class UClass* Class_0, class FName InBaseName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSE_OnlineFuncLib">();
	}
	static class UGSE_OnlineFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSE_OnlineFuncLib>();
	}
};
static_assert(alignof(UGSE_OnlineFuncLib) == 0x000008, "Wrong alignment on UGSE_OnlineFuncLib");
static_assert(sizeof(UGSE_OnlineFuncLib) == 0x000028, "Wrong size on UGSE_OnlineFuncLib");

// Class b1.B1OnlineSession
// 0x0000 (0x0028 - 0x0028)
class UB1OnlineSession : public UOnlineSession
{
public:
	void ClearOnlineDelegatesCS();
	void EndOnlineSessionCS(class FName SessionName);
	void HandleDisconnectCS(class UWorld* World, class UNetDriver* NetDriver);
	void OnSessionUserInviteAcceptedCS(const bool bWasSuccess, const int32 ControllerId);
	void RegisterOnlineDelegatesCS();
	void StartOnlineSessionCS(class FName SessionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1OnlineSession">();
	}
	static class UB1OnlineSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1OnlineSession>();
	}
};
static_assert(alignof(UB1OnlineSession) == 0x000008, "Wrong alignment on UB1OnlineSession");
static_assert(sizeof(UB1OnlineSession) == 0x000028, "Wrong size on UB1OnlineSession");

// Class b1.B1ReplicationGraphNode_AlwaysRelevant
// 0x0000 (0x00D0 - 0x00D0)
class UB1ReplicationGraphNode_AlwaysRelevant final : public UReplicationGraphNode_ActorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1ReplicationGraphNode_AlwaysRelevant">();
	}
	static class UB1ReplicationGraphNode_AlwaysRelevant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1ReplicationGraphNode_AlwaysRelevant>();
	}
};
static_assert(alignof(UB1ReplicationGraphNode_AlwaysRelevant) == 0x000008, "Wrong alignment on UB1ReplicationGraphNode_AlwaysRelevant");
static_assert(sizeof(UB1ReplicationGraphNode_AlwaysRelevant) == 0x0000D0, "Wrong size on UB1ReplicationGraphNode_AlwaysRelevant");

// Class b1.B1NetReplicationGraphConnection
// 0x0000 (0x02D8 - 0x02D8)
class UB1NetReplicationGraphConnection : public UNetReplicationGraphConnection
{
public:
	class APlayerController* GetPlayerControllerCS();
	void GSAddB1ActorChannel(class AActor* Actor);
	bool IsInServerReal();
	void NotifyActorChannelAddedCS(class AActor* Actor, class UActorChannel* Channel);
	void NotifyActorChannelCleanedUpCS(class UActorChannel* ActorChannel, int32 CloseReason);
	void NotifyActorChannelRemovedCS(class AActor* Actor);
	void SetActorNotDormantOnConnectionCS(class AActor* InActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1NetReplicationGraphConnection">();
	}
	static class UB1NetReplicationGraphConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1NetReplicationGraphConnection>();
	}
};
static_assert(alignof(UB1NetReplicationGraphConnection) == 0x000008, "Wrong alignment on UB1NetReplicationGraphConnection");
static_assert(sizeof(UB1NetReplicationGraphConnection) == 0x0002D8, "Wrong size on UB1NetReplicationGraphConnection");

// Class b1.B1ReplicationGraphNode_AlwaysRelevant_ForConnection
// 0x0020 (0x00F0 - 0x00D0)
class UB1ReplicationGraphNode_AlwaysRelevant_ForConnection final : public UReplicationGraphNode_ActorList
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAlwaysRelevantActorInfo>       PastRelevantActors;                                // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1ReplicationGraphNode_AlwaysRelevant_ForConnection">();
	}
	static class UB1ReplicationGraphNode_AlwaysRelevant_ForConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1ReplicationGraphNode_AlwaysRelevant_ForConnection>();
	}
};
static_assert(alignof(UB1ReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x000008, "Wrong alignment on UB1ReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(sizeof(UB1ReplicationGraphNode_AlwaysRelevant_ForConnection) == 0x0000F0, "Wrong size on UB1ReplicationGraphNode_AlwaysRelevant_ForConnection");
static_assert(offsetof(UB1ReplicationGraphNode_AlwaysRelevant_ForConnection, PastRelevantActors) == 0x0000E0, "Member 'UB1ReplicationGraphNode_AlwaysRelevant_ForConnection::PastRelevantActors' has a wrong offset!");

// Class b1.B1ReplicationGraph
// 0x0040 (0x05A0 - 0x0560)
class UB1ReplicationGraph : public UReplicationGraph
{
public:
	class UReplicationGraphNode*                  AlwaysRelevantNode;                                // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsWithoutNetConnection;                        // 0x0560(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FB1ConnectionAlwaysRelevantNodePair> AlwaysRelevantForConnectionList;                   // 0x0570(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_580[0x20];                                     // 0x0580(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBGUCharacterToAlwaysRelevantNodeCS(class ABGUCharacter* Actor);
	void AddConnectionGraphNodeCS(class UReplicationGraphNode* GraphNode, class UNetReplicationGraphConnection* ConnectionManager);
	void AddNetworkActorCS(class AActor* Actor);
	void ClienResetActorChannelCS(class ABGUCharacter* Actor);
	class UNetReplicationGraphConnection* GetConnectionByIndexCS(int32 Idx);
	class UB1NetReplicationGraphConnection* GetReplicationGraphConnectionByPC(class APlayerController* PlayerController);
	class UNetConnection* GetServerConnectionCS();
	class UWorld* GetWorldCS();
	void GSNetworkRemapPathCS(const class UObject* Outer_0, const class FString& OriginName, class FString* Name_0);
	void InitConnectionGraphNodesCS(class UNetReplicationGraphConnection* RepGraphConnection);
	void InitGlobalActorClassSettingsCS();
	void InitGlobalGraphNodesCS();
	void InitNodeCS(class UB1ReplicationGraphNode_CSBase* CSNode);
	void RemoveBGUCharacterFromAlwaysRelevantNodeCS(class ABGUCharacter* Actor);
	void RemoveConnectionGraphNodeCS(class UReplicationGraphNode* GraphNode, class UNetReplicationGraphConnection* ConnectionManager);
	void RemoveNetworkActorCS(class AActor* Actor);
	void ResetGameWorldStateCS();
	void RouteAddNetworkActorToNodesCS(class AActor* Actor, const struct FVector& WorldLocation);
	void RouteRemoveNetworkActorToNodesCS(class AActor* Actor);
	void SetAlwaysRelevantNodeCS(class UB1ReplicationGraphNode_CSBase* AlwaysRelevantNodeCS);
	void SetGlobalReplicationClassInfo(class UClass* ReplicatedClass, float CullDistanceSquared, int32 ReplicationPeriodFrame);
	void SetRoleSwapOnReplicateCS(class AActor* Actor, bool Swap);
	bool ShouldServerMultiCastRPCForPlayerCS(class APlayerController* Controller, class AActor* Actor, int64 FuncAddr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1ReplicationGraph">();
	}
	static class UB1ReplicationGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1ReplicationGraph>();
	}
};
static_assert(alignof(UB1ReplicationGraph) == 0x000010, "Wrong alignment on UB1ReplicationGraph");
static_assert(sizeof(UB1ReplicationGraph) == 0x0005A0, "Wrong size on UB1ReplicationGraph");
static_assert(offsetof(UB1ReplicationGraph, AlwaysRelevantNode) == 0x000558, "Member 'UB1ReplicationGraph::AlwaysRelevantNode' has a wrong offset!");
static_assert(offsetof(UB1ReplicationGraph, ActorsWithoutNetConnection) == 0x000560, "Member 'UB1ReplicationGraph::ActorsWithoutNetConnection' has a wrong offset!");
static_assert(offsetof(UB1ReplicationGraph, AlwaysRelevantForConnectionList) == 0x000570, "Member 'UB1ReplicationGraph::AlwaysRelevantForConnectionList' has a wrong offset!");

// Class b1.B1ReplicationGraphNode_CSBase
// 0x0030 (0x0080 - 0x0050)
class UB1ReplicationGraphNode_CSBase : public UReplicationGraphNode
{
public:
	TArray<class AActor*>                         CachedRepActors;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         CachedUpdateRepFrameActors;                        // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GatherActorListsForConnectionCS(class APlayerController* PlayerController);
	void NotifyAddNetworkActorCS(const class AActor* Actor);
	bool NotifyRemoveNetworkActorCS(const class AActor* Actor, bool bWarnIfNotFound);
	void NotifyResetAllNetworkActorsCS();
	void PostServerReplicateActorCS();
	void PrepareForReplicationCS();

	void LogNodeCS(int32 Flag, const class FString& NodeName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1ReplicationGraphNode_CSBase">();
	}
	static class UB1ReplicationGraphNode_CSBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1ReplicationGraphNode_CSBase>();
	}
};
static_assert(alignof(UB1ReplicationGraphNode_CSBase) == 0x000008, "Wrong alignment on UB1ReplicationGraphNode_CSBase");
static_assert(sizeof(UB1ReplicationGraphNode_CSBase) == 0x000080, "Wrong size on UB1ReplicationGraphNode_CSBase");
static_assert(offsetof(UB1ReplicationGraphNode_CSBase, CachedRepActors) == 0x000050, "Member 'UB1ReplicationGraphNode_CSBase::CachedRepActors' has a wrong offset!");
static_assert(offsetof(UB1ReplicationGraphNode_CSBase, CachedUpdateRepFrameActors) == 0x000060, "Member 'UB1ReplicationGraphNode_CSBase::CachedUpdateRepFrameActors' has a wrong offset!");

// Class b1.B1Util
// 0x0000 (0x0028 - 0x0028)
class UB1Util final : public UObject
{
public:
	static bool CheckIsSimulationPlayMode();
	static void CopyStringToClipboard(const class FString& Text);
	static int32 GetAgreementReaded();
	static bool GetArchiveMarkFinish();
	static int32 GetAvailableMaps(TArray<class FString>* OutAvailableMaps);
	static bool GetFirstSettingFinish();
	static int32 GetGMCommandList(TMap<uint8, class FString>* OutGMCommandList);
	static int32 GetPrivacyAgreement();
	static float GetRandomNumberFloat(float LeftNum, float RightNum);
	static int32 GetRandomNumberInt(int32 LeftNum, int32 RightNum);
	static int32 GetStartCommandList(TArray<class FString>* OutStartCommandList);
	static class FString GetStartLevelName();
	static int32 GetUISettingCustomData(TMap<class FString, class FString>* OutDetailSettingData);
	static int32 GetUISettingData(TMap<class FString, class FString>* OutUISettingData);
	static int32 GetUISettingPbTag();
	static bool IsNeverShowStartupUI();
	static bool IsStartupConfigEnable();
	static void OpenFileBrowser(const class FString& FolderPath);
	static void SaveGameUserSettings();
	static void SetAgreementReaded(int32 NewValue);
	static void SetArchiveMarkFinish(bool NewValue);
	static void SetFirstSettingFinish(bool NewValue);
	static void SetGMCommandList(const TMap<uint8, class FString>& InGMCommandList);
	static void SetMainMonitorID(const class FString& MonitorID);
	static void SetNeverShowStartupUI(bool bInNeverShowStartupUI);
	static void SetPrivacyAgreement(int32 NewValue);
	static void SetStartCommandList(const TArray<class FString>& InStartCommandList);
	static void SetStartLevelName(const class FString& InStartLevelName);
	static void SetStartupConfigEnable(bool bEnable);
	static void SetUISettingCustomData(const TMap<class FString, class FString>& DetailSettingData);
	static void SetUISettingData(const TMap<class FString, class FString>& SetUISettingData_0);
	static void SetUISettingPbTag(int32 TagId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"B1Util">();
	}
	static class UB1Util* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB1Util>();
	}
};
static_assert(alignof(UB1Util) == 0x000008, "Wrong alignment on UB1Util");
static_assert(sizeof(UB1Util) == 0x000028, "Wrong size on UB1Util");

// Class b1.SmartActorGuidObj
// 0x0000 (0x0028 - 0x0028)
class ISmartActorGuidObj final : public IInterface
{
public:
	bool CanManageStates();
	bool GetActorGuid(class AActor* InActor, class FString* OutActorGuid);
	int32 GetActorGuidOptions(const class FString& PropertyName, TArray<struct FActorGuidOption>* OutOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartActorGuidObj">();
	}
	static class ISmartActorGuidObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISmartActorGuidObj>();
	}
};
static_assert(alignof(ISmartActorGuidObj) == 0x000008, "Wrong alignment on ISmartActorGuidObj");
static_assert(sizeof(ISmartActorGuidObj) == 0x000028, "Wrong size on ISmartActorGuidObj");

// Class b1.BaseActorComp
// 0x0010 (0x00C0 - 0x00B0)
class UBaseActorComp : public UActorComponent
{
public:
	int32                                         DebugID;                                           // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LogLvl;                                            // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorCompContainer*                    ActorCompContainer;                                // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyWorldOffsetCS(const struct FVector& InOffset, bool bWorldShift);
	void BeginPlayInCS();
	void EndPlayInCS(const EEndPlayReason EndPlayReason);
	int32 GetDebugID();
	int32 GetLogLvl();
	void InitializeCS();
	void OnAttachInCS();
	void OnRegisterCS();
	void OnUnregisterCS();
	void PostInitPropertiesCS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseActorComp">();
	}
	static class UBaseActorComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseActorComp>();
	}
};
static_assert(alignof(UBaseActorComp) == 0x000008, "Wrong alignment on UBaseActorComp");
static_assert(sizeof(UBaseActorComp) == 0x0000C0, "Wrong size on UBaseActorComp");
static_assert(offsetof(UBaseActorComp, DebugID) == 0x0000B0, "Member 'UBaseActorComp::DebugID' has a wrong offset!");
static_assert(offsetof(UBaseActorComp, LogLvl) == 0x0000B4, "Member 'UBaseActorComp::LogLvl' has a wrong offset!");
static_assert(offsetof(UBaseActorComp, ActorCompContainer) == 0x0000B8, "Member 'UBaseActorComp::ActorCompContainer' has a wrong offset!");

// Class b1.BaseActorCompTickable
// 0x0000 (0x00C0 - 0x00C0)
class UBaseActorCompTickable : public UBaseActorComp
{
public:
	void TickComponentInCS(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseActorCompTickable">();
	}
	static class UBaseActorCompTickable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseActorCompTickable>();
	}
};
static_assert(alignof(UBaseActorCompTickable) == 0x000008, "Wrong alignment on UBaseActorCompTickable");
static_assert(sizeof(UBaseActorCompTickable) == 0x0000C0, "Wrong size on UBaseActorCompTickable");

// Class b1.BaseEditorTickableActorComp
// 0x0000 (0x00C0 - 0x00C0)
class UBaseEditorTickableActorComp : public UBaseActorCompTickable
{
public:
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseEditorTickableActorComp">();
	}
	static class UBaseEditorTickableActorComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseEditorTickableActorComp>();
	}
};
static_assert(alignof(UBaseEditorTickableActorComp) == 0x000008, "Wrong alignment on UBaseEditorTickableActorComp");
static_assert(sizeof(UBaseEditorTickableActorComp) == 0x0000C0, "Wrong size on UBaseEditorTickableActorComp");

// Class b1.SceneComponentTickable
// 0x0000 (0x02B0 - 0x02B0)
class USceneComponentTickable : public USceneComponent
{
public:
	void BeginPlayGS();
	void EndPlayGS(const EEndPlayReason EndPlayReason);
	void TickComponentGS(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneComponentTickable">();
	}
	static class USceneComponentTickable* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneComponentTickable>();
	}
};
static_assert(alignof(USceneComponentTickable) == 0x000010, "Wrong alignment on USceneComponentTickable");
static_assert(sizeof(USceneComponentTickable) == 0x0002B0, "Wrong size on USceneComponentTickable");

// Class b1.EditorOnlyCompBase
// 0x0008 (0x00B8 - 0x00B0)
class UEditorOnlyCompBase : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetParamDisplayNameCS(const class FString& PropertyName, const struct FCalliopeGuid& ConfigGuid);
	void GetPossibleParamsCS(const class FString& ParentPropertyName, const class FString& PropertyName, TArray<struct FCalliopeGuid>* OutParamArray);
	void PreSaveCS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorOnlyCompBase">();
	}
	static class UEditorOnlyCompBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorOnlyCompBase>();
	}
};
static_assert(alignof(UEditorOnlyCompBase) == 0x000008, "Wrong alignment on UEditorOnlyCompBase");
static_assert(sizeof(UEditorOnlyCompBase) == 0x0000B8, "Wrong size on UEditorOnlyCompBase");

// Class b1.BGPPlayerCameraManager
// 0x0010 (0x3880 - 0x3870)
class ABGPPlayerCameraManager : public APlayerCameraManager
{
public:
	uint8                                         Pad_3870[0x10];                                    // 0x3870(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlendCompleteCS();
	void OnViewTargetChangedCS(class APlayerController* PC, class AActor* OldViewTarget, class AActor* NewViewTarget);
	void SetViewTargetCS(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	void UpdateCameraCS(float DeltaTime);

	class AActor* GetPendingViewTargetCS() const;
	class AActor* GetViewTargetCS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGPPlayerCameraManager">();
	}
	static class ABGPPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGPPlayerCameraManager>();
	}
};
static_assert(alignof(ABGPPlayerCameraManager) == 0x000010, "Wrong alignment on ABGPPlayerCameraManager");
static_assert(sizeof(ABGPPlayerCameraManager) == 0x003880, "Wrong size on ABGPPlayerCameraManager");

// Class b1.BGPPlayerController
// 0x0018 (0x07E0 - 0x07C8)
class ABGPPlayerController : public APlayerController
{
public:
	bool                                          bGSIsLocalPlayerController;                        // 0x07C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C9[0x7];                                      // 0x07C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPathFollowingComponent*                PathFollowingComponent;                            // 0x07D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInTeleport;                                     // 0x07D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D9[0x7];                                      // 0x07D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetCachedConsoleCommandCS();
	static class UObject* GetCachedConsoleWorldContext();

	void BeginPlayCS();
	void ConsoleCommandCS(const class FString& Command);
	float GetCameraBlendTimeToGo();
	bool GetIsShouldPerformFullTickWhenPaused();
	class UNetConnection* GetNetConnectionCS();
	class AActor* GetPendingViewTarget();
	void GetSeamlessTravelActorListCS(bool bToEntry, TArray<class AActor*>* ActorList);
	struct FVector GetSpawnLocationCS();
	void InitInputSystemCS();
	void OnPossessWithViewTargetBlend(class APawn* InPawn, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing, bool EnableBlendViewTarget);
	void OnRep_PawnCS();
	void OnRep_PlayerStateCS();
	void PostInitializeComponentsCS();
	void SetIsShouldPerformFullTickWhenPaused(bool IsShould);
	void SetSpawnLocationCS(const struct FVector& NewLocation);

	void GetAudioListenerPositionCS(struct FVector* OutLocation, struct FVector* OutFrontDir, struct FVector* OutRightDir) const;
	void GetAudioListenerRotationCS(struct FRotator* OutRotation) const;
	bool GetPlayerViewPointCS(struct FVector* Out_Location, struct FRotator* Out_Rotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGPPlayerController">();
	}
	static class ABGPPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGPPlayerController>();
	}
};
static_assert(alignof(ABGPPlayerController) == 0x000008, "Wrong alignment on ABGPPlayerController");
static_assert(sizeof(ABGPPlayerController) == 0x0007E0, "Wrong size on ABGPPlayerController");
static_assert(offsetof(ABGPPlayerController, bGSIsLocalPlayerController) == 0x0007C8, "Member 'ABGPPlayerController::bGSIsLocalPlayerController' has a wrong offset!");
static_assert(offsetof(ABGPPlayerController, PathFollowingComponent) == 0x0007D0, "Member 'ABGPPlayerController::PathFollowingComponent' has a wrong offset!");
static_assert(offsetof(ABGPPlayerController, bIsInTeleport) == 0x0007D8, "Member 'ABGPPlayerController::bIsInTeleport' has a wrong offset!");

// Class b1.BGPPlayerReverseReplicator
// 0x0018 (0x0290 - 0x0278)
class ABGPPlayerReverseReplicator final : public AActor
{
public:
	struct FECSNetSerialization                   ECSDataNetSerialization;                           // 0x0278(0x0010)(Net, Transient, NoDestructor, NativeAccessSpecifierPublic)
	class ABGUCharacter*                          OwnerBGUChr;                                       // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetOwnerBGUChr(class ABGUCharacter* BGUOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGPPlayerReverseReplicator">();
	}
	static class ABGPPlayerReverseReplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGPPlayerReverseReplicator>();
	}
};
static_assert(alignof(ABGPPlayerReverseReplicator) == 0x000008, "Wrong alignment on ABGPPlayerReverseReplicator");
static_assert(sizeof(ABGPPlayerReverseReplicator) == 0x000290, "Wrong size on ABGPPlayerReverseReplicator");
static_assert(offsetof(ABGPPlayerReverseReplicator, ECSDataNetSerialization) == 0x000278, "Member 'ABGPPlayerReverseReplicator::ECSDataNetSerialization' has a wrong offset!");
static_assert(offsetof(ABGPPlayerReverseReplicator, OwnerBGUChr) == 0x000288, "Member 'ABGPPlayerReverseReplicator::OwnerBGUChr' has a wrong offset!");

// Class b1.BGPPlayerState
// 0x0018 (0x03A8 - 0x0390)
class ABGPPlayerState : public APlayerState
{
public:
	struct FECSNetSerialization                   ECSDataNetSerialization;                           // 0x0390(0x0010)(Net, Transient, NoDestructor, NativeAccessSpecifierPublic)
	class UActorDataContainer*                    BGPDataComp;                                       // 0x03A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BeginPlayCS();
	void PostInitializeComponentsCS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGPPlayerState">();
	}
	static class ABGPPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGPPlayerState>();
	}
};
static_assert(alignof(ABGPPlayerState) == 0x000008, "Wrong alignment on ABGPPlayerState");
static_assert(sizeof(ABGPPlayerState) == 0x0003A8, "Wrong size on ABGPPlayerState");
static_assert(offsetof(ABGPPlayerState, ECSDataNetSerialization) == 0x000390, "Member 'ABGPPlayerState::ECSDataNetSerialization' has a wrong offset!");
static_assert(offsetof(ABGPPlayerState, BGPDataComp) == 0x0003A0, "Member 'ABGPPlayerState::BGPDataComp' has a wrong offset!");

// Class b1.BGU3rdCameraBase
// 0x0010 (0x0288 - 0x0278)
class ABGU3rdCameraBase : public AActor
{
public:
	class USpringArmComponent*                    CameraBoom;                                        // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       FollowCamera;                                      // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGU3rdCameraBase">();
	}
	static class ABGU3rdCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGU3rdCameraBase>();
	}
};
static_assert(alignof(ABGU3rdCameraBase) == 0x000008, "Wrong alignment on ABGU3rdCameraBase");
static_assert(sizeof(ABGU3rdCameraBase) == 0x000288, "Wrong size on ABGU3rdCameraBase");
static_assert(offsetof(ABGU3rdCameraBase, CameraBoom) == 0x000278, "Member 'ABGU3rdCameraBase::CameraBoom' has a wrong offset!");
static_assert(offsetof(ABGU3rdCameraBase, FollowCamera) == 0x000280, "Member 'ABGU3rdCameraBase::FollowCamera' has a wrong offset!");

// Class b1.BGUActorBase
// 0x0040 (0x02B8 - 0x0278)
class ABGUActorBase : public AActor
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBeginPlayFromLevelStreaming;                      // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorCompContainer*                    ActorCompContainer;                                // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBUS_EventCollection*                   EventCollection;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFullyInit;                                      // 0x02A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FECSNetSerialization                   ECSDataNetSerialization;                           // 0x02A8(0x0010)(Net, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void ApplyWorldOffsetCS(const struct FVector& InOffset, bool bWorldShift);
	void AttachBaseActorComp(class UBaseActorComp* Comp);
	void BeginPlayCS();
	void ForceRefreshDetailView();
	void FullyInit();
	class UBUS_EventCollection* GetBUSEventCollection();
	void OnConstructionCS(const struct FTransform& Transform);
	void OnPostEditMove(bool bFinish);
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);
	void PostInitializeComponentsCS();
	void SetCompCanEverAffectNavigation(class UActorComponent* ActorComponent, bool bRelevant);
	void SetRootComponentCS(class USceneComponent* NewRootComponent);
	void SetTeamID(int32 ID);

	bool GetActorGuid(class FString* OutActorGuid) const;
	bool GetActorGuidCS(class FString* OutActorGuid) const;
	int32 GetTeamID() const;
	int32 GetTeamIDCS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUActorBase">();
	}
	static class ABGUActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUActorBase>();
	}
};
static_assert(alignof(ABGUActorBase) == 0x000008, "Wrong alignment on ABGUActorBase");
static_assert(sizeof(ABGUActorBase) == 0x0002B8, "Wrong size on ABGUActorBase");
static_assert(offsetof(ABGUActorBase, bBeginPlayFromLevelStreaming) == 0x000288, "Member 'ABGUActorBase::bBeginPlayFromLevelStreaming' has a wrong offset!");
static_assert(offsetof(ABGUActorBase, ActorCompContainer) == 0x000290, "Member 'ABGUActorBase::ActorCompContainer' has a wrong offset!");
static_assert(offsetof(ABGUActorBase, EventCollection) == 0x000298, "Member 'ABGUActorBase::EventCollection' has a wrong offset!");
static_assert(offsetof(ABGUActorBase, bIsFullyInit) == 0x0002A0, "Member 'ABGUActorBase::bIsFullyInit' has a wrong offset!");
static_assert(offsetof(ABGUActorBase, ECSDataNetSerialization) == 0x0002A8, "Member 'ABGUActorBase::ECSDataNetSerialization' has a wrong offset!");

// Class b1.BGUActorI
// 0x0000 (0x0028 - 0x0028)
class IBGUActorI final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUActorI">();
	}
	static class IBGUActorI* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBGUActorI>();
	}
};
static_assert(alignof(IBGUActorI) == 0x000008, "Wrong alignment on IBGUActorI");
static_assert(sizeof(IBGUActorI) == 0x000028, "Wrong size on IBGUActorI");

// Class b1.BGUAIController
// 0x0018 (0x03B8 - 0x03A0)
class ABGUAIController : public AAIController
{
public:
	class UBlackboardComponent*                   BlackboardComp;                                    // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 BehaviorComp;                                      // 0x03A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIPerceptionComponent*                 AIPerceptionComp;                                  // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUAIController">();
	}
	static class ABGUAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUAIController>();
	}
};
static_assert(alignof(ABGUAIController) == 0x000008, "Wrong alignment on ABGUAIController");
static_assert(sizeof(ABGUAIController) == 0x0003B8, "Wrong size on ABGUAIController");
static_assert(offsetof(ABGUAIController, BlackboardComp) == 0x0003A0, "Member 'ABGUAIController::BlackboardComp' has a wrong offset!");
static_assert(offsetof(ABGUAIController, BehaviorComp) == 0x0003A8, "Member 'ABGUAIController::BehaviorComp' has a wrong offset!");
static_assert(offsetof(ABGUAIController, AIPerceptionComp) == 0x0003B0, "Member 'ABGUAIController::AIPerceptionComp' has a wrong offset!");

// Class b1.BGUAIPlayerController
// 0x0000 (0x03B8 - 0x03B8)
class ABGUAIPlayerController : public ABGUAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUAIPlayerController">();
	}
	static class ABGUAIPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUAIPlayerController>();
	}
};
static_assert(alignof(ABGUAIPlayerController) == 0x000008, "Wrong alignment on ABGUAIPlayerController");
static_assert(sizeof(ABGUAIPlayerController) == 0x0003B8, "Wrong size on ABGUAIPlayerController");

// Class b1.BGUAnimationSyncComponent
// 0x0098 (0x0148 - 0x00B0)
class UBGUAnimationSyncComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        OwnerMasterComp;                                   // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 DummyMeshComp;                                     // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        DrivingComp;                                       // 0x00C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x38];                                      // 0x00D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GuestActor;                                        // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 GuestMeshComp;                                     // 0x0110(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           GuestMontage;                                      // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x28];                                     // 0x0120(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginSyncAnimationOnGuest(class UAnimMontage* InGuestMontage, class FName InTargetSyncPointOnHost, class FName InSelfSyncPointOnGuest, bool bEnableDebugDraw, float NotifyBeginTime, class USkeletalMeshComponent* DummyMesh, class AActor* InGuestActor, float InBlendInTime, float PlayRate, bool bIgnoreSceneCollision);
	void OnEndSyncAnimationOnGuest(bool bStopGuestMontage);
	void OnRespectCollisionInASS(bool bRespect);
	void OnSwitchSyncGuestTarget(class AActor* NewGuest);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUAnimationSyncComponent">();
	}
	static class UBGUAnimationSyncComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUAnimationSyncComponent>();
	}
};
static_assert(alignof(UBGUAnimationSyncComponent) == 0x000008, "Wrong alignment on UBGUAnimationSyncComponent");
static_assert(sizeof(UBGUAnimationSyncComponent) == 0x000148, "Wrong size on UBGUAnimationSyncComponent");
static_assert(offsetof(UBGUAnimationSyncComponent, OwnerMasterComp) == 0x0000B8, "Member 'UBGUAnimationSyncComponent::OwnerMasterComp' has a wrong offset!");
static_assert(offsetof(UBGUAnimationSyncComponent, DummyMeshComp) == 0x0000C0, "Member 'UBGUAnimationSyncComponent::DummyMeshComp' has a wrong offset!");
static_assert(offsetof(UBGUAnimationSyncComponent, DrivingComp) == 0x0000C8, "Member 'UBGUAnimationSyncComponent::DrivingComp' has a wrong offset!");
static_assert(offsetof(UBGUAnimationSyncComponent, GuestActor) == 0x000108, "Member 'UBGUAnimationSyncComponent::GuestActor' has a wrong offset!");
static_assert(offsetof(UBGUAnimationSyncComponent, GuestMeshComp) == 0x000110, "Member 'UBGUAnimationSyncComponent::GuestMeshComp' has a wrong offset!");
static_assert(offsetof(UBGUAnimationSyncComponent, GuestMontage) == 0x000118, "Member 'UBGUAnimationSyncComponent::GuestMontage' has a wrong offset!");

// Class b1.BGUBirthPoint
// 0x0008 (0x02A8 - 0x02A0)
class ABGUBirthPoint : public ANavigationObjectBase
{
public:
	int32                                         BirthPointID;                                      // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUBirthPoint">();
	}
	static class ABGUBirthPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUBirthPoint>();
	}
};
static_assert(alignof(ABGUBirthPoint) == 0x000008, "Wrong alignment on ABGUBirthPoint");
static_assert(sizeof(ABGUBirthPoint) == 0x0002A8, "Wrong size on ABGUBirthPoint");
static_assert(offsetof(ABGUBirthPoint, BirthPointID) == 0x0002A0, "Member 'ABGUBirthPoint::BirthPointID' has a wrong offset!");

// Class b1.BGUBounceCheckObject
// 0x0008 (0x0030 - 0x0028)
class UBGUBounceCheckObject final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindBounceEvent(class UProjectileMovementComponent* ProjectileMovementComp);
	void OnBounceCheck(const struct FHitResult& Hit, const struct FVector& OldVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUBounceCheckObject">();
	}
	static class UBGUBounceCheckObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUBounceCheckObject>();
	}
};
static_assert(alignof(UBGUBounceCheckObject) == 0x000008, "Wrong alignment on UBGUBounceCheckObject");
static_assert(sizeof(UBGUBounceCheckObject) == 0x000030, "Wrong size on UBGUBounceCheckObject");

// Class b1.BGUCharacter
// 0x0130 (0x0730 - 0x0600)
class ABGUCharacter : public ACharacter
{
public:
	uint8                                         Pad_5F8[0x10];                                     // 0x05F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorCompContainer*                    ActorCompContainer;                                // 0x0608(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBGUDataComp*                           BGUDataComp;                                       // 0x0610(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBUS_EventCollection*                   EventCollection;                                   // 0x0618(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFullyInit;                                      // 0x0620(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPreferActorRotToControlRot;                       // 0x0621(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_622[0x2];                                      // 0x0622(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewRotationYawOffset;                             // 0x0624(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBGUReplicatedAcceleration             ReplicatedAcceleration;                            // 0x0628(0x0003)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_62B[0x55];                                     // 0x062B(0x0055)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          GSNetInitFinish;                                   // 0x0680(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_681[0x7];                                      // 0x0681(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FECSNetSerialization                   ECSDataNetSerialization;                           // 0x0688(0x0010)(Net, Transient, NoDestructor, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      AnimCapsule;                                       // 0x0698(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGURootMotionFollowMovementComponent*  AnimMoveComp;                                      // 0x06A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeginPlayFromLevelStreaming;                      // 0x06A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A9[0x7];                                      // 0x06A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABGUTamerBase*                          TamerOwner;                                        // 0x06B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIPerceptionStimuliSourceComponent*    AIPerceptionStimuliSourceComponent;                // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamIDDeprecate;                                   // 0x06C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C4[0x4];                                      // 0x06C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FUStGSNotifyStateCache> BranchPointNotifyStateCache;                       // 0x06C8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           HostSyncMontage;                                   // 0x0718(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HostSyncMontageStartTime;                          // 0x0720(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_724[0xC];                                      // 0x0724(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachBaseActorComp(class UBaseActorComp* Comp);
	void CallPostNetInit();
	void ForceSpawnDefaultControllerCS();
	void FullyInit();
	class UBUS_EventCollection* GetBUSEventCollection();
	class APlayerController* GetGSAuthorityPlayerCS();
	float GetHostSyncMontageSyncStartTime();
	void GSSwapNetRoleCS(bool HasAuthority_0);
	bool IsInGuestSyncMontage();
	bool IsPlayerCharacterCS();
	void LeaveGuestSyncMontage();
	void OnActorChannelOpen(class UNetConnection* Connection);
	void OnConstructionCS(const struct FTransform& Transform);
	void OnGuestSyncMontage(class UAnimMontage* _HostSyncMontage, float _HostSyncMontageStartTime);
	void OnMovementModeChangedCS(EMovementMode PrevMovementMode, EMovementMode NewMovementMode, uint8 PrevCustomMode, uint8 NewCustomMode);
	void OnPossessedCS(class AController* NewController);
	void OnRep_PlayerStateCS();
	void OnRep_ReplicatedAcceleration();
	void PostInitializeComponentsCS();
	void PostNetReceiveRoleCS();
	void PreDestroyFromReplicationCS();
	void SetPreferActorRotToControlRot(bool bValue);
	void SetTamerOwner(class ABGUTamerBase* NewOwner);
	void SetTeamID(int32 ID);
	void SetupPlayerInputComponentCS(class UInputComponent* PlayerInputComponent);
	void SetViewRotationYawOffset(float NewOffset);
	void SwitchNetRoleOnly(bool HasAuthority_0);
	class UActorComponent* TryGetComponentByName(const class FName& CompName);
	class UAnimMontage* TryGetHostSyncMontage();

	bool GetActorGuid(class FString* OutActorGuid) const;
	bool GetActorGuidCS(class FString* OutActorGuid) const;
	class ABGUTamerBase* GetTamerOwner() const;
	int32 GetTeamID() const;
	float GetViewRotationYawOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUCharacter">();
	}
	static class ABGUCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUCharacter>();
	}
};
static_assert(alignof(ABGUCharacter) == 0x000010, "Wrong alignment on ABGUCharacter");
static_assert(sizeof(ABGUCharacter) == 0x000730, "Wrong size on ABGUCharacter");
static_assert(offsetof(ABGUCharacter, ActorCompContainer) == 0x000608, "Member 'ABGUCharacter::ActorCompContainer' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, BGUDataComp) == 0x000610, "Member 'ABGUCharacter::BGUDataComp' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, EventCollection) == 0x000618, "Member 'ABGUCharacter::EventCollection' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, bIsFullyInit) == 0x000620, "Member 'ABGUCharacter::bIsFullyInit' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, bPreferActorRotToControlRot) == 0x000621, "Member 'ABGUCharacter::bPreferActorRotToControlRot' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, ViewRotationYawOffset) == 0x000624, "Member 'ABGUCharacter::ViewRotationYawOffset' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, ReplicatedAcceleration) == 0x000628, "Member 'ABGUCharacter::ReplicatedAcceleration' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, GSNetInitFinish) == 0x000680, "Member 'ABGUCharacter::GSNetInitFinish' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, ECSDataNetSerialization) == 0x000688, "Member 'ABGUCharacter::ECSDataNetSerialization' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, AnimCapsule) == 0x000698, "Member 'ABGUCharacter::AnimCapsule' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, AnimMoveComp) == 0x0006A0, "Member 'ABGUCharacter::AnimMoveComp' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, bBeginPlayFromLevelStreaming) == 0x0006A8, "Member 'ABGUCharacter::bBeginPlayFromLevelStreaming' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, TamerOwner) == 0x0006B0, "Member 'ABGUCharacter::TamerOwner' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, AIPerceptionStimuliSourceComponent) == 0x0006B8, "Member 'ABGUCharacter::AIPerceptionStimuliSourceComponent' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, TeamIDDeprecate) == 0x0006C0, "Member 'ABGUCharacter::TeamIDDeprecate' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, BranchPointNotifyStateCache) == 0x0006C8, "Member 'ABGUCharacter::BranchPointNotifyStateCache' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, HostSyncMontage) == 0x000718, "Member 'ABGUCharacter::HostSyncMontage' has a wrong offset!");
static_assert(offsetof(ABGUCharacter, HostSyncMontageStartTime) == 0x000720, "Member 'ABGUCharacter::HostSyncMontageStartTime' has a wrong offset!");

// Class b1.BGUCharacterMovementComponent
// 0x06A0 (0x15A0 - 0x0F00)
class UBGUCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	bool                                          bWalkOnDitch;                                      // 0x0F00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F01[0x3];                                      // 0x0F01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpOff_GravityScale_Config;                       // 0x0F04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOff_GravityScaleResetTime;                     // 0x0F08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOff_TestTickTime;                              // 0x0F0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOff_XYMaxSpeed;                                // 0x0F10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOff_ZAddtionalVelocity;                        // 0x0F14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOff_XYMaxSpeedAddtionalScale;                  // 0x0F18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOff_XYBaseCapsuelAddtionalScale;               // 0x0F1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F20[0x4];                                      // 0x0F20(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpOff_GravityScaleResetTimer;                    // 0x0F24(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediateUpdateRootMotion;                        // 0x0F28(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnMovingPlatform;                                 // 0x0F29(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSimplifiedMove;                             // 0x0F2A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2B[0x5];                                      // 0x0F2B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurNavOptFloorNormal;                              // 0x0F30(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurHitPoint;                                       // 0x0F48(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F60[0x4];                                      // 0x0F60(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CanSwitchToNavWalkCD;                              // 0x0F64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CanSwitchToNavWalkMaxCD;                           // 0x0F68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavWalkCanStepHeight;                              // 0x0F6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavWalkFallingHight;                               // 0x0F70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastDesireDeltaFloorZ;                             // 0x0F74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadiusRayExtraAdditiveScale;                // 0x0F78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NavWalkOptLevel;                                   // 0x0F7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XYMoveCenterBlockTriggerRollBackCapsuleScale;      // 0x0F80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XYMoveSideBlockTriggerRollBackCapsuleScale;        // 0x0F84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNavWalkOpt_MassiveOpt;                            // 0x0F88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePhysWalkingParam;                         // 0x0F89(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8A[0x2];                                      // 0x0F8A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavWalkCanStepAngel;                               // 0x0F8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpOff;                                          // 0x0F90(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F91[0x3];                                      // 0x0F91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavWalkCanStepDotValue;                            // 0x0F94(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavWalkCanStepCapsuelHeightScale;                  // 0x0F98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavWalkCapsuelStepLinTraceZOffsetFromCenter;       // 0x0F9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNavWalkDebugEnable;                               // 0x0FA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceOrgNavWalk;                                  // 0x0FA1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA2[0x1];                                      // 0x0FA2(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableCheckFloor;                                 // 0x0FA3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplePhysWalkCollisionRadius;                     // 0x0FA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplePhysWalkStartPenetratingRollBack;            // 0x0FA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplePhysWalkStartPenetratingMaxRollBack;         // 0x0FAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSimplePhysWalkCollision;                    // 0x0FB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB1[0x7];                                      // 0x0FB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RootMotionTranslationScale;                        // 0x0FB8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MMRootMotionScale;                                 // 0x0FD0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OptimizeDistanceLevel1;                            // 0x0FE8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalNavWalkOptDistanceLevel1;                     // 0x0FEC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OptimizeDistanceLevel2;                            // 0x0FF0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalNavWalkOptDistanceLevel2;                     // 0x0FF4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanOptimizeFromCS;                                // 0x0FF8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPatrolling;                                     // 0x0FF9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInBattle;                                       // 0x0FFA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBlendAnimRootMotion;                        // 0x0FFB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateRootMotionMove;                          // 0x0FFC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRootMotionFollowMode;                      // 0x0FFD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInFollowState;                                  // 0x0FFE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FFF[0x1];                                      // 0x0FFF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FollowClampDistanceOverride;                       // 0x1000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFollowClampDistance;                        // 0x1004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePrediction;                                 // 0x1008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1009[0x3];                                     // 0x1009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PredictionTime;                                    // 0x100C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PredictionPointNum;                                // 0x1010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAI;                                             // 0x1014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1015[0x1F];                                    // 0x1015(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MovementModeChangeTimeInOneFrame;                  // 0x1034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MovementModeChangeTimeInOneFrame_MutilTimes;       // 0x1038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_103C[0x3E0];                                   // 0x103C(0x03E0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MoveStartHistoryZDeltaNum_NavWalkOpt;              // 0x141C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MoveEndHistoryZDeltaNum_NavWalkOpt;                // 0x1420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZDeltaThrehold_NavWalkOpt;                         // 0x1424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorZSlopeDeltaThrehold_Anisotropy;               // 0x1428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorZSlopeDeltaThrehold_Syntropy;                 // 0x142C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurFloorZAdditionalWeight;                         // 0x1430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorZTraceStartScaleShrink;                       // 0x1434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorTestCapsuleRadiusScale;                       // 0x1438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_143C[0x4];                                     // 0x143C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DitchFallDeltaMoveForTest;                         // 0x1440(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1458[0x44];                                    // 0x1458(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugLength;                                       // 0x149C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugSingleStep;                                   // 0x14A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14A4[0x4];                                     // 0x14A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DebugZOffset;                                      // 0x14A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C0[0x10];                                    // 0x14C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionMovementParams              LastRootMotion;                                    // 0x14D0(0x0070)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     PredictionTrajectoryTransforms;                    // 0x1540(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         TopZInFalling;                                     // 0x1550(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCustomJumpData                        CustomJumpData;                                    // 0x1554(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1564[0x28];                                    // 0x1564(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwitchToNavWalkCumulateTime;                       // 0x158C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1590[0x10];                                    // 0x1590(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanGetNormalAndSurfaceTypeInfoFromMovement();
	void ClearTopZInFalling();
	void CustomJumpMoveBreak();
	float GetTopZInFalling();
	bool HasAnimRootMotion_CS();
	bool IsUseSeparateBrakingFriction();
	void LaunchVelocityZ(float VelocityZ);
	void MoveUpdateHitMove(const struct FVector& Delta);
	void ResetGravityToNormalGravity();
	void SetCustomJumpVelocityIncrement(float VelocityIncrement);
	void SetDisableNavWalkOptByWhiteList(bool bDisable);
	void SetEnableSimplePhysWalkCollision(bool bEnable);
	void SetGravityToJumpOffGravity();
	void SetNavWalkOptLevel(int32 NewLevel);
	void SetNavWalkOptMassiveMode(bool bMassiveOpt);
	void SetOnMovingPlatform(bool bIsOnMovingPlatform);
	void SetSwitchToNavWalkCumulateTime(float Time);
	void SetUseSeparateBrakingFriction(bool bUse);
	struct FVector TryGetCurHitPointFromMovement();
	struct FVector TryGetCurNormalFromMovement();
	int32 TryGetCurSurfaceTypeFromMovement();

	bool IsInJumpOffAdjust() const;
	bool IsInNavWalkOptMode() const;
	bool IsWalkOnDitch() const;
	void SetJumpOffState(bool JumpOff) const;
	void SetWalkOnDitch(bool bDitch) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUCharacterMovementComponent">();
	}
	static class UBGUCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUCharacterMovementComponent>();
	}
};
static_assert(alignof(UBGUCharacterMovementComponent) == 0x000010, "Wrong alignment on UBGUCharacterMovementComponent");
static_assert(sizeof(UBGUCharacterMovementComponent) == 0x0015A0, "Wrong size on UBGUCharacterMovementComponent");
static_assert(offsetof(UBGUCharacterMovementComponent, bWalkOnDitch) == 0x000F00, "Member 'UBGUCharacterMovementComponent::bWalkOnDitch' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, JumpOff_GravityScale_Config) == 0x000F04, "Member 'UBGUCharacterMovementComponent::JumpOff_GravityScale_Config' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, JumpOff_GravityScaleResetTime) == 0x000F08, "Member 'UBGUCharacterMovementComponent::JumpOff_GravityScaleResetTime' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, JumpOff_TestTickTime) == 0x000F0C, "Member 'UBGUCharacterMovementComponent::JumpOff_TestTickTime' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, JumpOff_XYMaxSpeed) == 0x000F10, "Member 'UBGUCharacterMovementComponent::JumpOff_XYMaxSpeed' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, JumpOff_ZAddtionalVelocity) == 0x000F14, "Member 'UBGUCharacterMovementComponent::JumpOff_ZAddtionalVelocity' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, JumpOff_XYMaxSpeedAddtionalScale) == 0x000F18, "Member 'UBGUCharacterMovementComponent::JumpOff_XYMaxSpeedAddtionalScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, JumpOff_XYBaseCapsuelAddtionalScale) == 0x000F1C, "Member 'UBGUCharacterMovementComponent::JumpOff_XYBaseCapsuelAddtionalScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, JumpOff_GravityScaleResetTimer) == 0x000F24, "Member 'UBGUCharacterMovementComponent::JumpOff_GravityScaleResetTimer' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bImmediateUpdateRootMotion) == 0x000F28, "Member 'UBGUCharacterMovementComponent::bImmediateUpdateRootMotion' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bOnMovingPlatform) == 0x000F29, "Member 'UBGUCharacterMovementComponent::bOnMovingPlatform' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bEnableSimplifiedMove) == 0x000F2A, "Member 'UBGUCharacterMovementComponent::bEnableSimplifiedMove' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, CurNavOptFloorNormal) == 0x000F30, "Member 'UBGUCharacterMovementComponent::CurNavOptFloorNormal' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, CurHitPoint) == 0x000F48, "Member 'UBGUCharacterMovementComponent::CurHitPoint' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, CanSwitchToNavWalkCD) == 0x000F64, "Member 'UBGUCharacterMovementComponent::CanSwitchToNavWalkCD' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, CanSwitchToNavWalkMaxCD) == 0x000F68, "Member 'UBGUCharacterMovementComponent::CanSwitchToNavWalkMaxCD' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, NavWalkCanStepHeight) == 0x000F6C, "Member 'UBGUCharacterMovementComponent::NavWalkCanStepHeight' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, NavWalkFallingHight) == 0x000F70, "Member 'UBGUCharacterMovementComponent::NavWalkFallingHight' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, LastDesireDeltaFloorZ) == 0x000F74, "Member 'UBGUCharacterMovementComponent::LastDesireDeltaFloorZ' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, CapsuleRadiusRayExtraAdditiveScale) == 0x000F78, "Member 'UBGUCharacterMovementComponent::CapsuleRadiusRayExtraAdditiveScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, NavWalkOptLevel) == 0x000F7C, "Member 'UBGUCharacterMovementComponent::NavWalkOptLevel' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, XYMoveCenterBlockTriggerRollBackCapsuleScale) == 0x000F80, "Member 'UBGUCharacterMovementComponent::XYMoveCenterBlockTriggerRollBackCapsuleScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, XYMoveSideBlockTriggerRollBackCapsuleScale) == 0x000F84, "Member 'UBGUCharacterMovementComponent::XYMoveSideBlockTriggerRollBackCapsuleScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bNavWalkOpt_MassiveOpt) == 0x000F88, "Member 'UBGUCharacterMovementComponent::bNavWalkOpt_MassiveOpt' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bOverridePhysWalkingParam) == 0x000F89, "Member 'UBGUCharacterMovementComponent::bOverridePhysWalkingParam' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, NavWalkCanStepAngel) == 0x000F8C, "Member 'UBGUCharacterMovementComponent::NavWalkCanStepAngel' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bJumpOff) == 0x000F90, "Member 'UBGUCharacterMovementComponent::bJumpOff' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, NavWalkCanStepDotValue) == 0x000F94, "Member 'UBGUCharacterMovementComponent::NavWalkCanStepDotValue' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, NavWalkCanStepCapsuelHeightScale) == 0x000F98, "Member 'UBGUCharacterMovementComponent::NavWalkCanStepCapsuelHeightScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, NavWalkCapsuelStepLinTraceZOffsetFromCenter) == 0x000F9C, "Member 'UBGUCharacterMovementComponent::NavWalkCapsuelStepLinTraceZOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bNavWalkDebugEnable) == 0x000FA0, "Member 'UBGUCharacterMovementComponent::bNavWalkDebugEnable' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bForceOrgNavWalk) == 0x000FA1, "Member 'UBGUCharacterMovementComponent::bForceOrgNavWalk' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bEnableCheckFloor) == 0x000FA3, "Member 'UBGUCharacterMovementComponent::bEnableCheckFloor' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, SimplePhysWalkCollisionRadius) == 0x000FA4, "Member 'UBGUCharacterMovementComponent::SimplePhysWalkCollisionRadius' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, SimplePhysWalkStartPenetratingRollBack) == 0x000FA8, "Member 'UBGUCharacterMovementComponent::SimplePhysWalkStartPenetratingRollBack' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, SimplePhysWalkStartPenetratingMaxRollBack) == 0x000FAC, "Member 'UBGUCharacterMovementComponent::SimplePhysWalkStartPenetratingMaxRollBack' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bEnableSimplePhysWalkCollision) == 0x000FB0, "Member 'UBGUCharacterMovementComponent::bEnableSimplePhysWalkCollision' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, RootMotionTranslationScale) == 0x000FB8, "Member 'UBGUCharacterMovementComponent::RootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, MMRootMotionScale) == 0x000FD0, "Member 'UBGUCharacterMovementComponent::MMRootMotionScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, OptimizeDistanceLevel1) == 0x000FE8, "Member 'UBGUCharacterMovementComponent::OptimizeDistanceLevel1' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, FinalNavWalkOptDistanceLevel1) == 0x000FEC, "Member 'UBGUCharacterMovementComponent::FinalNavWalkOptDistanceLevel1' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, OptimizeDistanceLevel2) == 0x000FF0, "Member 'UBGUCharacterMovementComponent::OptimizeDistanceLevel2' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, FinalNavWalkOptDistanceLevel2) == 0x000FF4, "Member 'UBGUCharacterMovementComponent::FinalNavWalkOptDistanceLevel2' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bCanOptimizeFromCS) == 0x000FF8, "Member 'UBGUCharacterMovementComponent::bCanOptimizeFromCS' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bIsPatrolling) == 0x000FF9, "Member 'UBGUCharacterMovementComponent::bIsPatrolling' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bIsInBattle) == 0x000FFA, "Member 'UBGUCharacterMovementComponent::bIsInBattle' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bEnableBlendAnimRootMotion) == 0x000FFB, "Member 'UBGUCharacterMovementComponent::bEnableBlendAnimRootMotion' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bReplicateRootMotionMove) == 0x000FFC, "Member 'UBGUCharacterMovementComponent::bReplicateRootMotionMove' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bDisableRootMotionFollowMode) == 0x000FFD, "Member 'UBGUCharacterMovementComponent::bDisableRootMotionFollowMode' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bIsInFollowState) == 0x000FFE, "Member 'UBGUCharacterMovementComponent::bIsInFollowState' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, FollowClampDistanceOverride) == 0x001000, "Member 'UBGUCharacterMovementComponent::FollowClampDistanceOverride' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, DefaultFollowClampDistance) == 0x001004, "Member 'UBGUCharacterMovementComponent::DefaultFollowClampDistance' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bEnablePrediction) == 0x001008, "Member 'UBGUCharacterMovementComponent::bEnablePrediction' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, PredictionTime) == 0x00100C, "Member 'UBGUCharacterMovementComponent::PredictionTime' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, PredictionPointNum) == 0x001010, "Member 'UBGUCharacterMovementComponent::PredictionPointNum' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, bIsAI) == 0x001014, "Member 'UBGUCharacterMovementComponent::bIsAI' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, MovementModeChangeTimeInOneFrame) == 0x001034, "Member 'UBGUCharacterMovementComponent::MovementModeChangeTimeInOneFrame' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, MovementModeChangeTimeInOneFrame_MutilTimes) == 0x001038, "Member 'UBGUCharacterMovementComponent::MovementModeChangeTimeInOneFrame_MutilTimes' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, MoveStartHistoryZDeltaNum_NavWalkOpt) == 0x00141C, "Member 'UBGUCharacterMovementComponent::MoveStartHistoryZDeltaNum_NavWalkOpt' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, MoveEndHistoryZDeltaNum_NavWalkOpt) == 0x001420, "Member 'UBGUCharacterMovementComponent::MoveEndHistoryZDeltaNum_NavWalkOpt' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, ZDeltaThrehold_NavWalkOpt) == 0x001424, "Member 'UBGUCharacterMovementComponent::ZDeltaThrehold_NavWalkOpt' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, FloorZSlopeDeltaThrehold_Anisotropy) == 0x001428, "Member 'UBGUCharacterMovementComponent::FloorZSlopeDeltaThrehold_Anisotropy' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, FloorZSlopeDeltaThrehold_Syntropy) == 0x00142C, "Member 'UBGUCharacterMovementComponent::FloorZSlopeDeltaThrehold_Syntropy' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, CurFloorZAdditionalWeight) == 0x001430, "Member 'UBGUCharacterMovementComponent::CurFloorZAdditionalWeight' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, FloorZTraceStartScaleShrink) == 0x001434, "Member 'UBGUCharacterMovementComponent::FloorZTraceStartScaleShrink' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, FloorTestCapsuleRadiusScale) == 0x001438, "Member 'UBGUCharacterMovementComponent::FloorTestCapsuleRadiusScale' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, DitchFallDeltaMoveForTest) == 0x001440, "Member 'UBGUCharacterMovementComponent::DitchFallDeltaMoveForTest' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, DebugLength) == 0x00149C, "Member 'UBGUCharacterMovementComponent::DebugLength' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, DebugSingleStep) == 0x0014A0, "Member 'UBGUCharacterMovementComponent::DebugSingleStep' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, DebugZOffset) == 0x0014A8, "Member 'UBGUCharacterMovementComponent::DebugZOffset' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, LastRootMotion) == 0x0014D0, "Member 'UBGUCharacterMovementComponent::LastRootMotion' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, PredictionTrajectoryTransforms) == 0x001540, "Member 'UBGUCharacterMovementComponent::PredictionTrajectoryTransforms' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, TopZInFalling) == 0x001550, "Member 'UBGUCharacterMovementComponent::TopZInFalling' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, CustomJumpData) == 0x001554, "Member 'UBGUCharacterMovementComponent::CustomJumpData' has a wrong offset!");
static_assert(offsetof(UBGUCharacterMovementComponent, SwitchToNavWalkCumulateTime) == 0x00158C, "Member 'UBGUCharacterMovementComponent::SwitchToNavWalkCumulateTime' has a wrong offset!");

// Class b1.BGUFuncLibCSSystem
// 0x0000 (0x0028 - 0x0028)
class UBGUFuncLibCSSystem final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* CSGetDataByClass(class UBaseActorComp* Comp, class UClass* Cls);
	static class UObject* CSGetReadOnlyData(class AActor* OwnerActor, class UClass* Cls);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFuncLibCSSystem">();
	}
	static class UBGUFuncLibCSSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFuncLibCSSystem>();
	}
};
static_assert(alignof(UBGUFuncLibCSSystem) == 0x000008, "Wrong alignment on UBGUFuncLibCSSystem");
static_assert(sizeof(UBGUFuncLibCSSystem) == 0x000028, "Wrong size on UBGUFuncLibCSSystem");

// Class b1.BGUFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBGUFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FName AddLevelStreaming(class UObject* WorldContextObject, const class FName& LevelName, const struct FVector& Location, const struct FRotator& Rotation, bool bShouldBlockOnLoad);
	static void ApplyLevelTransform(class UObject* WorldContextObject, const class FName& LevelName, const struct FTransform& LevelTransform);
	static void BGUActorUpdateAllTFXComp(class AActor* Actor);
	static class AActor* BGUBeginDeferredActorSpawnFromClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner);
	static class AActor* BGUBeginDeferredActorSpawnFromClassWithName(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class FName ActorName, class ULevel* OverrideLevel);
	static void BGUCalcBounds(class UPrimitiveComponent* StaticMesh, struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius);
	static class AActor* BGUFindFirstActorWithTag(const class UObject* WorldContextObject, class FName TagName);
	static class AActor* BGUFinishSpawningActor(class AActor* Actor, const struct FTransform& SpawnTransform);
	static void BGUFlushLevelStreamingOnlyVisibility(class UObject* WorldContextObject);
	static class UActorComponent* BGUGenComponent(class AActor* Actor, TSubclassOf<class UActorComponent> ActorComponentClass);
	static class UActorComponent* BGUGenComponentAndAdd(class AActor* Actor, TSubclassOf<class UActorComponent> ActorComponentClass);
	static class ULevelStreaming* BGUGenProceduralLevel(class UObject* WorldContextObject, const class FName& WorldAssetName, const class FName& InLevelName, const struct FTransform& InLevelTransform);
	static float BGUGetActiveMontagePosition(const class ABGUCharacter* Actor, const class UAnimMontage* Montage);
	static bool BGUGetAllActorsWithTagInRangeSorted(class AActor* CenterActor, class FName TagName, int32 Range, TArray<class AActor*>* OutActors);
	static class AActor* BGUGetHitResultActor(const struct FActorInstanceHandle& ActorInstanceHandle);
	static float BGUGetMontageSectionLengthByIndex(class AActor* Unit, class UAnimMontage* AnimMontage, int32 Index_0);
	static float BGUGetMontageSectionLengthByName(class AActor* Unit, class UAnimMontage* AnimMontage, class FName SectionName);
	static bool BGUGetMontageSectionStartAndEndTime(class UAnimMontage* AnimMontage, class FName SectionName, float* OutStartTime, float* OutEndTime);
	static float BGUGetMontageSectionTimeLeftFromPos(class AActor* Unit, class UAnimMontage* AnimMontage, float Position);
	static int32 BGUGetSkeletalMeshSimulatedBodiesBelowNum(class USkeletalMeshComponent* SkeletalMesh, class FName BoneName, bool bIncludeSelf);
	static int32 BGUGetTeamID(class AActor* Unit);
	static void BGUGetWindParameters_GameThread(class AActor* WorldContext, struct FVector* Position, struct FVector* OutDirection, float* OutSpeed, float* OutMinGustAmt, float* OutMaxGustAmt);
	static bool BGUHasFuncName(class FName FuncName, class UObject* Object, class UClass* StopAtClass);
	static bool BGUIsExistFile(const class FString& Path);
	static void BGULoadStreamLevel(class UObject* WorldContextObject, const class FName& LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, class UObject* CallbackTarget, const class FName& CallbackFunc, int32 ActionID, int32 Linkage);
	static bool BGUMergeSkeletalMesh(class USkeletalMesh* InMergeMesh, const TArray<class USkeletalMesh*>& InSrcMeshList, int32 StripTopLODS, EMeshBufferAccess MeshBufferAccess);
	static void BGUNavigationCalPathCost(class UObject* WorldContextObject, const struct FVector& PathStart, const struct FVector& PathEnd, float* PathCost, class AController* Querier);
	static bool BGUNavigationRaycast(class UObject* WorldContextObject, const struct FVector& RayStart, const struct FVector& RayEnd, struct FVector* HitLocation, TSubclassOf<class UNavigationQueryFilter> FilterClass, class AController* Querier);
	static float BGUPerlinNoise1D(float Value);
	static void BGUPlayerCtrlerGetViewPoint(class APlayerController* PlayerCtrler, struct FVector* Out_Location, struct FRotator* Out_Rotation);
	static void BGUProcessLatentActions(class UObject* WorldContextObject, class UObject* InObject, float DeltaTime);
	static bool BGUProjectPointToNavigation(class UObject* WorldContextObject, const struct FVector& Point, struct FVector* ProjectedLocation, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass, const struct FVector& QueryExtent);
	static void BGURenameActorComponent(class UActorComponent* Comp, const class FString& NewName);
	static void BGUResetActorVelocity(class AActor* Actor);
	static void BGUResetGeometryCollectionComponent(class UGeometryCollectionComponent* GeometryCollectionComponent);
	static void BGUResetToDefaultBoomCameraLagSpeed(class AActor* PlayerCharacter);
	static void BGUSaveUnitAttrToFile(const class FString& Name_0, const class FString& Text, bool Overwrite);
	static bool BGUSeparatingAxisPointCheck(const TArray<struct FVector>& InPolyVertices, const struct FVector& InBoxCenter, const struct FVector& InBoxExtent, bool bInCalcLeastPenetration);
	static bool BGUSetActiveMontagePosition(const class ABGUCharacter* Character, const class UAnimMontage* Montage, const float Position);
	static void BGUSetEnableGravity(class USkeletalMeshComponent* TargetMesh, bool bEnableGravity);
	static void BGUSetLinearColorParameterValueToMesh(class UMeshComponent* MeshInst, const class FName ParameterName, const struct FLinearColor& LinearColorParameterValue);
	static void BGUSetTressFXAssetAndMaterial(class UTressFXComponent* TFXComp, class UTressFXAsset* Asset, class UMaterialInstance* Material);
	static void BGUSetValueToCurveFloat(class UCurveFloat* CurveFloat, float Key, float Value, ERichCurveInterpMode InterpMode);
	static void BGUSetValueToCurveVector(class UCurveVector* CurveVector, float Key, const struct FVector& Value, ERichCurveInterpMode InterpMode);
	static bool BGUShapeSweepMultiByObjectType(const class UShapeComponent* ShapeComp, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf);
	static bool BGUSKMeshContainSocket(class USkeletalMeshComponent* SkMeshComp, class FName SocketName);
	static void BGUUnloadStreamLevel(class UObject* WorldContextObject, const class FName& LevelName, bool bShouldBlockOnUnload, class UObject* CallbackTarget, const class FName& CallbackFunc, int32 ActionID, int32 Linkage);
	static void BGUUpdateLevelStreaming(class UWorld* CurWorld);
	static void BGUWoodTestCharacter(class AActor* Character, class UAnimMontage* Montage, float ScaleRate);
	static TArray<class FName> BonesSphereMask(class USkeletalMeshComponent* TargetSkeletalMesh, float Radius, const struct FVector& WorldPosition);
	static void CalculateMontageCostValue(const TArray<class UAnimMontage*>& MontageList, const TArray<class FName>& BoneNameList);
	static void DrawDebugString(const class UObject* WorldContextObject, const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration);
	static void ForceLoadTileLOD(class UObject* WorldContext, const class FString& TileName, int32 SwitchOn);
	static TArray<class AActor*> GetAllActorsInLevel(class ULevel* Level);
	static TArray<class AActor*> GetAllActorsInWorld(class UWorld* World);
	static TArray<class FName> GetAllAssetDependencies(class FName SelectedPackageName);
	static TArray<class FName> GetAllAssetReference(class FName SelectedPackageName);
	static class FName GetAssetLongPackageName(const class FName& ClassName, const class FString& AssetName);
	static TArray<class ULevelStreaming*> GetLevelStreaming(class UObject* WorldContextObject);
	static TArray<class ULevelStreaming*> GetLevelStreamingFromWorld(const class UWorld* World);
	static struct FTransform GetLevelStreamingLevelTransformByName(class UObject* WorldContextObject, const class FName& LevelName);
	static uint8 GetLevelStreamingState(class UObject* WorldContextObject, const class FName& LevelName);
	static class FName GetNearestBoneName(class USkeletalMeshComponent* TargetSkeletalMesh, const struct FVector& WorldPosition, const TArray<class FString>& OptionalWhiteList);
	static class ACharacter* GetPlayerCharacter(class UObject* WorldContextObject);
	static struct FBox GetStreamingVolumeBounds(class ULevelStreaming* LevelStreaming);
	static void MoveLevel(class UObject* WorldContextObject, const class FName& LevelName, const struct FVector& InWorldOffset, bool bActorOnly);
	static void RemoveActorComponentFromLevelActor(class AActor* TargetLevelActor, class UActorComponent* InActorComponent);
	static void RemoveLevelStreaming(class UObject* WorldContextObject, const class FName& LevelName);
	static void SerializeActorComponentToLevelActor(class AActor* TargetLevelActor, class UActorComponent* InActorComponent);
	static void SetAllBodiesBelowSimulatePhysics(class USkeletalMeshComponent* TargetMesh, const class FName& InBoneName, bool bNewSimulate, bool bIncludeSelf, bool bSkipCustomPhysicsType);
	static void SetBodyBonePhysic(class USkeletalMeshComponent* TargetMesh, class FName BoneName, bool NewBool);
	static void SetIKValid(class ACharacter* Character, bool NewValid);
	static void SetLocalKinematics(class USkeletalMeshComponent* TargetMesh, bool NewBool);
	static void SphereComponentInitRadius(class USphereComponent* SphereComp, float Radius);
	static bool VolumeEncompassPoint(class AVolume* Volume, const struct FVector& Point, float SphereRadius, float* OutDistanceToPoint);
	static struct FUStGSHitResult WrapHitResult(const struct FHitResult& HitResult);

	class FName MakeUniqueTamerMonsterName(class ULevel* SpawnLevel, class FName InBaseName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFunctionLibrary">();
	}
	static class UBGUFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFunctionLibrary>();
	}
};
static_assert(alignof(UBGUFunctionLibrary) == 0x000008, "Wrong alignment on UBGUFunctionLibrary");
static_assert(sizeof(UBGUFunctionLibrary) == 0x000028, "Wrong size on UBGUFunctionLibrary");

// Class b1.BGUFunctionLibraryForCS
// 0x0000 (0x0028 - 0x0028)
class UBGUFunctionLibraryForCS final : public UBlueprintFunctionLibrary
{
public:
	static void AddNotifyPreloadedAsset(class UObject* Notify, class UObject* Asset);
	static void BGUBindOnActorBeginOverlapEvent(class AActor* Actor, class UObject* Obj, class FName FuncName);
	static void BGUBindOnActorEndOverlapEvent(class AActor* Actor, class UObject* Obj, class FName FuncName);
	static void BGUBindOnAllSetLevelsStateFinished(class UObject* Obj, class FName FuncName);
	static void BGUBindOnComponentBeginOverlapEvent(class UPrimitiveComponent* Comp, class UObject* Obj, class FName FuncName);
	static void BGUBindOnComponentEndOverlapEvent(class UPrimitiveComponent* Comp, class UObject* Obj, class FName FuncName);
	static void BGUBindOnComponentHitEvent(class UPrimitiveComponent* Comp, class UObject* Obj, class FName Func_0);
	static void BGUBindOnSetLevelsStateFinished(class UObject* Obj, class FName FuncName);
	static struct FVector BGUComputeActorHitMovePenetration(class AActor* SelfActor, const TArray<class UHitMoveOverlapOtherActorCollisionsInfo*>& OverlappedOtherActorInfos, float SelfWeight, const struct FVector& PlaneNormalVector, int32 MaxComputeRound, float Epsilon);
	static class UTexture2D* BGUCreateLandscapeHeightMap(class ALandscape* Landscape, const class FString& PackageName, const class FString& AssetName);
	static void BGUDrawDebugAnnularSector(const class UWorld* World, const struct FVector& CenterPos, const struct FVector& Direction, float InnerRadius, float OuterRadius, float HalfAngle, const struct FColor& Color, float Duration, float Thickness, int32 Segments);
	static void BGUDrawDebugCircle(const class UWorld* World, const struct FVector& CenterPos, float Raidus);
	static void BGUDrawDebugCircleEx(const class UWorld* World, const struct FVector& CenterPos, float Raidus, float KeepTime, const struct FColor& Color);
	static void BGUDrawDebugRect(const class UWorld* World, const struct FVector& CenterPos, const struct FVector& Direction, float Width, float Length);
	static void BGUDrawDebugSphere(const class UWorld* World, const struct FVector& CenterPos, float Raidus);
	static void BGUDrawDebugSphereEx(const class UWorld* World, const struct FVector& CenterPos, float Raidus, float KeepTime, const struct FColor& Color);
	static void BGUDrawLineArrow(const class UWorld* World, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize);
	static void BGUDrawLineArrowEx(const class UWorld* World, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FColor& Color, bool IsPersistentLines, float LifeTime);
	static void BGUDrawSphereSweep(const class UWorld* World, const struct FTransform& Start, const struct FTransform& End, float Radius);
	static void BguDrawSphereSweepWithColor(const class UWorld* World, const struct FTransform& Start, const struct FTransform& End, float Radius, const struct FColor& Color);
	static void BGUDrawSweepCheckShape(const class UWorld* World, const struct FVector& CenterPos, const struct FQuat& Rot, const struct FGSSweepCheckShapeInfo& SweepCheckShapeInfo);
	static void BguDrawSweepCheckShapeWithColor(const class UWorld* World, const struct FVector& CenterPos, const struct FQuat& Rot, const struct FGSSweepCheckShapeInfo& SweepCheckShapeInfo, const struct FColor& Color);
	static void BGUEnableActorTick(class AActor* Actor, bool bEnable);
	static void BGUExceutePyCode(const class FString& PyPath);
	static class FString BGUGetActorLevelName(class AActor* Unit);
	static bool BGUGetAIStimulusWasSuccessfullySensed(const struct FAIStimulus& Stimulus);
	static TArray<class AActor*> BGUGetAllActorsFromGroupActor(class AActor* GroupActor, bool bRecurse);
	static float BGUGetBodyRadius(class USkeletalMeshComponent* SkMeshComp, class FName BoneName, bool bGetWelded);
	static void BGUGetBounds(class UPrimitiveComponent* PrimComp, struct FVector* Origin, struct FVector* BoxExtent);
	static int32 BGUGetCurActiveMontageInstID(class UAnimInstance* AnimInstance);
	static float BGUGetCurrentTime(class UObject* WorldContextObject, bool* IsValid);
	static bool BGUGetFloatValueTableRow(class UDataTable* DataTable, class FName RowName, struct FGSFloatValueTableRow* Result, const class FString& ContextString, bool bWarnIfRowMissing);
	static bool BGUGetIsBuildShipping();
	static bool BGUGetIsEditor();
	static bool BGUGetIsInEditorPreview(class UObject* WorldContextObject);
	static bool BGUGetIsInGameWorld(class UObject* WorldContextObject);
	static bool BGUGetIsRuntionShowCollision(class UObject* WorldContextObject);
	static void BGUGetLandscapeExtent(class ALandscape* Landscape, int32* MinX, int32* MinY, int32* MaxX, int32* MaxY);
	static float BGUGetLevelSequenceCurTime(class ULevelSequencePlayer* LeveleSequencePlayer);
	static float BGUGetLevelSequenceLength(class ULevelSequencePlayer* LeveleSequencePlayer);
	static int32 BGUGetMeshPredictedLODLevel(class USkeletalMeshComponent* MeshComp);
	static struct FVector2D BGUGetPaperSpriteSize(class UPaperSprite* PaperSprite);
	static int32 BGUGetPARadiusByBoneName(class UPhysicsAsset* PA, class FName BoneName, float* BodyRadius);
	static bool BGUGetParticleSystemIsLooping(const class UParticleSystem* ParticleForPlay);
	static void BGUGetSectionFromProceduralMesh(class UProceduralMeshComponent* InProcMesh, int32 SectionIndex, TArray<struct FVector>* Vertices, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs, TArray<struct FProcMeshTangent>* Tangents);
	static class UWorld* BGUGetUWorld(class UObject* InnerObject);
	static bool BGUIsBlackBoardKeyTypeMatch(class UBlackboardKeyType* BBKey, EBBKeyType BBKeyType);
	static void BGUMovementComponentHandleImpact(class UMovementComponent* MoveComp, const struct FHitResult& Hit, float TimeSlice, const struct FVector& MoveDelta);
	static float BGUMovementComponentSlideAlongSurface(class UMovementComponent* MoveComp, const struct FVector& Delta, float Time, const struct FVector& Normal, const struct FHitResult& InHit, bool bHandleImpact, struct FHitResult* OutHit);
	static bool BGURegistComp(class UObject* WorldContextObject, class UActorComponent* ActorComp);
	static void BGURestartBT(class ABGUAIController* AIController);
	static void BGUSetDecalSize(class UDecalComponent* DecalComp, const struct FVector& Size);
	static void BGUSetIKComponentValid(class ACharacter* Character, bool NewValid);
	static void BGUSetParticleSysCompPoolingMethod(class UParticleSystemComponent* ParticleComp, EPSCPoolMethod PoolMethod);
	static void BGUSetParticleSysSortPriority(class UParticleSystemComponent* ParticleSystemComp, int32 SortPriority);
	static void BGUSliceProceduralMesh(class UProceduralMeshComponent* InProcMesh, const struct FVector& PlanePosition, const struct FVector& PlaneNormal, bool bCreateOtherHalf, class UProceduralMeshComponent** OutOtherHalfProcMesh, EProcMeshSliceCapOption CapOption, class UMaterialInterface* CapMaterial);
	static class UDecalComponent* BGUSpawnDecalAttached(class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, float LifeSpan);
	static bool BGUTeleportTo(class AActor* Owner, const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bIsATest, bool bNoCheck);
	static void BGUUnBindOnAllSetLevelsStateFinished(class UObject* Obj, class FName FuncName);
	static void BGUUnBindOnComponentBeginOverlapEvent(class UPrimitiveComponent* Comp, class UObject* Obj, class FName FuncName);
	static void BGUUnBindOnComponentEndOverlapEvent(class UPrimitiveComponent* Comp, class UObject* Obj, class FName FuncName);
	static void BGUUnBindOnComponentHitEvent(class UPrimitiveComponent* Comp, class UObject* Obj, class FName Func_0);
	static void BGUUnBindOnSetLevelsStateFinished(class UObject* Obj, class FName FuncName);
	static void CallSectionManuallyChangeOnCrossSectionNotifies(class ABGUCharacter* OwnerChar, const class FName& NewSectionName);
	static bool CompForceUpdateOverlaps(class UPrimitiveComponent* Comp, bool bDoNotifies);
	static ECollisionChannel ConvertObjectTypeToCollisionChannel(EObjectTypeQuery ObjectType);
	static EObjectTypeQuery ConvertToObjectType(ECollisionChannel CollisionChannel);
	static ETraceTypeQuery ConvertToTraceType(ECollisionChannel CollisionChannel);
	static ECollisionChannel ConvertTraceTypeToCollisionChannel(ETraceTypeQuery TraceType);
	static void CopyProceduralMeshFromStaticMeshComponent(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, class UProceduralMeshComponent* ProcMeshComponent, bool bCreateCollision);
	static void RemoveAllQueriesByQuerier(class UObject* Querier);
	static struct FGameplayTag RequestGameplayTag(class FName TagName, bool ErrorIfNotFound);
	static void ValidateMontagesForCrossSectionNS(const class FString& ResourcePath);

	void OnActorBeginOverlapPlaceholder(class AActor* OverlapActor, class AActor* OtherActor);
	void OnActorEndOverlapPlaceholder(class AActor* OverlapActor, class AActor* OtherActor);
	void OnAllSetLevelsStateFinishedPlaceHolder();
	void OnComponentBeginOverlapPlaceholder(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnComponentEndOverlapPlaceholder(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnComponentHitPlaceholder(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& HitImpule, const struct FHitResult& Hit);
	void OnSetLevelsStateFinishedPlaceHolder(const class FString& InTargetLevelsKeyword, const class FString& InTargetLevelState, int32 InOperationID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFunctionLibraryForCS">();
	}
	static class UBGUFunctionLibraryForCS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFunctionLibraryForCS>();
	}
};
static_assert(alignof(UBGUFunctionLibraryForCS) == 0x000008, "Wrong alignment on UBGUFunctionLibraryForCS");
static_assert(sizeof(UBGUFunctionLibraryForCS) == 0x000028, "Wrong size on UBGUFunctionLibraryForCS");

// Class b1.BGUFunctionLibAK
// 0x0000 (0x0028 - 0x0028)
class UBGUFunctionLibAK final : public UBlueprintFunctionLibrary
{
public:
	static void AkEventPinInGarbageCollector(class UAkAudioEvent* Event, int32 PlayingID);
	static void BGUAKStopPlayingID(int32 PlayingID, int32 FadeOutTimeMs, int32 FadeOutCurveType);
	static void ExecuteActionOnPlayingID(int32 ActionType, int32 PlayingID, int32 FadeOutTimeMs, int32 FadeOutCurveType);
	static int32 GetSourcePlayPosition(int32 PlayingID);
	static void LoadBank(const class FString& BankName);
	static int32 PostAkEventOnDummyActor(const class FString& EventName, class UAkAudioEvent* Event);
	static EAkResult SeekOnEvent(const class FString& InEventName, class UAkComponent* InComponent, float InPercent, bool bInSeekToNearestMarker, int32 InPlayingID);
	static void SetUnrealGlobalSwitch(class FName SwitchGroup, class FName SwitchState);
	static void UnLoadBank(const class FString& BankName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFunctionLibAK">();
	}
	static class UBGUFunctionLibAK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFunctionLibAK>();
	}
};
static_assert(alignof(UBGUFunctionLibAK) == 0x000008, "Wrong alignment on UBGUFunctionLibAK");
static_assert(sizeof(UBGUFunctionLibAK) == 0x000028, "Wrong size on UBGUFunctionLibAK");

// Class b1.BGUFunctionLibCollisionChannel
// 0x0000 (0x0028 - 0x0028)
class UBGUFunctionLibCollisionChannel final : public UBlueprintFunctionLibrary
{
public:
	static bool BGUGetCollisionResponseToChannels(const class UPrimitiveComponent* Comp, TMap<ECollisionChannel, ECollisionResponse>* OutResponseToChannels);
	static void BGUSetCollisionResponseToChannels(class UPrimitiveComponent* Comp, const TMap<ECollisionChannel, ECollisionResponse>& ResponseToChannels);
	static ECollisionChannel ConvertToCollisionChannelByObjectType(EObjectTypeQuery ObjectType);
	static ECollisionChannel ConvertToCollisionChannelByTraceType(ETraceTypeQuery TraceType);
	static EObjectTypeQuery ConvertToObjectType(ECollisionChannel CollisionChannel);
	static ETraceTypeQuery ConvertToTraceType(ECollisionChannel CollisionChannel);
	static bool GetCollisionProfileData(const class UPrimitiveComponent* Comp, const class FName& ProfileName, ECollisionEnabled* OutCollisionEnabled, ECollisionChannel* OutObjectType, TMap<ECollisionChannel, ECollisionResponse>* OutResponseToChannels);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFunctionLibCollisionChannel">();
	}
	static class UBGUFunctionLibCollisionChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFunctionLibCollisionChannel>();
	}
};
static_assert(alignof(UBGUFunctionLibCollisionChannel) == 0x000008, "Wrong alignment on UBGUFunctionLibCollisionChannel");
static_assert(sizeof(UBGUFunctionLibCollisionChannel) == 0x000028, "Wrong size on UBGUFunctionLibCollisionChannel");

// Class b1.BGUFuncLibCSDelegateRegister
// 0x0000 (0x0028 - 0x0028)
class UBGUFuncLibCSDelegateRegister final : public UBlueprintFunctionLibrary
{
public:
	static void Register_BTDecoratorCheckCondition(const struct FIntPtr& FuncPtr);
	static void Register_BTServiceActivation(const struct FIntPtr& FuncPtr);
	static void Register_BTServiceDeactivation(const struct FIntPtr& FuncPtr);
	static void Register_BTServiceSearchStart(const struct FIntPtr& FuncPtr);
	static void Register_BTServiceTick(const struct FIntPtr& FuncPtr);
	static void Register_BTTaskAbort(const struct FIntPtr& FuncPtr);
	static void Register_BTTaskExecute(const struct FIntPtr& FuncPtr);
	static void Register_BTTaskTick(const struct FIntPtr& FuncPtr);
	static void Register_ResetProperty(const struct FIntPtr& FuncPtr);
	static void Register_SetCollisionResponseProperty(const struct FIntPtr& FuncPtr);
	static void Register_SetEnumProperty(const struct FIntPtr& FuncPtr);
	static void Register_SetFloatProperty(const struct FIntPtr& FuncPtr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUFuncLibCSDelegateRegister">();
	}
	static class UBGUFuncLibCSDelegateRegister* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUFuncLibCSDelegateRegister>();
	}
};
static_assert(alignof(UBGUFuncLibCSDelegateRegister) == 0x000008, "Wrong alignment on UBGUFuncLibCSDelegateRegister");
static_assert(sizeof(UBGUFuncLibCSDelegateRegister) == 0x000028, "Wrong size on UBGUFuncLibCSDelegateRegister");

// Class b1.BGUWCStreamingFuncLib
// 0x0000 (0x0028 - 0x0028)
class UBGUWCStreamingFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void CacheWorldCompositionLevelNames(class UObject* InWorldContext);
	static void CacheWorldCompositionStreamingLayers(class UObject* InWorldContext);
	static void CheckLevelState(class UObject* InWorldContext, const class FString& InTargetLevelName);
	static void DestroyGSWCWorldStreamingSources(class UObject* WorldContext);
	static void DisableStreamingSource(class AActor* InActor);
	static void EnableStreamingSource(class AActor* InActor);
	static void FlushAllLevelState(class UObject* InWorldContext, const TArray<class FString>& InExcludedLevelKeywords);
	static void ForceLoadAllStreamingLevels(class UObject* InWorldContext);
	static int32 GetAllLevelCurrentState(class UObject* InWorldContext, TMap<class FString, uint8>* OutLevelStreamingList, bool bIgnoreWCTile);
	static void GetLevelCurrentStateAndIsConsideredUpdate(class UObject* InWorldContext, const TArray<class FString>& LevelNames, TMap<class FString, uint8>* OutLevelStreamingList, TSet<class FString>* OutCosideredUpdateSet);
	static int32 GetLevelNames(class UObject* InWorldContext, TArray<class FString>* OutLevelNames);
	static TArray<class FString> GetLevelNamesByKeyword(class UObject* InWorldContext, const class FString& InLevelNameKeyword);
	static int32 GetProcessingStreamingLevelNum(class UObject* InWorldContext);
	static bool IsLevelStreamable(class UObject* InWorldContext, const class FString& InTargetLevelName);
	static void ModifyStreamingDistanceScaleByStreamingLayer(class UObject* InWorldContext, const class FString& InTargetLayerName, int32 InTargetLODIndex, float InTargetScaleFactor, bool bBlockTillStreamingCompleted);
	static void PauseDistanceStreaming(class UObject* InWorldContext, const TArray<class FString>& InExcludedLevelKeywords);
	static TMap<class FString, class FString> QueryProcessingStreamingLevels(class UObject* InWorldContext);
	static void RegisterAsStreamingSource(class AActor* InActor);
	static TArray<struct FGSSetLevelStateFailedInfo> SetLevelsState(class UObject* InWorldContext, const class FString& InTargetLevelNameOrKeyword, EGSLevelState InTargetState, int32 InOperationID, bool bKeywordMatch, bool bBlockOnLoad);
	static TArray<struct FGSSetLevelStateFailedInfo> SetLevelsStateByNames(class UObject* InWorldContext, const TArray<class FString>& InTargetLevelNames, EGSLevelState InTargetState, int32 InOperationID, bool bBlockOnLoad);
	static void SetStreamingManagerViewSource(const struct FVector& ViewLocation, float Duration);
	static void SpawnStreamingSource(class UObject* WorldContext, const struct FVector& SpawnLocation);
	static void UnregisterFromStreamingSource(class AActor* InActor);
	static void UpdateStreamingState(class UObject* WorldContext, bool bBlockTillComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUWCStreamingFuncLib">();
	}
	static class UBGUWCStreamingFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUWCStreamingFuncLib>();
	}
};
static_assert(alignof(UBGUWCStreamingFuncLib) == 0x000008, "Wrong alignment on UBGUWCStreamingFuncLib");
static_assert(sizeof(UBGUWCStreamingFuncLib) == 0x000028, "Wrong size on UBGUWCStreamingFuncLib");

// Class b1.BGUHiddenDistanceComponent
// 0x0028 (0x00D8 - 0x00B0)
class UBGUHiddenDistanceComponent final : public UActorComponent
{
public:
	TArray<TSoftClassPtr<class UClass>>           SupportComponents;                                 // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         FadeOutDistance;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeOut;                                          // 0x00C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UPrimitiveComponent>> SwitchedComponents;                                // 0x00C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUHiddenDistanceComponent">();
	}
	static class UBGUHiddenDistanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUHiddenDistanceComponent>();
	}
};
static_assert(alignof(UBGUHiddenDistanceComponent) == 0x000008, "Wrong alignment on UBGUHiddenDistanceComponent");
static_assert(sizeof(UBGUHiddenDistanceComponent) == 0x0000D8, "Wrong size on UBGUHiddenDistanceComponent");
static_assert(offsetof(UBGUHiddenDistanceComponent, SupportComponents) == 0x0000B0, "Member 'UBGUHiddenDistanceComponent::SupportComponents' has a wrong offset!");
static_assert(offsetof(UBGUHiddenDistanceComponent, FadeOutDistance) == 0x0000C0, "Member 'UBGUHiddenDistanceComponent::FadeOutDistance' has a wrong offset!");
static_assert(offsetof(UBGUHiddenDistanceComponent, bFadeOut) == 0x0000C4, "Member 'UBGUHiddenDistanceComponent::bFadeOut' has a wrong offset!");
static_assert(offsetof(UBGUHiddenDistanceComponent, SwitchedComponents) == 0x0000C8, "Member 'UBGUHiddenDistanceComponent::SwitchedComponents' has a wrong offset!");

// Class b1.BGULevelSequenceActor
// 0x0010 (0x0300 - 0x02F0)
class ABGULevelSequenceActor final : public ALevelSequenceActor
{
public:
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGULevelSequenceActor">();
	}
	static class ABGULevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGULevelSequenceActor>();
	}
};
static_assert(alignof(ABGULevelSequenceActor) == 0x000008, "Wrong alignment on ABGULevelSequenceActor");
static_assert(sizeof(ABGULevelSequenceActor) == 0x000300, "Wrong size on ABGULevelSequenceActor");

// Class b1.BGULevelSequenceInstanceData
// 0x0000 (0x00A0 - 0x00A0)
class UBGULevelSequenceInstanceData final : public UDefaultLevelSequenceInstanceData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGULevelSequenceInstanceData">();
	}
	static class UBGULevelSequenceInstanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGULevelSequenceInstanceData>();
	}
};
static_assert(alignof(UBGULevelSequenceInstanceData) == 0x000010, "Wrong alignment on UBGULevelSequenceInstanceData");
static_assert(sizeof(UBGULevelSequenceInstanceData) == 0x0000A0, "Wrong size on UBGULevelSequenceInstanceData");

// Class b1.BGULevelStreamingPauseSection
// 0x0008 (0x00F0 - 0x00E8)
class UBGULevelStreamingPauseSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGULevelStreamingPauseSection">();
	}
	static class UBGULevelStreamingPauseSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGULevelStreamingPauseSection>();
	}
};
static_assert(alignof(UBGULevelStreamingPauseSection) == 0x000008, "Wrong alignment on UBGULevelStreamingPauseSection");
static_assert(sizeof(UBGULevelStreamingPauseSection) == 0x0000F0, "Wrong size on UBGULevelStreamingPauseSection");

// Class b1.BGULevelStreamingPauseTrack
// 0x0010 (0x00A0 - 0x0090)
class UBGULevelStreamingPauseTrack final : public UMovieSceneNameableTrack
{
public:
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x0090(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGULevelStreamingPauseTrack">();
	}
	static class UBGULevelStreamingPauseTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGULevelStreamingPauseTrack>();
	}
};
static_assert(alignof(UBGULevelStreamingPauseTrack) == 0x000008, "Wrong alignment on UBGULevelStreamingPauseTrack");
static_assert(sizeof(UBGULevelStreamingPauseTrack) == 0x0000A0, "Wrong size on UBGULevelStreamingPauseTrack");
static_assert(offsetof(UBGULevelStreamingPauseTrack, Sections) == 0x000090, "Member 'UBGULevelStreamingPauseTrack::Sections' has a wrong offset!");

// Class b1.BGULevelStreamingPauseTrackInstance
// 0x0000 (0x0050 - 0x0050)
class UBGULevelStreamingPauseTrackInstance final : public UMovieSceneTrackInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGULevelStreamingPauseTrackInstance">();
	}
	static class UBGULevelStreamingPauseTrackInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGULevelStreamingPauseTrackInstance>();
	}
};
static_assert(alignof(UBGULevelStreamingPauseTrackInstance) == 0x000008, "Wrong alignment on UBGULevelStreamingPauseTrackInstance");
static_assert(sizeof(UBGULevelStreamingPauseTrackInstance) == 0x000050, "Wrong size on UBGULevelStreamingPauseTrackInstance");

// Class b1.BGULocalFluid2DComponent
// 0x0210 (0x02C0 - 0x00B0)
class UBGULocalFluid2DComponent final : public UActorComponent
{
public:
	bool                                          ToggleSim;                                         // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPostProcessCollisionData;                         // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          blueprintDrivenParameters;                         // 0x00B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovedCheck;                                       // 0x00B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          blocationCheck;                                    // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLocalSim;                                         // 0x00B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHighQualitySim;                                   // 0x00B6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimAreaClamp;                                     // 0x00B7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxIteration;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SimulationResX;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SimulationResY;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimAreaSizeInCM;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SnappedPosParameterName;                           // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           DynamicSDFMpc;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOffsetThreshold;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveThreadhold;                                    // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgeExtendSize;                                    // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExportVeloDensity;                                // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExportPressureDivergence;                         // 0x00E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 VeloDensityOutput;                                 // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 PressureDivergenceOutput;                          // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CollisionQueryMaterial;                            // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PPCollisionQueryMaterial;                          // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CompositeMaterial;                                 // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     AdvectMaterial;                                    // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DivergenceMaterial;                                // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PressureStep1Material;                             // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     PressureStep2Material;                             // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushPuncture;                                     // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloDirNoise;                                      // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloFromSimAreaMotion;                             // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimEdgeBouncyness;                                 // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeDensityAtSimEdge;                              // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloDirNoiseSize;                                  // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloDirNoiseSpeed;                                 // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloOffsetX;                                       // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloOffsetY;                                       // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloFromBrushMotion;                               // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloStrength;                                      // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloRotate;                                        // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloAmpNoise;                                      // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InputFeedback;                                     // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlowFeedback;                                      // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Divergence;                                        // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushSize;                                         // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushStrength;                                     // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EraserMode;                                        // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushHardness;                                     // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DensityTemplate;                                   // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             VelocityTemplate;                                  // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityOffsetSpeed;                               // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgeMaskWidth;                                     // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityTxtMult;                                    // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityTxtScale;                                   // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityTxtOffsetX;                                 // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityTxtOffsetY;                                 // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushNoise;                                        // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeloInputTile;                                     // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityInputNoiseAmp;                              // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityInputNoiseOffset;                           // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DensityInputNoiseTile;                             // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrushRnd;                                          // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOffsetX;                                      // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WorldOffsetY;                                      // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x88];                                     // 0x01D0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RT_CollisionResult;                                // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_PPCollisionResult;                              // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_Advection;                                      // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_PressureDivergence;                             // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_Composite;                                      // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RT_PressureDivergenceTemp;                         // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CollisionQueryMaterialInstance;                    // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PPCollisionQueryMaterialInstance;                  // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CompositeMaterialInstance;                         // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               AdvectMaterialInstance;                            // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DivergenceMaterialInstance;                        // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PressureStep1MaterialInstance;                     // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PressureStep2MaterialInstance;                     // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UTextureRenderTarget2D* GetPressureDivergenceTexture();
	class UTextureRenderTarget2D* GetVeloDensityTexture();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGULocalFluid2DComponent">();
	}
	static class UBGULocalFluid2DComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGULocalFluid2DComponent>();
	}
};
static_assert(alignof(UBGULocalFluid2DComponent) == 0x000008, "Wrong alignment on UBGULocalFluid2DComponent");
static_assert(sizeof(UBGULocalFluid2DComponent) == 0x0002C0, "Wrong size on UBGULocalFluid2DComponent");
static_assert(offsetof(UBGULocalFluid2DComponent, ToggleSim) == 0x0000B0, "Member 'UBGULocalFluid2DComponent::ToggleSim' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, bPostProcessCollisionData) == 0x0000B1, "Member 'UBGULocalFluid2DComponent::bPostProcessCollisionData' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, blueprintDrivenParameters) == 0x0000B2, "Member 'UBGULocalFluid2DComponent::blueprintDrivenParameters' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, bMovedCheck) == 0x0000B3, "Member 'UBGULocalFluid2DComponent::bMovedCheck' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, blocationCheck) == 0x0000B4, "Member 'UBGULocalFluid2DComponent::blocationCheck' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, bLocalSim) == 0x0000B5, "Member 'UBGULocalFluid2DComponent::bLocalSim' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, bHighQualitySim) == 0x0000B6, "Member 'UBGULocalFluid2DComponent::bHighQualitySim' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, bSimAreaClamp) == 0x0000B7, "Member 'UBGULocalFluid2DComponent::bSimAreaClamp' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, MaxIteration) == 0x0000B8, "Member 'UBGULocalFluid2DComponent::MaxIteration' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, SimulationResX) == 0x0000BC, "Member 'UBGULocalFluid2DComponent::SimulationResX' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, SimulationResY) == 0x0000C0, "Member 'UBGULocalFluid2DComponent::SimulationResY' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, SimAreaSizeInCM) == 0x0000C4, "Member 'UBGULocalFluid2DComponent::SimAreaSizeInCM' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, SnappedPosParameterName) == 0x0000C8, "Member 'UBGULocalFluid2DComponent::SnappedPosParameterName' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DynamicSDFMpc) == 0x0000D0, "Member 'UBGULocalFluid2DComponent::DynamicSDFMpc' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, WorldOffsetThreshold) == 0x0000D8, "Member 'UBGULocalFluid2DComponent::WorldOffsetThreshold' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, MoveThreadhold) == 0x0000DC, "Member 'UBGULocalFluid2DComponent::MoveThreadhold' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, EdgeExtendSize) == 0x0000E0, "Member 'UBGULocalFluid2DComponent::EdgeExtendSize' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, bExportVeloDensity) == 0x0000E4, "Member 'UBGULocalFluid2DComponent::bExportVeloDensity' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, bExportPressureDivergence) == 0x0000E5, "Member 'UBGULocalFluid2DComponent::bExportPressureDivergence' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloDensityOutput) == 0x0000E8, "Member 'UBGULocalFluid2DComponent::VeloDensityOutput' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, PressureDivergenceOutput) == 0x0000F0, "Member 'UBGULocalFluid2DComponent::PressureDivergenceOutput' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, CollisionQueryMaterial) == 0x0000F8, "Member 'UBGULocalFluid2DComponent::CollisionQueryMaterial' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, PPCollisionQueryMaterial) == 0x000100, "Member 'UBGULocalFluid2DComponent::PPCollisionQueryMaterial' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, CompositeMaterial) == 0x000108, "Member 'UBGULocalFluid2DComponent::CompositeMaterial' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, AdvectMaterial) == 0x000110, "Member 'UBGULocalFluid2DComponent::AdvectMaterial' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DivergenceMaterial) == 0x000118, "Member 'UBGULocalFluid2DComponent::DivergenceMaterial' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, PressureStep1Material) == 0x000120, "Member 'UBGULocalFluid2DComponent::PressureStep1Material' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, PressureStep2Material) == 0x000128, "Member 'UBGULocalFluid2DComponent::PressureStep2Material' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, BrushPuncture) == 0x000130, "Member 'UBGULocalFluid2DComponent::BrushPuncture' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloDirNoise) == 0x000134, "Member 'UBGULocalFluid2DComponent::VeloDirNoise' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, Speed) == 0x000138, "Member 'UBGULocalFluid2DComponent::Speed' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloFromSimAreaMotion) == 0x00013C, "Member 'UBGULocalFluid2DComponent::VeloFromSimAreaMotion' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, SimEdgeBouncyness) == 0x000140, "Member 'UBGULocalFluid2DComponent::SimEdgeBouncyness' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, FadeDensityAtSimEdge) == 0x000144, "Member 'UBGULocalFluid2DComponent::FadeDensityAtSimEdge' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloDirNoiseSize) == 0x000148, "Member 'UBGULocalFluid2DComponent::VeloDirNoiseSize' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloDirNoiseSpeed) == 0x00014C, "Member 'UBGULocalFluid2DComponent::VeloDirNoiseSpeed' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloOffsetX) == 0x000150, "Member 'UBGULocalFluid2DComponent::VeloOffsetX' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloOffsetY) == 0x000154, "Member 'UBGULocalFluid2DComponent::VeloOffsetY' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloFromBrushMotion) == 0x000158, "Member 'UBGULocalFluid2DComponent::VeloFromBrushMotion' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloStrength) == 0x00015C, "Member 'UBGULocalFluid2DComponent::VeloStrength' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloRotate) == 0x000160, "Member 'UBGULocalFluid2DComponent::VeloRotate' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloAmpNoise) == 0x000164, "Member 'UBGULocalFluid2DComponent::VeloAmpNoise' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, InputFeedback) == 0x000168, "Member 'UBGULocalFluid2DComponent::InputFeedback' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, FlowFeedback) == 0x00016C, "Member 'UBGULocalFluid2DComponent::FlowFeedback' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, Divergence) == 0x000170, "Member 'UBGULocalFluid2DComponent::Divergence' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, BrushSize) == 0x000174, "Member 'UBGULocalFluid2DComponent::BrushSize' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, BrushStrength) == 0x000178, "Member 'UBGULocalFluid2DComponent::BrushStrength' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, EraserMode) == 0x00017C, "Member 'UBGULocalFluid2DComponent::EraserMode' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, BrushHardness) == 0x000180, "Member 'UBGULocalFluid2DComponent::BrushHardness' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DensityTemplate) == 0x000188, "Member 'UBGULocalFluid2DComponent::DensityTemplate' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VelocityTemplate) == 0x000190, "Member 'UBGULocalFluid2DComponent::VelocityTemplate' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VelocityOffsetSpeed) == 0x000198, "Member 'UBGULocalFluid2DComponent::VelocityOffsetSpeed' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, EdgeMaskWidth) == 0x00019C, "Member 'UBGULocalFluid2DComponent::EdgeMaskWidth' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DensityTxtMult) == 0x0001A0, "Member 'UBGULocalFluid2DComponent::DensityTxtMult' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DensityTxtScale) == 0x0001A4, "Member 'UBGULocalFluid2DComponent::DensityTxtScale' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DensityTxtOffsetX) == 0x0001A8, "Member 'UBGULocalFluid2DComponent::DensityTxtOffsetX' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DensityTxtOffsetY) == 0x0001AC, "Member 'UBGULocalFluid2DComponent::DensityTxtOffsetY' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, BrushNoise) == 0x0001B0, "Member 'UBGULocalFluid2DComponent::BrushNoise' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, VeloInputTile) == 0x0001B4, "Member 'UBGULocalFluid2DComponent::VeloInputTile' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DensityInputNoiseAmp) == 0x0001B8, "Member 'UBGULocalFluid2DComponent::DensityInputNoiseAmp' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DensityInputNoiseOffset) == 0x0001BC, "Member 'UBGULocalFluid2DComponent::DensityInputNoiseOffset' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DensityInputNoiseTile) == 0x0001C0, "Member 'UBGULocalFluid2DComponent::DensityInputNoiseTile' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, BrushRnd) == 0x0001C4, "Member 'UBGULocalFluid2DComponent::BrushRnd' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, WorldOffsetX) == 0x0001C8, "Member 'UBGULocalFluid2DComponent::WorldOffsetX' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, WorldOffsetY) == 0x0001CC, "Member 'UBGULocalFluid2DComponent::WorldOffsetY' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, RT_CollisionResult) == 0x000258, "Member 'UBGULocalFluid2DComponent::RT_CollisionResult' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, RT_PPCollisionResult) == 0x000260, "Member 'UBGULocalFluid2DComponent::RT_PPCollisionResult' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, RT_Advection) == 0x000268, "Member 'UBGULocalFluid2DComponent::RT_Advection' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, RT_PressureDivergence) == 0x000270, "Member 'UBGULocalFluid2DComponent::RT_PressureDivergence' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, RT_Composite) == 0x000278, "Member 'UBGULocalFluid2DComponent::RT_Composite' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, RT_PressureDivergenceTemp) == 0x000280, "Member 'UBGULocalFluid2DComponent::RT_PressureDivergenceTemp' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, CollisionQueryMaterialInstance) == 0x000288, "Member 'UBGULocalFluid2DComponent::CollisionQueryMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, PPCollisionQueryMaterialInstance) == 0x000290, "Member 'UBGULocalFluid2DComponent::PPCollisionQueryMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, CompositeMaterialInstance) == 0x000298, "Member 'UBGULocalFluid2DComponent::CompositeMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, AdvectMaterialInstance) == 0x0002A0, "Member 'UBGULocalFluid2DComponent::AdvectMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, DivergenceMaterialInstance) == 0x0002A8, "Member 'UBGULocalFluid2DComponent::DivergenceMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, PressureStep1MaterialInstance) == 0x0002B0, "Member 'UBGULocalFluid2DComponent::PressureStep1MaterialInstance' has a wrong offset!");
static_assert(offsetof(UBGULocalFluid2DComponent, PressureStep2MaterialInstance) == 0x0002B8, "Member 'UBGULocalFluid2DComponent::PressureStep2MaterialInstance' has a wrong offset!");

// Class b1.BGUPerformerActor
// 0x0020 (0x02D8 - 0x02B8)
class ABGUPerformerActor : public ABGUActorBase
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOptimizeEnabled(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUPerformerActor">();
	}
	static class ABGUPerformerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUPerformerActor>();
	}
};
static_assert(alignof(ABGUPerformerActor) == 0x000008, "Wrong alignment on ABGUPerformerActor");
static_assert(sizeof(ABGUPerformerActor) == 0x0002D8, "Wrong size on ABGUPerformerActor");
static_assert(offsetof(ABGUPerformerActor, Mesh) == 0x0002C0, "Member 'ABGUPerformerActor::Mesh' has a wrong offset!");
static_assert(offsetof(ABGUPerformerActor, CapsuleComponent) == 0x0002C8, "Member 'ABGUPerformerActor::CapsuleComponent' has a wrong offset!");

// Class b1.BGUPlacedEditorUtilityBase
// 0x0010 (0x0288 - 0x0278)
class ABGUPlacedEditorUtilityBase : public AActor
{
public:
	class FString                                 HelpText;                                          // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearActorSelectionSet();
	class AActor* GetActorReference(const class FString& PathToActor);
	bool GetLevelViewportCameraInfo(struct FVector* CameraLocation, struct FRotator* CameraRotation);
	TArray<class AActor*> GetSelectionSet();
	void OnWorldCleanup(class UWorld* World, bool SessionEnded, bool CleanupResources);
	void SelectNothing();
	void SetActorSelectionState(class AActor* Actor, bool bShouldBeSelected);
	void SetLevelViewportCameraInfo(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUPlacedEditorUtilityBase">();
	}
	static class ABGUPlacedEditorUtilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUPlacedEditorUtilityBase>();
	}
};
static_assert(alignof(ABGUPlacedEditorUtilityBase) == 0x000008, "Wrong alignment on ABGUPlacedEditorUtilityBase");
static_assert(sizeof(ABGUPlacedEditorUtilityBase) == 0x000288, "Wrong size on ABGUPlacedEditorUtilityBase");
static_assert(offsetof(ABGUPlacedEditorUtilityBase, HelpText) == 0x000278, "Member 'ABGUPlacedEditorUtilityBase::HelpText' has a wrong offset!");

// Class b1.BGUPlayerStart
// 0x0000 (0x02A8 - 0x02A8)
class ABGUPlayerStart final : public APlayerStart
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUPlayerStart">();
	}
	static class ABGUPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUPlayerStart>();
	}
};
static_assert(alignof(ABGUPlayerStart) == 0x000008, "Wrong alignment on ABGUPlayerStart");
static_assert(sizeof(ABGUPlayerStart) == 0x0002A8, "Wrong size on ABGUPlayerStart");

// Class b1.BGUPlayMontageCallbackProxy
// 0x0090 (0x00B8 - 0x0028)
class UBGUPlayMontageCallbackProxy final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyBegin;                                     // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyEnd;                                       // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x38];                                      // 0x0080(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBGUPlayMontageCallbackProxy* CreateProxyObjectForPlayMontage(int32 ReqIdx, class UAnimMontage* MontageToPlay);

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	bool PlayMontage(class USkeletalMeshComponent* InSkeletalMeshComponent, class UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, bool bSnapShot, const class FName StartingSection, const class FName ExceptAdditiveSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUPlayMontageCallbackProxy">();
	}
	static class UBGUPlayMontageCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUPlayMontageCallbackProxy>();
	}
};
static_assert(alignof(UBGUPlayMontageCallbackProxy) == 0x000008, "Wrong alignment on UBGUPlayMontageCallbackProxy");
static_assert(sizeof(UBGUPlayMontageCallbackProxy) == 0x0000B8, "Wrong size on UBGUPlayMontageCallbackProxy");
static_assert(offsetof(UBGUPlayMontageCallbackProxy, OnCompleted) == 0x000030, "Member 'UBGUPlayMontageCallbackProxy::OnCompleted' has a wrong offset!");
static_assert(offsetof(UBGUPlayMontageCallbackProxy, OnBlendOut) == 0x000040, "Member 'UBGUPlayMontageCallbackProxy::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UBGUPlayMontageCallbackProxy, OnInterrupted) == 0x000050, "Member 'UBGUPlayMontageCallbackProxy::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UBGUPlayMontageCallbackProxy, OnNotifyBegin) == 0x000060, "Member 'UBGUPlayMontageCallbackProxy::OnNotifyBegin' has a wrong offset!");
static_assert(offsetof(UBGUPlayMontageCallbackProxy, OnNotifyEnd) == 0x000070, "Member 'UBGUPlayMontageCallbackProxy::OnNotifyEnd' has a wrong offset!");

// Class b1.BGUProjectileMovementComponent
// 0x0020 (0x0270 - 0x0250)
class UBGUProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	bool                                          bForceEnableSimulateWithoutBounce;                 // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeMoveDeltaOnClient;                         // 0x0249(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A[0x6];                                      // 0x024A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RepLocation;                                       // 0x0250(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUProjectileMovementComponent">();
	}
	static class UBGUProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUProjectileMovementComponent>();
	}
};
static_assert(alignof(UBGUProjectileMovementComponent) == 0x000010, "Wrong alignment on UBGUProjectileMovementComponent");
static_assert(sizeof(UBGUProjectileMovementComponent) == 0x000270, "Wrong size on UBGUProjectileMovementComponent");
static_assert(offsetof(UBGUProjectileMovementComponent, bForceEnableSimulateWithoutBounce) == 0x000248, "Member 'UBGUProjectileMovementComponent::bForceEnableSimulateWithoutBounce' has a wrong offset!");
static_assert(offsetof(UBGUProjectileMovementComponent, bComputeMoveDeltaOnClient) == 0x000249, "Member 'UBGUProjectileMovementComponent::bComputeMoveDeltaOnClient' has a wrong offset!");
static_assert(offsetof(UBGUProjectileMovementComponent, RepLocation) == 0x000250, "Member 'UBGUProjectileMovementComponent::RepLocation' has a wrong offset!");

// Class b1.BGURootMotionFollowMovementComponent
// 0x0000 (0x15A0 - 0x15A0)
class UBGURootMotionFollowMovementComponent final : public UBGUCharacterMovementComponent
{
public:
	class UBGUCharacterMovementComponent* GetMasterMoveComp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGURootMotionFollowMovementComponent">();
	}
	static class UBGURootMotionFollowMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGURootMotionFollowMovementComponent>();
	}
};
static_assert(alignof(UBGURootMotionFollowMovementComponent) == 0x000010, "Wrong alignment on UBGURootMotionFollowMovementComponent");
static_assert(sizeof(UBGURootMotionFollowMovementComponent) == 0x0015A0, "Wrong size on UBGURootMotionFollowMovementComponent");

// Class b1.BGURootMotionSourceObject_Base
// 0x0018 (0x0040 - 0x0028)
class UBGURootMotionSourceObject_Base : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            CharacterMovement;                                 // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class UCharacterMovementComponent* MoveComp, const class FName& InInstanceName);
	void RemoveRootMotionSource();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGURootMotionSourceObject_Base">();
	}
	static class UBGURootMotionSourceObject_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGURootMotionSourceObject_Base>();
	}
};
static_assert(alignof(UBGURootMotionSourceObject_Base) == 0x000008, "Wrong alignment on UBGURootMotionSourceObject_Base");
static_assert(sizeof(UBGURootMotionSourceObject_Base) == 0x000040, "Wrong size on UBGURootMotionSourceObject_Base");
static_assert(offsetof(UBGURootMotionSourceObject_Base, CharacterMovement) == 0x000030, "Member 'UBGURootMotionSourceObject_Base::CharacterMovement' has a wrong offset!");

// Class b1.BGURootMotionSourceObject_ConstantForce
// 0x0000 (0x0040 - 0x0040)
class UBGURootMotionSourceObject_ConstantForce final : public UBGURootMotionSourceObject_Base
{
public:
	bool ApplyRootMotionSource(const struct FVector& WorldDirection, float Strength, float Duration, bool bIsAdditive, class UCurveFloat* StrengthOverTime, ERootMotionFinishVelocityMode FinishVelocityMode, const struct FVector& FinishSetVelocity, float FinishClampVelocity, bool bEnableGravity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGURootMotionSourceObject_ConstantForce">();
	}
	static class UBGURootMotionSourceObject_ConstantForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGURootMotionSourceObject_ConstantForce>();
	}
};
static_assert(alignof(UBGURootMotionSourceObject_ConstantForce) == 0x000008, "Wrong alignment on UBGURootMotionSourceObject_ConstantForce");
static_assert(sizeof(UBGURootMotionSourceObject_ConstantForce) == 0x000040, "Wrong size on UBGURootMotionSourceObject_ConstantForce");

// Class b1.BGUSelectUtil
// 0x0000 (0x0028 - 0x0028)
class UBGUSelectUtil final : public UBlueprintFunctionLibrary
{
public:
	static int32 BoxOverlapBGUCharacters(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, TArray<class ABGUCharacter*>* OutArray, ECollisionChannel QueryChannel);
	static int32 BoxOverlapV2BGUCharacters(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FQuat& Rot, const struct FVector& BoxExtent, TArray<class ABGUCharacter*>* OutArray);
	static bool GetHitUnderCursor(class APlayerController* PlayerCtrl, ETraceTypeQuery QueryChnl, bool bTraceComplex, struct FHitResultSimple* HitResult);
	static int32 LineTraceForObjects(class UObject* WorldContextObject, const struct FVector& StartTrace, const struct FVector& EndTrace, const TArray<EObjectTypeQuery>& ObjectTypes, bool bDebug, struct FHitResultSimple* HitResult);
	static int32 LineTraceForObjectsTypeSimple(class UObject* WorldContextObject, const struct FVector& StartTrace, const struct FVector& EndTrace, const TArray<EObjectTypeQuery>& ObjectTypes, bool bDebug, struct FHitResultSimple* HitResult, bool bTraceComplex);
	static int32 LineTraceMultiByObjType(class UObject* WorldContextObject, const struct FVector& StartTrace, const struct FVector& EndTrace, const TArray<EObjectTypeQuery>& ObjectTypes, bool bDebug, TArray<struct FHitResultSimple>* HitResultList);
	static int32 LineTraceOnlyCheck(class UObject* WorldContextObject, const struct FVector& StartTrace, const struct FVector& EndTrace, ETraceTypeQuery QueryChnl, bool bDebug, struct FHitResultSimple* HitResult, const TArray<class AActor*>& Ingnores, bool bTraceComplex);
	static int32 LineTraceSimple(class UObject* WorldContextObject, const struct FVector& StartTrace, const struct FVector& EndTrace, ETraceTypeQuery QueryChnl, bool bDebug, struct FHitResultSimple* HitResult, const TArray<class AActor*>& Ingnores, bool bTraceComplex);
	static bool LineTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static int32 MultiSphereTraceForObjects(class UObject* WorldContextObject, const struct FVector& StartTrace, const struct FVector& EndTrace, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bDebug, TArray<struct FHitResultSimple>* HitResultList);
	static int32 SelectBGUCharactersInCircle(class UObject* WorldContextObject, TArray<class AActor*>* OutActors, class AActor* TargetBase, int32 TargetCount, int32 TargetFilter, const TArray<int32>& Params_0);
	static int32 SelectBGUCharactersInCylinder(class UObject* WorldContextObject, TArray<class AActor*>* OutActors, class AActor* TargetBase, int32 TargetCount, int32 TargetFilter, const TArray<int32>& Params_0);
	static int32 SelectBGUCharactersInRect(class UObject* WorldContextObject, TArray<class AActor*>* OutActors, class AActor* TargetBase, int32 TargetCount, int32 TargetFilter, const TArray<int32>& Params_0);
	static int32 SphereOverlapBGUCharacters(class UObject* WorldContext, const struct FVector& SphereCenter, float Radius, TArray<class ABGUCharacter*>* OutArray, ECollisionChannel QueryChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUSelectUtil">();
	}
	static class UBGUSelectUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUSelectUtil>();
	}
};
static_assert(alignof(UBGUSelectUtil) == 0x000008, "Wrong alignment on UBGUSelectUtil");
static_assert(sizeof(UBGUSelectUtil) == 0x000028, "Wrong size on UBGUSelectUtil");

// Class b1.BGUSpiderCharacter
// 0x0000 (0x0600 - 0x0600)
class ABGUSpiderCharacter final : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUSpiderCharacter">();
	}
	static class ABGUSpiderCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUSpiderCharacter>();
	}
};
static_assert(alignof(ABGUSpiderCharacter) == 0x000010, "Wrong alignment on ABGUSpiderCharacter");
static_assert(sizeof(ABGUSpiderCharacter) == 0x000600, "Wrong size on ABGUSpiderCharacter");

// Class b1.BGUSpiderMovementComponent
// 0x01D0 (0x1770 - 0x15A0)
class UBGUSpiderMovementComponent final : public UBGUCharacterMovementComponent
{
public:
	uint8                                         Pad_15A0[0x1C8];                                   // 0x15A0(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsOnPlatform;                                     // 0x1768(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1769[0x7];                                     // 0x1769(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUSpiderMovementComponent">();
	}
	static class UBGUSpiderMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUSpiderMovementComponent>();
	}
};
static_assert(alignof(UBGUSpiderMovementComponent) == 0x000010, "Wrong alignment on UBGUSpiderMovementComponent");
static_assert(sizeof(UBGUSpiderMovementComponent) == 0x001770, "Wrong size on UBGUSpiderMovementComponent");
static_assert(offsetof(UBGUSpiderMovementComponent, bIsOnPlatform) == 0x001768, "Member 'UBGUSpiderMovementComponent::bIsOnPlatform' has a wrong offset!");

// Class b1.BGUSpringArmSettings
// 0x0060 (0x0098 - 0x0038)
class UBGUSpringArmSettings final : public UDeveloperSettings
{
public:
	TMap<EPhysicalSurface, float>                 SurfaceHeightMap;                                  // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         SurfaceMaxHeight;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeightAboveCharacter;                           // 0x008C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MixArmLengthTolerance;                             // 0x0090(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugSphere;                                  // 0x0094(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUSpringArmSettings">();
	}
	static class UBGUSpringArmSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUSpringArmSettings>();
	}
};
static_assert(alignof(UBGUSpringArmSettings) == 0x000008, "Wrong alignment on UBGUSpringArmSettings");
static_assert(sizeof(UBGUSpringArmSettings) == 0x000098, "Wrong size on UBGUSpringArmSettings");
static_assert(offsetof(UBGUSpringArmSettings, SurfaceHeightMap) == 0x000038, "Member 'UBGUSpringArmSettings::SurfaceHeightMap' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmSettings, SurfaceMaxHeight) == 0x000088, "Member 'UBGUSpringArmSettings::SurfaceMaxHeight' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmSettings, MaxHeightAboveCharacter) == 0x00008C, "Member 'UBGUSpringArmSettings::MaxHeightAboveCharacter' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmSettings, MixArmLengthTolerance) == 0x000090, "Member 'UBGUSpringArmSettings::MixArmLengthTolerance' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmSettings, bDrawDebugSphere) == 0x000094, "Member 'UBGUSpringArmSettings::bDrawDebugSphere' has a wrong offset!");

// Class b1.BGUSpringArmComponent
// 0x0070 (0x0420 - 0x03B0)
class UBGUSpringArmComponent : public USpringArmComponent
{
public:
	bool                                          bEnableHideMeshTrace;                              // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringBackSpeed;                                   // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLagMaxDistance3Axis;                         // 0x03B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLagSpeed3Axis;                               // 0x03D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLagInverseSpeed3Axis;                        // 0x03E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagUseMaxOffset;                             // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x1C];                                     // 0x0404(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector BlendLocationsInCS(const struct FVector& OriginArmLocation, const struct FVector& DesiredArmLocation, const struct FHitResult& HitResult, float DeltaTime);
	struct FVector CalcSmoothLocation(const struct FVector& Current, const struct FVector& Target, float DeltaTime, const struct FVector& SmoothSpeed);
	void GetPreviousValues(struct FVector* OutPreviousDesiredLoc, struct FVector* OutPreviousArmOrigin, struct FRotator* OutPreviousDesiredRot);
	void ResetArmLengthLerpCache();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUSpringArmComponent">();
	}
	static class UBGUSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUSpringArmComponent>();
	}
};
static_assert(alignof(UBGUSpringArmComponent) == 0x000010, "Wrong alignment on UBGUSpringArmComponent");
static_assert(sizeof(UBGUSpringArmComponent) == 0x000420, "Wrong size on UBGUSpringArmComponent");
static_assert(offsetof(UBGUSpringArmComponent, bEnableHideMeshTrace) == 0x0003B0, "Member 'UBGUSpringArmComponent::bEnableHideMeshTrace' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmComponent, SpringBackSpeed) == 0x0003B4, "Member 'UBGUSpringArmComponent::SpringBackSpeed' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmComponent, CameraLagMaxDistance3Axis) == 0x0003B8, "Member 'UBGUSpringArmComponent::CameraLagMaxDistance3Axis' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmComponent, CameraLagSpeed3Axis) == 0x0003D0, "Member 'UBGUSpringArmComponent::CameraLagSpeed3Axis' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmComponent, CameraLagInverseSpeed3Axis) == 0x0003E8, "Member 'UBGUSpringArmComponent::CameraLagInverseSpeed3Axis' has a wrong offset!");
static_assert(offsetof(UBGUSpringArmComponent, CameraLagUseMaxOffset) == 0x000400, "Member 'UBGUSpringArmComponent::CameraLagUseMaxOffset' has a wrong offset!");

// Class b1.BGUTamerBase
// 0x00A0 (0x0318 - 0x0278)
class ABGUTamerBase : public AActor
{
public:
	bool                                          bBeginPlayFromLevelStreaming;                      // 0x0278(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           SpawnedPlayerState;                                // 0x0280(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpawnedTamerGuid;                                  // 0x0288(0x0010)(BlueprintVisible, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETamerType                                    TamerType;                                         // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableShowLODMesh;                                // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODMaxDistance;                                    // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LowLODMesh;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class USkeletalMeshComponent*>           HighLODMeshComponents;                             // 0x02C0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyWorldOffsetCS(const struct FVector& InOffset, bool bWorldShift);
	void BeginPlayCS();
	void ForceRefreshDetailView();
	bool GetHighLODMeshConfig(struct FTamerHighLODRootMeshConfig* OutMeshConfig);
	void OnConstructionCS(const struct FTransform& Transform);
	void OnPostEditMove(bool bFisnish);
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);
	void PostInitializeComponentsCS();
	void SetLODMeshVisible(bool Invisible);

	bool GetActorGuid(class FString* OutActorGuid) const;
	bool GetActorGuidCS(class FString* OutActorGuid) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUTamerBase">();
	}
	static class ABGUTamerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUTamerBase>();
	}
};
static_assert(alignof(ABGUTamerBase) == 0x000008, "Wrong alignment on ABGUTamerBase");
static_assert(sizeof(ABGUTamerBase) == 0x000318, "Wrong size on ABGUTamerBase");
static_assert(offsetof(ABGUTamerBase, bBeginPlayFromLevelStreaming) == 0x000278, "Member 'ABGUTamerBase::bBeginPlayFromLevelStreaming' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, SpawnedPlayerState) == 0x000280, "Member 'ABGUTamerBase::SpawnedPlayerState' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, SpawnedTamerGuid) == 0x000288, "Member 'ABGUTamerBase::SpawnedTamerGuid' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, TamerType) == 0x000298, "Member 'ABGUTamerBase::TamerType' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, bEnableShowLODMesh) == 0x00029C, "Member 'ABGUTamerBase::bEnableShowLODMesh' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, LODMaxDistance) == 0x0002A0, "Member 'ABGUTamerBase::LODMaxDistance' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, Mesh) == 0x0002A8, "Member 'ABGUTamerBase::Mesh' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, CapsuleComponent) == 0x0002B0, "Member 'ABGUTamerBase::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, LowLODMesh) == 0x0002B8, "Member 'ABGUTamerBase::LowLODMesh' has a wrong offset!");
static_assert(offsetof(ABGUTamerBase, HighLODMeshComponents) == 0x0002C0, "Member 'ABGUTamerBase::HighLODMeshComponents' has a wrong offset!");

// Class b1.BGUTeleportPoint
// 0x0010 (0x0288 - 0x0278)
class ABGUTeleportPoint : public AActor
{
public:
	class FString                                 GSActorLabel;                                      // 0x0278(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FString GetGSActorLablel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUTeleportPoint">();
	}
	static class ABGUTeleportPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGUTeleportPoint>();
	}
};
static_assert(alignof(ABGUTeleportPoint) == 0x000008, "Wrong alignment on ABGUTeleportPoint");
static_assert(sizeof(ABGUTeleportPoint) == 0x000288, "Wrong size on ABGUTeleportPoint");
static_assert(offsetof(ABGUTeleportPoint, GSActorLabel) == 0x000278, "Member 'ABGUTeleportPoint::GSActorLabel' has a wrong offset!");

// Class b1.BGWActorVisibilityVolume
// 0x0018 (0x02C8 - 0x02B0)
class ABGWActorVisibilityVolume final : public AVolume
{
public:
	TArray<class AActor*>                         AttachedActors;                                    // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsHide;                                            // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWActorVisibilityVolume">();
	}
	static class ABGWActorVisibilityVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWActorVisibilityVolume>();
	}
};
static_assert(alignof(ABGWActorVisibilityVolume) == 0x000008, "Wrong alignment on ABGWActorVisibilityVolume");
static_assert(sizeof(ABGWActorVisibilityVolume) == 0x0002C8, "Wrong size on ABGWActorVisibilityVolume");
static_assert(offsetof(ABGWActorVisibilityVolume, AttachedActors) == 0x0002B0, "Member 'ABGWActorVisibilityVolume::AttachedActors' has a wrong offset!");
static_assert(offsetof(ABGWActorVisibilityVolume, IsHide) == 0x0002C0, "Member 'ABGWActorVisibilityVolume::IsHide' has a wrong offset!");
static_assert(offsetof(ABGWActorVisibilityVolume, bDisabled) == 0x0002C1, "Member 'ABGWActorVisibilityVolume::bDisabled' has a wrong offset!");

// Class b1.BGWActorVisibilityVolumeManager
// 0x0028 (0x0050 - 0x0028)
class UBGWActorVisibilityVolumeManager final : public UObject
{
public:
	TArray<class ABGWActorVisibilityVolume*>      ActorShownVolumes;                                 // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABGWActorVisibilityVolume*>      ActorHiddenVolumes;                                // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWActorVisibilityVolumeManager">();
	}
	static class UBGWActorVisibilityVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWActorVisibilityVolumeManager>();
	}
};
static_assert(alignof(UBGWActorVisibilityVolumeManager) == 0x000008, "Wrong alignment on UBGWActorVisibilityVolumeManager");
static_assert(sizeof(UBGWActorVisibilityVolumeManager) == 0x000050, "Wrong size on UBGWActorVisibilityVolumeManager");
static_assert(offsetof(UBGWActorVisibilityVolumeManager, ActorShownVolumes) == 0x000028, "Member 'UBGWActorVisibilityVolumeManager::ActorShownVolumes' has a wrong offset!");
static_assert(offsetof(UBGWActorVisibilityVolumeManager, ActorHiddenVolumes) == 0x000038, "Member 'UBGWActorVisibilityVolumeManager::ActorHiddenVolumes' has a wrong offset!");

// Class b1.BGWAssetLoader
// 0x0000 (0x0028 - 0x0028)
class UBGWAssetLoader final : public UBlueprintFunctionLibrary
{
public:
	static void AsyncLoadClass(const struct FSoftClassPath& LoadPath, class UBGWAssetLoaderRequest* Request, int32 Priority);
	static void AsyncLoadObject(const struct FSoftObjectPath& LoadPath, class UBGWAssetLoaderRequest* Request, int32 Priority);
	static void AsyncLoadObjects(const TArray<struct FSoftObjectPath>& LoadList, class UBGWAssetLoaderRequest* Request, int32 Priority);
	static class UObject* SyncLoadObject(const struct FSoftObjectPath& Path);
	static int32 SyncLoadObjects(const TArray<struct FSoftObjectPath>& LoadList, TArray<class UObject*>* OutObjList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWAssetLoader">();
	}
	static class UBGWAssetLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWAssetLoader>();
	}
};
static_assert(alignof(UBGWAssetLoader) == 0x000008, "Wrong alignment on UBGWAssetLoader");
static_assert(sizeof(UBGWAssetLoader) == 0x000028, "Wrong size on UBGWAssetLoader");

// Class b1.BGWAssetLoaderRequest
// 0x0010 (0x0038 - 0x0028)
class UBGWAssetLoaderRequest : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Cancel();
	bool WaitUntilComplete(float Timeout, bool bStartStalledHandles);

	void ExecuteCS() const;
	class FString GetDebugName() const;
	void GetLoadedAssets(TArray<class UObject*>* LoadedAssets) const;
	void GetLoadedCount(int32* LoadedCount, int32* RequestedCount) const;
	int32 GetPriority() const;
	float GetProgress() const;
	void GetRequestedAssets(TArray<struct FSoftObjectPath>* AssetList) const;
	bool HasLoadCompleted() const;
	bool HasLoadCompletedOrStalled() const;
	bool IsActive() const;
	bool IsCombinedHandle() const;
	bool IsLoadingInProgress() const;
	bool IsStalled() const;
	bool WasCanceled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWAssetLoaderRequest">();
	}
	static class UBGWAssetLoaderRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWAssetLoaderRequest>();
	}
};
static_assert(alignof(UBGWAssetLoaderRequest) == 0x000008, "Wrong alignment on UBGWAssetLoaderRequest");
static_assert(sizeof(UBGWAssetLoaderRequest) == 0x000038, "Wrong size on UBGWAssetLoaderRequest");

// Class b1.BGWCalliopeActor
// 0x0048 (0x02C0 - 0x0278)
class ABGWCalliopeActor final : public AActor
{
public:
	TSoftObjectPtr<class UCalliopeAsset>          Asset;                                             // 0x0278(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        PreloadedAssets;                                   // 0x02A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWCalliopeActor">();
	}
	static class ABGWCalliopeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWCalliopeActor>();
	}
};
static_assert(alignof(ABGWCalliopeActor) == 0x000008, "Wrong alignment on ABGWCalliopeActor");
static_assert(sizeof(ABGWCalliopeActor) == 0x0002C0, "Wrong size on ABGWCalliopeActor");
static_assert(offsetof(ABGWCalliopeActor, Asset) == 0x000278, "Member 'ABGWCalliopeActor::Asset' has a wrong offset!");
static_assert(offsetof(ABGWCalliopeActor, PreloadedAssets) == 0x0002A0, "Member 'ABGWCalliopeActor::PreloadedAssets' has a wrong offset!");

// Class b1.BGWVolumeBase
// 0x0010 (0x02C0 - 0x02B0)
class ABGWVolumeBase : public AVolume
{
public:
	int32                                         Priority;                                          // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendLength;                                       // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWVolumeBase">();
	}
	static class ABGWVolumeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWVolumeBase>();
	}
};
static_assert(alignof(ABGWVolumeBase) == 0x000008, "Wrong alignment on ABGWVolumeBase");
static_assert(sizeof(ABGWVolumeBase) == 0x0002C0, "Wrong size on ABGWVolumeBase");
static_assert(offsetof(ABGWVolumeBase, Priority) == 0x0002B0, "Member 'ABGWVolumeBase::Priority' has a wrong offset!");
static_assert(offsetof(ABGWVolumeBase, BlendLength) == 0x0002B4, "Member 'ABGWVolumeBase::BlendLength' has a wrong offset!");
static_assert(offsetof(ABGWVolumeBase, BlendTime) == 0x0002B8, "Member 'ABGWVolumeBase::BlendTime' has a wrong offset!");

// Class b1.BGWCameraGroupVolume
// 0x0008 (0x02C8 - 0x02C0)
class ABGWCameraGroupVolume final : public ABGWVolumeBase
{
public:
	int32                                         CameraGroupId;                                     // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWCameraGroupVolume">();
	}
	static class ABGWCameraGroupVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWCameraGroupVolume>();
	}
};
static_assert(alignof(ABGWCameraGroupVolume) == 0x000008, "Wrong alignment on ABGWCameraGroupVolume");
static_assert(sizeof(ABGWCameraGroupVolume) == 0x0002C8, "Wrong size on ABGWCameraGroupVolume");
static_assert(offsetof(ABGWCameraGroupVolume, CameraGroupId) == 0x0002C0, "Member 'ABGWCameraGroupVolume::CameraGroupId' has a wrong offset!");

// Class b1.BGWVolumeManagerBase
// 0x0010 (0x0038 - 0x0028)
class UBGWVolumeManagerBase : public UObject
{
public:
	TArray<class ABGWVolumeBase*>                 RegisteredVolumes;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWVolumeManagerBase">();
	}
	static class UBGWVolumeManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWVolumeManagerBase>();
	}
};
static_assert(alignof(UBGWVolumeManagerBase) == 0x000008, "Wrong alignment on UBGWVolumeManagerBase");
static_assert(sizeof(UBGWVolumeManagerBase) == 0x000038, "Wrong size on UBGWVolumeManagerBase");
static_assert(offsetof(UBGWVolumeManagerBase, RegisteredVolumes) == 0x000028, "Member 'UBGWVolumeManagerBase::RegisteredVolumes' has a wrong offset!");

// Class b1.BGWCameraGroupVolumeManager
// 0x0040 (0x0078 - 0x0038)
class UBGWCameraGroupVolumeManager final : public UBGWVolumeManagerBase
{
public:
	FMulticastInlineDelegateProperty_             OnSwitchCameraGroupTo;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bEnableCameraGroupManager;                         // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TickIntervalMs;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastFrameTargetGroupId;                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PlayerController;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABGWCameraGroupVolume*                  TargetVolume;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetAlpha;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TickIntervalSeconds;                               // 0x006C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TickTime;                                          // 0x0070(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastFrameAlpha;                                    // 0x0074(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UBGWCameraGroupVolumeManager* Get(class UObject* WorldContext);

	void OnSwitchCameraGroupTo__DelegateSignature(int32 TargetCameraGroupId, float Alpha, float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWCameraGroupVolumeManager">();
	}
	static class UBGWCameraGroupVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWCameraGroupVolumeManager>();
	}
};
static_assert(alignof(UBGWCameraGroupVolumeManager) == 0x000008, "Wrong alignment on UBGWCameraGroupVolumeManager");
static_assert(sizeof(UBGWCameraGroupVolumeManager) == 0x000078, "Wrong size on UBGWCameraGroupVolumeManager");
static_assert(offsetof(UBGWCameraGroupVolumeManager, OnSwitchCameraGroupTo) == 0x000038, "Member 'UBGWCameraGroupVolumeManager::OnSwitchCameraGroupTo' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, bEnableCameraGroupManager) == 0x000048, "Member 'UBGWCameraGroupVolumeManager::bEnableCameraGroupManager' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, TickIntervalMs) == 0x00004C, "Member 'UBGWCameraGroupVolumeManager::TickIntervalMs' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, LastFrameTargetGroupId) == 0x000050, "Member 'UBGWCameraGroupVolumeManager::LastFrameTargetGroupId' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, PlayerController) == 0x000058, "Member 'UBGWCameraGroupVolumeManager::PlayerController' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, TargetVolume) == 0x000060, "Member 'UBGWCameraGroupVolumeManager::TargetVolume' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, TargetAlpha) == 0x000068, "Member 'UBGWCameraGroupVolumeManager::TargetAlpha' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, TickIntervalSeconds) == 0x00006C, "Member 'UBGWCameraGroupVolumeManager::TickIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, TickTime) == 0x000070, "Member 'UBGWCameraGroupVolumeManager::TickTime' has a wrong offset!");
static_assert(offsetof(UBGWCameraGroupVolumeManager, LastFrameAlpha) == 0x000074, "Member 'UBGWCameraGroupVolumeManager::LastFrameAlpha' has a wrong offset!");

// Class b1.BGWCellSpacePartitionSubSystem
// 0x0000 (0x0030 - 0x0030)
class UBGWCellSpacePartitionSubSystem final : public UWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWCellSpacePartitionSubSystem">();
	}
	static class UBGWCellSpacePartitionSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWCellSpacePartitionSubSystem>();
	}
};
static_assert(alignof(UBGWCellSpacePartitionSubSystem) == 0x000008, "Wrong alignment on UBGWCellSpacePartitionSubSystem");
static_assert(sizeof(UBGWCellSpacePartitionSubSystem) == 0x000030, "Wrong size on UBGWCellSpacePartitionSubSystem");

// Class b1.BGWCppExport
// 0x0000 (0x0028 - 0x0028)
class UBGWCppExport final : public UBlueprintFunctionLibrary
{
public:
	static TMap<class FString, struct FIntPtr> GetAllFuncAsMap();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWCppExport">();
	}
	static class UBGWCppExport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWCppExport>();
	}
};
static_assert(alignof(UBGWCppExport) == 0x000008, "Wrong alignment on UBGWCppExport");
static_assert(sizeof(UBGWCppExport) == 0x000028, "Wrong size on UBGWCppExport");

// Class b1.BGWDataAsset
// 0x0000 (0x0030 - 0x0030)
class UBGWDataAsset : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWDataAsset">();
	}
	static class UBGWDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWDataAsset>();
	}
};
static_assert(alignof(UBGWDataAsset) == 0x000008, "Wrong alignment on UBGWDataAsset");
static_assert(sizeof(UBGWDataAsset) == 0x000030, "Wrong size on UBGWDataAsset");

// Class b1.BGWPreloadDataAsset
// 0x0010 (0x0040 - 0x0030)
class UBGWPreloadDataAsset final : public UBGWDataAsset
{
public:
	TArray<TSoftObjectPtr<class UObject>>         PreloadAssets;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWPreloadDataAsset">();
	}
	static class UBGWPreloadDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWPreloadDataAsset>();
	}
};
static_assert(alignof(UBGWPreloadDataAsset) == 0x000008, "Wrong alignment on UBGWPreloadDataAsset");
static_assert(sizeof(UBGWPreloadDataAsset) == 0x000040, "Wrong size on UBGWPreloadDataAsset");
static_assert(offsetof(UBGWPreloadDataAsset, PreloadAssets) == 0x000030, "Member 'UBGWPreloadDataAsset::PreloadAssets' has a wrong offset!");

// Class b1.BGWSaveCheckDataAsset
// 0x0000 (0x0030 - 0x0030)
class UBGWSaveCheckDataAsset : public UBGWDataAsset
{
public:
	bool SaveCheckCS(class FString* OutTitle, class FString* OutMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWSaveCheckDataAsset">();
	}
	static class UBGWSaveCheckDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWSaveCheckDataAsset>();
	}
};
static_assert(alignof(UBGWSaveCheckDataAsset) == 0x000008, "Wrong alignment on UBGWSaveCheckDataAsset");
static_assert(sizeof(UBGWSaveCheckDataAsset) == 0x000030, "Wrong size on UBGWSaveCheckDataAsset");

// Class b1.BGWDeviceProfile
// 0x0000 (0x00C0 - 0x00C0)
class UBGWDeviceProfile final : public UDeviceProfile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWDeviceProfile">();
	}
	static class UBGWDeviceProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWDeviceProfile>();
	}
};
static_assert(alignof(UBGWDeviceProfile) == 0x000008, "Wrong alignment on UBGWDeviceProfile");
static_assert(sizeof(UBGWDeviceProfile) == 0x0000C0, "Wrong size on UBGWDeviceProfile");

// Class b1.BWC_DispLibEnvVolume
// 0x0028 (0x02D8 - 0x02B0)
class ABWC_DispLibEnvVolume final : public AVolume
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBWS_DispLibEnvWeatherSetting*>  Settings;                                          // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRadius;                                       // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnbound;                                          // 0x02D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D6[0x2];                                      // 0x02D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BWC_DispLibEnvVolume">();
	}
	static class ABWC_DispLibEnvVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABWC_DispLibEnvVolume>();
	}
};
static_assert(alignof(ABWC_DispLibEnvVolume) == 0x000008, "Wrong alignment on ABWC_DispLibEnvVolume");
static_assert(sizeof(ABWC_DispLibEnvVolume) == 0x0002D8, "Wrong size on ABWC_DispLibEnvVolume");
static_assert(offsetof(ABWC_DispLibEnvVolume, Settings) == 0x0002B8, "Member 'ABWC_DispLibEnvVolume::Settings' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibEnvVolume, Priority) == 0x0002C8, "Member 'ABWC_DispLibEnvVolume::Priority' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibEnvVolume, BlendRadius) == 0x0002CC, "Member 'ABWC_DispLibEnvVolume::BlendRadius' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibEnvVolume, BlendWeight) == 0x0002D0, "Member 'ABWC_DispLibEnvVolume::BlendWeight' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibEnvVolume, bEnabled) == 0x0002D4, "Member 'ABWC_DispLibEnvVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibEnvVolume, bUnbound) == 0x0002D5, "Member 'ABWC_DispLibEnvVolume::bUnbound' has a wrong offset!");

// Class b1.BWS_DispLibEnvSystemConf
// 0x0030 (0x0060 - 0x0030)
class UBWS_DispLibEnvSystemConf final : public UBGWDataAsset
{
public:
	float                                         DayLength;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NightLength;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SunnyTimeRange;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WeatherTimeRange;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeatherChangeDuration;                             // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BWS_DispLibEnvSystemConf">();
	}
	static class UBWS_DispLibEnvSystemConf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBWS_DispLibEnvSystemConf>();
	}
};
static_assert(alignof(UBWS_DispLibEnvSystemConf) == 0x000008, "Wrong alignment on UBWS_DispLibEnvSystemConf");
static_assert(sizeof(UBWS_DispLibEnvSystemConf) == 0x000060, "Wrong size on UBWS_DispLibEnvSystemConf");
static_assert(offsetof(UBWS_DispLibEnvSystemConf, DayLength) == 0x000030, "Member 'UBWS_DispLibEnvSystemConf::DayLength' has a wrong offset!");
static_assert(offsetof(UBWS_DispLibEnvSystemConf, NightLength) == 0x000034, "Member 'UBWS_DispLibEnvSystemConf::NightLength' has a wrong offset!");
static_assert(offsetof(UBWS_DispLibEnvSystemConf, SunnyTimeRange) == 0x000038, "Member 'UBWS_DispLibEnvSystemConf::SunnyTimeRange' has a wrong offset!");
static_assert(offsetof(UBWS_DispLibEnvSystemConf, WeatherTimeRange) == 0x000048, "Member 'UBWS_DispLibEnvSystemConf::WeatherTimeRange' has a wrong offset!");
static_assert(offsetof(UBWS_DispLibEnvSystemConf, WeatherChangeDuration) == 0x000058, "Member 'UBWS_DispLibEnvSystemConf::WeatherChangeDuration' has a wrong offset!");

// Class b1.BWS_DispLibEnvWeatherSetting
// 0x01E0 (0x0210 - 0x0030)
class UBWS_DispLibEnvWeatherSetting final : public UBGWDataAsset
{
public:
	struct FBWC_DispLibEnvSettings                Setting;                                           // 0x0030(0x01E0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BWS_DispLibEnvWeatherSetting">();
	}
	static class UBWS_DispLibEnvWeatherSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBWS_DispLibEnvWeatherSetting>();
	}
};
static_assert(alignof(UBWS_DispLibEnvWeatherSetting) == 0x000010, "Wrong alignment on UBWS_DispLibEnvWeatherSetting");
static_assert(sizeof(UBWS_DispLibEnvWeatherSetting) == 0x000210, "Wrong size on UBWS_DispLibEnvWeatherSetting");
static_assert(offsetof(UBWS_DispLibEnvWeatherSetting, Setting) == 0x000030, "Member 'UBWS_DispLibEnvWeatherSetting::Setting' has a wrong offset!");

// Class b1.BWC_DispLibLocalFogWrapper
// 0x0000 (0x0278 - 0x0278)
class ABWC_DispLibLocalFogWrapper final : public AActor
{
public:
	void SetLocalFogParameter(const struct FBWC_DispLibEnvSettings& InSettings, const struct FVector2D& WindDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BWC_DispLibLocalFogWrapper">();
	}
	static class ABWC_DispLibLocalFogWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABWC_DispLibLocalFogWrapper>();
	}
};
static_assert(alignof(ABWC_DispLibLocalFogWrapper) == 0x000008, "Wrong alignment on ABWC_DispLibLocalFogWrapper");
static_assert(sizeof(ABWC_DispLibLocalFogWrapper) == 0x000278, "Wrong size on ABWC_DispLibLocalFogWrapper");

// Class b1.BWC_DispLibDynamicEnvManager
// 0x0288 (0x0500 - 0x0278)
class ABWC_DispLibDynamicEnvManager final : public AActor
{
public:
	class UCurveFloat*                            MoonPositionCurve;                                 // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBWS_DispLibEnvSystemConf*              EnvSystemConf;                                     // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBGW_DispLibEnvWeather                        Weather;                                           // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeOfDay;                                         // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoTimeOfDay;                                     // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoRandormWeather;                                // 0x0291(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDayNightCircle;                             // 0x0292(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_293[0x5];                                      // 0x0293(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WindDir;                                           // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBWC_DispLibEnvSettings                FinalEnvSettings;                                  // 0x02B0(0x01E0)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        SceneRoot;                                         // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             SunLight;                                          // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             MoonLight;                                         // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkyLightComponent*                     SkyLight;                                          // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExponentialHeightFogComponent*         HeightFog;                                         // 0x04B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkyAtmosphereComponent*                SkyAtmosphere;                                     // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        SunRoot;                                           // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        MoonRoot;                                          // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        WeathFXRoot;                                       // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 WeatherFXActor;                                    // 0x04D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E0[0x20];                                     // 0x04E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsWeatherAvailable(EBGW_DispLibEnvWeather InWeather, const struct FVector& ViewLocation);
	void OnApplyEnvSettings(bool IsNight);
	void OnLerpEnvSettings(float Weight, float InTime, const struct FBWC_DispLibEnvSettings& Src);
	void OnTickEnvVolume(struct FBWC_DispLibEnvSettings* EnvSettings, const struct FVector& ViewLocation, float InTime);
	void OnWeatherChanged(const struct FVector& CameraLocation);
	void OverrideEnvSettings(const struct FBWC_DispLibEnvSettings& Src, struct FBWC_DispLibEnvSettings* Dest, float Weight);
	EBGW_DispLibEnvWeather RandomWeather(const struct FVector& ViewLocation);
	void SetEnvSettings(bool IsNight, const struct FVector& CameraLocation);
	void SetWeather(EBGW_DispLibEnvWeather InWeather);
	void SwithToNarrative(bool Enable, float ChangeDuration);
	void UpdateEnvSystemConfig(class UBWS_DispLibEnvSystemConf* SystemConf);
	void UpdateSunAndMoonAngle(const struct FBWC_DispLibEnvSettings& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BWC_DispLibDynamicEnvManager">();
	}
	static class ABWC_DispLibDynamicEnvManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABWC_DispLibDynamicEnvManager>();
	}
};
static_assert(alignof(ABWC_DispLibDynamicEnvManager) == 0x000010, "Wrong alignment on ABWC_DispLibDynamicEnvManager");
static_assert(sizeof(ABWC_DispLibDynamicEnvManager) == 0x000500, "Wrong size on ABWC_DispLibDynamicEnvManager");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, MoonPositionCurve) == 0x000278, "Member 'ABWC_DispLibDynamicEnvManager::MoonPositionCurve' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, EnvSystemConf) == 0x000280, "Member 'ABWC_DispLibDynamicEnvManager::EnvSystemConf' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, Weather) == 0x000288, "Member 'ABWC_DispLibDynamicEnvManager::Weather' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, TimeOfDay) == 0x00028C, "Member 'ABWC_DispLibDynamicEnvManager::TimeOfDay' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, AutoTimeOfDay) == 0x000290, "Member 'ABWC_DispLibDynamicEnvManager::AutoTimeOfDay' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, AutoRandormWeather) == 0x000291, "Member 'ABWC_DispLibDynamicEnvManager::AutoRandormWeather' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, bEnableDayNightCircle) == 0x000292, "Member 'ABWC_DispLibDynamicEnvManager::bEnableDayNightCircle' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, WindDir) == 0x000298, "Member 'ABWC_DispLibDynamicEnvManager::WindDir' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, FinalEnvSettings) == 0x0002B0, "Member 'ABWC_DispLibDynamicEnvManager::FinalEnvSettings' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, SceneRoot) == 0x000490, "Member 'ABWC_DispLibDynamicEnvManager::SceneRoot' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, SunLight) == 0x000498, "Member 'ABWC_DispLibDynamicEnvManager::SunLight' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, MoonLight) == 0x0004A0, "Member 'ABWC_DispLibDynamicEnvManager::MoonLight' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, SkyLight) == 0x0004A8, "Member 'ABWC_DispLibDynamicEnvManager::SkyLight' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, HeightFog) == 0x0004B0, "Member 'ABWC_DispLibDynamicEnvManager::HeightFog' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, SkyAtmosphere) == 0x0004B8, "Member 'ABWC_DispLibDynamicEnvManager::SkyAtmosphere' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, SunRoot) == 0x0004C0, "Member 'ABWC_DispLibDynamicEnvManager::SunRoot' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, MoonRoot) == 0x0004C8, "Member 'ABWC_DispLibDynamicEnvManager::MoonRoot' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, WeathFXRoot) == 0x0004D0, "Member 'ABWC_DispLibDynamicEnvManager::WeathFXRoot' has a wrong offset!");
static_assert(offsetof(ABWC_DispLibDynamicEnvManager, WeatherFXActor) == 0x0004D8, "Member 'ABWC_DispLibDynamicEnvManager::WeatherFXActor' has a wrong offset!");

// Class b1.BWC_DispLibEnvRuntimeSubsystem
// 0x0018 (0x0048 - 0x0030)
class UBWC_DispLibEnvRuntimeSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BWC_DispLibEnvRuntimeSubsystem">();
	}
	static class UBWC_DispLibEnvRuntimeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBWC_DispLibEnvRuntimeSubsystem>();
	}
};
static_assert(alignof(UBWC_DispLibEnvRuntimeSubsystem) == 0x000008, "Wrong alignment on UBWC_DispLibEnvRuntimeSubsystem");
static_assert(sizeof(UBWC_DispLibEnvRuntimeSubsystem) == 0x000048, "Wrong size on UBWC_DispLibEnvRuntimeSubsystem");

// Class b1.BGWEnvironmentSurfaceVolume
// 0x0008 (0x02B8 - 0x02B0)
class ABGWEnvironmentSurfaceVolume final : public AVolume
{
public:
	int32                                         EnvironmentSurfaceEffectID;                        // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWEnvironmentSurfaceVolume">();
	}
	static class ABGWEnvironmentSurfaceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWEnvironmentSurfaceVolume>();
	}
};
static_assert(alignof(ABGWEnvironmentSurfaceVolume) == 0x000008, "Wrong alignment on ABGWEnvironmentSurfaceVolume");
static_assert(sizeof(ABGWEnvironmentSurfaceVolume) == 0x0002B8, "Wrong size on ABGWEnvironmentSurfaceVolume");
static_assert(offsetof(ABGWEnvironmentSurfaceVolume, EnvironmentSurfaceEffectID) == 0x0002B0, "Member 'ABGWEnvironmentSurfaceVolume::EnvironmentSurfaceEffectID' has a wrong offset!");

// Class b1.BGW_EventCollection
// 0x0070 (0x0098 - 0x0028)
class b1::UBGW_EventCollection final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             TestWorldEvent;                                    // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBWE_OldMKBorn;                                    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBWE_TianBing04Dead;                               // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBWE_UnitBeAttack;                                 // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBWE_TianJiangQTEEnd;                              // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBWE_DemoTianJiangBorn;                            // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBWE_DemoEnterCloudPlatform;                       // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Class b1.BGW_EventCollection", true>();
	}
	static class b1::UBGW_EventCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<b1::UBGW_EventCollection>();
	}
};
static_assert(alignof(b1::UBGW_EventCollection) == 0x000008, "Wrong alignment on b1::UBGW_EventCollection");
static_assert(sizeof(b1::UBGW_EventCollection) == 0x000098, "Wrong size on b1::UBGW_EventCollection");
static_assert(offsetof(b1::UBGW_EventCollection, TestWorldEvent) == 0x000028, "Member 'b1::UBGW_EventCollection::TestWorldEvent' has a wrong offset!");
static_assert(offsetof(b1::UBGW_EventCollection, FBWE_OldMKBorn) == 0x000038, "Member 'b1::UBGW_EventCollection::FBWE_OldMKBorn' has a wrong offset!");
static_assert(offsetof(b1::UBGW_EventCollection, FBWE_TianBing04Dead) == 0x000048, "Member 'b1::UBGW_EventCollection::FBWE_TianBing04Dead' has a wrong offset!");
static_assert(offsetof(b1::UBGW_EventCollection, FBWE_UnitBeAttack) == 0x000058, "Member 'b1::UBGW_EventCollection::FBWE_UnitBeAttack' has a wrong offset!");
static_assert(offsetof(b1::UBGW_EventCollection, FBWE_TianJiangQTEEnd) == 0x000068, "Member 'b1::UBGW_EventCollection::FBWE_TianJiangQTEEnd' has a wrong offset!");
static_assert(offsetof(b1::UBGW_EventCollection, FBWE_DemoTianJiangBorn) == 0x000078, "Member 'b1::UBGW_EventCollection::FBWE_DemoTianJiangBorn' has a wrong offset!");
static_assert(offsetof(b1::UBGW_EventCollection, FBWE_DemoEnterCloudPlatform) == 0x000088, "Member 'b1::UBGW_EventCollection::FBWE_DemoEnterCloudPlatform' has a wrong offset!");

// Class b1.BGWFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBGWFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BGWAddLevelToBlackList(class UObject* WorldContextObject, const class FName& InLevelName);
	static void BGWAddLevelToWhiteList(class UObject* WorldContextObject, const class FName& InLevelName, const EBGWStreamingVolumeUsage& InUsage);
	static class UWorld* BGWFindWorldInPackage(class UPackage* Package);
	static TArray<class ULevelStreaming*> BGWGetAllStreamingLevels(class UObject* WorldContextObject);
	static TArray<class FString> BGWGetAlwaysCookPathList();
	static bool BGWGetIsCameraMoveableWhenPaused(const class UObject* WorldContextObject);
	static void BGWGetStatusChangedStreamingLevels(class UObject* WorldContextObject, TMap<class ULevelStreaming*, struct FGSStreamingLevelLoadSetting>* OutStreamingLevels);
	static void BGWProcessLevelStreamingVolumes(class UObject* WorldContextObject, const struct FVector& OverrideViewLocation, bool bUseOverrideViewLocation);
	static void BGWRemoveLevelFromBlackList(class UObject* WorldContextObject, const class FName& InLevelName);
	static void BGWRemoveLevelFromWhiteList(class UObject* WorldContextObject, const class FName& InLevelName);
	static void BGWRequestAsyncLoad(class UObject* WorldContextObject, const TArray<struct FSoftObjectPath>& LoadList, TDelegate<void()> CallBackDelegate);
	static void BGWSetAllLevelStreamingVolumeEnabled(class UObject* WorldContextObject, bool bEnabled);
	static void BGWSetGamePaused(const class UObject* WorldContextObject, bool bPaused);
	static void BGWSetIsCameraMoveableWhenPaused(const class UObject* WorldContextObject, bool IsCameraMoveable);
	static class b1::UBGW_EventCollection* GetBGWEvents(class UObject* WorldContextObject);
	static class FString GetLevelStreamingAssetName(class ULevelStreaming* LevelStreaming);
	static bool IsDistanceStreamingValid(class UObject* WorldContextObject);
	static void MaintainVolumesContainYuanjing(const TArray<class ABGWLevelStreamingVolume*>& InStreamingVolumes);
	static void PauseBGWVolumeLevelStreaming(class UObject* WorldContextObject);
	static void ResumeBGWVolumeLevelStreaming(class UObject* WorldContextObject);
	static void RetargetLevelStreamingLevelNames(class UObject* WorldContext, const class FString& SourceNames, const class FString& DestNames, const class FString& LevelPrefix);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWFunctionLibrary">();
	}
	static class UBGWFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWFunctionLibrary>();
	}
};
static_assert(alignof(UBGWFunctionLibrary) == 0x000008, "Wrong alignment on UBGWFunctionLibrary");
static_assert(sizeof(UBGWFunctionLibrary) == 0x000028, "Wrong size on UBGWFunctionLibrary");

// Class b1.BGW_GameInstanceTicker
// 0x0010 (0x0288 - 0x0278)
class ABGW_GameInstanceTicker final : public AActor
{
public:
	class UBGWGameInstance*                       Parent;                                            // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickGroup;                                         // 0x0280(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGW_GameInstanceTicker">();
	}
	static class ABGW_GameInstanceTicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGW_GameInstanceTicker>();
	}
};
static_assert(alignof(ABGW_GameInstanceTicker) == 0x000008, "Wrong alignment on ABGW_GameInstanceTicker");
static_assert(sizeof(ABGW_GameInstanceTicker) == 0x000288, "Wrong size on ABGW_GameInstanceTicker");
static_assert(offsetof(ABGW_GameInstanceTicker, Parent) == 0x000278, "Member 'ABGW_GameInstanceTicker::Parent' has a wrong offset!");
static_assert(offsetof(ABGW_GameInstanceTicker, TickGroup) == 0x000280, "Member 'ABGW_GameInstanceTicker::TickGroup' has a wrong offset!");

// Class b1.BGW_GameInstanceTickerEvenWhenPaused
// 0x0010 (0x0288 - 0x0278)
class ABGW_GameInstanceTickerEvenWhenPaused final : public AActor
{
public:
	class UBGWGameInstance*                       Parent;                                            // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickGroup;                                         // 0x0280(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGW_GameInstanceTickerEvenWhenPaused">();
	}
	static class ABGW_GameInstanceTickerEvenWhenPaused* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGW_GameInstanceTickerEvenWhenPaused>();
	}
};
static_assert(alignof(ABGW_GameInstanceTickerEvenWhenPaused) == 0x000008, "Wrong alignment on ABGW_GameInstanceTickerEvenWhenPaused");
static_assert(sizeof(ABGW_GameInstanceTickerEvenWhenPaused) == 0x000288, "Wrong size on ABGW_GameInstanceTickerEvenWhenPaused");
static_assert(offsetof(ABGW_GameInstanceTickerEvenWhenPaused, Parent) == 0x000278, "Member 'ABGW_GameInstanceTickerEvenWhenPaused::Parent' has a wrong offset!");
static_assert(offsetof(ABGW_GameInstanceTickerEvenWhenPaused, TickGroup) == 0x000280, "Member 'ABGW_GameInstanceTickerEvenWhenPaused::TickGroup' has a wrong offset!");

// Class b1.BGWGameInstance
// 0x0180 (0x0328 - 0x01A8)
class UBGWGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldActorContainer*                   MainActorWorld;                                    // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWVolumeManager*                      VolumeMgr;                                         // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class b1::UBGW_EventCollection*               Events;                                            // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTicker*                TickActor_PreAnimation;                            // 0x01C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTicker*                TickActor_PrePhysics;                              // 0x01D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTicker*                TickActor_BeforeStartPhysics;                      // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTicker*                TickActor_DuringPhysics;                           // 0x01E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTicker*                TickActor_BeforePostPhysics;                       // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTicker*                TickActor_PostPhysics;                             // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTicker*                TickActor_BeforePostUpdateWork;                    // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTicker*                TickActor_PostUpdateWork;                          // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTickerEvenWhenPaused*  TickActor_PrePhysics_EvenWhenPaused;               // 0x0208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABGW_GameInstanceTickerEvenWhenPaused*  TickActor_BeforePostUpdateWork_EvenWhenPaused;     // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWAssetLoader*                        AssetLoader;                                       // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220[0x108];                                    // 0x0220(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginToggleLoadingTips(class UGSInputComponent* InputComponent);
	bool CanFadeAway();
	void CloseLoadingScreen();
	EGSLoadingScreenState GetCurLoadingScreenState();
	EGSLoadingScreenType GetCurLoadingScreenType();
	class b1::UBGW_EventCollection* GetEvents();
	class ULocalPlayer* GetFirstGamePlayerForCS();
	TArray<int32> GetLastUseTips();
	TSubclassOf<class UOnlineSession> GetOnlineSessionClassCS();
	double GetTimeInMSSinceLoadingOpen();
	class FString GetTravelURLForCS();
	class FString GetTravelURLHost();
	class UWorld* GetWorldForCS();
	bool IsLoadingScreenFadeAwayFinish();
	bool IsToggleLoadingTipsFinish();
	void OnGameModeMatchStateSetCS(class FName NewMatchState);
	void OnPostActorTickCS(class UWorld* World);
	void OnWorldChangedCS(class UWorld* OldWorld, class UWorld* NewWorld);
	void OnWorldTickStartCS(class UWorld* World);
	void OpenLoadingScreen(bool UseSlateThread, EGSLoadingScreenType LoadingScreenType);
	void PrepareFadeAway();
	void ProcessNianHuiLogic();
	void ReceiveTick(float DeltaSeconds, int32 TickGroup);
	void ReceiveTickEvenWhenPaused(float DeltaSeconds, int32 TickGroup);
	void RegisterChapterInfo(const struct FChapterInfo& ChapterInfo);
	void RegisterLoadingTipsInfo(const struct FLoadingTipsInfo& TipsInfo);
	void RegisterLoadingTipsMask(class UTexture2D* MaskTexture);
	void RequestFadeAway();
	void StartGameInstanceForCS(EStartGameInstanceTypeForCS StartType);
	void SwitchLoadingScreenThread(bool UseSlateThread);
	bool TravelURLHasHost();
	bool TravelURLHasOption(const class FString& Option);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWGameInstance">();
	}
	static class UBGWGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWGameInstance>();
	}
};
static_assert(alignof(UBGWGameInstance) == 0x000008, "Wrong alignment on UBGWGameInstance");
static_assert(sizeof(UBGWGameInstance) == 0x000328, "Wrong size on UBGWGameInstance");
static_assert(offsetof(UBGWGameInstance, MainActorWorld) == 0x0001B0, "Member 'UBGWGameInstance::MainActorWorld' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, VolumeMgr) == 0x0001B8, "Member 'UBGWGameInstance::VolumeMgr' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, Events) == 0x0001C0, "Member 'UBGWGameInstance::Events' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_PreAnimation) == 0x0001C8, "Member 'UBGWGameInstance::TickActor_PreAnimation' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_PrePhysics) == 0x0001D0, "Member 'UBGWGameInstance::TickActor_PrePhysics' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_BeforeStartPhysics) == 0x0001D8, "Member 'UBGWGameInstance::TickActor_BeforeStartPhysics' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_DuringPhysics) == 0x0001E0, "Member 'UBGWGameInstance::TickActor_DuringPhysics' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_BeforePostPhysics) == 0x0001E8, "Member 'UBGWGameInstance::TickActor_BeforePostPhysics' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_PostPhysics) == 0x0001F0, "Member 'UBGWGameInstance::TickActor_PostPhysics' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_BeforePostUpdateWork) == 0x0001F8, "Member 'UBGWGameInstance::TickActor_BeforePostUpdateWork' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_PostUpdateWork) == 0x000200, "Member 'UBGWGameInstance::TickActor_PostUpdateWork' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_PrePhysics_EvenWhenPaused) == 0x000208, "Member 'UBGWGameInstance::TickActor_PrePhysics_EvenWhenPaused' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, TickActor_BeforePostUpdateWork_EvenWhenPaused) == 0x000210, "Member 'UBGWGameInstance::TickActor_BeforePostUpdateWork_EvenWhenPaused' has a wrong offset!");
static_assert(offsetof(UBGWGameInstance, AssetLoader) == 0x000218, "Member 'UBGWGameInstance::AssetLoader' has a wrong offset!");

// Class b1.BGWGameMode
// 0x0000 (0x0360 - 0x0360)
class ABGWGameMode : public AGameMode
{
public:
	void BeginEndPlayCS(const EEndPlayReason EndPlayReason);
	void BeginPlayCS();
	void GetSeamlessTravelActorListCS(bool bToTransition, TArray<class AActor*>* ActorList);
	void HandleLeavingMapCS();
	void HandleMatchHasStartedCS();
	void HandleMatchIsWaitingToStartCS();
	void HandleStartingNewPlayerCS(class APlayerController* NewPlayer);
	void InitGameCS(const class FString& MapName, const class FString& Options, class FString* ErrorMessag);
	void LoginOutCS(class AController* Exiting);
	void PostInitializeComponentsCS();
	void PostInitPropertiesCS();
	void PostLoginCS(class APlayerController* NewPlayer);
	void PostSeamlessTravelCS();
	void PreInitializeComponentsCS();
	void PreLoginCS(const class FString& Options, const class FString& LoginAddress, const class FString& UniqueId, class FString* ErrorMessage);
	void RestartGameCS();
	void RestartPlayerCS(class AController* NewPlayer);
	void StartPlayCS();

	bool IsMovieRendering() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWGameMode">();
	}
	static class ABGWGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWGameMode>();
	}
};
static_assert(alignof(ABGWGameMode) == 0x000008, "Wrong alignment on ABGWGameMode");
static_assert(sizeof(ABGWGameMode) == 0x000360, "Wrong size on ABGWGameMode");

// Class b1.BGWGamePlayTraceObject
// 0x0158 (0x0180 - 0x0028)
class UBGWGamePlayTraceObject final : public UObject
{
public:
	uint8                                         Pad_28[0x158];                                     // 0x0028(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanShutdown();
	bool GetEnableTraceing();
	void OnInit();
	void OnShutdown();
	void OnTick(float DeltaTime);
	void RecordFrameRate_Start();
	class FString RecordFrameRate_Stop();
	void StartFetchTick();
	void StopFetchTick();
	void TraceEnd();
	void TraceStart(const class FString& TraceTaskName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWGamePlayTraceObject">();
	}
	static class UBGWGamePlayTraceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWGamePlayTraceObject>();
	}
};
static_assert(alignof(UBGWGamePlayTraceObject) == 0x000008, "Wrong alignment on UBGWGamePlayTraceObject");
static_assert(sizeof(UBGWGamePlayTraceObject) == 0x000180, "Wrong size on UBGWGamePlayTraceObject");

// Class b1.BGUSimpleGamePlayTraceObject
// 0x0050 (0x0078 - 0x0028)
class UBGUSimpleGamePlayTraceObject final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTraceStatByName(const class FString& Name_0);
	struct FTraceStatResult FindTraceStatResult(const class FString& Name_0);
	void OnInit();
	void OnShutdown();
	void OnTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGUSimpleGamePlayTraceObject">();
	}
	static class UBGUSimpleGamePlayTraceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGUSimpleGamePlayTraceObject>();
	}
};
static_assert(alignof(UBGUSimpleGamePlayTraceObject) == 0x000008, "Wrong alignment on UBGUSimpleGamePlayTraceObject");
static_assert(sizeof(UBGUSimpleGamePlayTraceObject) == 0x000078, "Wrong size on UBGUSimpleGamePlayTraceObject");

// Class b1.BGWGameState
// 0x0018 (0x0300 - 0x02E8)
class ABGWGameState : public AGameState
{
public:
	class UActorDataContainer*                    BGSDataComp;                                       // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FECSNetSerialization                   ECSDataNetSerialization;                           // 0x02F0(0x0010)(Net, Transient, NoDestructor, NativeAccessSpecifierPublic)

public:
	void BeginPlayCS();
	void HandleBeginPlayCS();
	void HandleLeavingMapCS();
	void HandleMatchHasEndedCS();
	void HandleMatchHasStartedCS();
	void HandleMatchIsWaitingToStartCS();
	bool IsGSEventDebuggerOpenCS();
	void OnPostTickDispatchEventCS();
	void OnTickDispatchEventCS(float DeltaTime);
	void PostInitializeComponentsCS();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWGameState">();
	}
	static class ABGWGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWGameState>();
	}
};
static_assert(alignof(ABGWGameState) == 0x000008, "Wrong alignment on ABGWGameState");
static_assert(sizeof(ABGWGameState) == 0x000300, "Wrong size on ABGWGameState");
static_assert(offsetof(ABGWGameState, BGSDataComp) == 0x0002E8, "Member 'ABGWGameState::BGSDataComp' has a wrong offset!");
static_assert(offsetof(ABGWGameState, ECSDataNetSerialization) == 0x0002F0, "Member 'ABGWGameState::ECSDataNetSerialization' has a wrong offset!");

// Class b1.BGWGSStreamingSourceActor
// 0x0000 (0x0278 - 0x0278)
class ABGWGSStreamingSourceActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWGSStreamingSourceActor">();
	}
	static class ABGWGSStreamingSourceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWGSStreamingSourceActor>();
	}
};
static_assert(alignof(ABGWGSStreamingSourceActor) == 0x000008, "Wrong alignment on ABGWGSStreamingSourceActor");
static_assert(sizeof(ABGWGSStreamingSourceActor) == 0x000278, "Wrong size on ABGWGSStreamingSourceActor");

// Class b1.BGWLevelStreamingStateVolume
// 0x0000 (0x02B0 - 0x02B0)
class ABGWLevelStreamingStateVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWLevelStreamingStateVolume">();
	}
	static class ABGWLevelStreamingStateVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWLevelStreamingStateVolume>();
	}
};
static_assert(alignof(ABGWLevelStreamingStateVolume) == 0x000008, "Wrong alignment on ABGWLevelStreamingStateVolume");
static_assert(sizeof(ABGWLevelStreamingStateVolume) == 0x0002B0, "Wrong size on ABGWLevelStreamingStateVolume");

// Class b1.BGWLevelStreamingStateVolumeManager
// 0x0048 (0x0070 - 0x0028)
class UBGWLevelStreamingStateVolumeManager final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnRequestUpdateLevelState;                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FString>                         CurrentActiveVolumes;                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AVolume>>         RegisteredVolumePtrs;                              // 0x0048(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class AVolume>>         CurrentActiveVolumePtrs;                           // 0x0058(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class APlayerController*                      PlayerController;                                  // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UBGWLevelStreamingStateVolumeManager* Get(class UObject* WorldContext);

	void OnRequestUpdateLevelState__DelegateSignature();
	void UpdateCurrentActiveVolumes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWLevelStreamingStateVolumeManager">();
	}
	static class UBGWLevelStreamingStateVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWLevelStreamingStateVolumeManager>();
	}
};
static_assert(alignof(UBGWLevelStreamingStateVolumeManager) == 0x000008, "Wrong alignment on UBGWLevelStreamingStateVolumeManager");
static_assert(sizeof(UBGWLevelStreamingStateVolumeManager) == 0x000070, "Wrong size on UBGWLevelStreamingStateVolumeManager");
static_assert(offsetof(UBGWLevelStreamingStateVolumeManager, OnRequestUpdateLevelState) == 0x000028, "Member 'UBGWLevelStreamingStateVolumeManager::OnRequestUpdateLevelState' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingStateVolumeManager, CurrentActiveVolumes) == 0x000038, "Member 'UBGWLevelStreamingStateVolumeManager::CurrentActiveVolumes' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingStateVolumeManager, RegisteredVolumePtrs) == 0x000048, "Member 'UBGWLevelStreamingStateVolumeManager::RegisteredVolumePtrs' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingStateVolumeManager, CurrentActiveVolumePtrs) == 0x000058, "Member 'UBGWLevelStreamingStateVolumeManager::CurrentActiveVolumePtrs' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingStateVolumeManager, PlayerController) == 0x000068, "Member 'UBGWLevelStreamingStateVolumeManager::PlayerController' has a wrong offset!");

// Class b1.BGWLevelStreamingVolume
// 0x0030 (0x02E0 - 0x02B0)
class ABGWLevelStreamingVolume final : public AVolume
{
public:
	TArray<class FName>                           StreamingLevelNames;                               // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ForceHideStreamingLevelNames;                      // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bEditorPreVisOnly : 1;                             // 0x02D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisabled : 1;                                     // 0x02D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnStartLoading : 1;                               // 0x02D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EBGWStreamingVolumeUsage                      StreamingUsage;                                    // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWorldCompositionGroup : 1;                        // 0x02D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTimeBetweenVolumeUnloadRequests;                // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetEnableWorldCompositionGroup(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWLevelStreamingVolume">();
	}
	static class ABGWLevelStreamingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWLevelStreamingVolume>();
	}
};
static_assert(alignof(ABGWLevelStreamingVolume) == 0x000008, "Wrong alignment on ABGWLevelStreamingVolume");
static_assert(sizeof(ABGWLevelStreamingVolume) == 0x0002E0, "Wrong size on ABGWLevelStreamingVolume");
static_assert(offsetof(ABGWLevelStreamingVolume, StreamingLevelNames) == 0x0002B0, "Member 'ABGWLevelStreamingVolume::StreamingLevelNames' has a wrong offset!");
static_assert(offsetof(ABGWLevelStreamingVolume, ForceHideStreamingLevelNames) == 0x0002C0, "Member 'ABGWLevelStreamingVolume::ForceHideStreamingLevelNames' has a wrong offset!");
static_assert(offsetof(ABGWLevelStreamingVolume, StreamingUsage) == 0x0002D4, "Member 'ABGWLevelStreamingVolume::StreamingUsage' has a wrong offset!");
static_assert(offsetof(ABGWLevelStreamingVolume, MinTimeBetweenVolumeUnloadRequests) == 0x0002DC, "Member 'ABGWLevelStreamingVolume::MinTimeBetweenVolumeUnloadRequests' has a wrong offset!");

// Class b1.BGWMeshActor
// 0x0010 (0x0288 - 0x0278)
class ABGWMeshActor final : public AActor
{
public:
	TSubclassOf<class AActor>                     OriginBlueprint;                                   // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        SceneRoot;                                         // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWMeshActor">();
	}
	static class ABGWMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWMeshActor>();
	}
};
static_assert(alignof(ABGWMeshActor) == 0x000008, "Wrong alignment on ABGWMeshActor");
static_assert(sizeof(ABGWMeshActor) == 0x000288, "Wrong size on ABGWMeshActor");
static_assert(offsetof(ABGWMeshActor, OriginBlueprint) == 0x000278, "Member 'ABGWMeshActor::OriginBlueprint' has a wrong offset!");
static_assert(offsetof(ABGWMeshActor, SceneRoot) == 0x000280, "Member 'ABGWMeshActor::SceneRoot' has a wrong offset!");

// Class b1.BGWObjectExtend
// 0x0000 (0x0028 - 0x0028)
class UBGWObjectExtend : public UObject
{
public:
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWObjectExtend">();
	}
	static class UBGWObjectExtend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWObjectExtend>();
	}
};
static_assert(alignof(UBGWObjectExtend) == 0x000008, "Wrong alignment on UBGWObjectExtend");
static_assert(sizeof(UBGWObjectExtend) == 0x000028, "Wrong size on UBGWObjectExtend");

// Class b1.BGWOnlineInterface
// 0x0000 (0x0028 - 0x0028)
class UBGWOnlineInterface : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineInterface">();
	}
	static class UBGWOnlineInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineInterface>();
	}
};
static_assert(alignof(UBGWOnlineInterface) == 0x000008, "Wrong alignment on UBGWOnlineInterface");
static_assert(sizeof(UBGWOnlineInterface) == 0x000028, "Wrong size on UBGWOnlineInterface");

// Class b1.BGWOnlineAchievement
// 0x0030 (0x0058 - 0x0028)
class UBGWOnlineAchievement : public UBGWOnlineInterface
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Destroy();
	bool GetAllAchievements(TArray<struct FBGWOnlineAchievementTag>* OutAchievements);
	int32 Init();
	void OnAchievementsWrittenCompleteCS(bool bWasSuccessful);
	void OnQueryAchievementsCompleteCS(bool bWasSuccessful);
	void OnStatUpdatedCompleteCS(bool bWasSuccessful);
	void ReadAchievements();
	void UpdateStat(const class FString& StatName, int32 StatValue);
	void WriteAchievement(const class FString& WriteObjKey, double WriteObjValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineAchievement">();
	}
	static class UBGWOnlineAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineAchievement>();
	}
};
static_assert(alignof(UBGWOnlineAchievement) == 0x000008, "Wrong alignment on UBGWOnlineAchievement");
static_assert(sizeof(UBGWOnlineAchievement) == 0x000058, "Wrong size on UBGWOnlineAchievement");

// Class b1.BGWOnlineActivity
// 0x00B8 (0x00E0 - 0x0028)
class UBGWOnlineActivity : public UBGWOnlineInterface
{
public:
	uint8                                         Pad_28[0xB8];                                      // 0x0028(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Destroy();
	void EndActivity(const class FString& ActivityId, const EOnlineActivityOutcomeType& Outcome);
	int32 Init();
	void OnEndActivityCompleteCS(bool bWasSuccessful);
	void OnGameActivityActivationCompleteCS(const class FString& ActivityId, const class FString& SessionStr);
	void OnResetAllActiveActivitiesCompleteCS(bool bWasSuccessful);
	void OnResumeActivityCompleteCS(bool bWasSuccessful);
	void OnSetActivityAvailabilityCompleteCS(bool bWasSuccessful);
	void OnSetActivityPriorityCompleteCS(bool bWasSuccessful);
	void OnStartActivityCompleteCS(bool bWasSuccessful);
	void ResetAllActiveActivities();
	void ResumeActivity(const class FString& ActivityId, const TArray<class FString>& InProgressTasks, const TArray<class FString>& CompletedTasks);
	void SetActivityAvailability(const class FString& ActivityId, bool bEnable);
	void SetActivityPriority(const TMap<class FString, int32>& PriorityMap);
	void StartActivity(const class FString& ActivityId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineActivity">();
	}
	static class UBGWOnlineActivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineActivity>();
	}
};
static_assert(alignof(UBGWOnlineActivity) == 0x000008, "Wrong alignment on UBGWOnlineActivity");
static_assert(sizeof(UBGWOnlineActivity) == 0x0000E0, "Wrong size on UBGWOnlineActivity");

// Class b1.BGWOnlineCloud
// 0x00B0 (0x00D8 - 0x0028)
class UBGWOnlineCloud : public UBGWOnlineInterface
{
public:
	uint8                                         Pad_28[0xB0];                                      // 0x0028(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeleteUserFile(const class FString& Filename, bool bCloudDelete, bool bLocalDelete);
	void Destroy();
	void EnumerateUserFiles();
	int32 Init();
	void OnDeleteUserFilesCompleteCS(const class FString& Filename, bool bWasSuccessful);
	void OnEnumerateUserFilesCompleteCS(bool bWasSuccessful);
	void OnReadUserFilesCompleteCS(const class FString& Filename, bool bWasSuccessful);
	void OnWriteUserCloudFileCompleteCS(const class FString& Filename, bool bWasSuccessful);
	bool ReadAllUserFiles();
	bool ReadUserFile(const class FString& Filename);
	void WriteUserFile(const class FString& Filename, const TArray<uint8>& UserData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineCloud">();
	}
	static class UBGWOnlineCloud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineCloud>();
	}
};
static_assert(alignof(UBGWOnlineCloud) == 0x000008, "Wrong alignment on UBGWOnlineCloud");
static_assert(sizeof(UBGWOnlineCloud) == 0x0000D8, "Wrong size on UBGWOnlineCloud");

// Class b1.BGWOnlineFriend
// 0x0040 (0x0068 - 0x0028)
class UBGWOnlineFriend : public UBGWOnlineInterface
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Destroy();
	bool GetFriend(const class FString& ListName);
	bool GetFriendsList(EFriendsListsType ListType, TArray<struct FBGWOnlineFriendInfo>* OutFriends);
	int32 Init();
	void OnReadFriendListCompleteCS(bool bWasSuccessful);
	void ReadFriendsList(EFriendsListsType ListType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineFriend">();
	}
	static class UBGWOnlineFriend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineFriend>();
	}
};
static_assert(alignof(UBGWOnlineFriend) == 0x000008, "Wrong alignment on UBGWOnlineFriend");
static_assert(sizeof(UBGWOnlineFriend) == 0x000068, "Wrong size on UBGWOnlineFriend");

// Class b1.BGWOnlineIdentity
// 0x0030 (0x0058 - 0x0028)
class UBGWOnlineIdentity : public UBGWOnlineInterface
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Destroy();
	class FString GetAuthToken();
	class FString GetLinkedAccountExternalToken();
	void GetUserPrivilege(EBGWUserPrivileges Privilege);
	int32 Init();
	void Login();
	void OnGetUserPrivilegeCompleteCS(EBGWUserPrivileges Privilege, EBGWPrivilegeResult PrivilegeResult);
	void OnLoginCompletedCS(bool bSuccessful);
	void OnRecvAntiAddictionActionCS(const class FString& RecvActionsJsonStr);

	class FString GetAuthOnlineUserId() const;
	EBGWLoginStatus GetLoginStatus() const;
	class FString GetPlayerNickname() const;
	class FString GetUniquePlayerId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineIdentity">();
	}
	static class UBGWOnlineIdentity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineIdentity>();
	}
};
static_assert(alignof(UBGWOnlineIdentity) == 0x000008, "Wrong alignment on UBGWOnlineIdentity");
static_assert(sizeof(UBGWOnlineIdentity) == 0x000058, "Wrong size on UBGWOnlineIdentity");

// Class b1.BGWOnlinePresence
// 0x0048 (0x0070 - 0x0028)
class UBGWOnlinePresence : public UBGWOnlineInterface
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Destroy();
	int32 Init();
	void OnSetPresenceCompleteCS(bool bWasSuccessful);
	void SetRichPresence(const class FString& PresenceId, const class FString& StatusStr, const TMap<class FString, class FString>& Properties);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlinePresence">();
	}
	static class UBGWOnlinePresence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlinePresence>();
	}
};
static_assert(alignof(UBGWOnlinePresence) == 0x000008, "Wrong alignment on UBGWOnlinePresence");
static_assert(sizeof(UBGWOnlinePresence) == 0x000070, "Wrong size on UBGWOnlinePresence");

// Class b1.BGWOnlineSession
// 0x0088 (0x00B0 - 0x0028)
class UBGWOnlineSession : public UBGWOnlineInterface
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBGWOnlineSessionContext               Context;                                           // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x50];                                      // 0x0060(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateSession(EBGWOnlineSessionType SessionType, int32 MaxNumPlayers, const TMap<class FName, class FString>& CustumSettings, bool bIsLANMatch, const class FString& OverrideSessionTemplate);
	void Destroy();
	void DestroySession(EBGWOnlineSessionType SessionType);
	void FindSessionById(const class FString& SessionId, bool IsGameSession);
	class FString GetSessionIdStr(EBGWOnlineSessionType SessionType);
	EBGWOnlineSessionState GetSessionState(EBGWOnlineSessionType SessionType);
	class FString GetTravelUrl(EBGWOnlineSessionType SessionType);
	int32 Init();
	void JoinSession(EBGWOnlineSessionType SessionType, const class FString& SessionId);
	void OnCreateSessionCompleteCS(bool Success);
	void OnDestroySessionCompleteCS(EBGWOnlineSessionType SessionType, bool Success);
	void OnFindSessionByIdCompleteCS(bool Success);
	void OnJoinSessionCompleteCS(EBGWJoinSessionResult Result);
	void OnSearchSessionsCompleteCS(bool Success);
	void OnSessionInviteReceivedCS();
	void OnSessionUserInviteAcceptedCS(bool bWasSuccess);
	void SearchSessions(EBGWOnlineSessionType SessionType, const TMap<class FName, class FString>& SearchFilters, bool bIsLANMatch);
	void ShowFriendUI();
	void ShowInviteUI(EBGWOnlineSessionType SessionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineSession">();
	}
	static class UBGWOnlineSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineSession>();
	}
};
static_assert(alignof(UBGWOnlineSession) == 0x000008, "Wrong alignment on UBGWOnlineSession");
static_assert(sizeof(UBGWOnlineSession) == 0x0000B0, "Wrong size on UBGWOnlineSession");
static_assert(offsetof(UBGWOnlineSession, Context) == 0x000050, "Member 'UBGWOnlineSession::Context' has a wrong offset!");

// Class b1.BGWOnlineSubsystem
// 0x0018 (0x0040 - 0x0028)
class UBGWOnlineSubsystem : public UBGWOnlineInterface
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EBGWSubsystemType GetSubsystemType();

	int32 AfterInit();
	void Destroy();
	class FName GetInstanceName();
	class FString GetLocalPlatformName();
	class FName GetSubsystemNameForDebug();
	int32 Init();
	void OnQueryIsOwnAdditionContentCompleteCS(const class FString& EntitlementId, bool bWasSuccessful);
	void OnShowStoreUIClosedCS(bool bPurchased);
	void QueryIsOwnAdditionContent(const class FString& EntitlementId);
	bool QueryIsOwnAdditionContentSync(const class FString& EntitlementId);
	void QueryUserNATType();
	bool ShowStoreUI(const class FString& ProductId, bool AddToCard);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineSubsystem">();
	}
	static class UBGWOnlineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineSubsystem>();
	}
};
static_assert(alignof(UBGWOnlineSubsystem) == 0x000008, "Wrong alignment on UBGWOnlineSubsystem");
static_assert(sizeof(UBGWOnlineSubsystem) == 0x000040, "Wrong size on UBGWOnlineSubsystem");

// Class b1.BGWOnlineSubSystemMgr
// 0x00E0 (0x0108 - 0x0028)
class UBGWOnlineSubSystemMgr final : public UObject
{
public:
	class UObject*                                WorldCtx;                                          // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnLineGameMapName;                                 // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MainMenuMapName;                                   // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBlueprintSearchResult>         SearchResults;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          QueryFlag;                                         // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xB7];                                      // 0x0051(0x00B7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FindGames(bool bIsLAN);
	void HandleNetworkErrorCS(class UWorld* World, ENetworkFailure FailureType, const class FString& ErrorString);
	bool HostGame(bool bIsLAN, int32 MaxNumPlayers, const TMap<class FString, class FString>& CustumSettings);
	bool JoinGame(const struct FBlueprintSearchResult& Result);
	void LeaveGame();
	void OnCreateSessionCompleteCS(class FName SessionName, bool bWasSuccessful);
	void OnDestroySessionCompleteCS(class FName SessionName, bool bWasSuccessful);
	void OnFindSessionsCompleteCS(bool bWasSuccessful);
	void OnJoinSessionCompleteCS(class FName SessionName, int32 Result);
	void OnStartOnlineGameCompleteCS(class FName SessionName, bool bWasSuccessful);
	void OnUpdateSessionCompleteCS(class FName SessionName, bool bWasSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWOnlineSubSystemMgr">();
	}
	static class UBGWOnlineSubSystemMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWOnlineSubSystemMgr>();
	}
};
static_assert(alignof(UBGWOnlineSubSystemMgr) == 0x000008, "Wrong alignment on UBGWOnlineSubSystemMgr");
static_assert(sizeof(UBGWOnlineSubSystemMgr) == 0x000108, "Wrong size on UBGWOnlineSubSystemMgr");
static_assert(offsetof(UBGWOnlineSubSystemMgr, WorldCtx) == 0x000028, "Member 'UBGWOnlineSubSystemMgr::WorldCtx' has a wrong offset!");
static_assert(offsetof(UBGWOnlineSubSystemMgr, OnLineGameMapName) == 0x000030, "Member 'UBGWOnlineSubSystemMgr::OnLineGameMapName' has a wrong offset!");
static_assert(offsetof(UBGWOnlineSubSystemMgr, MainMenuMapName) == 0x000038, "Member 'UBGWOnlineSubSystemMgr::MainMenuMapName' has a wrong offset!");
static_assert(offsetof(UBGWOnlineSubSystemMgr, SearchResults) == 0x000040, "Member 'UBGWOnlineSubSystemMgr::SearchResults' has a wrong offset!");
static_assert(offsetof(UBGWOnlineSubSystemMgr, QueryFlag) == 0x000050, "Member 'UBGWOnlineSubSystemMgr::QueryFlag' has a wrong offset!");

// Class b1.BGWPlatformEventMgr
// 0x0000 (0x0028 - 0x0028)
class UBGWPlatformEventMgr : public UObject
{
public:
	void Destroy();
	void Init();
	void OnApplicationDeactivateCS();
	void OnApplicationExitCS();
	void OnApplicationInitCS();
	void OnApplicationPreExitCS();
	void OnApplicationReactivatedCS();
	void OnApplicationResumeCS();
	void OnApplicationSuspendCS();
	void OnApplicationTerminateCS();
	void OnNetworkInitializedChangeCS(bool bIsNetworkInitialized);
	void OnUserLoginChangeCS(bool bIsSignIn, int32 PlatformUserId, int32 UserIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWPlatformEventMgr">();
	}
	static class UBGWPlatformEventMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWPlatformEventMgr>();
	}
};
static_assert(alignof(UBGWPlatformEventMgr) == 0x000008, "Wrong alignment on UBGWPlatformEventMgr");
static_assert(sizeof(UBGWPlatformEventMgr) == 0x000028, "Wrong size on UBGWPlatformEventMgr");

// Class b1.BGWPlayerController
// 0x0008 (0x07D0 - 0x07C8)
class ABGWPlayerController : public APlayerController
{
public:
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BGWDeprojectScreenToWorld(const struct FVector2D& ScreenPosition, struct FVector* RayOrigin, struct FVector* RayDirection);
	bool GetViewportClientMousePosition(struct FVector2D* MousePosition);
	void InitCS();
	void ProcessPlayerInputCS(const float DeltaTime, const bool bGamePaused);
	void SetupInputComponentCS();

	bool BGWGetHitResultAtScreenPosition(const struct FVector2D& ScreenPosition, const ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const;
	struct FVector GetPlayerInputTouch(int32 Idx) const;
	int32 GetPlayerInputTouchesCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWPlayerController">();
	}
	static class ABGWPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWPlayerController>();
	}
};
static_assert(alignof(ABGWPlayerController) == 0x000008, "Wrong alignment on ABGWPlayerController");
static_assert(sizeof(ABGWPlayerController) == 0x0007D0, "Wrong size on ABGWPlayerController");

// Class b1.BGWSluaActor
// 0x0000 (0x0278 - 0x0278)
class ABGWSluaActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWSluaActor">();
	}
	static class ABGWSluaActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWSluaActor>();
	}
};
static_assert(alignof(ABGWSluaActor) == 0x000008, "Wrong alignment on ABGWSluaActor");
static_assert(sizeof(ABGWSluaActor) == 0x000278, "Wrong size on ABGWSluaActor");

// Class b1.BGWSplinePrismVolume
// 0x0030 (0x02E0 - 0x02B0)
class ABGWSplinePrismVolume : public AVolume
{
public:
	class USplineComponent*                       Spline;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       MidPoint;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrismMidPoint;                                     // 0x02C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesc1;                                            // 0x02DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesc2;                                            // 0x02DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDesc3;                                            // 0x02DE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DF[0x1];                                      // 0x02DF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool K2_EncompassesPoint(const struct FVector& InPoint, float* OutDistanceToPoint, float SphereRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWSplinePrismVolume">();
	}
	static class ABGWSplinePrismVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWSplinePrismVolume>();
	}
};
static_assert(alignof(ABGWSplinePrismVolume) == 0x000008, "Wrong alignment on ABGWSplinePrismVolume");
static_assert(sizeof(ABGWSplinePrismVolume) == 0x0002E0, "Wrong size on ABGWSplinePrismVolume");
static_assert(offsetof(ABGWSplinePrismVolume, Spline) == 0x0002B0, "Member 'ABGWSplinePrismVolume::Spline' has a wrong offset!");
static_assert(offsetof(ABGWSplinePrismVolume, MidPoint) == 0x0002B8, "Member 'ABGWSplinePrismVolume::MidPoint' has a wrong offset!");
static_assert(offsetof(ABGWSplinePrismVolume, PrismMidPoint) == 0x0002C0, "Member 'ABGWSplinePrismVolume::PrismMidPoint' has a wrong offset!");
static_assert(offsetof(ABGWSplinePrismVolume, Height) == 0x0002D8, "Member 'ABGWSplinePrismVolume::Height' has a wrong offset!");
static_assert(offsetof(ABGWSplinePrismVolume, bDesc1) == 0x0002DC, "Member 'ABGWSplinePrismVolume::bDesc1' has a wrong offset!");
static_assert(offsetof(ABGWSplinePrismVolume, bDesc2) == 0x0002DD, "Member 'ABGWSplinePrismVolume::bDesc2' has a wrong offset!");
static_assert(offsetof(ABGWSplinePrismVolume, bDesc3) == 0x0002DE, "Member 'ABGWSplinePrismVolume::bDesc3' has a wrong offset!");

// Class b1.BGWSpatialAudioVolume
// 0x0018 (0x02F8 - 0x02E0)
class ABGWSpatialAudioVolume final : public ABGWSplinePrismVolume
{
public:
	class UAkSurfaceReflectorSetComponent*        SurfaceReflectorSet;                               // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkLateReverbComponent*                 LateReverb;                                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRoomComponent*                       Room;                                              // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWSpatialAudioVolume">();
	}
	static class ABGWSpatialAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWSpatialAudioVolume>();
	}
};
static_assert(alignof(ABGWSpatialAudioVolume) == 0x000008, "Wrong alignment on ABGWSpatialAudioVolume");
static_assert(sizeof(ABGWSpatialAudioVolume) == 0x0002F8, "Wrong size on ABGWSpatialAudioVolume");
static_assert(offsetof(ABGWSpatialAudioVolume, SurfaceReflectorSet) == 0x0002E0, "Member 'ABGWSpatialAudioVolume::SurfaceReflectorSet' has a wrong offset!");
static_assert(offsetof(ABGWSpatialAudioVolume, LateReverb) == 0x0002E8, "Member 'ABGWSpatialAudioVolume::LateReverb' has a wrong offset!");
static_assert(offsetof(ABGWSpatialAudioVolume, Room) == 0x0002F0, "Member 'ABGWSpatialAudioVolume::Room' has a wrong offset!");

// Class b1.BGWStatsCapturer
// 0x00B8 (0x0330 - 0x0278)
class ABGWStatsCapturer final : public AActor
{
public:
	float                                         TickInterval;                                      // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaptureSwitch;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapturingVRAMInfo;                                // 0x027D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E[0x2];                                      // 0x027E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             StatDataTable;                                     // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         StatNameList;                                      // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FString>                         VRAMCategoryList;                                  // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGSCapturedStatResult>          DesiredStatsValue;                                 // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FGSCapturedStatResult>          DesiredVRAMInfo;                                   // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x68];                                     // 0x02C8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableCapturing(bool bIsStop);
	void EnableCapturing(bool bTriggerLogListening, const class FString& MetricsConfigPathUnderProjDir);
	void EnableCapturing_DT(bool bTriggerLogListening, class UDataTable* InStatDataTable);
	void ExecuteRHIDumpResMemCmds();
	TArray<struct FGSCapturedStatResult> GetDesiredStatsValue();
	TArray<struct FGSCapturedStatResult> GetDesiredVRAMInfo();
	int64 GetStartCycle();
	TArray<struct FGSCapturedStatResult> GetTotalCapturedPerfInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWStatsCapturer">();
	}
	static class ABGWStatsCapturer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWStatsCapturer>();
	}
};
static_assert(alignof(ABGWStatsCapturer) == 0x000008, "Wrong alignment on ABGWStatsCapturer");
static_assert(sizeof(ABGWStatsCapturer) == 0x000330, "Wrong size on ABGWStatsCapturer");
static_assert(offsetof(ABGWStatsCapturer, TickInterval) == 0x000278, "Member 'ABGWStatsCapturer::TickInterval' has a wrong offset!");
static_assert(offsetof(ABGWStatsCapturer, bCaptureSwitch) == 0x00027C, "Member 'ABGWStatsCapturer::bCaptureSwitch' has a wrong offset!");
static_assert(offsetof(ABGWStatsCapturer, bCapturingVRAMInfo) == 0x00027D, "Member 'ABGWStatsCapturer::bCapturingVRAMInfo' has a wrong offset!");
static_assert(offsetof(ABGWStatsCapturer, StatDataTable) == 0x000280, "Member 'ABGWStatsCapturer::StatDataTable' has a wrong offset!");
static_assert(offsetof(ABGWStatsCapturer, StatNameList) == 0x000288, "Member 'ABGWStatsCapturer::StatNameList' has a wrong offset!");
static_assert(offsetof(ABGWStatsCapturer, VRAMCategoryList) == 0x000298, "Member 'ABGWStatsCapturer::VRAMCategoryList' has a wrong offset!");
static_assert(offsetof(ABGWStatsCapturer, DesiredStatsValue) == 0x0002A8, "Member 'ABGWStatsCapturer::DesiredStatsValue' has a wrong offset!");
static_assert(offsetof(ABGWStatsCapturer, DesiredVRAMInfo) == 0x0002B8, "Member 'ABGWStatsCapturer::DesiredVRAMInfo' has a wrong offset!");

// Class b1.BGWVolumSubSystem
// 0x0000 (0x0030 - 0x0030)
class UBGWVolumSubSystem final : public UWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWVolumSubSystem">();
	}
	static class UBGWVolumSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWVolumSubSystem>();
	}
};
static_assert(alignof(UBGWVolumSubSystem) == 0x000008, "Wrong alignment on UBGWVolumSubSystem");
static_assert(sizeof(UBGWVolumSubSystem) == 0x000030, "Wrong size on UBGWVolumSubSystem");

// Class b1.BGWVolumeManager
// 0x0180 (0x01A8 - 0x0028)
class UBGWVolumeManager final : public UObject
{
public:
	class UBGWLevelStreamingVolumeManager*        LevelSteamingVolumeManager;                        // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWActorVisibilityVolumeManager*       ActorVisibilityVolumeManager;                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWCameraGroupVolumeManager*           CameraGroupVolumeManager;                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGWLevelStreamingStateVolumeManager*   LevelStreamingStateVolumeManager;                  // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x160];                                     // 0x0048(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGSLevelStateChanged(int32 ActionID, int32 Linkage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWVolumeManager">();
	}
	static class UBGWVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWVolumeManager>();
	}
};
static_assert(alignof(UBGWVolumeManager) == 0x000008, "Wrong alignment on UBGWVolumeManager");
static_assert(sizeof(UBGWVolumeManager) == 0x0001A8, "Wrong size on UBGWVolumeManager");
static_assert(offsetof(UBGWVolumeManager, LevelSteamingVolumeManager) == 0x000028, "Member 'UBGWVolumeManager::LevelSteamingVolumeManager' has a wrong offset!");
static_assert(offsetof(UBGWVolumeManager, ActorVisibilityVolumeManager) == 0x000030, "Member 'UBGWVolumeManager::ActorVisibilityVolumeManager' has a wrong offset!");
static_assert(offsetof(UBGWVolumeManager, CameraGroupVolumeManager) == 0x000038, "Member 'UBGWVolumeManager::CameraGroupVolumeManager' has a wrong offset!");
static_assert(offsetof(UBGWVolumeManager, LevelStreamingStateVolumeManager) == 0x000040, "Member 'UBGWVolumeManager::LevelStreamingStateVolumeManager' has a wrong offset!");

// Class b1.BGWTileLevelGroup
// 0x0038 (0x0060 - 0x0028)
class UBGWTileLevelGroup final : public UObject
{
public:
	bool                                          bShouldBeLoaded;                                   // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBeVisible;                                  // 0x0029(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockOnLoad;                                // 0x002A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastVolumeUnloadRequestTime;                       // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenVolumeUnloadRequests;                // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABGWLevelStreamingVolume*>       Volumes;                                           // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class ULevelStreaming*>                Levels;                                            // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWTileLevelGroup">();
	}
	static class UBGWTileLevelGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWTileLevelGroup>();
	}
};
static_assert(alignof(UBGWTileLevelGroup) == 0x000008, "Wrong alignment on UBGWTileLevelGroup");
static_assert(sizeof(UBGWTileLevelGroup) == 0x000060, "Wrong size on UBGWTileLevelGroup");
static_assert(offsetof(UBGWTileLevelGroup, bShouldBeLoaded) == 0x000028, "Member 'UBGWTileLevelGroup::bShouldBeLoaded' has a wrong offset!");
static_assert(offsetof(UBGWTileLevelGroup, bShouldBeVisible) == 0x000029, "Member 'UBGWTileLevelGroup::bShouldBeVisible' has a wrong offset!");
static_assert(offsetof(UBGWTileLevelGroup, bShouldBlockOnLoad) == 0x00002A, "Member 'UBGWTileLevelGroup::bShouldBlockOnLoad' has a wrong offset!");
static_assert(offsetof(UBGWTileLevelGroup, LastVolumeUnloadRequestTime) == 0x00002C, "Member 'UBGWTileLevelGroup::LastVolumeUnloadRequestTime' has a wrong offset!");
static_assert(offsetof(UBGWTileLevelGroup, MinTimeBetweenVolumeUnloadRequests) == 0x000030, "Member 'UBGWTileLevelGroup::MinTimeBetweenVolumeUnloadRequests' has a wrong offset!");
static_assert(offsetof(UBGWTileLevelGroup, Volumes) == 0x000038, "Member 'UBGWTileLevelGroup::Volumes' has a wrong offset!");
static_assert(offsetof(UBGWTileLevelGroup, Levels) == 0x000048, "Member 'UBGWTileLevelGroup::Levels' has a wrong offset!");
static_assert(offsetof(UBGWTileLevelGroup, Name_0) == 0x000058, "Member 'UBGWTileLevelGroup::Name_0' has a wrong offset!");

// Class b1.BGWLevelStreamingVolumeManager
// 0x02D0 (0x02F8 - 0x0028)
class UBGWLevelStreamingVolumeManager final : public UObject
{
public:
	TMap<class FName, struct FBGWLevelStreamingVolumeArr> LevelStreamingVolumes;                             // 0x0028(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FBGWLevelStreamingVolumeArr> ForceHideLevelStreamingVolumes;                    // 0x0078(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UBGWTileLevelGroup*>  TileLevelStreamingGroupWithKeyWords;               // 0x00C8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, class UBGWTileLevelGroup*>  ForceHideGroupWithKeyWords;                        // 0x0118(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ULevelStreaming*>                DisabledDistanceStreamingLevels;                   // 0x0168(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULevelStreaming*>                LevelStreamingObjectsWithVolumes;                  // 0x0178(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSet<class ULevelStreaming*>                  LevelStreamingObjectsWithVolumesOtherThanBlockingLoad; // 0x0188(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class ULevelStreaming*, struct FGSStreamingLevelLoadSetting> StatusChangedStreamingLevels;                      // 0x01D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FBGWVisibleLevelStreamingSettings> LevelStreamingWhiteList;                           // 0x0228(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class FName>                             LevelStreamingBlackList;                           // 0x0278(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x30];                                     // 0x02C8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWLevelStreamingVolumeManager">();
	}
	static class UBGWLevelStreamingVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWLevelStreamingVolumeManager>();
	}
};
static_assert(alignof(UBGWLevelStreamingVolumeManager) == 0x000008, "Wrong alignment on UBGWLevelStreamingVolumeManager");
static_assert(sizeof(UBGWLevelStreamingVolumeManager) == 0x0002F8, "Wrong size on UBGWLevelStreamingVolumeManager");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, LevelStreamingVolumes) == 0x000028, "Member 'UBGWLevelStreamingVolumeManager::LevelStreamingVolumes' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, ForceHideLevelStreamingVolumes) == 0x000078, "Member 'UBGWLevelStreamingVolumeManager::ForceHideLevelStreamingVolumes' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, TileLevelStreamingGroupWithKeyWords) == 0x0000C8, "Member 'UBGWLevelStreamingVolumeManager::TileLevelStreamingGroupWithKeyWords' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, ForceHideGroupWithKeyWords) == 0x000118, "Member 'UBGWLevelStreamingVolumeManager::ForceHideGroupWithKeyWords' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, DisabledDistanceStreamingLevels) == 0x000168, "Member 'UBGWLevelStreamingVolumeManager::DisabledDistanceStreamingLevels' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, LevelStreamingObjectsWithVolumes) == 0x000178, "Member 'UBGWLevelStreamingVolumeManager::LevelStreamingObjectsWithVolumes' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, LevelStreamingObjectsWithVolumesOtherThanBlockingLoad) == 0x000188, "Member 'UBGWLevelStreamingVolumeManager::LevelStreamingObjectsWithVolumesOtherThanBlockingLoad' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, StatusChangedStreamingLevels) == 0x0001D8, "Member 'UBGWLevelStreamingVolumeManager::StatusChangedStreamingLevels' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, LevelStreamingWhiteList) == 0x000228, "Member 'UBGWLevelStreamingVolumeManager::LevelStreamingWhiteList' has a wrong offset!");
static_assert(offsetof(UBGWLevelStreamingVolumeManager, LevelStreamingBlackList) == 0x000278, "Member 'UBGWLevelStreamingVolumeManager::LevelStreamingBlackList' has a wrong offset!");

// Class b1.BGWWorldSettings
// 0x0010 (0x0498 - 0x0488)
class ABGWWorldSettings : public AWorldSettings
{
public:
	FMulticastInlineDelegateProperty_             FBGWOnWorldCleanup;                                // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWWorldSettings">();
	}
	static class ABGWWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGWWorldSettings>();
	}
};
static_assert(alignof(ABGWWorldSettings) == 0x000008, "Wrong alignment on ABGWWorldSettings");
static_assert(sizeof(ABGWWorldSettings) == 0x000498, "Wrong size on ABGWWorldSettings");
static_assert(offsetof(ABGWWorldSettings, FBGWOnWorldCleanup) == 0x000488, "Member 'ABGWWorldSettings::FBGWOnWorldCleanup' has a wrong offset!");

// Class b1.BGWWorldSubSystem
// 0x0000 (0x0030 - 0x0030)
class UBGWWorldSubSystem final : public UWorldSubsystem
{
public:
	class UWorld* GetWorldRefCS();
	void OnWorldBeginPlayCS(class UWorld* InWorld);
	void OnWorldComponentsUpdatedCS(class UWorld* World);
	void PostInitializeCS();

	bool DoesSupportWorldTypeCS(int32 WorldType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWWorldSubSystem">();
	}
	static class UBGWWorldSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWWorldSubSystem>();
	}
};
static_assert(alignof(UBGWWorldSubSystem) == 0x000008, "Wrong alignment on UBGWWorldSubSystem");
static_assert(sizeof(UBGWWorldSubSystem) == 0x000030, "Wrong size on UBGWWorldSubSystem");

// Class b1.BGWTickableWorldSubSystem
// 0x0000 (0x0040 - 0x0040)
class UBGWTickableWorldSubSystem : public UTickableWorldSubsystem
{
public:
	class UWorld* GetWorldRefCS();
	void OnTickCS(float DeltaTime);
	void OnWorldBeginPlayCS(class UWorld* InWorld);
	void OnWorldComponentsUpdatedCS(class UWorld* World);
	void PostInitializeCS();

	bool DoesSupportWorldTypeCS(int32 WorldType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGWTickableWorldSubSystem">();
	}
	static class UBGWTickableWorldSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGWTickableWorldSubSystem>();
	}
};
static_assert(alignof(UBGWTickableWorldSubSystem) == 0x000008, "Wrong alignment on UBGWTickableWorldSubSystem");
static_assert(sizeof(UBGWTickableWorldSubSystem) == 0x000040, "Wrong size on UBGWTickableWorldSubSystem");

// Class b1.HitMoveOverlapOtherActorCollisionsInfo
// 0x0060 (0x0088 - 0x0028)
class UHitMoveOverlapOtherActorCollisionsInfo final : public UObject
{
public:
	class AActor*                                 OtherActor;                                        // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherActorWeight;                                  // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UShapeComponent*>                OtherCollisions;                                   // 0x0038(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 OtherCollisionDirections;                          // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UShapeComponent*>                SelfCollisions;                                    // 0x0058(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 SelfCollisionDirections;                           // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 OtherCollisionsLastTickCounts;                     // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMoveOverlapOtherActorCollisionsInfo">();
	}
	static class UHitMoveOverlapOtherActorCollisionsInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitMoveOverlapOtherActorCollisionsInfo>();
	}
};
static_assert(alignof(UHitMoveOverlapOtherActorCollisionsInfo) == 0x000008, "Wrong alignment on UHitMoveOverlapOtherActorCollisionsInfo");
static_assert(sizeof(UHitMoveOverlapOtherActorCollisionsInfo) == 0x000088, "Wrong size on UHitMoveOverlapOtherActorCollisionsInfo");
static_assert(offsetof(UHitMoveOverlapOtherActorCollisionsInfo, OtherActor) == 0x000028, "Member 'UHitMoveOverlapOtherActorCollisionsInfo::OtherActor' has a wrong offset!");
static_assert(offsetof(UHitMoveOverlapOtherActorCollisionsInfo, OtherActorWeight) == 0x000030, "Member 'UHitMoveOverlapOtherActorCollisionsInfo::OtherActorWeight' has a wrong offset!");
static_assert(offsetof(UHitMoveOverlapOtherActorCollisionsInfo, OtherCollisions) == 0x000038, "Member 'UHitMoveOverlapOtherActorCollisionsInfo::OtherCollisions' has a wrong offset!");
static_assert(offsetof(UHitMoveOverlapOtherActorCollisionsInfo, OtherCollisionDirections) == 0x000048, "Member 'UHitMoveOverlapOtherActorCollisionsInfo::OtherCollisionDirections' has a wrong offset!");
static_assert(offsetof(UHitMoveOverlapOtherActorCollisionsInfo, SelfCollisions) == 0x000058, "Member 'UHitMoveOverlapOtherActorCollisionsInfo::SelfCollisions' has a wrong offset!");
static_assert(offsetof(UHitMoveOverlapOtherActorCollisionsInfo, SelfCollisionDirections) == 0x000068, "Member 'UHitMoveOverlapOtherActorCollisionsInfo::SelfCollisionDirections' has a wrong offset!");
static_assert(offsetof(UHitMoveOverlapOtherActorCollisionsInfo, OtherCollisionsLastTickCounts) == 0x000078, "Member 'UHitMoveOverlapOtherActorCollisionsInfo::OtherCollisionsLastTickCounts' has a wrong offset!");

// Class b1.GSDescPropertyDetailCustomizationHelper
// 0x0000 (0x0028 - 0x0028)
class UGSDescPropertyDetailCustomizationHelper : public UObject
{
public:
	int32 FindDescIdByRowName(class FName RowName);
	bool GetRowNameByDescId(int32 DescID, class FName* RowName);
	void OnGetRowStrings(TArray<class FString>* OutStrings, TArray<bool>* OutRestrictedItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSDescPropertyDetailCustomizationHelper">();
	}
	static class UGSDescPropertyDetailCustomizationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSDescPropertyDetailCustomizationHelper>();
	}
};
static_assert(alignof(UGSDescPropertyDetailCustomizationHelper) == 0x000008, "Wrong alignment on UGSDescPropertyDetailCustomizationHelper");
static_assert(sizeof(UGSDescPropertyDetailCustomizationHelper) == 0x000028, "Wrong size on UGSDescPropertyDetailCustomizationHelper");

// Class b1.BTDecorator_USharpBase
// 0x0028 (0x0090 - 0x0068)
class UBTDecorator_USharpBase : public UBTDecorator
{
public:
	class AAIController*                          AIOwner;                                           // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bShowPropertyDetails : 1;                          // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_71[0x1F];                                      // 0x0071(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);
	void RefreshNodeInfoInEditor();
	void SetNodeNameInCS(const class FString& NewNodeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_USharpBase">();
	}
	static class UBTDecorator_USharpBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_USharpBase>();
	}
};
static_assert(alignof(UBTDecorator_USharpBase) == 0x000008, "Wrong alignment on UBTDecorator_USharpBase");
static_assert(sizeof(UBTDecorator_USharpBase) == 0x000090, "Wrong size on UBTDecorator_USharpBase");
static_assert(offsetof(UBTDecorator_USharpBase, AIOwner) == 0x000068, "Member 'UBTDecorator_USharpBase::AIOwner' has a wrong offset!");

// Class b1.BTService_USharpBase
// 0x0028 (0x0098 - 0x0070)
class UBTService_USharpBase : public UBTService
{
public:
	class AAIController*                          AIOwner;                                           // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ActorOwner;                                        // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bShowPropertyDetails : 1;                          // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bShowEventDetails : 1;                             // 0x0090(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);
	void RefreshNodeInfoInEditor();
	void SetNodeNameInCS(const class FString& NewNodeName);

	bool IsServiceActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_USharpBase">();
	}
	static class UBTService_USharpBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_USharpBase>();
	}
};
static_assert(alignof(UBTService_USharpBase) == 0x000008, "Wrong alignment on UBTService_USharpBase");
static_assert(sizeof(UBTService_USharpBase) == 0x000098, "Wrong size on UBTService_USharpBase");
static_assert(offsetof(UBTService_USharpBase, AIOwner) == 0x000070, "Member 'UBTService_USharpBase::AIOwner' has a wrong offset!");
static_assert(offsetof(UBTService_USharpBase, ActorOwner) == 0x000078, "Member 'UBTService_USharpBase::ActorOwner' has a wrong offset!");

// Class b1.BTTask_USharpBase
// 0x0038 (0x00A8 - 0x0070)
class UBTTask_USharpBase : public UBTTaskNode
{
public:
	class AAIController*                          AIOwner;                                           // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ActorOwner;                                        // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntervalCountdown                     TickInterval;                                      // 0x0080(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bShowPropertyDetails : 1;                          // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishAbort();
	void FinishExecute(bool bSuccess);
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);
	void RefreshNodeInfoInEditor();
	void SetNodeNameInCS(const class FString& NewNodeName);

	bool IsTaskAborting() const;
	bool IsTaskExecuting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_USharpBase">();
	}
	static class UBTTask_USharpBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_USharpBase>();
	}
};
static_assert(alignof(UBTTask_USharpBase) == 0x000008, "Wrong alignment on UBTTask_USharpBase");
static_assert(sizeof(UBTTask_USharpBase) == 0x0000A8, "Wrong size on UBTTask_USharpBase");
static_assert(offsetof(UBTTask_USharpBase, AIOwner) == 0x000070, "Member 'UBTTask_USharpBase::AIOwner' has a wrong offset!");
static_assert(offsetof(UBTTask_USharpBase, ActorOwner) == 0x000078, "Member 'UBTTask_USharpBase::ActorOwner' has a wrong offset!");
static_assert(offsetof(UBTTask_USharpBase, TickInterval) == 0x000080, "Member 'UBTTask_USharpBase::TickInterval' has a wrong offset!");

// Class b1.BUAnimLocomotionEx
// 0x0000 (0x0028 - 0x0028)
class IBUAnimLocomotionEx final : public IInterface
{
public:
	void SetLocoExEnable(bool bEnable);
	void SetLocoExSettings(const struct FBUAnimSettingsLocomotionEx& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BUAnimLocomotionEx">();
	}
	static class IBUAnimLocomotionEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBUAnimLocomotionEx>();
	}
};
static_assert(alignof(IBUAnimLocomotionEx) == 0x000008, "Wrong alignment on IBUAnimLocomotionEx");
static_assert(sizeof(IBUAnimLocomotionEx) == 0x000028, "Wrong size on IBUAnimLocomotionEx");

// Class b1.BUAnimHandAndFootIKAction
// 0x0000 (0x0028 - 0x0028)
class IBUAnimHandAndFootIKAction final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BUAnimHandAndFootIKAction">();
	}
	static class IBUAnimHandAndFootIKAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBUAnimHandAndFootIKAction>();
	}
};
static_assert(alignof(IBUAnimHandAndFootIKAction) == 0x000008, "Wrong alignment on IBUAnimHandAndFootIKAction");
static_assert(sizeof(IBUAnimHandAndFootIKAction) == 0x000028, "Wrong size on IBUAnimHandAndFootIKAction");

// Class b1.BUC_ACharacterComponent
// 0x0028 (0x0050 - 0x0028)
class UBUC_ACharacterComponent final : public UObject
{
public:
	class ACharacter*                             OwnerCharacter;                                    // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBGUCharacterMovementComponent*         OwnerMovement;                                     // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        OwnerShapeComponent;                               // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MainSkinMesh;                                      // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            OwnerController;                                   // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BUC_ACharacterComponent">();
	}
	static class UBUC_ACharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBUC_ACharacterComponent>();
	}
};
static_assert(alignof(UBUC_ACharacterComponent) == 0x000008, "Wrong alignment on UBUC_ACharacterComponent");
static_assert(sizeof(UBUC_ACharacterComponent) == 0x000050, "Wrong size on UBUC_ACharacterComponent");
static_assert(offsetof(UBUC_ACharacterComponent, OwnerCharacter) == 0x000028, "Member 'UBUC_ACharacterComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UBUC_ACharacterComponent, OwnerMovement) == 0x000030, "Member 'UBUC_ACharacterComponent::OwnerMovement' has a wrong offset!");
static_assert(offsetof(UBUC_ACharacterComponent, OwnerShapeComponent) == 0x000038, "Member 'UBUC_ACharacterComponent::OwnerShapeComponent' has a wrong offset!");
static_assert(offsetof(UBUC_ACharacterComponent, MainSkinMesh) == 0x000040, "Member 'UBUC_ACharacterComponent::MainSkinMesh' has a wrong offset!");
static_assert(offsetof(UBUC_ACharacterComponent, OwnerController) == 0x000048, "Member 'UBUC_ACharacterComponent::OwnerController' has a wrong offset!");

// Class b1.BUC_AIComponent
// 0x0010 (0x0038 - 0x0028)
class UBUC_AIComponent final : public UObject
{
public:
	class ABGUAIController*                       AIController;                                      // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIPerceptionComponent*                 PerceptionComp;                                    // 0x0030(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BUC_AIComponent">();
	}
	static class UBUC_AIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBUC_AIComponent>();
	}
};
static_assert(alignof(UBUC_AIComponent) == 0x000008, "Wrong alignment on UBUC_AIComponent");
static_assert(sizeof(UBUC_AIComponent) == 0x000038, "Wrong size on UBUC_AIComponent");
static_assert(offsetof(UBUC_AIComponent, AIController) == 0x000028, "Member 'UBUC_AIComponent::AIController' has a wrong offset!");
static_assert(offsetof(UBUC_AIComponent, PerceptionComp) == 0x000030, "Member 'UBUC_AIComponent::PerceptionComp' has a wrong offset!");

// Class b1.BUC_GameplayTagData
// 0x01E0 (0x0208 - 0x0028)
class UBUC_GameplayTagData final : public UObject
{
public:
	TMap<class FName, int32>                      TagInts;                                           // 0x0028(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      TagFloats;                                         // 0x0078(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FVector>             TagVectors;                                        // 0x00C8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, uint8>                      TagEnums;                                          // 0x0118(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, class FName>                TagNames;                                          // 0x0168(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, TWeakObjectPtr<class UObject>> TagObjects;                                        // 0x01B8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BUC_GameplayTagData">();
	}
	static class UBUC_GameplayTagData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBUC_GameplayTagData>();
	}
};
static_assert(alignof(UBUC_GameplayTagData) == 0x000008, "Wrong alignment on UBUC_GameplayTagData");
static_assert(sizeof(UBUC_GameplayTagData) == 0x000208, "Wrong size on UBUC_GameplayTagData");
static_assert(offsetof(UBUC_GameplayTagData, TagInts) == 0x000028, "Member 'UBUC_GameplayTagData::TagInts' has a wrong offset!");
static_assert(offsetof(UBUC_GameplayTagData, TagFloats) == 0x000078, "Member 'UBUC_GameplayTagData::TagFloats' has a wrong offset!");
static_assert(offsetof(UBUC_GameplayTagData, TagVectors) == 0x0000C8, "Member 'UBUC_GameplayTagData::TagVectors' has a wrong offset!");
static_assert(offsetof(UBUC_GameplayTagData, TagEnums) == 0x000118, "Member 'UBUC_GameplayTagData::TagEnums' has a wrong offset!");
static_assert(offsetof(UBUC_GameplayTagData, TagNames) == 0x000168, "Member 'UBUC_GameplayTagData::TagNames' has a wrong offset!");
static_assert(offsetof(UBUC_GameplayTagData, TagObjects) == 0x0001B8, "Member 'UBUC_GameplayTagData::TagObjects' has a wrong offset!");

// Class b1.BUS_EventCollection
// 0x0050 (0x0100 - 0x00B0)
class UBUS_EventCollection : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             FBUE_BounceCheck;                                  // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBUE_BP_UnitDie;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBUE_BP_ClearCameraLock;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FBUE_BP_AI_FSMEventTrigger;                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void()>                             FBUE_GrantItemsDeferred_CS;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BUS_EventCollection">();
	}
	static class UBUS_EventCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBUS_EventCollection>();
	}
};
static_assert(alignof(UBUS_EventCollection) == 0x000008, "Wrong alignment on UBUS_EventCollection");
static_assert(sizeof(UBUS_EventCollection) == 0x000100, "Wrong size on UBUS_EventCollection");
static_assert(offsetof(UBUS_EventCollection, FBUE_BounceCheck) == 0x0000B0, "Member 'UBUS_EventCollection::FBUE_BounceCheck' has a wrong offset!");
static_assert(offsetof(UBUS_EventCollection, FBUE_BP_UnitDie) == 0x0000C0, "Member 'UBUS_EventCollection::FBUE_BP_UnitDie' has a wrong offset!");
static_assert(offsetof(UBUS_EventCollection, FBUE_BP_ClearCameraLock) == 0x0000D0, "Member 'UBUS_EventCollection::FBUE_BP_ClearCameraLock' has a wrong offset!");
static_assert(offsetof(UBUS_EventCollection, FBUE_BP_AI_FSMEventTrigger) == 0x0000E0, "Member 'UBUS_EventCollection::FBUE_BP_AI_FSMEventTrigger' has a wrong offset!");
static_assert(offsetof(UBUS_EventCollection, FBUE_GrantItemsDeferred_CS) == 0x0000F0, "Member 'UBUS_EventCollection::FBUE_GrantItemsDeferred_CS' has a wrong offset!");

// Class b1.BGU_AIMover
// 0x0038 (0x0060 - 0x0028)
class UBGU_AIMover final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             FBUE_OnMoveComplete;                               // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AController*                            OwnerCtrl;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPathFollowingComponent*                PathFollowingComponent;                            // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortMove();
	int32 GetRequestID();
	void Init(class AController* OwnerAICtrl);
	bool IsOutOfRange();
	bool IsRequestValid();
	void MoveTo(const struct FBGU_AIMoverRequest& Request);
	void ResetRequest();

	EPathFollowingStatus GetMoveStatus() const;
	class UPathFollowingComponent* GetPathFollowingComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGU_AIMover">();
	}
	static class UBGU_AIMover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBGU_AIMover>();
	}
};
static_assert(alignof(UBGU_AIMover) == 0x000008, "Wrong alignment on UBGU_AIMover");
static_assert(sizeof(UBGU_AIMover) == 0x000060, "Wrong size on UBGU_AIMover");
static_assert(offsetof(UBGU_AIMover, FBUE_OnMoveComplete) == 0x000028, "Member 'UBGU_AIMover::FBUE_OnMoveComplete' has a wrong offset!");
static_assert(offsetof(UBGU_AIMover, OwnerCtrl) == 0x000038, "Member 'UBGU_AIMover::OwnerCtrl' has a wrong offset!");
static_assert(offsetof(UBGU_AIMover, PathFollowingComponent) == 0x000040, "Member 'UBGU_AIMover::PathFollowingComponent' has a wrong offset!");

// Class b1.BUS_UtilComm
// 0x0000 (0x0028 - 0x0028)
class UBUS_UtilComm final : public UBlueprintFunctionLibrary
{
public:
	static float CalcDegreeFromRotatorsInYaw(const struct FRotator& ARotator, const struct FRotator& BRotator);
	static float CalcDegreeFromVectorsProjectInXYPlane(const struct FVector& AVector, const struct FVector& BVector);
	static struct FRotator CalcDirWithInput(class ACharacter* CurCharacter, float ForwardVal, float RightVal);
	static struct FRotator CalcYawRotator(const struct FVector& TargetLocation, const struct FVector& FromLocation);
	static float GetCurActiveMontagePos(class ACharacter* CurCharacter);
	static int32 GetEasingFuncType(EGSBlendTypeG GSBlengTypeG);
	static float GetUMatineeCameraShakeBlendOutTime(class UMatineeCameraShake* CameraShake);
	static float GSEase(float Start, float End, float Alpha, EGSBlendTypeG GSBlendTypeG, float EaseExp);
	static struct FRotator GSEaseRotator(const struct FRotator& Start, const struct FRotator& End, float Alpha, EGSBlendTypeG GSBlendTypeG, float EaseExp, bool IsShortestPath);
	static bool IsCharacterStoped(class ACharacter* CurCharacter);
	static class UObject* LoadAKEventFromString(const class FString& ResPath);
	static class UAnimMontage* LoadAnimMontageFromString(const class FString& ResPath);
	static class UClass* LoadCameraShakeFromString(const class FString& ResPath);
	static class UCurveFloat* LoadCurveFloatFromString(const class FString& ResPath);
	static class ULevelSequence* LoadLevelSequenceFromString(const class FString& ResPath);
	static class UParticleSystem* LoadParticleSystemFromString(const class FString& ResPath, float DefaultDelayTime);
	static void ParticleSystemComponentTrailSetTimeRate(class ACharacter* CurCharacter, float TimeRate);
	static class UMatineeCameraShake* PlayCameraShakeByClass(class AActor* Caster, class UClass* CameraShakeCls);
	static bool PlayMontage(class ACharacter* CurCharacter, class UAnimMontage* AnimMontage);
	static bool SafeSetCharacterMontagePlaying(class ACharacter* CurCharacter, bool IsPlaying);
	static bool SafeSetCharacterMontagePlayingRate(class ACharacter* CurCharacter, float PlayRate);
	static void SetCurActiveMontagePos(class ACharacter* CurCharacter, float TargetPos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BUS_UtilComm">();
	}
	static class UBUS_UtilComm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBUS_UtilComm>();
	}
};
static_assert(alignof(UBUS_UtilComm) == 0x000008, "Wrong alignment on UBUS_UtilComm");
static_assert(sizeof(UBUS_UtilComm) == 0x000028, "Wrong size on UBUS_UtilComm");

// Class b1.EnvironmentSurfaceEffectMgr
// 0x0028 (0x02A0 - 0x0278)
class AEnvironmentSurfaceEffectMgr : public AActor
{
public:
	int32                                         DefaultEnvironmentSurfaceEffectID;                 // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeatherType                                  WeatherType;                                       // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class ABGWEnvironmentSurfaceVolume>> RegisteredVolumes;                                 // 0x0280(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class ABGWEnvironmentSurfaceVolume>> DisabledVolumes;                                   // 0x0290(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	class ABGWEnvironmentSurfaceVolume* GetEnvironmentSurfaceVolumeByLocation(const struct FVector& Location);
	void RegisterVolume(const TSoftObjectPtr<class ABGWEnvironmentSurfaceVolume>& InVolume);
	void UnregisterVolume(const TSoftObjectPtr<class ABGWEnvironmentSurfaceVolume>& InVolume, bool IsDisableVolume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentSurfaceEffectMgr">();
	}
	static class AEnvironmentSurfaceEffectMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentSurfaceEffectMgr>();
	}
};
static_assert(alignof(AEnvironmentSurfaceEffectMgr) == 0x000008, "Wrong alignment on AEnvironmentSurfaceEffectMgr");
static_assert(sizeof(AEnvironmentSurfaceEffectMgr) == 0x0002A0, "Wrong size on AEnvironmentSurfaceEffectMgr");
static_assert(offsetof(AEnvironmentSurfaceEffectMgr, DefaultEnvironmentSurfaceEffectID) == 0x000278, "Member 'AEnvironmentSurfaceEffectMgr::DefaultEnvironmentSurfaceEffectID' has a wrong offset!");
static_assert(offsetof(AEnvironmentSurfaceEffectMgr, WeatherType) == 0x00027C, "Member 'AEnvironmentSurfaceEffectMgr::WeatherType' has a wrong offset!");
static_assert(offsetof(AEnvironmentSurfaceEffectMgr, RegisteredVolumes) == 0x000280, "Member 'AEnvironmentSurfaceEffectMgr::RegisteredVolumes' has a wrong offset!");
static_assert(offsetof(AEnvironmentSurfaceEffectMgr, DisabledVolumes) == 0x000290, "Member 'AEnvironmentSurfaceEffectMgr::DisabledVolumes' has a wrong offset!");

// Class b1.GSEnvQueryAsset
// 0x0018 (0x0048 - 0x0030)
class UGSEnvQueryAsset final : public UDataAsset
{
public:
	class UEnvQuery*                              EnvQueryTemplate;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAIDynamicParam>                QueryConfig;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEnvQueryAsset">();
	}
	static class UGSEnvQueryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEnvQueryAsset>();
	}
};
static_assert(alignof(UGSEnvQueryAsset) == 0x000008, "Wrong alignment on UGSEnvQueryAsset");
static_assert(sizeof(UGSEnvQueryAsset) == 0x000048, "Wrong size on UGSEnvQueryAsset");
static_assert(offsetof(UGSEnvQueryAsset, EnvQueryTemplate) == 0x000030, "Member 'UGSEnvQueryAsset::EnvQueryTemplate' has a wrong offset!");
static_assert(offsetof(UGSEnvQueryAsset, QueryConfig) == 0x000038, "Member 'UGSEnvQueryAsset::QueryConfig' has a wrong offset!");

// Class b1.GSEnvQueryManager
// 0x0000 (0x0158 - 0x0158)
class UGSEnvQueryManager final : public UEnvQueryManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEnvQueryManager">();
	}
	static class UGSEnvQueryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEnvQueryManager>();
	}
};
static_assert(alignof(UGSEnvQueryManager) == 0x000008, "Wrong alignment on UGSEnvQueryManager");
static_assert(sizeof(UGSEnvQueryManager) == 0x000158, "Wrong size on UGSEnvQueryManager");

// Class b1.GSEQCBase
// 0x0048 (0x0070 - 0x0028)
class UGSEQCBase : public UEnvQueryContext
{
public:
	EBGUEQCQueryType                              EQCQueryType;                                      // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SingleActorResult;                                 // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SingleLocationResult;                              // 0x0038(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsSetResult;                                   // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        LocationsSetResult;                                // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void ProvideActorsSetCS(class UObject* QuerierObject, class AActor* QuerierActor) const;
	void ProvideLocationsSetCS(class UObject* QuerierObject, class AActor* QuerierActor) const;
	void ProvideSingleActorCS(class UObject* QuerierObject, class AActor* QuerierActor) const;
	void ProvideSingleLocationCS(class UObject* QuerierObject, class AActor* QuerierActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQCBase">();
	}
	static class UGSEQCBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQCBase>();
	}
};
static_assert(alignof(UGSEQCBase) == 0x000008, "Wrong alignment on UGSEQCBase");
static_assert(sizeof(UGSEQCBase) == 0x000070, "Wrong size on UGSEQCBase");
static_assert(offsetof(UGSEQCBase, EQCQueryType) == 0x000028, "Member 'UGSEQCBase::EQCQueryType' has a wrong offset!");
static_assert(offsetof(UGSEQCBase, SingleActorResult) == 0x000030, "Member 'UGSEQCBase::SingleActorResult' has a wrong offset!");
static_assert(offsetof(UGSEQCBase, SingleLocationResult) == 0x000038, "Member 'UGSEQCBase::SingleLocationResult' has a wrong offset!");
static_assert(offsetof(UGSEQCBase, ActorsSetResult) == 0x000050, "Member 'UGSEQCBase::ActorsSetResult' has a wrong offset!");
static_assert(offsetof(UGSEQCBase, LocationsSetResult) == 0x000060, "Member 'UGSEQCBase::LocationsSetResult' has a wrong offset!");

// Class b1.GSEQGBase_ProjectedPoint
// 0x00B8 (0x0108 - 0x0050)
class UGSEQGBase_ProjectedPoint : public UEnvQueryGenerator
{
public:
	struct FEnvTraceData                          ProjectionData;                                    // 0x0050(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   GeneratorsActionDescription;                       // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        GenerateItemList;                                  // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FEnvTraceData                          TraceData;                                         // 0x00C0(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGeneratedActor(class AActor* GeneratedActor) const;
	void AddGeneratedVector(const struct FVector& GeneratedVector) const;
	void DoItemGenerationCS(const TArray<struct FVector>& ContextLocations) const;
	class UObject* GetQuerier() const;
	TArray<struct FVector> ProjectAndFilterNavPointsInCS(const TArray<struct FVector>& Points) const;
	TArray<struct FVector> RunNavRaycastsInCS(const TArray<struct FVector>& Points, const struct FVector& SourcePt) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQGBase_ProjectedPoint">();
	}
	static class UGSEQGBase_ProjectedPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQGBase_ProjectedPoint>();
	}
};
static_assert(alignof(UGSEQGBase_ProjectedPoint) == 0x000008, "Wrong alignment on UGSEQGBase_ProjectedPoint");
static_assert(sizeof(UGSEQGBase_ProjectedPoint) == 0x000108, "Wrong size on UGSEQGBase_ProjectedPoint");
static_assert(offsetof(UGSEQGBase_ProjectedPoint, ProjectionData) == 0x000050, "Member 'UGSEQGBase_ProjectedPoint::ProjectionData' has a wrong offset!");
static_assert(offsetof(UGSEQGBase_ProjectedPoint, GeneratorsActionDescription) == 0x000090, "Member 'UGSEQGBase_ProjectedPoint::GeneratorsActionDescription' has a wrong offset!");
static_assert(offsetof(UGSEQGBase_ProjectedPoint, Context) == 0x0000A8, "Member 'UGSEQGBase_ProjectedPoint::Context' has a wrong offset!");
static_assert(offsetof(UGSEQGBase_ProjectedPoint, GenerateItemList) == 0x0000B0, "Member 'UGSEQGBase_ProjectedPoint::GenerateItemList' has a wrong offset!");
static_assert(offsetof(UGSEQGBase_ProjectedPoint, TraceData) == 0x0000C0, "Member 'UGSEQGBase_ProjectedPoint::TraceData' has a wrong offset!");

// Class b1.GSEQG_SimpleTeleport
// 0x0080 (0x00D0 - 0x0050)
class UGSEQG_SimpleTeleport : public UEnvQueryGenerator
{
public:
	bool                                          bUseCustomCapsuleSize;                             // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomCapsuleHalfHeight;                           // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomCapsuleRadius;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSEnvContextBase                             ContextBase;                                       // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           CustomActorContext;                                // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SceneItemTag;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     SceneItemClass;                                    // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           PlayerContext;                                     // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           TargetContext;                                     // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContextNavProjection;                             // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NavProjectionMaxRange;                             // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNavigationTrace;                            // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCapsuleTrace;                               // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNavigationProjection;                       // 0x009A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCapsuleHalfHeightAsVerticalOffset;                // 0x009B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCapsuleProjection;                          // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuerierNavPathExist;                              // 0x009D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerNavPathExist;                               // 0x009E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestCapsuleOverlap;                               // 0x009F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNavCost;                                        // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGSEQT_Project*                         NavProjectionTest;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGSEQT_Project*                         CapsuleProjectionTest;                             // 0x00B0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGSEQT_ProjectionPathFinding*           PlayerNavPathExistTest;                            // 0x00B8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGSEQT_ProjectionPathFinding*           QuerierNavPathExistTest;                           // 0x00C0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGSEQT_Overlap*                         CapsuleOverlapTest;                                // 0x00C8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQG_SimpleTeleport">();
	}
	static class UGSEQG_SimpleTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQG_SimpleTeleport>();
	}
};
static_assert(alignof(UGSEQG_SimpleTeleport) == 0x000008, "Wrong alignment on UGSEQG_SimpleTeleport");
static_assert(sizeof(UGSEQG_SimpleTeleport) == 0x0000D0, "Wrong size on UGSEQG_SimpleTeleport");
static_assert(offsetof(UGSEQG_SimpleTeleport, bUseCustomCapsuleSize) == 0x000050, "Member 'UGSEQG_SimpleTeleport::bUseCustomCapsuleSize' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, CustomCapsuleHalfHeight) == 0x000054, "Member 'UGSEQG_SimpleTeleport::CustomCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, CustomCapsuleRadius) == 0x000058, "Member 'UGSEQG_SimpleTeleport::CustomCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, ContextBase) == 0x00005C, "Member 'UGSEQG_SimpleTeleport::ContextBase' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, CustomActorContext) == 0x000060, "Member 'UGSEQG_SimpleTeleport::CustomActorContext' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, SceneItemTag) == 0x000068, "Member 'UGSEQG_SimpleTeleport::SceneItemTag' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, SceneItemClass) == 0x000070, "Member 'UGSEQG_SimpleTeleport::SceneItemClass' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, QuerierContext) == 0x000078, "Member 'UGSEQG_SimpleTeleport::QuerierContext' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, PlayerContext) == 0x000080, "Member 'UGSEQG_SimpleTeleport::PlayerContext' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, TargetContext) == 0x000088, "Member 'UGSEQG_SimpleTeleport::TargetContext' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bContextNavProjection) == 0x000090, "Member 'UGSEQG_SimpleTeleport::bContextNavProjection' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, NavProjectionMaxRange) == 0x000094, "Member 'UGSEQG_SimpleTeleport::NavProjectionMaxRange' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bEnableNavigationTrace) == 0x000098, "Member 'UGSEQG_SimpleTeleport::bEnableNavigationTrace' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bEnableCapsuleTrace) == 0x000099, "Member 'UGSEQG_SimpleTeleport::bEnableCapsuleTrace' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bEnableNavigationProjection) == 0x00009A, "Member 'UGSEQG_SimpleTeleport::bEnableNavigationProjection' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bCapsuleHalfHeightAsVerticalOffset) == 0x00009B, "Member 'UGSEQG_SimpleTeleport::bCapsuleHalfHeightAsVerticalOffset' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bEnableCapsuleProjection) == 0x00009C, "Member 'UGSEQG_SimpleTeleport::bEnableCapsuleProjection' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bQuerierNavPathExist) == 0x00009D, "Member 'UGSEQG_SimpleTeleport::bQuerierNavPathExist' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bPlayerNavPathExist) == 0x00009E, "Member 'UGSEQG_SimpleTeleport::bPlayerNavPathExist' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, bTestCapsuleOverlap) == 0x00009F, "Member 'UGSEQG_SimpleTeleport::bTestCapsuleOverlap' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, MaxNavCost) == 0x0000A0, "Member 'UGSEQG_SimpleTeleport::MaxNavCost' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, NavProjectionTest) == 0x0000A8, "Member 'UGSEQG_SimpleTeleport::NavProjectionTest' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, CapsuleProjectionTest) == 0x0000B0, "Member 'UGSEQG_SimpleTeleport::CapsuleProjectionTest' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, PlayerNavPathExistTest) == 0x0000B8, "Member 'UGSEQG_SimpleTeleport::PlayerNavPathExistTest' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, QuerierNavPathExistTest) == 0x0000C0, "Member 'UGSEQG_SimpleTeleport::QuerierNavPathExistTest' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleTeleport, CapsuleOverlapTest) == 0x0000C8, "Member 'UGSEQG_SimpleTeleport::CapsuleOverlapTest' has a wrong offset!");

// Class b1.GSEQG_Circle
// 0x0018 (0x00E8 - 0x00D0)
class UGSEQG_Circle final : public UGSEQG_SimpleTeleport
{
public:
	float                                         CircleRadius;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpaceBetween;                                      // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfPoints;                                    // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSPointOnCircleSpacingMethod                 PointOnCircleSpacingMethod;                        // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSAngleCenterDirection                       AngleCenterDirection;                              // 0x00DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftAngle;                                         // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightAngle;                                        // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQG_Circle">();
	}
	static class UGSEQG_Circle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQG_Circle>();
	}
};
static_assert(alignof(UGSEQG_Circle) == 0x000008, "Wrong alignment on UGSEQG_Circle");
static_assert(sizeof(UGSEQG_Circle) == 0x0000E8, "Wrong size on UGSEQG_Circle");
static_assert(offsetof(UGSEQG_Circle, CircleRadius) == 0x0000D0, "Member 'UGSEQG_Circle::CircleRadius' has a wrong offset!");
static_assert(offsetof(UGSEQG_Circle, SpaceBetween) == 0x0000D4, "Member 'UGSEQG_Circle::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UGSEQG_Circle, NumberOfPoints) == 0x0000D8, "Member 'UGSEQG_Circle::NumberOfPoints' has a wrong offset!");
static_assert(offsetof(UGSEQG_Circle, PointOnCircleSpacingMethod) == 0x0000DC, "Member 'UGSEQG_Circle::PointOnCircleSpacingMethod' has a wrong offset!");
static_assert(offsetof(UGSEQG_Circle, AngleCenterDirection) == 0x0000DD, "Member 'UGSEQG_Circle::AngleCenterDirection' has a wrong offset!");
static_assert(offsetof(UGSEQG_Circle, LeftAngle) == 0x0000E0, "Member 'UGSEQG_Circle::LeftAngle' has a wrong offset!");
static_assert(offsetof(UGSEQG_Circle, RightAngle) == 0x0000E4, "Member 'UGSEQG_Circle::RightAngle' has a wrong offset!");

// Class b1.GSEQG_Donut
// 0x0020 (0x00F0 - 0x00D0)
class UGSEQG_Donut : public UGSEQG_SimpleTeleport
{
public:
	float                                         InnerRadius;                                       // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfRings;                                     // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointsPerRing;                                     // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGSAngleCenterDirection                       AngleCenterDirection;                              // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftAngle;                                         // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightAngle;                                        // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQG_Donut">();
	}
	static class UGSEQG_Donut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQG_Donut>();
	}
};
static_assert(alignof(UGSEQG_Donut) == 0x000008, "Wrong alignment on UGSEQG_Donut");
static_assert(sizeof(UGSEQG_Donut) == 0x0000F0, "Wrong size on UGSEQG_Donut");
static_assert(offsetof(UGSEQG_Donut, InnerRadius) == 0x0000D0, "Member 'UGSEQG_Donut::InnerRadius' has a wrong offset!");
static_assert(offsetof(UGSEQG_Donut, OuterRadius) == 0x0000D4, "Member 'UGSEQG_Donut::OuterRadius' has a wrong offset!");
static_assert(offsetof(UGSEQG_Donut, NumberOfRings) == 0x0000D8, "Member 'UGSEQG_Donut::NumberOfRings' has a wrong offset!");
static_assert(offsetof(UGSEQG_Donut, PointsPerRing) == 0x0000DC, "Member 'UGSEQG_Donut::PointsPerRing' has a wrong offset!");
static_assert(offsetof(UGSEQG_Donut, AngleCenterDirection) == 0x0000E0, "Member 'UGSEQG_Donut::AngleCenterDirection' has a wrong offset!");
static_assert(offsetof(UGSEQG_Donut, LeftAngle) == 0x0000E4, "Member 'UGSEQG_Donut::LeftAngle' has a wrong offset!");
static_assert(offsetof(UGSEQG_Donut, RightAngle) == 0x0000E8, "Member 'UGSEQG_Donut::RightAngle' has a wrong offset!");

// Class b1.GSEQG_SimpleGrid
// 0x0008 (0x00D8 - 0x00D0)
class UGSEQG_SimpleGrid : public UGSEQG_SimpleTeleport
{
public:
	float                                         GridHalfSize;                                      // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpaceBetween;                                      // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQG_SimpleGrid">();
	}
	static class UGSEQG_SimpleGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQG_SimpleGrid>();
	}
};
static_assert(alignof(UGSEQG_SimpleGrid) == 0x000008, "Wrong alignment on UGSEQG_SimpleGrid");
static_assert(sizeof(UGSEQG_SimpleGrid) == 0x0000D8, "Wrong size on UGSEQG_SimpleGrid");
static_assert(offsetof(UGSEQG_SimpleGrid, GridHalfSize) == 0x0000D0, "Member 'UGSEQG_SimpleGrid::GridHalfSize' has a wrong offset!");
static_assert(offsetof(UGSEQG_SimpleGrid, SpaceBetween) == 0x0000D4, "Member 'UGSEQG_SimpleGrid::SpaceBetween' has a wrong offset!");

// Class b1.GSEQTBase
// 0x0010 (0x0208 - 0x01F8)
class UGSEQTBase : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetWorkOnFloatValuesCS();
	void OnPropertyChanged(const class FString& MemberName, const class FString& PropertyName);
	void SetWorkOnFloatValuesCS(bool bWorkOnFloats);

	void ForceItemStateFailed() const;
	void ForceItemStatePassed() const;
	class FString GetDescriptionDetailsCS() const;
	class FString GetDescriptionTitleCS() const;
	void PostProcessItems() const;
	void PreProcessItems(const TArray<class AActor*>& ContextActors, const TArray<struct FVector>& ContextLocations) const;
	void ProcessCustomItemScoreCS(const struct FGSEnvQueryTestItem& Item) const;
	bool ProcessItemCS(class UWorld* World, const struct FVector& ItemLocation, class AActor* ItemActor, class AActor* Querier) const;
	void SetItemScoreBool(bool bScore) const;
	void SetItemScoreFloat(float Score) const;
	bool ShouldPrepareContext() const;
	bool ShouldUseCustomItemScore() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQTBase">();
	}
	static class UGSEQTBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQTBase>();
	}
};
static_assert(alignof(UGSEQTBase) == 0x000008, "Wrong alignment on UGSEQTBase");
static_assert(sizeof(UGSEQTBase) == 0x000208, "Wrong size on UGSEQTBase");
static_assert(offsetof(UGSEQTBase, Context) == 0x0001F8, "Member 'UGSEQTBase::Context' has a wrong offset!");

// Class b1.GSEQT_Overlap
// 0x0030 (0x0228 - 0x01F8)
class UGSEQT_Overlap final : public UEnvQueryTest
{
public:
	struct FEnvOverlapData                        OverlapData;                                       // 0x01F8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQT_Overlap">();
	}
	static class UGSEQT_Overlap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQT_Overlap>();
	}
};
static_assert(alignof(UGSEQT_Overlap) == 0x000008, "Wrong alignment on UGSEQT_Overlap");
static_assert(sizeof(UGSEQT_Overlap) == 0x000228, "Wrong size on UGSEQT_Overlap");
static_assert(offsetof(UGSEQT_Overlap, OverlapData) == 0x0001F8, "Member 'UGSEQT_Overlap::OverlapData' has a wrong offset!");

// Class b1.GSEQT_ProjectionPathFinding
// 0x0010 (0x0290 - 0x0280)
class UGSEQT_ProjectionPathFinding final : public UEnvQueryTest_Pathfinding
{
public:
	struct FProjectionData                        ProjectionData;                                    // 0x0280(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQT_ProjectionPathFinding">();
	}
	static class UGSEQT_ProjectionPathFinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQT_ProjectionPathFinding>();
	}
};
static_assert(alignof(UGSEQT_ProjectionPathFinding) == 0x000008, "Wrong alignment on UGSEQT_ProjectionPathFinding");
static_assert(sizeof(UGSEQT_ProjectionPathFinding) == 0x000290, "Wrong size on UGSEQT_ProjectionPathFinding");
static_assert(offsetof(UGSEQT_ProjectionPathFinding, ProjectionData) == 0x000280, "Member 'UGSEQT_ProjectionPathFinding::ProjectionData' has a wrong offset!");

// Class b1.GSEQT_Project
// 0x0040 (0x0238 - 0x01F8)
class UGSEQT_Project final : public UEnvQueryTest
{
public:
	struct FEnvTraceData                          ProjectionData;                                    // 0x01F8(0x0040)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSEQT_Project">();
	}
	static class UGSEQT_Project* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSEQT_Project>();
	}
};
static_assert(alignof(UGSEQT_Project) == 0x000008, "Wrong alignment on UGSEQT_Project");
static_assert(sizeof(UGSEQT_Project) == 0x000238, "Wrong size on UGSEQT_Project");
static_assert(offsetof(UGSEQT_Project, ProjectionData) == 0x0001F8, "Member 'UGSEQT_Project::ProjectionData' has a wrong offset!");

// Class b1.GSLocalPlayer
// 0x0000 (0x02A0 - 0x02A0)
class UGSLocalPlayer : public ULocalPlayer
{
public:
	class FString GetGameLoginOptionsCS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSLocalPlayer">();
	}
	static class UGSLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSLocalPlayer>();
	}
};
static_assert(alignof(UGSLocalPlayer) == 0x000008, "Wrong alignment on UGSLocalPlayer");
static_assert(sizeof(UGSLocalPlayer) == 0x0002A0, "Wrong size on UGSLocalPlayer");

// Class b1.GSVersionSettings
// 0x0038 (0x0070 - 0x0038)
class UGSVersionSettings final : public UDeveloperSettings
{
public:
	class FString                                 AppVersion;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PS5MasterVersion;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XBoxMasterVersion;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Revision;                                          // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSVersionSettings">();
	}
	static class UGSVersionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSVersionSettings>();
	}
};
static_assert(alignof(UGSVersionSettings) == 0x000008, "Wrong alignment on UGSVersionSettings");
static_assert(sizeof(UGSVersionSettings) == 0x000070, "Wrong size on UGSVersionSettings");
static_assert(offsetof(UGSVersionSettings, AppVersion) == 0x000038, "Member 'UGSVersionSettings::AppVersion' has a wrong offset!");
static_assert(offsetof(UGSVersionSettings, PS5MasterVersion) == 0x000048, "Member 'UGSVersionSettings::PS5MasterVersion' has a wrong offset!");
static_assert(offsetof(UGSVersionSettings, XBoxMasterVersion) == 0x000058, "Member 'UGSVersionSettings::XBoxMasterVersion' has a wrong offset!");
static_assert(offsetof(UGSVersionSettings, Revision) == 0x000068, "Member 'UGSVersionSettings::Revision' has a wrong offset!");

// Class b1.Interface_DispLibEnvVolume
// 0x0000 (0x0028 - 0x0028)
class IInterface_DispLibEnvVolume final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interface_DispLibEnvVolume">();
	}
	static class IInterface_DispLibEnvVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterface_DispLibEnvVolume>();
	}
};
static_assert(alignof(IInterface_DispLibEnvVolume) == 0x000008, "Wrong alignment on IInterface_DispLibEnvVolume");
static_assert(sizeof(IInterface_DispLibEnvVolume) == 0x000028, "Wrong size on IInterface_DispLibEnvVolume");

// Class b1.Interface_DispLibEnvSubsystem
// 0x0000 (0x0028 - 0x0028)
class IInterface_DispLibEnvSubsystem final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interface_DispLibEnvSubsystem">();
	}
	static class IInterface_DispLibEnvSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterface_DispLibEnvSubsystem>();
	}
};
static_assert(alignof(IInterface_DispLibEnvSubsystem) == 0x000008, "Wrong alignment on IInterface_DispLibEnvSubsystem");
static_assert(sizeof(IInterface_DispLibEnvSubsystem) == 0x000028, "Wrong size on IInterface_DispLibEnvSubsystem");

// Class b1.U3DebugUtil
// 0x0000 (0x0028 - 0x0028)
class UU3DebugUtil final : public UBlueprintFunctionLibrary
{
public:
	static void DisableAllScreenMessages(class UObject* WorldCtx);
	static void U3DrawCircle(const class UWorld* InWorld, const struct FVector& Base, const struct FVector& X, const struct FVector& Y, const struct FColor& Color, float Radius, int32 NumSides, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebug2DDonut(const class UWorld* InWorld, const struct FMatrix& TransformMatrix, float InnerRadius, float OuterRadius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugAltCone(const class UWorld* InWorld, const struct FVector& Origin, const struct FRotator& Rotation, float Length, float AngleWidth, float AngleHeight, const struct FColor& DrawColor, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugBox(const class UWorld* InWorld, const struct FVector& Center, const struct FVector& Extent, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugBox2(const class UWorld* InWorld, const struct FVector& Center, const struct FVector& Extent, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugCamera(const class UWorld* InWorld, const struct FVector& Location, const struct FRotator& Rotation, float FOVDeg, float Scale, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugCanvas2DBox(class UCanvas* Canvas, const struct FBox2D& Box, const struct FLinearColor& LineColor, const float& LineThickness);
	static void U3DrawDebugCanvas2DCircle(class UCanvas* Canvas, const struct FVector2D& Center, float Radius, int32 NumSides, const struct FLinearColor& LineColor, const float& LineThickness);
	static void U3DrawDebugCanvas2DLine(class UCanvas* Canvas, const struct FVector& Start, const struct FVector& End, const struct FLinearColor& LineColor);
	static void U3DrawDebugCanvas2DLine2(class UCanvas* Canvas, const struct FVector2D& StartPosition, const struct FVector2D& EndPosition, const struct FLinearColor& LineColor, const float& LineThickness);
	static void U3DrawDebugCanvasCircle(class UCanvas* Canvas, const struct FVector& Base, const struct FVector& X, const struct FVector& Y, const struct FColor& Color, float Radius, int32 NumSides);
	static void U3DrawDebugCanvasLine(class UCanvas* Canvas, const struct FVector& Start, const struct FVector& End, const struct FLinearColor& LineColor);
	static void U3DrawDebugCanvasWireCone(class UCanvas* Canvas, const struct FTransform& Transform, float ConeRadius, float ConeAngle, int32 ConeSides, const struct FColor& Color);
	static void U3DrawDebugCanvasWireSphere(class UCanvas* Canvas, const struct FVector& Base, const struct FColor& Color, float Radius, int32 NumSides);
	static void U3DrawDebugCapsule(const class UWorld* InWorld, const struct FVector& Center, float HalfHeight, float Radius, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugCircle(const class UWorld* InWorld, const struct FMatrix& TransformMatrix, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness, bool bDrawAxis);
	static void U3DrawDebugCircle2(const class UWorld* InWorld, const struct FVector& Center, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis);
	static void U3DrawDebugCone(const class UWorld* InWorld, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugCoordinateSystem(const class UWorld* InWorld, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugCrosshairs(const class UWorld* InWorld, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugCylinder(const class UWorld* InWorld, const struct FVector& Start, const struct FVector& End, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugDirectionalArrow(const class UWorld* InWorld, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugFrustum(const class UWorld* InWorld, const struct FMatrix& FrustumToWorld, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugLine(const class UWorld* InWorld, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugMesh(const class UWorld* InWorld, const TArray<struct FVector>& Verts, const TArray<int32>& Indices, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugPoint(const class UWorld* InWorld, const struct FVector& Position, float Size, const struct FColor& PointColor, bool bPersistentLines, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugSolidBox(const class UWorld* InWorld, const struct FBox& Box, const struct FColor& Color, const struct FTransform& Transform, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugSolidBox2(const class UWorld* InWorld, const struct FVector& Center, const struct FVector& Extent, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugSolidBox3(const class UWorld* InWorld, const struct FVector& Center, const struct FVector& Extent, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugSolidPlane(const class UWorld* InWorld, const struct FPlane& P, const struct FVector& Loc, float Size, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugSolidPlane2(const class UWorld* InWorld, const struct FPlane& P, const struct FVector& Loc, const struct FVector2D& Extents, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void U3DrawDebugSphere(const class UWorld* InWorld, const struct FVector& Center, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void U3DrawDebugString(const class UWorld* InWorld, const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FColor& TextColor, float Duration, bool bDrawShadow, float FontScale);
	static void U3FlushDebugStrings(const class UWorld* InWorld);
	static void U3FlushPersistentDebugLines(const class UWorld* InWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"U3DebugUtil">();
	}
	static class UU3DebugUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UU3DebugUtil>();
	}
};
static_assert(alignof(UU3DebugUtil) == 0x000008, "Wrong alignment on UU3DebugUtil");
static_assert(sizeof(UU3DebugUtil) == 0x000028, "Wrong size on UU3DebugUtil");

// Class b1.USharpStructPersistentTest
// 0x0000 (0x0278 - 0x0278)
class AUSharpStructPersistentTest final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"USharpStructPersistentTest">();
	}
	static class AUSharpStructPersistentTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUSharpStructPersistentTest>();
	}
};
static_assert(alignof(AUSharpStructPersistentTest) == 0x000008, "Wrong alignment on AUSharpStructPersistentTest");
static_assert(sizeof(AUSharpStructPersistentTest) == 0x000278, "Wrong size on AUSharpStructPersistentTest");

// Class b1.USharpPerfTestBase
// 0x0030 (0x02A8 - 0x0278)
class AUSharpPerfTestBase : public AActor
{
public:
	int32                                         IntProp;                                           // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             FBUE_USharpCallbackPerfTest;                       // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginPlayInCS();
	bool BoolRetTest(int32 P1, float P2, bool bP3);
	void EmptyCallableFunc();
	void EmptyCallableFuncWithParams(int32 P1, float P2, int32 P3, bool bP4);
	void EmptyCallableFuncWithParams2(class FName P1, const class FString& P2, const class FText& P3);
	int32 IntRetTest(int32 P1, float P2, bool bP3, int32* Out1);
	int32 IntRetTest2(int32 P1, float P2, bool bP3);
	void InvokeMultiDelegate(int32 AttrID, int32 RealNewValue, int32 RealOrgValue, int32 ExpectChangeValue);
	void InvokeMultiDelegateNoDyn(int32 AttrID, int32 RealNewValue, int32 RealOrgValue, int32 ExpectChangeValue);
	struct FUSharpTestStructAsClass StructAsClassCreate(int32 RawValue);
	int32 StructAsClassGetInt(const struct FUSharpTestStructAsClass& InVal);
	float TestFastFuncExport(int32 P1, float P2, int32 P3, bool bP4);
	void TickInCS(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"USharpPerfTestBase">();
	}
	static class AUSharpPerfTestBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUSharpPerfTestBase>();
	}
};
static_assert(alignof(AUSharpPerfTestBase) == 0x000008, "Wrong alignment on AUSharpPerfTestBase");
static_assert(sizeof(AUSharpPerfTestBase) == 0x0002A8, "Wrong size on AUSharpPerfTestBase");
static_assert(offsetof(AUSharpPerfTestBase, IntProp) == 0x000278, "Member 'AUSharpPerfTestBase::IntProp' has a wrong offset!");
static_assert(offsetof(AUSharpPerfTestBase, FBUE_USharpCallbackPerfTest) == 0x000280, "Member 'AUSharpPerfTestBase::FBUE_USharpCallbackPerfTest' has a wrong offset!");

// Class b1.WorldActorContainer
// 0x00F8 (0x0120 - 0x0028)
class UWorldActorContainer final : public UObject
{
public:
	int32                                         AllocID;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UActorCompContainer*>       ActorCompsMap;                                     // 0x0030(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<int32, class AActor*>                    ActorMap;                                          // 0x0080(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, class APlayerController*>         PlayerCtrlMap;                                     // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldActorContainer">();
	}
	static class UWorldActorContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldActorContainer>();
	}
};
static_assert(alignof(UWorldActorContainer) == 0x000008, "Wrong alignment on UWorldActorContainer");
static_assert(sizeof(UWorldActorContainer) == 0x000120, "Wrong size on UWorldActorContainer");
static_assert(offsetof(UWorldActorContainer, AllocID) == 0x000028, "Member 'UWorldActorContainer::AllocID' has a wrong offset!");
static_assert(offsetof(UWorldActorContainer, ActorCompsMap) == 0x000030, "Member 'UWorldActorContainer::ActorCompsMap' has a wrong offset!");
static_assert(offsetof(UWorldActorContainer, ActorMap) == 0x000080, "Member 'UWorldActorContainer::ActorMap' has a wrong offset!");
static_assert(offsetof(UWorldActorContainer, PlayerCtrlMap) == 0x0000D0, "Member 'UWorldActorContainer::PlayerCtrlMap' has a wrong offset!");

// Class b1.X2DebugUtil
// 0x0000 (0x0028 - 0x0028)
class UX2DebugUtil final : public UBlueprintFunctionLibrary
{
public:
	static void DisableAllScreenMessages(class UObject* WorldCtx);
	static void X2DrawCircle(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Base, const struct FVector& X, const struct FVector& Y, const struct FColor& Color, float Radius, int32 NumSides, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebug2DDonut(const bool DebugTag, const class UWorld* InWorld, const struct FMatrix& TransformMatrix, float InnerRadius, float OuterRadius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugAltCone(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Origin, const struct FRotator& Rotation, float Length, float AngleWidth, float AngleHeight, const struct FColor& DrawColor, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugBox(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Center, const struct FVector& Extent, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugBox2(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Center, const struct FVector& Extent, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugCamera(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Location, const struct FRotator& Rotation, float FOVDeg, float Scale, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugCanvas2DBox(const bool DebugTag, class UCanvas* Canvas, const struct FBox2D& Box, const struct FLinearColor& LineColor, const float& LineThickness);
	static void X2DrawDebugCanvas2DCircle(const bool DebugTag, class UCanvas* Canvas, const struct FVector2D& Center, float Radius, int32 NumSides, const struct FLinearColor& LineColor, const float& LineThickness);
	static void X2DrawDebugCanvas2DLine(const bool DebugTag, class UCanvas* Canvas, const struct FVector& Start, const struct FVector& End, const struct FLinearColor& LineColor);
	static void X2DrawDebugCanvas2DLine2(const bool DebugTag, class UCanvas* Canvas, const struct FVector2D& StartPosition, const struct FVector2D& EndPosition, const struct FLinearColor& LineColor, const float& LineThickness);
	static void X2DrawDebugCanvasCircle(const bool DebugTag, class UCanvas* Canvas, const struct FVector& Base, const struct FVector& X, const struct FVector& Y, const struct FColor& Color, float Radius, int32 NumSides);
	static void X2DrawDebugCanvasLine(const bool DebugTag, class UCanvas* Canvas, const struct FVector& Start, const struct FVector& End, const struct FLinearColor& LineColor);
	static void X2DrawDebugCanvasWireCone(const bool DebugTag, class UCanvas* Canvas, const struct FTransform& Transform, float ConeRadius, float ConeAngle, int32 ConeSides, const struct FColor& Color);
	static void X2DrawDebugCanvasWireSphere(const bool DebugTag, class UCanvas* Canvas, const struct FVector& Base, const struct FColor& Color, float Radius, int32 NumSides);
	static void X2DrawDebugCapsule(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Center, float HalfHeight, float Radius, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugCircle(const bool DebugTag, const class UWorld* InWorld, const struct FMatrix& TransformMatrix, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness, bool bDrawAxis);
	static void X2DrawDebugCircle2(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Center, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis);
	static void X2DrawDebugCone(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugCoordinateSystem(const bool DebugTag, const class UWorld* InWorld, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugCrosshairs(const bool DebugTag, const class UWorld* InWorld, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugCylinder(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Start, const struct FVector& End, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugDirectionalArrow(const bool DebugTag, const class UWorld* InWorld, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugFrustum(const bool DebugTag, const class UWorld* InWorld, const struct FMatrix& FrustumToWorld, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugLine(const bool DebugTag, const class UWorld* InWorld, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugMesh(const bool DebugTag, const class UWorld* InWorld, const TArray<struct FVector>& Verts, const TArray<int32>& Indices, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugPoint(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Position, float Size, const struct FColor& PointColor, bool bPersistentLines, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugSolidBox(const bool DebugTag, const class UWorld* InWorld, const struct FBox& Box, const struct FColor& Color, const struct FTransform& Transform, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugSolidBox2(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Center, const struct FVector& Extent, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugSolidBox3(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Center, const struct FVector& Extent, const struct FQuat& Rotation, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugSolidPlane(const bool DebugTag, const class UWorld* InWorld, const struct FPlane& P, const struct FVector& Loc, float Size, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugSolidPlane2(const bool DebugTag, const class UWorld* InWorld, const struct FPlane& P, const struct FVector& Loc, const struct FVector2D& Extents, const struct FColor& Color, bool bPersistent, float LifeTime, uint8 DepthPriority);
	static void X2DrawDebugSphere(const bool DebugTag, const class UWorld* InWorld, const struct FVector& Center, float Radius, int32 Segments, const struct FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
	static void X2DrawDebugString(const bool DebugTag, const class UWorld* InWorld, const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FColor& TextColor, float Duration, bool bDrawShadow, float FontScale);
	static void X2FlushDebugStrings(const bool DebugTag, const class UWorld* InWorld);
	static void X2FlushPersistentDebugLines(const bool DebugTag, const class UWorld* InWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"X2DebugUtil">();
	}
	static class UX2DebugUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UX2DebugUtil>();
	}
};
static_assert(alignof(UX2DebugUtil) == 0x000008, "Wrong alignment on UX2DebugUtil");
static_assert(sizeof(UX2DebugUtil) == 0x000028, "Wrong size on UX2DebugUtil");

}

