#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MM

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum MM.EAnimSeqAssetLoadStatType
// NumValues: 0x0005
enum class EAnimSeqAssetLoadStatType : uint8
{
	INVALID                                  = 0,
	UNLOAD                                   = 1,
	LOADING                                  = 2,
	LOADED                                   = 3,
	EAnimSeqAssetLoadStatType_MAX            = 4,
};

// ScriptStruct MM.DefaultMotionJointData
// 0x0020 (0x0020 - 0x0000)
struct FDefaultMotionJointData final
{
public:
	TArray<struct FVector>                        JointLocation;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        JointVelocity;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultMotionJointData) == 0x000008, "Wrong alignment on FDefaultMotionJointData");
static_assert(sizeof(FDefaultMotionJointData) == 0x000020, "Wrong size on FDefaultMotionJointData");
static_assert(offsetof(FDefaultMotionJointData, JointLocation) == 0x000000, "Member 'FDefaultMotionJointData::JointLocation' has a wrong offset!");
static_assert(offsetof(FDefaultMotionJointData, JointVelocity) == 0x000010, "Member 'FDefaultMotionJointData::JointVelocity' has a wrong offset!");

// ScriptStruct MM.MotionMatchData
// 0x0018 (0x0018 - 0x0000)
struct FMotionMatchData final
{
public:
	TArray<struct FTransform>                     SelectedSkeletonBoneTransforms;                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ElectedSourceReference;                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionMatchData) == 0x000008, "Wrong alignment on FMotionMatchData");
static_assert(sizeof(FMotionMatchData) == 0x000018, "Wrong size on FMotionMatchData");
static_assert(offsetof(FMotionMatchData, SelectedSkeletonBoneTransforms) == 0x000000, "Member 'FMotionMatchData::SelectedSkeletonBoneTransforms' has a wrong offset!");
static_assert(offsetof(FMotionMatchData, ElectedSourceReference) == 0x000010, "Member 'FMotionMatchData::ElectedSourceReference' has a wrong offset!");

// ScriptStruct MM.PlayerDirectionInput
// 0x0070 (0x0070 - 0x0000)
struct FPlayerDirectionInput final
{
public:
	struct FTransform                             CurrentRefTransform;                               // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AllowedTimeOffset;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDirectionInput) == 0x000010, "Wrong alignment on FPlayerDirectionInput");
static_assert(sizeof(FPlayerDirectionInput) == 0x000070, "Wrong size on FPlayerDirectionInput");
static_assert(offsetof(FPlayerDirectionInput, CurrentRefTransform) == 0x000000, "Member 'FPlayerDirectionInput::CurrentRefTransform' has a wrong offset!");
static_assert(offsetof(FPlayerDirectionInput, AllowedTimeOffset) == 0x000060, "Member 'FPlayerDirectionInput::AllowedTimeOffset' has a wrong offset!");

// ScriptStruct MM.InputPlayerDirectionData
// 0x0028 (0x0028 - 0x0000)
struct FInputPlayerDirectionData final
{
public:
	TArray<struct FPlayerDirectionInput>          DirectionalPointsArray;                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                FinishVector;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputPlayerDirectionData) == 0x000008, "Wrong alignment on FInputPlayerDirectionData");
static_assert(sizeof(FInputPlayerDirectionData) == 0x000028, "Wrong size on FInputPlayerDirectionData");
static_assert(offsetof(FInputPlayerDirectionData, DirectionalPointsArray) == 0x000000, "Member 'FInputPlayerDirectionData::DirectionalPointsArray' has a wrong offset!");
static_assert(offsetof(FInputPlayerDirectionData, FinishVector) == 0x000010, "Member 'FInputPlayerDirectionData::FinishVector' has a wrong offset!");

// ScriptStruct MM.SkeletonStructure
// 0x0030 (0x0030 - 0x0000)
struct FSkeletonStructure final
{
public:
	struct FVector                                BoneTransformPosition;                             // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoneTransformVelocity;                             // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletonStructure) == 0x000008, "Wrong alignment on FSkeletonStructure");
static_assert(sizeof(FSkeletonStructure) == 0x000030, "Wrong size on FSkeletonStructure");
static_assert(offsetof(FSkeletonStructure, BoneTransformPosition) == 0x000000, "Member 'FSkeletonStructure::BoneTransformPosition' has a wrong offset!");
static_assert(offsetof(FSkeletonStructure, BoneTransformVelocity) == 0x000018, "Member 'FSkeletonStructure::BoneTransformVelocity' has a wrong offset!");

// ScriptStruct MM.MatchResults
// 0x0050 (0x0050 - 0x0000)
struct FMatchResults final
{
public:
	struct FInputPlayerDirectionData              PlayersInputData;                                  // 0x0000(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FInputPlayerDirectionData              PlayersPredictedInputData;                         // 0x0028(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchResults) == 0x000008, "Wrong alignment on FMatchResults");
static_assert(sizeof(FMatchResults) == 0x000050, "Wrong size on FMatchResults");
static_assert(offsetof(FMatchResults, PlayersInputData) == 0x000000, "Member 'FMatchResults::PlayersInputData' has a wrong offset!");
static_assert(offsetof(FMatchResults, PlayersPredictedInputData) == 0x000028, "Member 'FMatchResults::PlayersPredictedInputData' has a wrong offset!");

// ScriptStruct MM.MotionAnim
// 0x0020 (0x0020 - 0x0000)
struct FMotionAnim final
{
public:
	class UAnimationAnalyzer*                     AnimationAnalyzer;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimIndex;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedMotionTransitionTime;                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limit;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LimitOfOperation;                                  // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMotionAnim) == 0x000008, "Wrong alignment on FMotionAnim");
static_assert(sizeof(FMotionAnim) == 0x000020, "Wrong size on FMotionAnim");
static_assert(offsetof(FMotionAnim, AnimationAnalyzer) == 0x000000, "Member 'FMotionAnim::AnimationAnalyzer' has a wrong offset!");
static_assert(offsetof(FMotionAnim, AnimIndex) == 0x000008, "Member 'FMotionAnim::AnimIndex' has a wrong offset!");
static_assert(offsetof(FMotionAnim, Position) == 0x00000C, "Member 'FMotionAnim::Position' has a wrong offset!");
static_assert(offsetof(FMotionAnim, AllowedMotionTransitionTime) == 0x000010, "Member 'FMotionAnim::AllowedMotionTransitionTime' has a wrong offset!");
static_assert(offsetof(FMotionAnim, Limit) == 0x000014, "Member 'FMotionAnim::Limit' has a wrong offset!");
static_assert(offsetof(FMotionAnim, LimitOfOperation) == 0x000018, "Member 'FMotionAnim::LimitOfOperation' has a wrong offset!");

// ScriptStruct MM.MMForLMAnimGraph
// 0x0288 (0x02C0 - 0x0038)
struct FMMForLMAnimGraph final : public FAnimNode_AssetPlayerBase
{
public:
	struct FDefaultMotionJointData                DefaultMotionJointData;                            // 0x0038(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                DefaultVelocity;                                   // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAnalyzer*                     AnimationAnalyzer;                                 // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPoseLink                              AnimationPose;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InputDesiredTransform;                             // 0x0090(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InputRootTransform;                                // 0x00F0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InputStrength;                                     // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenBlends;                                 // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordAnimData;                                   // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepInputUnchanged;                               // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x16];                                     // 0x0162(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentAnimationReferencesIndex;                   // 0x0178(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WorldTimer;                                        // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReferenceMMTimer;                                  // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowLooping;                                     // 0x0184(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_185[0x123];                                    // 0x0185(0x0123)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMotionAnim>                    MotionMatchAnimationsRef;                          // 0x02A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMMForLMAnimGraph) == 0x000010, "Wrong alignment on FMMForLMAnimGraph");
static_assert(sizeof(FMMForLMAnimGraph) == 0x0002C0, "Wrong size on FMMForLMAnimGraph");
static_assert(offsetof(FMMForLMAnimGraph, DefaultMotionJointData) == 0x000038, "Member 'FMMForLMAnimGraph::DefaultMotionJointData' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, DefaultVelocity) == 0x000058, "Member 'FMMForLMAnimGraph::DefaultVelocity' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, AnimationAnalyzer) == 0x000070, "Member 'FMMForLMAnimGraph::AnimationAnalyzer' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, AnimationPose) == 0x000078, "Member 'FMMForLMAnimGraph::AnimationPose' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, InputDesiredTransform) == 0x000090, "Member 'FMMForLMAnimGraph::InputDesiredTransform' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, InputRootTransform) == 0x0000F0, "Member 'FMMForLMAnimGraph::InputRootTransform' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, InputStrength) == 0x000150, "Member 'FMMForLMAnimGraph::InputStrength' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, PlayRate) == 0x000154, "Member 'FMMForLMAnimGraph::PlayRate' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, BlendTime) == 0x000158, "Member 'FMMForLMAnimGraph::BlendTime' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, TimeBetweenBlends) == 0x00015C, "Member 'FMMForLMAnimGraph::TimeBetweenBlends' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, bRecordAnimData) == 0x000160, "Member 'FMMForLMAnimGraph::bRecordAnimData' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, bKeepInputUnchanged) == 0x000161, "Member 'FMMForLMAnimGraph::bKeepInputUnchanged' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, CurrentAnimationReferencesIndex) == 0x000178, "Member 'FMMForLMAnimGraph::CurrentAnimationReferencesIndex' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, WorldTimer) == 0x00017C, "Member 'FMMForLMAnimGraph::WorldTimer' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, ReferenceMMTimer) == 0x000180, "Member 'FMMForLMAnimGraph::ReferenceMMTimer' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, bAllowLooping) == 0x000184, "Member 'FMMForLMAnimGraph::bAllowLooping' has a wrong offset!");
static_assert(offsetof(FMMForLMAnimGraph, MotionMatchAnimationsRef) == 0x0002A8, "Member 'FMMForLMAnimGraph::MotionMatchAnimationsRef' has a wrong offset!");

// ScriptStruct MM.MotionMatchingAnimGraph
// 0x0218 (0x0250 - 0x0038)
struct FMotionMatchingAnimGraph final : public FAnimNode_AssetPlayerBase
{
public:
	struct FDefaultMotionJointData                DefaultMotionJointData;                            // 0x0038(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                DefaultVelocity;                                   // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAnalyzer*                     AnimationAnalyzer;                                 // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPoseLink                              AnimationPose;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InputDesiredTransform;                             // 0x0090(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InputRootTransform;                                // 0x00F0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InputStrength;                                     // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenBlends;                                 // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordAnimData;                                   // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableMMRootMotion;                              // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x16];                                     // 0x0162(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentAnimationReferencesIndex;                   // 0x0178(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WorldTimer;                                        // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReferenceMMTimer;                                  // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowLooping;                                     // 0x0184(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_185[0xBB];                                     // 0x0185(0x00BB)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMotionAnim>                    MotionMatchAnimationsRef;                          // 0x0240(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMotionMatchingAnimGraph) == 0x000010, "Wrong alignment on FMotionMatchingAnimGraph");
static_assert(sizeof(FMotionMatchingAnimGraph) == 0x000250, "Wrong size on FMotionMatchingAnimGraph");
static_assert(offsetof(FMotionMatchingAnimGraph, DefaultMotionJointData) == 0x000038, "Member 'FMotionMatchingAnimGraph::DefaultMotionJointData' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, DefaultVelocity) == 0x000058, "Member 'FMotionMatchingAnimGraph::DefaultVelocity' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, AnimationAnalyzer) == 0x000070, "Member 'FMotionMatchingAnimGraph::AnimationAnalyzer' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, AnimationPose) == 0x000078, "Member 'FMotionMatchingAnimGraph::AnimationPose' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, InputDesiredTransform) == 0x000090, "Member 'FMotionMatchingAnimGraph::InputDesiredTransform' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, InputRootTransform) == 0x0000F0, "Member 'FMotionMatchingAnimGraph::InputRootTransform' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, InputStrength) == 0x000150, "Member 'FMotionMatchingAnimGraph::InputStrength' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, PlayRate) == 0x000154, "Member 'FMotionMatchingAnimGraph::PlayRate' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, BlendTime) == 0x000158, "Member 'FMotionMatchingAnimGraph::BlendTime' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, TimeBetweenBlends) == 0x00015C, "Member 'FMotionMatchingAnimGraph::TimeBetweenBlends' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, bRecordAnimData) == 0x000160, "Member 'FMotionMatchingAnimGraph::bRecordAnimData' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, bDisableMMRootMotion) == 0x000161, "Member 'FMotionMatchingAnimGraph::bDisableMMRootMotion' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, CurrentAnimationReferencesIndex) == 0x000178, "Member 'FMotionMatchingAnimGraph::CurrentAnimationReferencesIndex' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, WorldTimer) == 0x00017C, "Member 'FMotionMatchingAnimGraph::WorldTimer' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, ReferenceMMTimer) == 0x000180, "Member 'FMotionMatchingAnimGraph::ReferenceMMTimer' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, bAllowLooping) == 0x000184, "Member 'FMotionMatchingAnimGraph::bAllowLooping' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimGraph, MotionMatchAnimationsRef) == 0x000240, "Member 'FMotionMatchingAnimGraph::MotionMatchAnimationsRef' has a wrong offset!");

// ScriptStruct MM.MotionMatchingCostData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FMotionMatchingCostData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMotionMatchingCostData) == 0x000008, "Wrong alignment on FMotionMatchingCostData");
static_assert(sizeof(FMotionMatchingCostData) == 0x000010, "Wrong size on FMotionMatchingCostData");

// ScriptStruct MM.MMKDTreeNode
// 0x0028 (0x0028 - 0x0000)
struct FMMKDTreeNode final
{
public:
	TArray<int32>                                 AnimRefIndex;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SplitIndex;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Median;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftIndex;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RightIndex;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMMKDTreeNode) == 0x000008, "Wrong alignment on FMMKDTreeNode");
static_assert(sizeof(FMMKDTreeNode) == 0x000028, "Wrong size on FMMKDTreeNode");
static_assert(offsetof(FMMKDTreeNode, AnimRefIndex) == 0x000000, "Member 'FMMKDTreeNode::AnimRefIndex' has a wrong offset!");
static_assert(offsetof(FMMKDTreeNode, SplitIndex) == 0x000010, "Member 'FMMKDTreeNode::SplitIndex' has a wrong offset!");
static_assert(offsetof(FMMKDTreeNode, Median) == 0x000014, "Member 'FMMKDTreeNode::Median' has a wrong offset!");
static_assert(offsetof(FMMKDTreeNode, LeftIndex) == 0x000018, "Member 'FMMKDTreeNode::LeftIndex' has a wrong offset!");
static_assert(offsetof(FMMKDTreeNode, RightIndex) == 0x00001C, "Member 'FMMKDTreeNode::RightIndex' has a wrong offset!");
static_assert(offsetof(FMMKDTreeNode, ParentIndex) == 0x000020, "Member 'FMMKDTreeNode::ParentIndex' has a wrong offset!");

// ScriptStruct MM.MotionMatchingMath
// 0x0080 (0x0080 - 0x0000)
struct FMotionMatchingMath final
{
public:
	int32                                         SrcAnimIndex;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SequenceLength;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SerializedFeatures;                                // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x60];                                      // 0x0020(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMotionMatchingMath) == 0x000008, "Wrong alignment on FMotionMatchingMath");
static_assert(sizeof(FMotionMatchingMath) == 0x000080, "Wrong size on FMotionMatchingMath");
static_assert(offsetof(FMotionMatchingMath, SrcAnimIndex) == 0x000000, "Member 'FMotionMatchingMath::SrcAnimIndex' has a wrong offset!");
static_assert(offsetof(FMotionMatchingMath, StartTime) == 0x000004, "Member 'FMotionMatchingMath::StartTime' has a wrong offset!");
static_assert(offsetof(FMotionMatchingMath, SequenceLength) == 0x000008, "Member 'FMotionMatchingMath::SequenceLength' has a wrong offset!");
static_assert(offsetof(FMotionMatchingMath, SerializedFeatures) == 0x000010, "Member 'FMotionMatchingMath::SerializedFeatures' has a wrong offset!");

// ScriptStruct MM.MotionMatchingAnimSeqdata
// 0x0028 (0x0028 - 0x0000)
struct FMotionMatchingAnimSeqdata final
{
public:
	class UAnimSequence*                          AnimationInMemory;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AnimationSoftPath;                                 // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimSeqAssetLoadStatType                     AnimationsAssetLoadStat;                           // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMotionMatchingAnimSeqdata) == 0x000008, "Wrong alignment on FMotionMatchingAnimSeqdata");
static_assert(sizeof(FMotionMatchingAnimSeqdata) == 0x000028, "Wrong size on FMotionMatchingAnimSeqdata");
static_assert(offsetof(FMotionMatchingAnimSeqdata, AnimationInMemory) == 0x000000, "Member 'FMotionMatchingAnimSeqdata::AnimationInMemory' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimSeqdata, AnimationSoftPath) == 0x000008, "Member 'FMotionMatchingAnimSeqdata::AnimationSoftPath' has a wrong offset!");
static_assert(offsetof(FMotionMatchingAnimSeqdata, AnimationsAssetLoadStat) == 0x000020, "Member 'FMotionMatchingAnimSeqdata::AnimationsAssetLoadStat' has a wrong offset!");

}

